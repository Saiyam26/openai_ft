{
  "1911.10742": {
    "title": "End-to-End Trainable Non-Collaborative Dialog System",
    "abstract": "End-to-end task-oriented dialog models have achieved promising performance on collaborative tasks where users willingly coordinate with the system to complete a given task. While in non-collaborative settings, for example, negotiation and persuasion, users and systems do not share a common goal. As a result, compared to collaborate tasks, people use social content to build rapport and trust in these non-collaborative settings in order to advance their goals. To handle social content, we introduce a hierarchical intent annotation scheme, which can be generalized to different non-collaborative dialog tasks. Building upon TransferTransfo (Wolf et al. 2019), we propose an end-to-end neural network model to generate diverse coherent responses. Our model utilizes intent and semantic slots as the intermediate sentence representation to guide the generation process. In addition, we design a filter to select appropriate responses based on whether these intermediate representations fit the designed task and conversation constraints. Our non-collaborative dialog model guides users to complete the task while simultaneously keeps them engaged. We test our approach on our newly proposed ANTISCAM dataset and an existing PERSUASIONFORGOOD dataset. Both automatic and human evaluations suggest that our model outperforms multiple baselines in these two non-collaborative tasks.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Considerable progress has been made building end-to-end dialog systems for collaborative tasks in which users cooperate with the system to achieve a common goal. Examples of collaborative tasks include making restaurant reservations and retrieving bus time-table information. Since users typically have clear and explicit intentions in collaborative tasks, existing systems commonly classify user utterances into pre-defined intents. In contrast, non-collaborative tasks are those where the users and the system do not strive to achieve the same goal. Examples of such tasks include deceiving attackers, persuading users to donate to a cause BIBREF1, and negotiating a product price BIBREF2, BIBREF3. In these tasks, users often perform complex actions that are beyond a simple set of pre-defined intents. In order to reach a common state, the user and the system need to build rapport and trust which naturally involves off-task content. Previous work did not model off-task content BIBREF2, which may have led to less optimal results. For example, in the persuasion task BIBREF1, users would ask the system \u201cHow do you feel about war?\" An example of an on-task system response that the system could have made is \u201cDo you want to make a donation?\", which sticks to the task but neglects users' question. However, a better response to such an off-task question is \u201cWar is destructive and pitiless, but you can donate to help child victims of war.\" This response is better, as it has been found that users are more likely to end the conversation if the system neglects their questions BIBREF4. Therefore, we need to design a system that handles both on-task and off-task information appropriately and in a way that leads back to the system's goal.",
          "To tackle the issue of incoherent system responses to off-task content, previous studies have built hybrid systems to interleave off-task and on-task content. BIBREF4 used a rule-based dialog manager for on-task content and a neural model for off-task content, and trained a reinforcement learning model to select between these two models based on the dialog context. However, such a method is difficult to train and struggles to generalize beyond the movie promotion task they considered. To tackle these problems, we propose a hierarchical intent annotation scheme that separates on-task and off-task information in order to provide detailed supervision. For on-task information, we directly use task-related intents for representation. Off-task information, on the other hand, is too general to categorize into specific intents, so we choose dialog acts that convey syntax information. These acts, such as \u201copen question\" are general to all tasks.",
          "Previous studies use template-based methods to maintain sentence coherence. However, rigid templates lead to limited diversity, causing the user losing engagement. On the other hand, language generation models can generate diverse responses but are bad at being coherent. We propose Multiple Intents and Semantic Slots Annotation Neural Network (MISSA) to combine the advantages of both template and generation models and takes advantage from the hierarchical annotation at the same time. MISSA follows the TransferTransfo framework BIBREF0 with three modifications: (i) We first concurrently predict user's, system's intents and semantic slots; (ii) We then perform conditional generation to improve generated response's coherence. Specifically, we generate responses conditioned on the above intermediate representation (intents and slots); (iii) Finally, we generate multiple responses with the nucleus sampling strategy BIBREF5 and then apply a response filter, which contains a set of pre-defined constraints to select coherent responses. The constraints in the filter can be defined according to specific task requirements or general conversational rules.",
          "To enrich publicly available non-collaborative task datasets, we collect a new dataset AntiScam, where users defend themselves against attackers trying to collect personal information. As non-collaborative tasks are still relatively new to the study of dialog systems, there are insufficiently many meaningful datasets for evaluation and we hope this provides a valuable example. We evaluate MISSA on the newly collected AntiScam dataset and an existing PersuasionForGood dataset. Both automatic and human evaluations suggest that MISSA outperforms multiple competitive baselines.",
          "In summary, our contributions include: (i) We design a hierarchical intent annotation scheme and a semantic slot annotation scheme to annotate the non-collaborative dialog dataset, we also propose a carefully-designed AntiScam dataset to facilitate the research of non-collaborative dialog systems. (ii) We propose a model that can be applied to all non-collaborative tasks, outperforming other baselines on two different non-collaborative tasks. (iii) We develop an anti-scam dialog system to occupy attacker's attention and elicit their private information for social good. Furthermore, we also build a persuasion dialog system to persuade people to donate to charities. We release the code and data."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "The interest in non-collaborative tasks has been increasing and there have already been several related datasets. For instance, BIBREF1 wang2019persuasion collected conversations where one participant persuades another to donate to a charity. BIBREF2 he2018decoupling collected negotiation dialogs where buyers and sellers bargain for items for sale on Craigslist. There are many other non-collaborative tasks, such as the turn-taking game BIBREF6, the multi-party game BIBREF7 and item splitting negotiation BIBREF8. Similar to the AntiScam dataset proposed in this paper, these datasets contain off-task content and can be used to train non-collaborative dialog systems. However, since they are not specifically collected and designed for non-collaborative tasks, it might be difficult to disentangle the on-task and off-task contents and measure the performance. Therefore, we propose the AntiScam dataset, which is designed to interleave the on-task and off-task contents in the conversation, and can serve as a benchmark dataset for similar non-collaborative tasks.",
          "To better understand user utterances and separate on-task and off-task content within a conversation, previous work has designed hierarchical annotation schemes for specific domains. BIBREF9 hardy2002multi followed the DAMSL schemeBIBREF10 and annotated a multilingual human-computer dialog corpus with a hierarchical dialog act annotation scheme. BIBREF11 gupta2018semantic used a hierarchical annotation scheme for semantic parsing. Inspired by these studies, our idea is to annotate the intent and semantic slot separately in non-collaborative tasks. We propose a hierarchical intent annotation scheme that can be adopted by all non-collaborative tasks. With this annotation scheme, MISSA is able to quickly build an end-to-end trainable dialog system for any non-collaborative task.",
          "Traditional task-oriented dialog systems BIBREF12 are usually composed of multiple independent modules, for example, natural language understanding, dialog state tracking BIBREF13, BIBREF14, dialog policy manager BIBREF15, and natural language generation BIBREF16. Conversational intent is adopted to capture the meaning of task content in these dialog systems BIBREF2, BIBREF17. In comparison to this work, we use a hierarchical intent scheme that includes off-task and on-task intents to capture utterance meaning. We also train the model in a multi-task fashion to predict decoupled intents and semantic slots. The major defect of a separately trained pipeline is the laborious dialog state design and annotation. In order to mitigate this problem, recent work has explored replacing independent modules with end-to-end neural networks BIBREF18, BIBREF19, BIBREF20. Our model also follows this end-to-end fashion.",
          "Over the last few years, we have witnessed a huge growth in non-task-oriented dialog systems BIBREF21, BIBREF22. Social chatbots such as Gunrock BIBREF23 were able to maintain a conversation for around ten minutes in an open domain. Recent improvements build on top of the transformer and pre-trained language models BIBREF24, BIBREF25, BIBREF26, obtained state-of-the-art results on the Persona-Chat dataset BIBREF0. Pre-trained language models are proposed to build task-oriented dialog systems to drive the progress on leveraging large amounts of available unannotated data. BIBREF27. Similarly, our approach is also built on top of the TransferTransfo framework BIBREF0. BIBREF27 budzianowski2019hello focused on collaborative tasks BIBREF28. We target non-collaborative tasks instead.",
          "Another line of work interleaves on-task and off-task content by building a hybrid dialog system that combines a task-oriented model and a non-task-oriented model BIBREF4, BIBREF29. In these studies, task-oriented systems and non-task-oriented systems are designed separately and both systems generate candidate responses. A selector is then designed to choose an appropriate output from the candidate responses BIBREF4 and a connector to combine two response candidates BIBREF30, BIBREF31. Compared with these works, MISSA is end-to-end trainable and thus easier to train and update."
        ]
      },
      {
        "section_name": "Non-Collaborative Task Annotation Scheme",
        "paragraphs": [
          "To decouple syntactic and semantic information in utterances and provide detailed supervision, we design a hierarchical intent annotation scheme for non-collaborative tasks. We first separate on-task and off-task intents. As on-task intents are key actions that can vary among different tasks, we need to specifically define on-task intents for each task. On the other hand, since off-task content is too general to design task-specific intents, we choose common dialog acts as the categories. The advantage of this hierarchical annotation scheme is apparent when starting a new non-collaborative task: we only need to focus on designing the on-task categories and semantic slots which are the same as traditional task-oriented dialog systems. Consequently, we don't have to worry about the off-task annotation design since the off-task category is universal.",
          "In the intent annotation scheme shown in Table TABREF2, we list the designed intent annotation scheme for the newly collected AntiScam dataset and the PersuasionForGood dataset. We first define on-task intents for the datasets, which are key actions in the task. Since our AntiScam focuses on understanding and reacting towards elicitations, we define elicitation, providing_information and refusal as on-task intents. In the PersuasionForGood dataset, we define nine on-task intents in Table TABREF2 based on the original PersuasionForGood dialog act annotation scheme. All these intents are related to donation actions, which are salient on-task intents in the persuasion task. The off-task intents are the same for both tasks, including six general intents and six additional social intents. General intents are more closely related to the syntactic meaning of the sentence (open_question, yes_no_question, positive_answer, negative_answer, responsive_statement, and nonresponsive_statement) while social intents are common social actions (greeting, closing, apology, thanking,respond_to_thank, and hold).",
          "For specific tasks, we also design a semantic slot annotation scheme for annotating sentences based on their semantic content. We identify 13 main semantic slots in the anti-scam task, for example, credit card numbers. We present a detailed semantic slot annotation in Table TABREF3. Following BIBREF1, we segment each conversation turn into single sentences and then annotate each sentence rather than turns."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "We test our approach on two non-collaborative task datasets: the AntiScam dataset and the PersuasionForGood dataset BIBREF1. Both datasets are collected from the Amazon Mechanical Turk platform in the form of typing conversations and off-task dialog is interleaved in the dialog."
        ]
      },
      {
        "section_name": "Datasets ::: AntiScam Dataset",
        "paragraphs": [
          "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
        ]
      },
      {
        "section_name": "Datasets ::: PersuasionForGood Dataset",
        "paragraphs": [
          "The PersuasionForGood dataset BIBREF1 was collected from typing conversations on Amazon Mechanical Turk platform. Two workers were randomly paired, one was assigned the role of persuader, the other was persuadee. The goal of the persuader was to persuade the persuadee to donate a portion of task earning to a specific charity. The dataset consists of 1,017 dialogs, where 300 dialogs are annotated with dialog acts. The average conversation length is 10.43, the vocabulary size is 8,141. Since the original PersuasionForGood dataset is annotated with dialog acts, we select the on-task dialog acts as on-task intents shown in Table TABREF2, and categorize the other dialog acts into our pre-defined off-task intents."
        ]
      },
      {
        "section_name": "Model ::: Background",
        "paragraphs": [
          "The TransferTransfo framework was proposed to build open domain dialog systems. BIBREF0 wolf2019transfertransfo fine-tuned the generative pre-training model (GPT) BIBREF32 with the PERSONA-CHAT dataset BIBREF33 in a multi-task fashion, where the language model objective is combined with a next-utterance classification task. The language model's objective is to maximize the following likelihood for a given sequence of tokens, $X = \\lbrace x_1,\\dots ,x_n\\rbrace $:",
          "The authors also trained a classifier to distinguish the correct next-utterance appended to the input human utterances from a set of randomly selected utterance distractors. In addition, they introduced dialog state embeddings to indicate speaker role in the model. The model significantly outperformed previous baselines over both automatic evaluations and human evaluations in social conversations. Since the TransferTransfo framework performs well in open domain, we adapt it for non-collaborative settings. We keep all the embeddings in the framework and train the language model and next-utterance classification task in a multi-task fashion following TransferTransfo.",
          "We make two major changes: (1) To address the problem that TransferTransfo is originally designed for an open domain without explicit intents and regulations, we add two intent classifiers and two semantic slot classifiers to classify the intents and semantic slots for both human utterances and system responses as an effort to incorporate the proposed hierarchical intent and semantic slot annotation for non-collaborative tasks. (2) In dialog systems, multiple generated responses can be coherent under the current context. Generating diverse responses has proven to be an enduring challenge. To increase response diversity, we sample multiple generated responses and choose an appropriate one according to a set of pre-defined rules."
        ]
      },
      {
        "section_name": "Model ::: Intent and Semantic Slot Classifiers",
        "paragraphs": [
          "We train MISSA in a multi-task fashion. In addition to the language model task and the next-utterance prediction task, we also use separate classifiers to predict the intents and semantic slots of both human utterances and system responses. The intent classifier and semantic slot classifier for human utterances capture the semantic and syntactic meaning of human utterances, providing information to select the appropriate response among response candidates while the classifiers for the system intents and semantic slots are designed to help select an appropriate next-sentence. We describe response filtering in the corresponding subsection. Classifiers are designed as the following equation:",
          "where $L^i_{t}$ is the intent or semantic label of $i$-th sentence at turn $t$. $h^l_{t-1}$ is the hidden states at the end of last sentence in turn $t-1$, $h^i_{t}$ is the last hidden states at the end of $i$-th sentence in turn $t$. $W_{2h}$ are weights learned during training.",
          "MISSA is able to classify multiple intents and multiple semantic slots in a single utterance with these classifiers. Figure FIGREF6 shows how it works on the AntiScam dataset. Specifically, we set a special token $<$sep$>$ at the end of each sentence in an utterance (an utterance can consist of multiple sentences). Next, we pass the token's position information to the transformer architecture and obtain the representation of the position (represented as colored position at last layer in Figure FIGREF6). After that, we concatenate the embeddings at these position with the hidden states of last sentence. We pass these concatenated representations to the intent classifier and the slot classifier to obtain an intent and a semantic slot for each sentence in the utterance. As shown in Figure FIGREF6, the loss function ${\\mathcal {L}}$ for the model combines all the task losses:",
          "where ${\\mathcal {L}_{LM}}$ is the language model loss, ${\\mathcal {L}_{I_h}}$, ${\\mathcal {L}_{S_h}}$, ${\\mathcal {L}_{I_s}}$, and ${\\mathcal {L}_{S_s}}$ are losses of intent and slots classifiers, ${\\mathcal {L}_{nup}}$ is next-utterance classification loss. $\\lambda _{LM}$, $\\lambda _{I_h}$, $\\lambda _{S_h}$, $\\lambda _{I_s}$, $\\lambda _{S_s}$, and $\\lambda _{nup}$ are the hyper-parameters that control the relative importance of every loss."
        ]
      },
      {
        "section_name": "Model ::: Response Generation",
        "paragraphs": [
          "MISSA can generate multiple sentences in a single system turn. Therefore, we perform system generation conditioned on predicted system intents. More specifically, during the training phase, in addition to inserting a special $<$sep$>$ token at the end of each sentence, we also insert the intent of the system response as special tokens at the head of each sentence in the system response. For example, in Figure FIGREF6, we insert a $<$pos_ans$>$ token at the head of $S_t^1$, which is the system response in green. We then use a cross entropy loss function to calculate the loss between the predicted token and the ground truth intent token. During the testing phase, the model first generates a special intent token, then after being conditioned on this intent token, the model keeps generating a sentence until it generates a $<$sep$>$ token. After that, the model continues to generate another intent token and another sentence until it generates an $<$eos$>$ token."
        ]
      },
      {
        "section_name": "Model ::: Response Filtering",
        "paragraphs": [
          "Since we only perform conditional generation, a type of soft constraint on the predicted intent of system response, the system can still generate samples that violate simple conversation regulations, such as eliciting information that has already been provided. These corner cases may lead to fatal results in high-risk tasks, for example, health care and education. To improve the robustness of MISSA and improve its ability to generalize to more tasks, we add a response filtering module after the generation. With the nucleus sampling strategy BIBREF5, MISSA is able to generate multiple diverse candidate responses with different intents and semantic slots. We then adopt a task-specific response filtering policy to choose the best candidate response as the final output. In our anti-scam scenario, we set up a few simple rules to filter out some unreasonable candidates, for instance, eliciting the repeated information. The filtering module is easily adaptable to different domains or specific requirements, which makes our dialog system more controllable."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We evaluate MISSA on two non-collaborative task datasets. AntiScam aims to build a dialog system that occupies the attacker's attention and elicits the attacker's information while PersuasionForGood BIBREF1 aims to build a dialog system that persuades people to donate to a charity. We use $80\\%$ data for training, $10\\%$ data for validation, and $10\\%$ data for testing. More training details are presented in Appendix."
        ]
      },
      {
        "section_name": "Experiments ::: Baseline Models",
        "paragraphs": [
          "We compare MISSA mainly with two baseline models:",
          "TransferTransfo The vanilla TransferTransfo framework is compared with MISSA to show the impact and necessity of adding the intent and slot classifiers. We follow the original TransferTransfo design BIBREF0 and train with undelexicalized data.",
          "Hybrid Following BIBREF4 yu2017learning, we also build a hybrid dialog system by combining vanilla TransferTransfo and MISSA. Specifically, we first determine if the human utterances are on-task or off-task with human intent classifier. If the classifier decides that the utterance is on-task, we choose the response from MISSA; otherwise, we choose the response from vanilla TransferTransfo baseline.",
          "In addition, we perform ablation studies on MISSA to show the effects of different components.",
          "MISSA-sel denotes MISSA without response filtering.",
          "MISSA-con denotes MISSA leaving out the intent token at the start of the response generation."
        ]
      },
      {
        "section_name": "Experiments ::: Automatic Evaluation Metrics",
        "paragraphs": [
          "Perplexity Since the canonical measure of a good language model is perplexity, which indicates the error rate of the expected word. We choose perplexity to evaluate the model performance.",
          "Response-Intent Prediction (RIP) $\\&$ Response-Slot Prediction (RSP) Different from open-domain dialog systems, we care about the intents of the system response in non-collaborative tasks as we hope to know if the system response satisfies user intents. For example, in the anti-scam task, if the attacker elicits information from the system, we need to know if the system refuses or agrees to provide the information. Therefore we care about intent prediction for the generated system response. Since our baselines are more suited for social chat as they cannot produce system intents, we use the system intent and slot classifiers trained in our model to predict their responses' intents and slots. The intent predictor achieves a $84\\%$ accuracy and the semantic slot predictor achieves $77\\%$ on the AntiScam dataset. Then we compare the predicted values with human-annotated ground truth in the dataset to compute the response-intent prediction (RIP) and response-slot prediction (RSP).",
          "Extended Response-Intent Prediction (ERIP) $\\&$ Extended Response-Slot Prediction (ERSP) With Response-Intent Prediction, we verify the predicted intents to evaluate the coherence of the dialog. However, the real mapping between human-intent and system-intent is much more complicated as there might be multiple acceptable system-intents for the same human-intent. Therefore, we also design a metric to evaluate if the predicted system-intent is in the set of acceptable intents. Specifically, we estimate the transition probability $p(I_i|I_j)$ by counting the frequency of all the bi-gram human-intent and system-intent pairs in the training data. During the test stage, if the predicted intent matches the ground truth, we set the score as 1, otherwise we set the score as $p(I_{predict}|I_i)$ where $I_i$ is the intent of the input human utterance. We then report the average value of those scores over turns as the final extended response-intent prediction result."
        ]
      },
      {
        "section_name": "Experiments ::: Human Evaluation Metrics",
        "paragraphs": [
          "Automatic metrics only validate the system\u2019s performance on a single dimension at a time. The ultimate holistic evaluation should be conducted by having the trained system interact with human users. Therefore we also conduct human evaluations for the dialog system built on AntiScam. We test our models and baselines with 15 college-student volunteers. Each of them is asked to pretend to be an attacker and interact with all the models for at least three times to avoid randomness. We in total collect 225 number of dialogs. Each time, volunteers are required to use similar sentences and strategies to interact with all five models and score each model based on the metrics listed below at the end of the current round. Each model receives a total of 45 human ratings, and the average score is reported as the final human-evaluation score. In total, we design five different metrics to assess the models' conversational ability whilst interacting with humans. The results are shown in Table TABREF19.",
          "Fluency Fluency is used to explore different models' language generation quality.",
          "Coherence Different from single sentence's fluency, coherence focuses more on the logical consistency between sentences in each turn.",
          "Engagement In the anti-scam scenario, one of our missions is to keep engaging with the attackers to waste their time. So we directly ask volunteers (attackers) to what extend they would like to continue chatting with the system.",
          "Dialog length (Length) Engagement is a subjective metric. Anti-scam system's goal is to engage user in the conversation longer in order to limit their harm to other potential victims. So we count the dialog length as another metric to evaluate system performance.",
          "Task Success Score (TaskSuc) The other goal of the anti-scam system is to elicit attacker's personal information. We count the average type of information (name, address and phone number) that the system obtained from attackers as the task success score."
        ]
      },
      {
        "section_name": "Results and Analysis",
        "paragraphs": [
          "Table TABREF19 presents the main experiment results on AntiScam dataset, for both automatic evaluation metrics and human evaluation metrics. The experiment results on PersuasionForGood are shown in Table TABREF23. We observe that MISSA outperforms two baseline models (TransferTransfo and hybrid model) on almost all the metrics on both datasets. For further analysis, examples of real dialogs from the human evaluation are presented in Table TABREF21.",
          "Compared to the first TransferTransfo baseline, MISSA outperforms the TransferTransfo baseline on the on-task contents. From Table TABREF19, we observe that MISSA maintains longer conversations (14.9 turns) compared with TransferTransfo (8.5 turns), which means MISSA is better at maintaining the attacker's engagement. MISSA also has a higher task success score (1.294) than TransferTransfo (1.025), which indicates that it elicits information more strategically. In the top two dialogs (A and B) that are shown in Table TABREF21, both attackers were eliciting a credit card number in their first turns. TransferTransfo directly gave away the information, while MISSA replied with a semantically-related question \u201cwhy would you need my credit card number?\" Furthermore, in the next turn, TransferTransfo ignored the context and asked an irrelevant question \u201cwhat is your name?\u201d while MISSA was able to generate the response \u201cwhy can't you use my address?\u201d, which is consistent to the context. We suspect the improved performance of MISSA comes from our proposed annotation scheme: the semantic slot information enables MISSA to keep track of the current entities, and the intent information helps MISSA to maintain coherency and prolong conversations.",
          "Compared to the hybrid model baseline, MISSA performs better on off-task content. As shown in the bottom two dialogs in Table TABREF21, attackers in both dialogs introduced their names in their first utterances. MISSA recognized attacker's name, while the hybrid model did not. We suspect it is because the hybrid model does not have the built-in semantic slot predictor. In the second turn, both attackers were explaining the reason of requesting the billing address previously. With semantic slot information, MISSA can easily understand the attacker; but the hybrid model misunderstands that the attacker was talking about the order number, possibly because the token \u201corder\u201d appeared in the attacker's utterance. We suspect that the hybrid model's bad performance on the off-task content leads to its low coherence rating (2.76) and short dialog length (8.2).",
          "To explore the influence of the intent-based conditional response generation method and the designed response filter, we perform an ablation study. The results are shown in Table TABREF19. We find that MISSA has higher fluency score and coherence score than MISSA-con (4.18 vs 3.78 for fluency, and 3.75 vs 3.68 for coherence), which suggests that conditioning on the system intent to generate responses improves the quality of the generated sentences. Compared with MISSA-sel, MISSA achieves better performance on all the metrics. For example, the engagement score for MISSA is 3.69 while MISSA-sel only has 2.87. This is because the response filter removed all the incoherent responses, which makes the attacker more willing to keep chatting. The ablation study shows both the conditional language generation mechanism and the response filter are essential to MISSA's good performance.",
          "We also apply our method to the PersuasionForGood dataset. As shown in Table TABREF23, MISSA and its variants outperform the TransferTransfo and the hybrid models on all evaluation metrics. Such good performance indicates MISSA can be easily applied to a different non-collaborative task and achieve good performance. Particularly, MISSA achieves the lowest perplexity, which confirms that using conditional response generation leads to high quality responses. Compared with the result on AntiScam dataset, MISSA-con performs the best in terms of RIP and ERIP. We suspect the underlying reason is that there are more possible responses with the same intent in PersuasionForGood than in AntiScam. This also suggests that we should adjust the model structure according to the nature of the dataset."
        ]
      },
      {
        "section_name": "Conclusion and Future Work",
        "paragraphs": [
          "We propose a general dialog system pipeline to build non-collaborative dialog systems, including a hierarchical annotation scheme and an end-to-end neural response generation model called MISSA. With the hierarchical annotation scheme, we can distinguish on-task and off-task intents. MISSA takes both on and off-task intents as supervision in its training and thus can deal with diverse user utterances in non-collaborative settings. Moreover, to validate MISSA's performance, we create a non-collaborate dialog dataset that focuses on deterring phone scammers. MISSA outperforms all baseline methods in terms of fluency, coherency, and user engagement on both the newly proposed anti-scam task and an existing persuasion task. However, MISSA still produces responses that are not consistent with their distant conversation history as GPT can only track a limited history span. In future work, we plan to address this issue by developing methods that can effectively track longer dialog context."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "This work was supported by DARPA ASED Program HR001117S0050. The U.S. Government is authorized to reproduce and distribute reprints for governmental purposes not withstanding any copyright notation therein. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies, either expressed or implied, of DARPA or the U.S. Government."
        ]
      },
      {
        "section_name": "Appendix ::: Anti-Scam Collection Setting",
        "paragraphs": [
          "We randomly pair two workers: one is assigned the role of the attacker to elicit user information, and the other one is assigned the role of an everyday user who aims to protect her/his information and potentially elicit the attacker's information. We give both workers specific personal data. Instructions are shown in Table TABREF24. The \u201cattacker\u201d additionally receives training on how to elicit information from people. Workers cannot see their partners' instructions.",
          "There are two tasks for the users: firstly, users are required to chat with their partners and determine if they are attackers or not, reporting their decisions at the end of the task. If users think their partners are attackers, they are instructed to prolong the conversation and elicit information from their partners. We give a bonus to users if they detect the attackers and elicit real information from the attackers, including the attacker's name, address and phone number. Since one worker can only participate once in the task, they do not know their partners are always attackers.",
          "We provide real user information including the user's name and the task background (user purchased a product on Amazon) . Attackers are well-trained to pretend to be an Amazon customer service agent. To simulate a real-world scam, we tell attackers some details about the user, such as the user's name to stop them from being too easily identified. We give a bonus to attackers if they elicit correct information from users, including the user's address, credit card number, CVS and expiration date. Each worker can only participate once to prevent workers from knowing their partner's information and goals in advance. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable.",
          "We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value. Table TABREF2 shows that there is a vast amount of off-task content in the dataset, which confirms the necessity of a hierarchical on-task/off-task annotation scheme. We observe that sentences from the attacker and user have different intent distributions. Compared to attackers, users produce more refusal (74 vs 19), because users are more likely to refuse to provide requested information if they have detected the attacker. Moreover, users also ask more open_questions (173 vs 54) and yes_no_questions (165 vs 117) for off-task content because they are instructed to prolong the conversation after detecting the attacker. Furthermore, attackers and users both have a massive amount of social content (292 in total and 252 in total), suggesting that it is important to have social intent sentences to maintain the conversation."
        ]
      },
      {
        "section_name": "Appendix ::: Training details",
        "paragraphs": [
          "MISSA is based on the generative pre-trained transformer BIBREF32. We use an Adam optimizer with a learning rate of 6.25e-5 and $L2$ weight decay of $0.01$, we set the coefficient of language modeling loss to be 2, the coefficient of intent and slot classifiers to be 1, and the coefficient of next-utterance classifier to be 1. We first pre-train the model on the PERSONA-CHAT dataset. When fine-tuning on the AntiScam and the PersuasionForGood datasets, we use $80\\%$ data for training, $10\\%$ data for validation, and $10\\%$ data for testing. Since the original PersuasionForGood dataset is annotated with intents, we separate the original on-task and off-task intents, which are shown in Table TABREF2. To deal with the words out of the vocabulary, we conduct delexicalization to replace slot values with corresponding slot tokens during the training phase, and replace the slot tokens with pre-defined information during testing."
        ]
      },
      {
        "section_name": "Appendix ::: Example Dialog",
        "paragraphs": [
          "An example of human-human chat on AntiScam dataset is shown in Table TABREF25."
        ]
      }
    ],
    "qas": [
      {
        "question": "How big is the ANTISCAM dataset? ",
        "question_id": "397a1e851aab41c455c2b284f5e4947500d797f0",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "f7c76ad7ff9c8b54e8c397850358fa59258c6672",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " 3,044 sentences in 100 dialogs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words",
                "We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ]
            },
            "annotation_id": "02b0c6a33e3085050b5466b86495d599faed73a4",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "220 human-human dialogs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words."
              ]
            },
            "annotation_id": "0842e20969f9cc0e015b600b00aba111866213bf",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "220 human-human dialogs. ",
                "3,044 sentences in 100 dialogs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ]
            },
            "annotation_id": "088800b75f0f40f97436cccebd33a7f55023f32f",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words."
              ]
            },
            "annotation_id": "293218eb9afa8e4e5865ce8c7806821274c8ab71",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "220 human-human dialogs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ]
            },
            "annotation_id": "9834da998d57bbb3c84289c13cd888586a124fce",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "3,044 sentences in 100 dialogs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To enrich available non-collaborative task datasets, we created a corpus of human-human anti-scam dialogs in order to learn human elicitation strategies. We chose a popular Amazon customer service scam scenario to collect dialogs between users and attackers who aim to collect users information. We posted a role-playing task on the Amazon Mechanical Turk platform and collected a typing conversation dataset named AntiScam. We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ],
              "highlighted_evidence": [
                "We collected 220 human-human dialogs. The average conversation length is 12.45 turns and the average utterance length is 11.13 words. Only 172 out of 220 users successfully identified their partner as an attacker, suggesting that the attackers are well trained and not too easily identifiable. We recruited two expert annotators who have linguistic training to annotate 3,044 sentences in 100 dialogs, achieving a 0.874 averaged weighted kappa value."
              ]
            },
            "annotation_id": "cc82e44d4ec4b2ee68647b2eedb2cb8bf846d91d",
            "worker_id": "9cf96ca8b584b5de948019dc75e305c9e7707b92"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Hierarchical intent annotation scheme on both ANTISCAM dataset and PERSUASIONFORGOOD dataset. The On-task intents are task-specific while the Off-task intents are general for different non-collaborative tasks."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: ANTISCAM\u2019s semantic slot annotation scheme."
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: The training phase overview of MISSA on ANTISCAM dataset, the input consists of three parts: private information, dialog history, and an appended next utterance. We concatenate the last hidden states at <sep> tokens with the last hidden states at the end of the last utterance to predict intents and semantic slots for corresponding sentences. We can predict multiple intents and semantic slots for each human utterance and system response. During testing, the appended response and distractor are removed."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Experiments results with both automatic and human evaluation on ANTISCAM dataset."
      },
      {
        "file": "7-Table4-1.png",
        "caption": "Table 4: Examples of human-system dialogs, where systems are trained on ANTISCAM dataset. System responses are bolded."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: Automatic evaluation results on PERSUASIONFORGOOD dataset."
      },
      {
        "file": "8-Table6-1.png",
        "caption": "Table 6: Instructions for attackers and users on Amazon Mechanical Turk."
      },
      {
        "file": "9-Table7-1.png",
        "caption": "Table 7: An example human-human dialog in ANTISCAM dataset. All the slot values have been replaced with slot tokens."
      }
    ]
  },
  "1611.06322": {
    "title": "Spotting Rumors via Novelty Detection",
    "abstract": "Rumour detection is hard because the most accurate systems operate retrospectively, only recognising rumours once they have collected repeated signals. By then the rumours might have already spread and caused harm. We introduce a new category of features based on novelty, tailored to detect rumours early on. To compensate for the absence of repeated signals, we make use of news wire as an additional data source. Unconfirmed (novel) information with respect to the news articles is considered as an indication of rumours. Additionally we introduce pseudo feedback, which assumes that documents that are similar to previous rumours, are more likely to also be a rumour. Comparison with other real-time approaches shows that novelty based features in conjunction with pseudo feedback perform significantly better, when detecting rumours instantly after their publication.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Social Media has evolved from friendship based networks to become a major source for the consumption of news (NIST, 2008). On social media, news is decentralised as it provides everyone the means to efficiently report and spread information. In contrast to traditional news wire, information on social media is spread without intensive investigation, fact and background checking. The combination of ease and fast pace of sharing information provides a fertile breeding ground for rumours, false- and disinformation. Social media users tend to share controversial information in-order to verify it, while asking about for the opinions of their followers (Zhao et. al, 2015). This further amplifies the pace of a rumour's spread and reach. Rumours and deliberate disinformation have already caused panic and influenced public opinion.",
          "The cases in Germany and Austria in 2016, show how misleading and false information about crimes committed by refugees negatively influenced the opinion of citizens.",
          "Detecting these rumours allows debunking them to prevent them from further spreading and causing harm. The further a rumour has spread, the more likely it is to be debunked by users or traditional media (Liu et. al, 2015). However, by then rumours might have already caused harm. This highlights the importance and necessity of recognizing rumours as early as possible - preferably instantaneously.",
          "Rumour detection on social media is challenging due to the short texts, creative lexical variations and high volume of the streams. The task becomes even harder if we attempt to perform rumour detection on-the-fly, without looking into the future. We provide an effective and highly scalable approach to detect rumours instantly after they were posted with zero delay. We introduce a new features category called novelty based features. Novelty based features compensate the absence of repeated information by consulting additional data sources - news wire articles. We hypothesize that information not confirmed by official news is an indication of rumours. Additionally we introduce pseudo feedback for classification. In a nutshell, documents that are similar to previously detected rumours are considered to be more likely to also be a rumour. The proposed features can be computed in constant time and space allowing us to process high-volume streams in real-time (Muthukrishnan, 2005). Our experiments reveal that novelty based features and pseudo feedback significantly increases detection performance for early rumour detection.",
          "The contributions of this paper include:",
          "Novelty based Features",
          "We introduced a new category of features for instant rumour detection that harnesses trusted resources. Unconfirmed (novel) information with respect to trusted resources is considered as an indication of rumours.",
          "Pseudo Feedback for Detection/Classification",
          "Pseudo feedback increases detection accuracy by harnessing repeated signals, without the need of retrospective operation."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Before rumour detection, scientists already studied the related problem of information credibility evaluation (Castillo et. al. 2011; Richardson et. al, 2003). Recently, automated rumour detection on social media evolved into a popular research field which also relies on assessing the credibility of messages and their sources. The most successful methods proposed focus on classification harnessing lexical, user-centric, propagation-based (Wu et. al, 2015) and cluster-based (Cai et. al, 2014; Liu et. al, 2015; Zhao et. al, 2015) features.",
          "Many of these context based features originate from a study by Castillo et. al (2011), which pioneered in engineering features for credibility assessment on Twitter (Liu et. al, 2015). They observed a significant correlation between the trustworthiness of a tweet with context-based characteristics including hashtags, punctuation characters and sentiment polarity. When assessing the credibility of a tweet, they also assessed the source of its information by constructing features based on provided URLs as well as user based features like the activeness of the user and social graph based features like the frequency of re-tweets. A comprehensive study by Castillo et. al (2011) of information credibility assessment widely influenced recent research on rumour detection, whose main focuses lies upon improving detection quality.",
          "While studying the trustworthiness of tweets during crises, Mendoza et. al (2010) found that the topology of a distrustful tweet's propagation pattern differs from those of news and normal tweets. These findings along with the fact that rumours tend to more likely be questioned by responses than news paved the way for future research examining propagation graphs and clustering methods (Cai et. al, 2014; Zhao et. al, 2015). The majority of current research focuses on improving the accuracy of classifiers through new features based on clustering (Cai et. al, 2014; Zhao et. al, 2015), sentiment analysis (Qazvinian et. al, 2011; Wu et. al, 2015) as well as propagation graphs (Kwon, et. al, 2013; Wang et. al, 2015).",
          "Recent research mainly focuses on further improving the quality of rumour detection while neglecting the increasing delay between the publication and detection of a rumour. The motivation for rumour detection lies in debunking them to prevent them from spreading and causing harm. Unfortunately, state-of-the-art systems operate in a retrospective manner, meaning they detect rumours long after they have spread. The most accurate systems rely on features based on propagation graphs and clustering techniques. These features can only detect rumours after the rumours have spread and already caused harm.",
          "Therefore, researchers like Liu et. al (2015), Wu et. al (2015), Zhao et. al (2015) and Zhou et. al (2015) focus on 'early rumour-detection' while allowing a delay up to 24 hours. Their focus on latency aware rumour detection makes their approaches conceptually related to ours. Zhao et. al (1015) found clustering tweets containing enquiry patterns as an indication of rumours. Also clustering tweets by keywords and subsequently judging rumours using an ensemble model that combine user, propagation and content-based features proved to be effective (Zhou et. al, 2015). Although the computation of their features is efficient, the need for repeated mentions in the form of response by other users results in increased latency between publication and detection. The approach with the lowest latency banks on the 'wisdom of the crowd' (Liu et. al, 2015). In addition to traditional context and user based features they also rely on clustering micro-blogs by their topicality to identify conflicting claims, which indicate increased likelihood of rumours. Although they claim to operate in real-time, they require a cluster of at least 5 messages to detect a rumour.",
          "In contrast, we introduce new features to detect rumours as early as possible - preferably instantly, allowing them to be debunked before they spread and cause harm."
        ]
      },
      {
        "section_name": "Rumour Detection",
        "paragraphs": [
          "Rumour detection is a challenging task, as it requires determining the truth of information (Zhao et. al, 2015). The Cambridge dictionary, defines a rumour as information of doubtful or unconfirmed truth. We rely on classification using an SVM, which is the state-of-the-art approach for novelty detection. Numerous features have been proposed for rumour detection on social media, many of which originate from an original study on information credibility by Castillo et. al (2011). Unfortunately, the currently most successful features rely on information based on graph propagation and clustering, which can only be computed retrospectively. This renders them close to useless when detecting rumours early on. We introduce two new classes of features, one based on novelty, the other on pseudo feedback. Both feature categories improve detection accuracy early on, when information is limited."
        ]
      },
      {
        "section_name": "Problem Statement",
        "paragraphs": [
          "We frame the Real-time Rumour Detection task as a classification problem that assesses a document's likelihood of becoming a future rumour at the time of its publication. Consequently, prediction takes place in real-time with a single pass over the data.",
          "More formally, we denote by $d_t$ the document that arrives from stream $S:\\lbrace d_0, d_1, . . . d_n\\rbrace $ at time $t$ . Upon arrival of document $d_t$ we compute its corresponding feature vector $f_{d,t}$ . Given $f_{d,t}$ and the previously obtained weigh vector $w$ we compute the rumour score $RS_{d,t} = w^T \\times f_{d,t}$ . The rumour prediction is based on a fixed thresholding strategy with respect to $\\theta $ . We predict that message $d_t$ is likely to become a rumour if its rumour score exceeds the detection threshold $S:\\lbrace d_0, d_1, . . . d_n\\rbrace $0 . The optimal parameter setting for weight vector $S:\\lbrace d_0, d_1, . . . d_n\\rbrace $1 and detection threshold $S:\\lbrace d_0, d_1, . . . d_n\\rbrace $2 are learned on a test to maximise prediction accuracy."
        ]
      },
      {
        "section_name": "Novelty-based Features",
        "paragraphs": [
          "To increase instantaneous detection performance, we compensate for the absence of future information by consulting additional data sources. In particular, we make use of news wire articles, which are considered to be of high credibility. This is reasonable as according to Petrovic et. al (2013), in the majority of cases, news wires lead social media for reporting news. When a message arrives from a social media stream, we build features based on its novelty with respect to the confirmed information in the trusted sources. In a nutshell, the presence of information unconfirmed by the official media is construed as an indication of being a rumour. Note that this closely resembles the definition of what a rumour is."
        ]
      },
      {
        "section_name": "Novelty Feature Construction",
        "paragraphs": [
          "High volume streams demand highly efficient feature computation. This applies in particular to novelty based features since they can be computationally expensive. We explore two approaches to novelty computation: one based on vector proximity, the other on kterm hashing.",
          "Computing novelty based on traditional vector proximity alone does not yield adequate performance due to the length discrepancy between news wire articles and social media messages. To make vector proximity applicable, we slide a term-level based window, whose length resembles the average social media message length, through each of the news articles. This results in sub-documents whose length resembles those of social media messages. Novelty is computed using term weighted tf-idf dot products between the social media message and all news sub-documents. The inverse of the minimum similarity to the nearest neighbour equates to the degree of novelty.",
          "The second approach to compute novelty relies on kterm hashing (Wurzer et. al, 2015), a recent advance in novelty detection that improved the efficiency by an order of magnitude without sacrificing effectiveness. Kterm hashing computes novelty non-comparatively. Instead of measuring similarity between documents, a single representation of previously seen information is constructed. For each document, all possible kterms are formed and hashed onto a Bloom Filter. Novelty is computed by the fraction of unseen kterms. Kterm hashing has the interesting characteristic of forming a collective 'memory', able to span all trusted resources. We exhaustively form kterm for all news articles and store their corresponding hash positions in a Bloom Filter. This filter then captures the combined information of all trusted resources. A single representation allows computing novelty with a single step, instead of comparing each social media message individually with all trusted resources.",
          "When kterm hashing was introduced by Wurzer et. al (2015) for novelty detection on English tweets, they weighted all kterm uniformly. We found that treating all kterms as equally important, does not unlock the full potential of kterm hashing. Therefore, we additionally extract the top 10 keywords ranked by $tf.idf$ and build a separate set of kterms solely based on them. This allows us to compute a dedicated weight for kterms based on these top 10 keywords. The distinction in weights between kterms based on all versus keyword yields superior rumour detection quality, as described in section \"Feature analysis\" . This leaves us with a total of 6 novelty based features for kterm hashing - kterms of length 1 to 3 for all words and keywords.",
          "Apart from novelty based features, we also apply a range of 51 context based features. The full list of features can be found in table 6 . The focus lies on features that can be computed instantly based only on the text of a message to keep the latency of our approach to a minimum. Most of these 51 features overlap with previous studies (Castillo et. al, 2011; Liu et. al, 2015; Qazvinian et. al, 2011; Yang et. al, 2012; Zhao et. al, 2015). This includes features based on the presence or number of URLs, hash-tags and user-names, POS tags, punctuation characters as well as 8 different categories of sentiment and emotions.",
          "On the arrival of a new message from a stream, all its features are computed and linearly combined using weights obtained from an SVM classifier, yielding the rumour score. We then judge rumours based on an optimal threshold strategy for the rumour score."
        ]
      },
      {
        "section_name": "Pseudo Feedback",
        "paragraphs": [
          "In addition to novelty based features we introduce another category of features - dubbed Pseudo-Feedback (PF) feature - to boost detection performance. The feature is conceptually related to pseudo relevance feedback found in retrieval and ranking tasks in IR. The concept builds upon the idea that documents, which reveal similar characteristics as previously detected rumours are also likely to be a rumour. During detection, feedback about which of the previous documents describes a rumour is not available. Therefore, we rely on 'pseudo' feedback and consider all documents whose rumour score exceeds a threshold as true rumours.",
          "The PF feature describes the maximum similarity between a new document and those documents previously considered as rumour. Similarities are measured by vector proximity in term space. Conceptually, PF passes on evidence to repeated signals by increasing the rumour score of future documents if they are similar to a recently detected rumour. Note that this allows harnessing information from repeated signals without the need of operating retrospectively.",
          "Training Pseudo Feedback Features",
          "The trainings routine differs from the standard procedure, because the computation of the PF feature requires two training rounds as we require a model of all other features to identify 'pseudo' rumours. In a first training round a SVM is used to compute weights for all features in the trainings set, except the PF features. This provides a model for all but the PF features. Then the trainings set is processed to computing rumour scores based on the model obtained from our initial trainings round. This time, we additionally compute the PF feature value by measuring the minimum distance in term space between the current document vector and those previous documents, whose rumour score exceeds a previously defined threshold. Since we operate on a stream, the number of documents previously considered as rumours grows without bound. To keep operation constant in time and space, we only compare against the k most recent documents considered to be rumours. Once we obtained the value for the PF feature, we compute its weight using the SVM. The combination of the weight for the PF feature with the weights for all other features, obtained in the initial trainings round, resembles the final model."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "The previous sections introduced two new categories of features for rumour detection. Now we test their performance and impact on detection effectiveness and efficiency. In a streaming setting, documents arrive on a continual basis one at a time. We require our features to compute a rumour-score instantaneously for each document in a single-pass over the data. Messages with high rumour scores are considered likely being rumours. The classification decision is based on an optimal thresholding strategy based on the trainings set."
        ]
      },
      {
        "section_name": "Evaluation metrics",
        "paragraphs": [
          "We report accuracy to evaluate effectiveness, as is usual in the literature (Zhou et. al, 2015). Additionally we use the standard TDT evaluation procedure (Allan et. al, 2000; NIST, 2008) with the official TDT3 evaluation scripts (NIST, 2008) using standard settings. This procedure evaluates detection tasks using Detection Error Trade-off (DET) curves, which show the trade-off between miss and false alarm probability. By visualizing the full range of thresholds, DET plots provide a more comprehensive illustration of effectiveness than single value metrics (Allan et. al, 2000). We also evaluate the efficiency of computing the proposed features, measured by the throughput per second, when applied to a high number of messages."
        ]
      },
      {
        "section_name": "Data set",
        "paragraphs": [
          "Rumour detection on social media is a novel research field without official data sets. Since licences agreements forbid redistribution of data, no data sets from previous publications are available. We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset.",
          "trusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.",
          "For our social media stream, we chose Sina Weibo, a Chinese social media service with more than 200 million active users. Micro-blogs from Sina Weibo are denoted as 'weibos'.",
          "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours.",
          "non-rumours: We additionally gathered 202 non-rumours using the public Sina Weibo API. Three human annotators judged these weibos based on unanimous decision making to ensure that they don't contain rumours.",
          "Since we operate in a streaming environment, all weibos are sorted based on their publication time-stamp. Table 3 shows a list of example for rumours found in our data set.",
          "We ordered the rumours and non-rumours chronologically and divided them in half, forming a training and test set. We ensured that each of the sets consists of 50% rumours and non-rumours. This is important when effectiveness is measured by accuracy. All training and optimization use the trainings set. Performance is then reported based on a single run on the test set."
        ]
      },
      {
        "section_name": "Rumour detection effectiveness",
        "paragraphs": [
          "To evaluate our new features for rumour detection, we compare them with two state-of-the-art early rumour detection baselines Liu et. al (2015) and Yang et. al (2012), which we re-implemented. We chose the algorithm by Yang et. al (2012), dubbed Yang, because they proposed a feature set for early detection tailored to Sina Weibo and were used as a state-of-the-art baseline before by Liu et. al (2015). The algorithm by Liu et. al (2015), dubbed Liu, is said to operate in real-time and outperformed Yang, when only considering features available on Twitter. Both apply various message-, user-, topic- and propagation-based features and rely on an SVM classifier which they also found to perform best. The approaches advertise themselves as suitable for early or real-time detection and performed rumour detection with the smallest latency across all published methods. Yang performs early rumour detection and operates with a delay of 24 hours. Liu is claimed to perform in real-time while, requiring a cluster of 5 repeated messages to judge them for rumours. Note that although these algorithm are state-of-the-art for detecting rumours as quickly as possible, they still require a certain delay to reach their full potential.",
          "Table 2 compares the performance of our features with the two classifiers on the 101 rumours and 101 non-rumours of the test set, when detecting rumour instantly after their publication. The table reveals comparable accuracy for Yang and Liu at around 60%. Our observed performance of Yang matches those by Liu et. al (2015). Surprisingly, the algorithm Liu does not perform significantly better than Yang when applied to instantaneous rumour detection although they claimed to operate in real-time. Liu et. al (2015) report performance based on the first 5 messages which clearly outperforms Yang for early rumour detection. However, we find that when reducing the set from 5 to 1, their superiority is only marginal. In contrast, the combination of novelty and pseudo relevance based features performs significantly better (sign test with $p < 0.05$ ) than the baselines for instantaneous rumour detections. Novelty based features benefit from news articles as an external data source, which explains their superior performance. In particular for instantaneous rumour detection, where information can only be obtained from a single message, the use of external data proves to perform superior. Note that accuracy is a single value metric describing performance at an optimal threshold. Figure 1 compares the effectiveness of the three algorithms for the full range of rumour scores for instantaneous detection. Different applications require a different balance between miss and false alarm. But the DET curve shows that Liu\u2019s method would be preferable over Yang for any application. Similarly, the plot reveals that our approach dominates both baselines throughout all threshold settings and for the high-recall region in particular.",
          "When increasing the detection delay to 12 and 24 hours, all three algorithms reach comparable performance with no statistically significant difference, as seen in table 4. For our approach, none of the features are computed retrospectively, which explains why the performance does not change when increasing the detection delay. The additional time allows Liu and Yang to collect repeated signals, which improves their detection accuracy. After 24 hours Liu performs the highest due to its retrospectively computed features. Note that after 24 hours rumours might have already spread far through social networks and potentially caused harm."
        ]
      },
      {
        "section_name": "Feature analysis",
        "paragraphs": [
          "We group our 57 features into 7 categories shown in Table 6 and analyse their contribution using feature ablation, as seen in Table 5 . Feature ablation illustrates the importance of a feature by measuring performance, when removing it from the set of features. Novelty related features based on kterm hashing were found to be dominant for instantaneous rumour detection $(p < 0.05)$ . 'Sentence char' features, which include punctuation, hashtags, user-symbols and URLs, contributed the most of the traditional features, followed by Part of Speech ('POS') and 'extreme word' features. Our experiments found 'sentiment' and 'emotion' based features to contribute the least. Since excluding them both results in a considerable drop of performance we conclude that they capture comparable information and therefore compensated for each other.",
          "Novelty based Features",
          "Novelty based features revealed the highest impact on detection performance. In particular kterms formed from the top keywords contribute the most. This is interesting, as when kterm hashing was introduced (Wurzer et. al, 2015), all kterms were considered as equally important. We found that prioritising certain kterms yields increased performance.",
          "Interestingly, novelty based features computed by the vector similarity between weibos and news sub-documents perform slightly worse (-2% absolute). When striping all but the top tf-idf weighted terms from the news sub-documents, the hit in performance can be reduced to -1 % absolute. Kterm constructs a combined memory of all information presented to it. Pulling all information into a single representation bridges the gab between documents and allows finding information matches within documents. We hypothesize that this causes increased detection performance.",
          "Pseudo Feedbaack",
          "Features ablation revealed that pseudo feedback (PF) increased detection performance by 5.3% (relative). PF builds upon the output of the other features. High performance of the other features results in higher positive impact of PF. We want to further explore the behaviour of PF when other features perform badly in future studies."
        ]
      },
      {
        "section_name": "Detecting unpopular rumours",
        "paragraphs": [
          "Previous approaches to rumour detection rely on repeated signals to form propagation graphs or clustering methods. Beside causing a detection delay these methods are also blind to less popular rumours that don't go viral. In contrast, novelty based feature require only a single message enabling them to detect even the smallest rumours. Examples for such small rumours are shown in table 3 ."
        ]
      },
      {
        "section_name": "Efficiency and Scalability",
        "paragraphs": [
          "To demonstrate the high efficiency of computing novelty and pseudo feedback features, we implement a rumour detection system and measure its throughput when applied to 100k weibos. We implement our system in C and run it using a single core on a 2.2GHz Intel Core i7-4702HQ. We measure the throughput on an idle machine and average the observed performance over 5 runs. Figure 2 presents performance when processing more and more weibos. The average throughput of our system is around 7,000 weibos per second, which clearly exceeds the average volume of the full Twitter (5,700 tweets/sec.) and Sina Weibo (1,200 weibos/sec.) stream. Since the number of news articles is relatively small, we find no difference in terms of efficiency between computing novelty features based on kterm hashing and vector similarity. Figure 2 also illustrates that our proposed features can be computed in constant time with respect to the number of messages processed. This is crucial to keep operation in a true streaming environment feasible. Approaches, whose runtime depend on the number of documents processed become progressively slower, which is inapplicable when operating on data streams. Our experiments show that the proposed features perform effectively and their efficiency allows them to detect rumours instantly after their publication."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We introduced two new categories of features which significantly improve instantaneous rumour detection performance. Novelty based features consider the increased presence of unconfirmed information within a message with respect to trusted sources as an indication of being a rumour. Pseudo feedback features consider messages that are similar to previously detected rumours as more likely to also be a rumour. Pseudo feedback and its variant, recursive pseudo feedback, allow harnessing repeated signals without the need of operating retrospectively. Our evaluation showed that novelty and pseudo feedback based features perform significantly more effective than other real-time and early detection baselines, when detecting rumours instantly after their publication. This advantage vanishes when allowing an increased detection delay. We also showed that the proposed features can be computed efficiently enough to operate on the average Twitter and Sina Weibo stream while keeping time and space requirements constant."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they build a dataset of rumors?",
        "question_id": "85e417231a4bbb6691f7a89bd81710525f8fec4c",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "somewhat",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "trusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.",
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours."
              ],
              "highlighted_evidence": [
                "We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period.",
                "Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours."
              ]
            },
            "annotation_id": "04941eae5c74f8aaa4d6d9cbc0f8d75be8bd1fef",
            "worker_id": "efdb8f7f2fe9c47e34dfe1fb7c491d0638ec2d86"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Rumour detection on social media is a novel research field without official data sets. Since licences agreements forbid redistribution of data, no data sets from previous publications are available. We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset.",
                "trusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.",
                "For our social media stream, we chose Sina Weibo, a Chinese social media service with more than 200 million active users. Micro-blogs from Sina Weibo are denoted as 'weibos'.",
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours.",
                "non-rumours: We additionally gathered 202 non-rumours using the public Sina Weibo API. Three human annotators judged these weibos based on unanimous decision making to ensure that they don't contain rumours.",
                "Since we operate in a streaming environment, all weibos are sorted based on their publication time-stamp. Table 3 shows a list of example for rumours found in our data set.",
                "We ordered the rumours and non-rumours chronologically and divided them in half, forming a training and test set. We ensured that each of the sets consists of 50% rumours and non-rumours. This is important when effectiveness is measured by accuracy. All training and optimization use the trainings set. Performance is then reported based on a single run on the test set."
              ],
              "highlighted_evidence": [
                "Rumour detection on social media is a novel research field without official data sets. Since licences agreements forbid redistribution of data, no data sets from previous publications are available. We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset.\n\ntrusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.\n\nFor our social media stream, we chose Sina Weibo, a Chinese social media service with more than 200 million active users. Micro-blogs from Sina Weibo are denoted as 'weibos'.\n\nrumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours.\n\nnon-rumours: We additionally gathered 202 non-rumours using the public Sina Weibo API. Three human annotators judged these weibos based on unanimous decision making to ensure that they don't contain rumours.\n\nSince we operate in a streaming environment, all weibos are sorted based on their publication time-stamp. Table 3 shows a list of example for rumours found in our data set.\n\nWe ordered the rumours and non-rumours chronologically and divided them in half, forming a training and test set. We ensured that each of the sets consists of 50% rumours and non-rumours. "
              ]
            },
            "annotation_id": "2420b51cf1d056ad0a8fea91a25098f1503c3cc1",
            "worker_id": "1ba1b5b562aef9cd264cace5b7bdd46a7c065c0a"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours."
              ],
              "highlighted_evidence": [
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours."
              ]
            },
            "annotation_id": "6932f5798a91cb208bba211d0395fdad9da93a23",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "Rumour detection on social media is a novel research field without official data sets. Since licences agreements forbid redistribution of data, no data sets from previous publications are available. We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset.",
                "trusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.",
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours.",
                "non-rumours: We additionally gathered 202 non-rumours using the public Sina Weibo API. Three human annotators judged these weibos based on unanimous decision making to ensure that they don't contain rumours."
              ],
              "highlighted_evidence": [
                " We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset.",
                "trusted resources: We randomly collected 200 news articles about broad topics commonly reported by news wires over our target time period. These range from news about celebrities and disasters to financial and political affairs as seen in table 1 . Since we operate on Chinese social media, we gathered news articles from Xinhua News Agency, the leading news-wire in China. To ensure a fair evaluation, we collected the news articles before judging rumours, not knowing which rumours we would find later on. We also only consider news articles published before the timestamps of the social media messages.",
                "rumours: Sina Weibo offers an official rumour debunking service, operated by trained human professionals. Following Yang et. al (2012) and Zhou et. al (2015), we use this service to obtain a high quality set of 202 confirmed rumours.",
                "non-rumours: We additionally gathered 202 non-rumours using the public Sina Weibo API. Three human annotators judged these weibos based on unanimous decision making to ensure that they don't contain rumours."
              ],
              "yes_no": null,
              "free_form_answer": "Yes, consisting of trusted resources, rumours and non-rumours",
              "extractive_spans": []
            },
            "annotation_id": "d88818f5e8173a3f82e5ac17d6db100fcc19da9a",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "Rumour detection on social media is a novel research field without official data sets. Since licences agreements forbid redistribution of data, no data sets from previous publications are available. We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset."
              ],
              "highlighted_evidence": [
                "We therefore followed previous researchers like Liu et. al (2015) and Yang et. al (2012) and created our own dataset."
              ],
              "yes_no": true,
              "free_form_answer": "",
              "extractive_spans": []
            },
            "annotation_id": "15133c2bd9f411178e15d713d75efd220a149b58",
            "worker_id": "c7d4a630661cd719ea504dba56393f78278b296b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Excerpt of topics with synopsis of corresponding rumours"
      },
      {
        "file": "6-Figure1-1.png",
        "caption": "Figure 1: DET plot, revealing superior effectiveness of our approach for instant rumour detection for the full range of thresholds"
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Detection accuracy at different levels of delay; Asterisk indicates significance (p < 0.05)"
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Effectiveness in comparison with two state-of-the-art baselines for instant rumour detection using optimal thresholds"
      },
      {
        "file": "8-Figure2-1.png",
        "caption": "Figure 2: Throughput of our approach per second in comparison to the average Twitter (Firehose) and Sina Weibo stream"
      },
      {
        "file": "8-Table6-1.png",
        "caption": "Table 6: Description of features"
      }
    ]
  },
  "1911.04474": {
    "title": "TENER: Adapting Transformer Encoder for Named Entity Recognition",
    "abstract": "The Bidirectional long short-term memory networks (BiLSTM) have been widely used as an encoder in models solving the named entity recognition (NER) task. Recently, the Transformer is broadly adopted in various Natural Language Processing (NLP) tasks owing to its parallelism and advantageous performance. Nevertheless, the performance of the Transformer in NER is not as good as it is in other NLP tasks. In this paper, we propose TENER, a NER architecture adopting adapted Transformer Encoder to model the character-level features and word-level features. By incorporating the direction and relative distance aware attention and the un-scaled attention, we prove the Transformer-like encoder is just as effective for NER as other NLP tasks.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The named entity recognition (NER) is the task of finding the start and end of an entity in a sentence and assigning a class for this entity. NER has been widely studied in the field of natural language processing (NLP) because of its potential assistance in question generation BIBREF0, relation extraction BIBREF1, and coreference resolution BIBREF2. Since BIBREF3, various neural models have been introduced to avoid hand-crafted features BIBREF4, BIBREF5, BIBREF6.",
          "NER is usually viewed as a sequence labeling task, the neural models usually contain three components: word embedding layer, context encoder layer, and decoder layer BIBREF4, BIBREF5, BIBREF6, BIBREF7, BIBREF8, BIBREF9, BIBREF10. The difference between various NER models mainly lies in the variance in these components.",
          "Recurrent Neural Networks (RNNs) are widely employed in NLP tasks due to its sequential characteristic, which is aligned well with language. Specifically, bidirectional long short-term memory networks (BiLSTM) BIBREF11 is one of the most widely used RNN structures. BIBREF4 was the first one to apply the BiLSTM and Conditional Random Fields (CRF) BIBREF12 to sequence labeling tasks. Owing to BiLSTM's high power to learn the contextual representation of words, it has been adopted by the majority of NER models as the encoder BIBREF5, BIBREF6, BIBREF9, BIBREF10.",
          "Recently, Transformer BIBREF13 began to prevail in various NLP tasks, like machine translation BIBREF13, language modeling BIBREF14, and pretraining models BIBREF15. The Transformer encoder adopts a fully-connected self-attention structure to model the long-range context, which is the weakness of RNNs. Moreover, Transformer has better parallelism ability than RNNs. However, in the NER task, Transformer encoder has been reported to perform poorly BIBREF16, our experiments also confirm this result. Therefore, it is intriguing to explore the reason why Transformer does not work well in NER task.",
          "In this paper, we analyze the properties of Transformer and propose two specific improvements for NER.",
          "The first is that the sinusoidal position embedding used in the vanilla Transformer is aware of distance but unaware of the directionality. In addition, this property will lose when used in the vanilla Transformer. However, both the direction and distance information are important in the NER task. For example in Fig FIGREF3, words after \u201cin\" are more likely to be a location or time than words before it, and words before \u201cInc.\" are mostly likely to be of the entity type \u201cORG\". Besides, an entity is a continuous span of words. Therefore, the awareness of distance might help the word better recognizes its neighbor. To endow the Transformer with the ability of direction- and distance-awareness, we adopt the relative positional encoding BIBREF17, BIBREF18, BIBREF19. instead of the absolute position encoding. We propose a revised relative positional encoding that uses fewer parameters and performs better.",
          "The second is an empirical finding. The attention distribution of the vanilla Transformer is scaled and smooth. But for NER, a sparse attention is suitable since not all words are necessary to be attended. Given a current word, a few contextual words are enough to judge its label. The smooth attention could include some noisy information. Therefore, we abandon the scale factor of dot-production attention and use an un-scaled and sharp attention.",
          "With the above improvements, we can greatly boost the performance of Transformer encoder for NER.",
          "Other than only using Transformer to model the word-level context, we also tried to apply it as a character encoder to model word representation with character-level information. The previous work has proved that character encoder is necessary to capture the character-level features and alleviate the out-of-vocabulary (OOV) problem BIBREF6, BIBREF5, BIBREF7, BIBREF20. In NER, CNN is commonly used as the character encoder. However, we argue that CNN is also not perfect for representing character-level information, because the receptive field of CNN is limited, and the kernel size of the CNN character encoder is usually 3, which means it cannot correctly recognize 2-gram or 4-gram patterns. Although we can deliberately design different kernels, CNN still cannot solve patterns with discontinuous characters, such as \u201cun..ily\u201d in \u201cunhappily\" and \u201cunnecessarily\". Instead, the Transformer-based character encoder shall not only fully make use of the concurrence power of GPUs, but also have the potentiality to recognize different n-grams and even discontinuous patterns. Therefore, in this paper, we also try to use Transformer as the character encoder, and we compare four kinds of character encoders.",
          "In summary, to improve the performance of the Transformer-based model in the NER task, we explicitly utilize the directional relative positional encoding, reduce the number of parameters and sharp the attention distribution. After the adaptation, the performance raises a lot, making our model even performs better than BiLSTM based models. Furthermore, in the six NER datasets, we achieve state-of-the-art performance among models without considering the pre-trained language models or designed features."
        ]
      },
      {
        "section_name": "Related Work ::: Neural Architecture for NER",
        "paragraphs": [
          "BIBREF3 utilized the Multi-Layer Perceptron (MLP) and CNN to avoid using task-specific features to tackle different sequence labeling tasks, such as Chunking, Part-of-Speech (POS) and NER. In BIBREF4, BiLSTM-CRF was introduced to solve sequence labeling questions. Since then, the BiLSTM has been extensively used in the field of NER BIBREF7, BIBREF21, BIBREF22, BIBREF5.",
          "Despite BiLSTM's great success in the NER task, it has to compute token representations one by one, which massively hinders full exploitation of GPU's parallelism. Therefore, CNN has been proposed by BIBREF23, BIBREF24 to encode words concurrently. In order to enlarge the receptive field of CNNs, BIBREF23 used iterative dilated CNNs (ID-CNN).",
          "Since the word shape information, such as the capitalization and n-gram, is important in recognizing named entities, CNN and BiLSTM have been used to extract character-level information BIBREF7, BIBREF6, BIBREF5, BIBREF23, BIBREF8.",
          "Almost all neural-based NER models used pre-trained word embeddings, like Word2vec and Glove BIBREF25, BIBREF26. And when contextual word embeddings are combined, the performance of NER models will boost a lot BIBREF27, BIBREF28, BIBREF29. ELMo introduced by BIBREF28 used the CNN character encoder and BiLSTM language models to get contextualized word representations. Except for the BiLSTM based pre-trained models, BERT was based on Transformer BIBREF15."
        ]
      },
      {
        "section_name": "Related Work ::: Transformer",
        "paragraphs": [
          "Transformer was introduced by BIBREF13, which was mainly based on self-attention. It achieved great success in various NLP tasks. Since the self-attention mechanism used in the Transformer is unaware of positions, to avoid this shortage, position embeddings were used BIBREF13, BIBREF15. Instead of using the sinusoidal position embedding BIBREF13 and learned absolute position embedding, BIBREF17 argued that the distance between two tokens should be considered when calculating their attention score. BIBREF18 reduced the computation complexity of relative positional encoding from $O(l^2d)$ to $O(ld)$, where $l$ is the length of sequences and $d$ is the hidden size. BIBREF19 derived a new form of relative positional encodings, so that the relative relation could be better considered."
        ]
      },
      {
        "section_name": "Related Work ::: Transformer ::: Transformer Encoder Architecture",
        "paragraphs": [
          "We first introduce the Transformer encoder proposed in BIBREF13. The Transformer encoder takes in an matrix $H \\in \\mathbb {R}^{l \\times d}$, where $l$ is the sequence length, $d$ is the input dimension. Then three learnable matrix $W_q$, $W_k$, $W_v$ are used to project $H$ into different spaces. Usually, the matrix size of the three matrix are all $\\mathbb {R}^{d \\times d_k}$, where $d_k$ is a hyper-parameter. After that, the scaled dot-product attention can be calculated by the following equations,",
          "",
          "where $Q_t$ is the query vector of the $t$th token, $j$ is the token the $t$th token attends. $K_j$ is the key vector representation of the $j$th token. The softmax is along the last dimension. Instead of using one group of $W_q$, $W_k$, $W_v$, using several groups will enhance the ability of self-attention. When several groups are used, it is called multi-head self-attention, the calculation can be formulated as follows,",
          "",
          "where $n$ is the number of heads, the superscript $h$ represents the head index. $[head^{(1)}; ...; head^{(n)}]$ means concatenation in the last dimension. Usually $d_k \\times n = d$, which means the output of $[head^{(1)}; ...; head^{(n)}]$ will be of size $\\mathbb {R}^{l \\times d}$. $W_o$ is a learnable parameter, which is of size $\\mathbb {R}^{d \\times d}$.",
          "The output of the multi-head attention will be further processed by the position-wise feed-forward networks, which can be represented as follows,",
          "",
          "where $W_1$, $W_2$, $b_1$, $b_2$ are learnable parameters, and $W_1 \\in \\mathbb {R}^{d \\times d_{ff}}$, $W_2 \\in \\mathbb {R}^{d_{ff} \\times d}$, $b_1 \\in \\mathbb {R}^{d_{ff}}$, $b_2 \\in \\mathbb {R}^{d}$. $d_{ff}$ is a hyper-parameter. Other components of the Transformer encoder includes layer normalization and Residual connection, we use them the same as BIBREF13."
        ]
      },
      {
        "section_name": "Related Work ::: Transformer ::: Position Embedding",
        "paragraphs": [
          "The self-attention is not aware of the positions of different tokens, making it unable to capture the sequential characteristic of languages. In order to solve this problem, BIBREF13 suggested to use position embeddings generated by sinusoids of varying frequency. The $t$th token's position embedding can be represented by the following equations",
          "",
          "where $i$ is in the range of $[0, \\frac{d}{2}]$, $d$ is the input dimension. This sinusoid based position embedding makes Transformer have an ability to model the position of a token and the distance of each two tokens. For any fixed offset $k$, $PE_{t+k}$ can be represented by a linear transformation of $PE_{t}$ BIBREF13."
        ]
      },
      {
        "section_name": "Proposed Model",
        "paragraphs": [
          "In this paper, we utilize the Transformer encoder to model the long-range and complicated interactions of sentence for NER. The structure of proposed model is shown in Fig FIGREF12. We detail each parts in the following sections."
        ]
      },
      {
        "section_name": "Proposed Model ::: Embedding Layer",
        "paragraphs": [
          "To alleviate the problems of data sparsity and out-of-vocabulary (OOV), most NER models adopted the CNN character encoder BIBREF5, BIBREF30, BIBREF8 to represent words. Compared to BiLSTM based character encoder BIBREF6, BIBREF31, CNN is more efficient. Since Transformer can also fully exploit the GPU's parallelism, it is interesting to use Transformer as the character encoder. A potential benefit of Transformer-based character encoder is to extract different n-grams and even uncontinuous character patterns, like \u201cun..ily\u201d in \u201cunhappily\u201d and \u201cuneasily\u201d. For the model's uniformity, we use the \u201cadapted Transformer\u201d to represent the Transformer introduced in next subsection.",
          "The final word embedding is the concatenation of the character features extracted by the character encoder and the pre-trained word embeddings."
        ]
      },
      {
        "section_name": "Proposed Model ::: Encoding Layer with Adapted Transformer",
        "paragraphs": [
          "Although Transformer encoder has potential advantage in modeling long-range context, it is not working well for NER task. In this paper, we propose an adapted Transformer for NER task with two improvements."
        ]
      },
      {
        "section_name": "Proposed Model ::: Encoding Layer with Adapted Transformer ::: Direction- and Distance-Aware Attention",
        "paragraphs": [
          "Inspired by the success of BiLSTM in NER tasks, we consider what properties the Transformer lacks compared to BiLSTM-based models. One observation is that BiLSTM can discriminatively collect the context information of a token from its left and right sides. But it is not easy for the Transformer to distinguish which side the context information comes from.",
          "Although the dot product between two sinusoidal position embeddings is able to reflect their distance, it lacks directionality and this property will be broken by the vanilla Transformer attention. To illustrate this, we first prove two properties of the sinusoidal position embeddings.",
          "Property 1 For an offset $k$ and a position $t$, $PE_{t+k}^TPE_{t}$ only depends on $k$, which means the dot product of two sinusoidal position embeddings can reflect the distance between two tokens.",
          "Based on the definitions of Eq.(DISPLAY_FORM11) and Eq.(), the position embedding of $t$-th token is PEt = [ c (c0t)",
          "(c0t)",
          "$\\vdots $",
          "(cd2-1t)",
          "(cd2-1t)",
          "], where $d$ is the dimension of the position embedding, $c_i$ is a constant decided by $i$, and its value is $1/10000^{2i/d}$.",
          "Therefore,",
          "",
          "where Eq.(DISPLAY_FORM17) to Eq.() is based on the equation $\\cos (x-y) = \\sin (x)\\sin (y) + \\cos (x)\\cos (y)$.",
          "Property 2 For an offset $k$ and a position $t$, $PE_{t}^TPE_{t-k}=PE_{t}^TPE_{t+k}$, which means the sinusoidal position embeddings is unware of directionality.",
          "Let $j=t-k$, according to property 1, we have",
          "",
          "",
          "The relation between $d$, $k$ and $PE_t^TPE_{t+k}$ is displayed in Fig FIGREF18. The sinusoidal position embeddings are distance-aware but lacks directionality.",
          "However, the property of distance-awareness also disappears when $PE_t$ is projected into the query and key space of self-attention. Since in vanilla Transformer the calculation between $PE_t$ and $PE_{t+k}$ is actually $PE_t^TW_q^TW_kPE_{t+k}$, where $W_q, W_k$ are parameters in Eq.(DISPLAY_FORM7). Mathematically, it can be viewed as $PE_t^TWPE_{t+k}$ with only one parameter $W$. The relation between $PE_t^TPE_{t+k}$ and $PE_t^TWPE_{t+k}$ is depicted in Fig FIGREF19.",
          "Therefore, to improve the Transformer with direction- and distance-aware characteristic, we calculate the attention scores using the equations below:",
          "",
          "where $t$ is index of the target token, $j$ is the index of the context token, $Q_t, K_j$ is the query vector and key vector of token $t, j$ respectively, $W_q, W_v \\in \\mathbb {R}^{d \\times d_k}$. To get $H_{d_k}\\in \\mathbb {R}^{l \\times d_k}$, we first split $H$ into $d/d_k$ partitions in the second dimension, then for each head we use one partition. $\\mathbf {u} \\in \\mathbb {R}^{d_k}$, $\\mathbf {v} \\in \\mathbb {R}^{d_k}$ are learnable parameters, $R_{t-j}$ is the relative positional encoding, and $R_{t-j} \\in \\mathbb {R}^{d_k}$, $i$ in Eq.() is in the range $[0, \\frac{d_k}{2}]$. $Q_t^TK_j$ in Eq.() is the attention score between two tokens; $Q_t^TR_{t-j}$ is the $t$th token's bias on certain relative distance; $u^TK_j$ is the bias on the $j$th token; $v^TR_{t-j}$ is the bias term for certain distance and direction.",
          "Based on Eq.(), we have",
          "",
          "because $\\sin (-x)=-\\sin (x), \\cos (x)=\\cos (-x)$. This means for an offset $t$, the forward and backward relative positional encoding are the same with respect to the $\\cos (c_it)$ terms, but is the opposite with respect to the $\\sin (c_it)$ terms. Therefore, by using $R_{t-j}$, the attention score can distinguish different directions and distances.",
          "The above improvement is based on the work BIBREF17, BIBREF19. Since the size of NER datasets is usually small, we avoid direct multiplication of two learnable parameters, because they can be represented by one learnable parameter. Therefore we do not use $W_k$ in Eq.(DISPLAY_FORM22). The multi-head version is the same as Eq.(DISPLAY_FORM8), but we discard $W_o$ since it is directly multiplied by $W_1$ in Eq.(DISPLAY_FORM9)."
        ]
      },
      {
        "section_name": "Proposed Model ::: Encoding Layer with Adapted Transformer ::: Un-scaled Dot-Product Attention",
        "paragraphs": [
          "The vanilla Transformer use the scaled dot-product attention to smooth the output of softmax function. In Eq.(), the dot product of key and value matrices is divided by the scaling factor $\\sqrt{d_k}$.",
          "We empirically found that models perform better without the scaling factor $\\sqrt{d_k}$. We presume this is because without the scaling factor the attention will be sharper. And the sharper attention might be beneficial in the NER task since only few words in the sentence are named entities."
        ]
      },
      {
        "section_name": "Proposed Model ::: CRF Layer",
        "paragraphs": [
          "In order to take advantage of dependency between different tags, the Conditional Random Field (CRF) was used in all of our models. Given a sequence $\\mathbf {s}=[s_1, s_2, ..., s_T]$, the corresponding golden label sequence is $\\mathbf {y}=[y_1, y_2, ..., y_T]$, and $\\mathbf {Y}(\\mathbf {s})$ represents all valid label sequences. The probability of $\\mathbf {y}$ is calculated by the following equation",
          "",
          "where $f(\\mathbf {y}_{t-1},\\mathbf {y}_t,\\mathbf {s})$ computes the transition score from $\\mathbf {y}_{t-1}$ to $\\mathbf {y}_t$ and the score for $\\mathbf {y}_t$. The optimization target is to maximize $P(\\mathbf {y}|\\mathbf {s})$. When decoding, the Viterbi Algorithm is used to find the path achieves the maximum probability."
        ]
      },
      {
        "section_name": "Experiment ::: Data",
        "paragraphs": [
          "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
          "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
          "(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.",
          "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
          "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
          "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
          "(6) Resume NER was annotated by BIBREF33.",
          "Their statistics are listed in Table TABREF28. For all datasets, we replace all digits with \u201c0\u201d, and use the BIOES tag schema. For English, we use the Glove 100d pre-trained embedding BIBREF25. For the character encoder, we use 30d randomly initialized character embeddings. More details on models' hyper-parameters can be found in the supplementary material. For Chinese, we used the character embedding and bigram embedding released by BIBREF33. All pre-trained embeddings are finetuned during training. In order to reduce the impact of randomness, we ran all of our experiments at least three times, and its average F1 score and standard deviation are reported.",
          "We used random-search to find the optimal hyper-parameters, hyper-parameters and their ranges are displayed in the supplemental material. We use SGD and 0.9 momentum to optimize the model. We run 100 epochs and each batch has 16 samples. During the optimization, we use the triangle learning rate BIBREF39 where the learning rate rises to the pre-set learning rate at the first 1% steps and decreases to 0 in the left 99% steps. The model achieves the highest development performance was used to evaluate the test set. The hyper-parameter search range and other settings can be found in the supplementary material. Codes are available at https://github.com/fastnlp/TENER."
        ]
      },
      {
        "section_name": "Experiment ::: Results on Chinese NER Datasets",
        "paragraphs": [
          "We first present our results in the four Chinese NER datasets. Since Chinese NER is directly based on the characters, it is more straightforward to show the abilities of different models without considering the influence of word representation.",
          "As shown in Table TABREF29, the vanilla Transformer does not perform well and is worse than the BiLSTM and CNN based models. However, when relative positional encoding combined, the performance was enhanced greatly, resulting in better results than the BiLSTM and CNN in all datasets. The number of training examples of the Weibo dataset is tiny, therefore the performance of the Transformer is abysmal, which is as expected since the Transformer is data-hungry. Nevertheless, when enhanced with the relative positional encoding and unscaled attention, it can achieve even better performance than the BiLSTM-based model. The superior performance of the adapted Transformer in four datasets ranging from small datasets to big datasets depicts that the adapted Transformer is more robust to the number of training examples than the vanilla Transformer. As the last line of Table TABREF29 depicts, the scaled attention will deteriorate the performance."
        ]
      },
      {
        "section_name": "Experiment ::: Results on English NER datasets",
        "paragraphs": [
          "The comparison between different NER models on English NER datasets is shown in Table TABREF32. The poor performance of the Transformer in the NER datasets was also reported by BIBREF16. Although performance of the Transformer is higher than BIBREF16, it still lags behind the BiLSTM-based models BIBREF5. Nonetheless, the performance is massively enhanced by incorporating the relative positional encoding and unscaled attention into the Transformer. The adaptation not only makes the Transformer achieve superior performance than BiLSTM based models, but also unveil the new state-of-the-art performance in two NER datasets when only the Glove 100d embedding and CNN character embedding are used. The same deterioration of performance was observed when using the scaled attention. Besides, if ELMo was used BIBREF28, the performance of TENER can be further boosted as depicted in Table TABREF33."
        ]
      },
      {
        "section_name": "Experiment ::: Analysis of Different Character Encoders",
        "paragraphs": [
          "The character-level encoder has been widely used in the English NER task to alleviate the data sparsity and OOV problem in word representation. In this section, we cross different character-level encoders (BiLSTM, CNN, Transformer encoder and our adapted Transformer encoder (AdaTrans for short) ) and different word-level encoders (BiLSTM, ID-CNN and AdaTrans) to implement the NER task. Results on CoNLL2003 and OntoNotes 5.0 are presented in Table TABREF34 and Table TABREF34, respectively.",
          "The ID-CNN encoder is from BIBREF23, and we re-implement their model in PyTorch. For different combinations, we use random search to find its best hyper-parameters. Hyper-parameters for character encoders were fixed. The details can be found in the supplementary material.",
          "For the results on CoNLL2003 dataset which is depicted in Table TABREF34, the AdaTrans performs as good as the BiLSTM in different character encoder scenario averagely. In addition, from Table TABREF34, we can find the pattern that the AdaTrans character encoder outpaces the BiLSTM and CNN character encoders when different word-level encoders being used. Moreover, no matter what character encoder being used or none being used, the AdaTrans word-level encoder gets the best performance. This implies that when the number of training examples increases, the AdaTrans character-level and word-level encoder can better realize their ability."
        ]
      },
      {
        "section_name": "Experiment ::: Convergent Speed Comparison",
        "paragraphs": [
          "We compare the convergent speed of BiLSTM, ID-CNN, Transformer, and TENER in the development set of the OntoNotes 5.0. The curves are shown in Fig FIGREF37. TENER converges as fast as the BiLSTM model and outperforms the vanilla Transformer."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we propose TENER, a model adopting Transformer Encoder with specific customizations for the NER task. Transformer Encoder has a powerful ability to capture the long-range context. In order to make the Transformer more suitable to the NER task, we introduce the direction-aware, distance-aware and un-scaled attention. Experiments in two English NER tasks and four Chinese NER tasks show that the performance can be massively increased. Under the same pre-trained embeddings and external knowledge, our proposed modification outperforms previous models in the six datasets. Meanwhile, we also found the adapted Transformer is suitable for being used as the English character encoder, because it has the potentiality to extract intricate patterns from characters. Experiments in two English NER datasets show that the adapted Transformer character encoder performs better than BiLSTM and CNN character encoders."
        ]
      },
      {
        "section_name": "Supplemental Material ::: Character Encoder",
        "paragraphs": [
          "We exploit four kinds of character encoders. For all character encoders, the randomly initialized character embeddings are 30d. The hidden size of BiLSTM used in the character encoder is 50d in each direction. The kernel size of CNN used in the character encoder is 3, and we used 30 kernels with stride 1. For Transformer and adapted Transformer, the number of heads is 3, and every head is 10d, the dropout rate is 0.15, the feed-forward dimension is 60. The Transformer used the sinusoid position embedding. The number of parameters for the character encoder (excluding character embedding) when using BiLSTM, CNN, Transformer and adapted Transformer are 35830, 3660, 8460 and 6600 respectively. For all experiments, the hyper-parameters of character encoders stay unchanged."
        ]
      },
      {
        "section_name": "Supplemental Material ::: Hyper-parameters",
        "paragraphs": [
          "The hyper-parameters and search ranges for different encoders are presented in Table TABREF40, Table TABREF41 and Table TABREF42."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which NER dataset do they use?",
        "question_id": "6e040e80f2da69d50386a90a38ed6d2fa4f77bbd",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CoNLL2003",
                "OntoNotes 5.0",
                "OntoNotes 4.0.",
                "Chinese NER dataset MSRA",
                "Weibo NER",
                "Resume NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
                "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
                "(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.",
                "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
                "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
                "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
                "(6) Resume NER was annotated by BIBREF33."
              ],
              "highlighted_evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.\n\n(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.\n\n(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.\n\n(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.\n\n(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.\n\n(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.\n\n(6) Resume NER was annotated by BIBREF33."
              ]
            },
            "annotation_id": "2c7557d9a8329aa43c2563c30ec04ee220276ea1",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CoNLL2003 ",
                "OntoNotes 5.0",
                "OntoNotes 4.0",
                "MSRA ",
                "Weibo",
                "Resume "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
                "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
                "(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.",
                "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
                "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
                "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
                "(6) Resume NER was annotated by BIBREF33."
              ],
              "highlighted_evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.\n\n(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.\n\n(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.\n\n(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.\n\n(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.\n\n(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.\n\n(6) Resume NER was annotated by BIBREF33."
              ]
            },
            "annotation_id": "6b62b212b6701a3b74f40e52a388f302d72f2b3b",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CoNLL2003",
                "OntoNotes 5.0",
                "OntoNotes 4.0",
                "MSRA",
                "Weibo NER",
                "Resume NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "FLOAT SELECTED: Table 1: Details of Datasets.",
                "In summary, to improve the performance of the Transformer-based model in the NER task, we explicitly utilize the directional relative positional encoding, reduce the number of parameters and sharp the attention distribution. After the adaptation, the performance raises a lot, making our model even performs better than BiLSTM based models. Furthermore, in the six NER datasets, we achieve state-of-the-art performance among models without considering the pre-trained language models or designed features.",
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
                "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
                "(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.",
                "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
                "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
                "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
                "(6) Resume NER was annotated by BIBREF33."
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Table 1: Details of Datasets.",
                "In summary, to improve the performance of the Transformer-based model in the NER task, we explicitly utilize the directional relative positional encoding, reduce the number of parameters and sharp the attention distribution. After the adaptation, the performance raises a lot, making our model even performs better than BiLSTM based models. Furthermore, in the six NER datasets, we achieve state-of-the-art performance among models without considering the pre-trained language models or designed features.",
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
                "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
                "2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire.",
                "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
                "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
                "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
                "(6) Resume NER was annotated by BIBREF33."
              ]
            },
            "annotation_id": "aaf8c29a25b98d373ece9884dbe3e60dc118dd23",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CoNLL2003",
                "OntoNotes 5.0",
                "BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part",
                "Chinese NER dataset MSRA",
                "Weibo NER",
                "Resume NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.",
                "(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.",
                "(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.",
                "(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.",
                "(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.",
                "(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.",
                "(6) Resume NER was annotated by BIBREF33."
              ],
              "highlighted_evidence": [
                "We evaluate our model in two English NER datasets and four Chinese NER datasets.\n\n(1) CoNLL2003 is one of the most evaluated English NER datasets, which contains four different named entities: PERSON, LOCATION, ORGANIZATION, and MISC BIBREF34.\n\n(2) OntoNotes 5.0 is an English NER dataset whose corpus comes from different domains, such as telephone conversation, newswire. We exclude the New Testaments portion since there is no named entity in it BIBREF8, BIBREF7. This dataset has eleven entity names and seven value types, like CARDINAL, MONEY, LOC.\n\n(3) BIBREF35 released OntoNotes 4.0. In this paper, we use the Chinese part. We adopted the same pre-process as BIBREF36.\n\n(4) The corpus of the Chinese NER dataset MSRA came from news domain BIBREF37.\n\n(5) Weibo NER was built based on text in Chinese social media Sina Weibo BIBREF38, and it contained 4 kinds of entities.\n\n(6) Resume NER was annotated by BIBREF33."
              ]
            },
            "annotation_id": "e80e4c6bd8ad549a0145340cb91efe20bc20268b",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: An example for NER. The relative direction is important in the NER task, because words before \u201cInc.\u201d are mostly to be an organization, words after \u201cin\u201d are more likely to be time or location. Besides, the distance between words is also important, since only continuous words can form an entity, the former \u201cLouis Vuitton\u201d can not form an entity with the \u201cInc.\u201d."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Model structure of TENER for English NER tasks. In TENER, Transformer encoder is used not only to extract the word-level contextual information, but also to encode character-level information in a word."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Dot product between two sinusoidal position embeddings whose distance is k. It is clear that the product is symmetrical, and with the increment of |k|, it has a trend to decrease, but this decrease is not monotonous."
      },
      {
        "file": "5-Figure4-1.png",
        "caption": "Figure 4: The upper line is the product between PETt PEt+k. The lower two lines are the products of PETt WPEt+k with two random W s. Although PETt PEt+k can reflect the distance, the PETt WPEt+k has no clear pattern."
      },
      {
        "file": "6-Table1-1.png",
        "caption": "Table 1: Details of Datasets."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: The F1 scores on Chinese NER datasets. \u2663,\u2660 are results reported in (Zhang and Yang, 2018) and (Gui et al., 2019a), respectively. \u201cw/ scale\u201d means TENER using the scaled attention in Eq.(19). \u2217 their results are not directly comparable with ours, since they used 100d pre-trained character and bigram embeddings. Other models use the same embeddings."
      },
      {
        "file": "7-Table4-1.png",
        "caption": "Table 4: The F1 scores on English NER datasets. We only list results based on non-contextualized embeddings, and methods utilized pre-trained language models, pre-trained features, or higher dimension word vectors are excluded. TENER (Ours) uses the Transformer encoder both in the character-level and wordlevel. \u201cw/ scale\u201d means TENER using the scaled attention in Eq.(19). \u201cw/ CNN-char\u201d means TENER using CNN as character encoder instead of AdaTrans."
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3: Performance of models with ELMo as their embeddings in English NER datasets. \u201cBiLSTM\u201d is our run. In the larger OntoNotes5.0, TENER achieves much better F1 score."
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5: F1 scores in the CoNLL2003 and OntoNotes 5.0. \u201cChar\u201d means character-level encoder, and \u201cWord\u201d means word-level encoder. \u201cAdaTrans\u201d means our adapted Transformer encoder."
      },
      {
        "file": "8-Figure5-1.png",
        "caption": "Figure 5: Convergent speed in the development dataset of OntoNotes 5.0 for four kinds of models."
      },
      {
        "file": "10-Table6-1.png",
        "caption": "Table 6: The hyper-parameters and hyper-parameter search ranges for BiLSTM."
      },
      {
        "file": "11-Table7-1.png",
        "caption": "Table 7: The hyper-parameters and hyper-parameter search ranges for ID-CNN."
      },
      {
        "file": "11-Table8-1.png",
        "caption": "Table 8: The hyper-parameters and hyper-parameter search ranges for Transformer and adapted Transformer in Chinese and English NER datasets."
      }
    ]
  },
  "1905.00840": {
    "title": "Knowledge Authoring and Question Answering with KALM",
    "abstract": "Knowledge representation and reasoning (KRR) is one of the key areas in artificial intelligence (AI) field. It is intended to represent the world knowledge in formal languages (e.g., Prolog, SPARQL) and then enhance the expert systems to perform querying and inference tasks. Currently, constructing large scale knowledge bases (KBs) with high quality is prohibited by the fact that the construction process requires many qualified knowledge engineers who not only understand the domain-specific knowledge but also have sufficient skills in knowledge representation. Unfortunately, qualified knowledge engineers are in short supply. Therefore, it would be very useful to build a tool that allows the user to construct and query the KB simply via text. Although there is a number of systems developed for knowledge extraction and question answering, they mainly fail in that these system don't achieve high enough accuracy whereas KRR is highly sensitive to erroneous data. In this thesis proposal, I will present Knowledge Authoring Logic Machine (KALM), a rule-based system which allows the user to author knowledge and query the KB in text. The experimental results show that KALM achieved superior accuracy in knowledge authoring and question answering as compared to the state-of-the-art systems.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Knowledge representation and reasoning (KRR) is the process of representing the domain knowledge in formal languages (e.g., SPARQL, Prolog) such that it can be used by expert systems to execute querying and reasoning services. KRR have been applied in many fields including financial regulations, medical diagnosis, laws, and so on. One major obstacle in KRR is the creation of large-scale knowledge bases with high quality. For one thing, this requires the knowledge engineers (KEs) not only to have the background knowledge in a certain domain but have enough skills in knowledge representation as well. Unfortunately, qualified KEs are also in short supply. Therefore, it would be useful to build a tool that allows the domain experts without any background in logic to construct and query the knowledge base simply from text.",
          "Controlled natural languages (CNLs) BIBREF0 were developed as a technology that achieves this goal. CNLs are designed based on natural languages (NLs) but with restricted syntax and interpretation rules that determine the unique meaning of the sentence. Representative CNLs include Attempto Controlled English BIBREF1 and PENG BIBREF2 . Each CNL is developed with a language parser which translates the English sentences into an intermediate structure, discourse representation structure (DRS) BIBREF3 . Based on the DRS structure, the language parsers further translate the DRS into the corresponding logical representations, e.g., Answer Set Programming (ASP) BIBREF4 programs. One main issue with the aforementioned CNLs is that the systems do not provide enough background knowledge to preserve semantic equivalences of sentences that represent the same meaning but are expressed via different linguistic structures. For instance, the sentences Mary buys a car and Mary makes a purchase of a car are translated into different logical representations by the current CNL parsers. As a result, if the user ask a question who is a buyer of a car, these systems will fail to find the answer.",
          "In this thesis proposal, I will present KALM BIBREF5 , BIBREF6 , a system for knowledge authoring and question answering. KALM is superior to the current CNL systems in that KALM has a complex frame-semantic parser which can standardize the semantics of the sentences that express the same meaning via different linguistic structures. The frame-semantic parser is built based on FrameNet BIBREF7 and BabelNet BIBREF8 where FrameNet is used to capture the meaning of the sentence and BabelNet BIBREF8 is used to disambiguate the meaning of the extracted entities from the sentence. Experiment results show that KALM achieves superior accuracy in knowledge authoring and question answering as compared to the state-of-the-art systems.",
          "The rest parts are organized as follows: Section SECREF2 discusses the related works, Section SECREF3 presents the KALM architecture, Section SECREF4 presents KALM-QA, the question answering part of KALM, Section SECREF5 shows the evaluation results, Section SECREF6 shows the future work beyond the thesis, and Section SECREF7 concludes the paper."
        ]
      },
      {
        "section_name": "Related Works",
        "paragraphs": [
          "As is described in Section SECREF1 , CNL systems were proposed as the technology for knowledge representation and reasoning. Related works also include knowledge extraction tools, e.g., OpenIE BIBREF9 , SEMEFOR BIBREF10 , SLING BIBREF11 , and Standford KBP system BIBREF12 . These knowledge extraction tools are designed to extract semantic relations from English sentences that capture the meaning. The limitations of these tools are two-fold: first, they lack sufficient accuracy to extract the correct semantic relations and entities while KRR is very sensitive to incorrect data; second, these systems are not able to map the semantic relations to logical forms and therefore not capable of doing KRR. Other related works include the question answering frameworks, e.g., Memory Network BIBREF13 , Variational Reasoning Network BIBREF14 , ATHENA BIBREF15 , PowerAqua BIBREF16 . The first two belong to end-to-end learning approaches based on machine learning models. The last two systems have implemented semantic parsers which translate natural language sentences into intermediate query languages and then query the knowledge base to get the answers. For the machine learning based approaches, the results are not explainable. Besides, their accuracy is not high enough to provide correct answers. For ATHENA and PowerAqua, these systems perform question answering based on a priori knowledge bases. Therefore, they do not support knowledge authoring while KALM is able to support both knowledge authoring and question answering."
        ]
      },
      {
        "section_name": "The KALM Architecture",
        "paragraphs": [
          "Figure FIGREF1 shows the architecture of KALM which translates a CNL sentence to the corresponding logical representations, unique logical representations (ULR).",
          "Attempto Parsing Engine. The input sentences are CNL sentences based on ACE grammar. KALM starts with parsing the input sentence using ACE Parser and generates the DRS structure BIBREF17 which captures the syntactic information of the sentences.",
          "Frame Parser. KALM performs frame-based parsing based on the DRS and produces a set of frames that represent the semantic relations a sentence implies. A frame BIBREF18 represents a semantic relation of a set of entities where each plays a particular role in the frame relation. We have designed a frame ontology, called FrameOnt, which is based on the frames in FrameNet BIBREF7 and encoded as a Prolog fact. For instance, the Commerce_Buy frame is shown below:",
          "",
          " fp(Commerce_Buy,[",
          " role(Buyer,[bn:00014332n],[]),",
          " role(Seller,[bn:00053479n],[]),",
          " role(Goods,[bn:00006126n,bn:00021045n],[]),",
          " role(Recipient,[bn:00066495n],[]),",
          " role(Money,[bn:00017803n],[currency])]).",
          " In each role-term, the first argument is the name of the role and the second is a list of role meanings represented via BabelNet synset IDs BIBREF8 . The third argument of a role-term is a list of constraints on that role. For instance, the sentence Mary buys a car implies the Commerce_Buy frame where Mary is the Buyer and car is the Goods. To extract a frame instance from a given CNL sentence, KALM uses logical valence patterns (lvps) which are learned via structural learning. An example of the lvp is shown below:",
          "",
          " lvp(buy,v,Commerce_Buy, [",
          " pattern(Buyer,verb->subject,required),",
          " pattern(Goods,verb->object,required),",
          " pattern(Recipient,verb->pp(for)->dep,optnl),",
          " pattern(Money,verb->pp(for)->dep,optnl),",
          " pattern(Seller,verb->pp(from)->dep,optnl)]).",
          "",
          "The first three arguments of an lvp-fact identify the lexical unit, its part of speech, and the frame. The fourth argument is a set of pattern-terms, each having three parts: the name of a role, a grammatical pattern, and the required/optional flag. The grammatical pattern determines the grammatical context in which the lexical unit, a role, and a role-filler word can appear in that frame. Each grammatical pattern is captured by a parsing rule (a Prolog rule) that can be used to extract appropriate role-filler words based on the APE parses.",
          "Role-filler Disambiguation. Based on the extracted frame instance, the role-filler disambiguation module disambiguates the meaning of each role-filler word for the corresponding frame role a BabelNet Synset ID. A complex algorithm BIBREF5 was proposed to measure the semantic similarity between a candidate BabelNet synset that contains the role-filler word and the frame-role synset. The algorithm also has optimizations that improve the efficiency of the algorithm e.g., priority-based search, caching, and so on. In addition to disambiguating the meaning of the role-fillers, this module is also used to prune the extracted frame instances where the role-filler word and the frame role are semantically incompatible.",
          "Constructing ULR. The extracted frame instances are translated into the corresponding logical representations, unique logical representation (ULR). Examples can be found in reference BIBREF5 ."
        ]
      },
      {
        "section_name": "KALM-QA for Question Answering",
        "paragraphs": [
          "Based on KALM, KALM-QA BIBREF6 is developed for question answering. KALM-QA shares the same components with KALM for syntactic parsing, frame-based parsing and role-filler disambiguation. Different from KALM, KALM-QA translates the questions to unique logical representation for queries (ULRQ), which are used to query the authored knowledge base."
        ]
      },
      {
        "section_name": "Evaluations",
        "paragraphs": [
          "This section provides a summary of the evaluation of KALM and KALM-QA, where KALM is evaluated for knowledge authoring and KALM-QA is evaluated for question answering. We have created a total of 50 logical frames, mostly derived from FrameNet but also some that FrameNet is missing (like Restaurant, Human_Gender) for representing the meaning of English sentences. Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems.",
          "For KALM-QA, we evaluate it on two datasets. The first dataset is manually constructed general questions based on the 50 logical frames. KALM-QA achieves an accuracy of 95% for parsing the queries. The second dataset we use is MetaQA dataset BIBREF14 , which contains contains almost 29,000 test questions and over 260,000 training questions. KALM-QA achieves 100% accuracy\u2014much higher than the state-of-the-art machine learning approach BIBREF14 . Details of the evaluations can be found in BIBREF5 and BIBREF6 ."
        ]
      },
      {
        "section_name": "Future Work Beyond The Thesis",
        "paragraphs": [
          "This section discusses the future work beyond the thesis: (1) enhancing KALM to author rules, and (2) supporting time reasoning.",
          "Authoring Rules from CNL. There are two research problems with rules. The first problem is the standardization of rules parses that express the same information but via different syntactic forms or using different expressions. Suppose the knowledge base contains sentences like: (1) if a person buys a car then the person owns the car, (2) every person who is a purchaser of a car is an owner of the car, (3) if a car is bought by a person then the person possesses the car. All the above sentences represent rules and express exactly the same meaning. However, KALM's current syntactic parser will represent them in different DRSs and therefore not being able to map them into the same logical form. The second problem involves the recognition and representation of different types of rules in logic. For instance, defeasible rules are very common in text. However, this type of rules cannot be handled by first order logic. We believe defeasible logic BIBREF19 is a good fit.",
          "Time Reasoning. Time-related information is a crucial part of human knowledge, but semantic parsing that takes the time into account is rather hard. However, we can develop a CNL that would incorporate enough time related idioms to be useful in a number of domains of discourse (e.g., tax law). Time can then be added to DRSs and incorporated into our frame based approach down to the very level of the logical facts into which sentences will be translated. This time information can be represented either via special time-aware relations among events (e.g., before, after, causality, triggering) or using a reserved argument to represent time in each fluent."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "This thesis proposal provides an overview of KALM, a system for knowledge authoring. In addition, it introduces KALM-QA, the question answering part of KALM. Experimental results show that both KALM and KALM-QA achieve superior accuracy as compared to the state-of-the-art systems."
        ]
      }
    ],
    "qas": [
      {
        "question": "What are the state-of-the-art systems?",
        "question_id": "fe52b093735bb456d7e699aa9a2b806d2b498ba0",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SEMAFOR",
                "SLING",
                "Stanford KBP "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "This section provides a summary of the evaluation of KALM and KALM-QA, where KALM is evaluated for knowledge authoring and KALM-QA is evaluated for question answering. We have created a total of 50 logical frames, mostly derived from FrameNet but also some that FrameNet is missing (like Restaurant, Human_Gender) for representing the meaning of English sentences. Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems.",
                "This thesis proposal provides an overview of KALM, a system for knowledge authoring. In addition, it introduces KALM-QA, the question answering part of KALM. Experimental results show that both KALM and KALM-QA achieve superior accuracy as compared to the state-of-the-art systems."
              ],
              "highlighted_evidence": [
                "Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems.",
                "Experimental results show that both KALM and KALM-QA achieve superior accuracy as compared to the state-of-the-art systems."
              ]
            },
            "annotation_id": "1bf204d1745b407be43c79b14b3fa2c9d05098d3",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SEMAFOR",
                "SLING",
                "Stanford KBP system"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "This section provides a summary of the evaluation of KALM and KALM-QA, where KALM is evaluated for knowledge authoring and KALM-QA is evaluated for question answering. We have created a total of 50 logical frames, mostly derived from FrameNet but also some that FrameNet is missing (like Restaurant, Human_Gender) for representing the meaning of English sentences. Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems."
              ],
              "highlighted_evidence": [
                "Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. "
              ]
            },
            "annotation_id": "5a8460e788baf8e0ee40e8ef27fe32dc705a6850",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SEMAFOR",
                "SLING",
                "Stanford KBP system"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this thesis proposal, I will present KALM BIBREF5 , BIBREF6 , a system for knowledge authoring and question answering. KALM is superior to the current CNL systems in that KALM has a complex frame-semantic parser which can standardize the semantics of the sentences that express the same meaning via different linguistic structures. The frame-semantic parser is built based on FrameNet BIBREF7 and BabelNet BIBREF8 where FrameNet is used to capture the meaning of the sentence and BabelNet BIBREF8 is used to disambiguate the meaning of the extracted entities from the sentence. Experiment results show that KALM achieves superior accuracy in knowledge authoring and question answering as compared to the state-of-the-art systems.",
                "This section provides a summary of the evaluation of KALM and KALM-QA, where KALM is evaluated for knowledge authoring and KALM-QA is evaluated for question answering. We have created a total of 50 logical frames, mostly derived from FrameNet but also some that FrameNet is missing (like Restaurant, Human_Gender) for representing the meaning of English sentences. Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems."
              ],
              "highlighted_evidence": [
                " Experiment results show that KALM achieves superior accuracy in knowledge authoring and question answering as compared to the state-of-the-art systems.",
                "Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems."
              ]
            },
            "annotation_id": "88d3149ee97cf23a1c432315c5f0c85817cb9376",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SEMAFOR, SLING, and Stanford KBP system",
                "BIBREF14"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "This section provides a summary of the evaluation of KALM and KALM-QA, where KALM is evaluated for knowledge authoring and KALM-QA is evaluated for question answering. We have created a total of 50 logical frames, mostly derived from FrameNet but also some that FrameNet is missing (like Restaurant, Human_Gender) for representing the meaning of English sentences. Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. KALM achieves an accuracy of 95.6%\u2014much higher than the other systems.",
                "For KALM-QA, we evaluate it on two datasets. The first dataset is manually constructed general questions based on the 50 logical frames. KALM-QA achieves an accuracy of 95% for parsing the queries. The second dataset we use is MetaQA dataset BIBREF14 , which contains contains almost 29,000 test questions and over 260,000 training questions. KALM-QA achieves 100% accuracy\u2014much higher than the state-of-the-art machine learning approach BIBREF14 . Details of the evaluations can be found in BIBREF5 and BIBREF6 ."
              ],
              "highlighted_evidence": [
                "Based on the 50 frames, we have manually constructed 250 sentences that are adapted from FrameNet exemplar sentences and evaluate these sentences on KALM, SEMAFOR, SLING, and Stanford KBP system. ",
                "The second dataset we use is MetaQA dataset BIBREF14 , which contains contains almost 29,000 test questions and over 260,000 training questions. KALM-QA achieves 100% accuracy\u2014much higher than the state-of-the-art machine learning approach BIBREF14 ."
              ]
            },
            "annotation_id": "a6a993f2269da8cfffb976ed3f4d7aaaa0132c78",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: The KALM Architecture"
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: The KALM-QA Architecture"
      }
    ]
  },
  "1909.00091": {
    "title": "Automatically Inferring Gender Associations from Language",
    "abstract": "In this paper, we pose the question: do people talk about women and men in different ways? We introduce two datasets and a novel integration of approaches for automatically inferring gender associations from language, discovering coherent word clusters, and labeling the clusters for the semantic concepts they represent. The datasets allow us to compare how people write about women and men in two different settings - one set draws from celebrity news and the other from student reviews of computer science professors. We demonstrate that there are large-scale differences in the ways that people talk about women and men and that these differences vary across domains. Human evaluations show that our methods significantly outperform strong baselines.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "It is well-established that gender bias exists in language \u2013 for example, we see evidence of this given the prevalence of sexism in abusive language datasets BIBREF0, BIBREF1. However, these are extreme cases of gender norms in language, and only encompass a small proportion of speakers or texts.",
          "Less studied in NLP is how gender norms manifest in everyday language \u2013 do people talk about women and men in different ways? These types of differences are far subtler than abusive language, but they can provide valuable insight into the roots of more extreme acts of discrimination. Subtle differences are difficult to observe because each case on its own could be attributed to circumstance, a passing comment or an accidental word. However, at the level of hundreds of thousands of data points, these patterns, if they do exist, become undeniable. Thus, in this work, we introduce new datasets and methods so that we can study subtle gender associations in language at the large-scale.",
          "Our contributions include:",
          "Two datasets for studying language and gender, each consisting of over 300K sentences.",
          "Methods to infer gender-associated words and labeled clusters in any domain.",
          "Novel findings that demonstrate in both domains that people do talk about women and men in different ways.",
          "Each contribution brings us closer to modeling how gender associations appear in everyday language. In the remainder of the paper, we present related work, our data collection, methods and findings, and human evaluations of our system."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "The study of gender and language has a rich history in social science. Its roots are often attributed to Robin Lakoff, who argued that language is fundamental to gender inequality, \u201creflected in both the ways women are expected to speak, and the ways in which women are spoken of\u201d BIBREF2. Prominent scholars following Lakoff have included Deborah Tannen BIBREF3, Mary Bucholtz and Kira Hall BIBREF4, Janet Holmes BIBREF5, Penelope Eckert BIBREF6, and Deborah Cameron BIBREF7, along with many others.",
          "In recent decades, the study of gender and language has also attracted computational researchers. Echoing Lakoff's original claim, a popular strand of computational work focuses on differences in how women and men talk, analyzing key lexical traits BIBREF8, BIBREF9, BIBREF10 and predicting a person's gender from some text they have written BIBREF11, BIBREF12. There is also research studying how people talk to women and men BIBREF13, as well as how people talk about women and men, typically in specific domains such as sports journalism BIBREF14, fiction writing BIBREF15, movie scripts BIBREF16, and Wikipedia biographies BIBREF17, BIBREF18. Our work builds on this body by diving into two novel domains: celebrity news, which explores gender in pop culture, and student reviews of CS professors, which examines gender in academia and, particularly, the historically male-dominated field of CS. Furthermore, many of these works rely on manually constructed lexicons or topics to pinpoint gendered language, but our methods automatically infer gender-associated words and labeled clusters, thus reducing supervision and increasing the potential to discover subtleties in the data.",
          "Modeling gender associations in language could also be instrumental to other NLP tasks. Abusive language is often founded in sexism BIBREF0, BIBREF1, so models of gender associations could help to improve detection in those cases. Gender bias also manifests in NLP pipelines: prior research has found that word embeddings preserve gender biases BIBREF19, BIBREF20, BIBREF21, and some have developed methods to reduce this bias BIBREF22, BIBREF23. Yet, the problem is far from solved; for example, BIBREF24 showed that it is still possible to recover gender bias from \u201cde-biased\u201d embeddings. These findings further motivate our research, since before we can fully reduce gender bias in embeddings, we need to develop a deeper understanding of how gender permeates through language in the first place.",
          "We also build on methods to cluster words in word embedding space and automatically label clusters. Clustering word embeddings has proven useful for discovering salient patterns in text corpora BIBREF25, BIBREF26. Once clusters are derived, we would like them to be interpretable. Much research simply considers the top-n words from each cluster, but this method can be subjective and time-consuming to interpret. Thus, there are efforts to design methods of automatic cluster labeling BIBREF27. We take a similar approach to BIBREF28, who leverage word embeddings and WordNet during labeling, and we extend their method with additional techniques and evaluations."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "Our first dataset contains articles from celebrity magazines People, UsWeekly, and E!News. We labeled each article for whether it was reporting on men, women, or neither/unknown. To do this, we first extracted the article's topic tags. Some of these tags referred to people, but others to non-people entities, such as \u201cGift Ideas\u201d or \u201cHealth.\u201d To distinguish between these types of tags, we queried each tag on Wikipedia and checked whether the top page result contained a \u201cBorn\u201d entry in its infobox \u2013 if so, we concluded that the tag referred to a person.",
          "Then, from the person's Wikipedia page, we determined their gender by checking whether the introductory paragraphs of the page contained more male or female pronouns. This method was simple but effective, since pronouns in the introduction almost always resolve to the subject of that page. In fact, on a sample of 80 tags that we manually annotated, we found that comparing pronoun counts predicted gender with perfect accuracy. Finally, if an article tagged at least one woman and did not tag any men, we labeled the article as Female; in the opposite case, we labeled it as Male.",
          "Our second dataset contains reviews from RateMyProfessors (RMP), an online platform where students can review their professors. We included all 5,604 U.S. schools on RMP, and collected all reviews for CS professors at those schools. We labeled each review with the gender of the professor whom it was about, which we determined by comparing the count of male versus female pronouns over all reviews for that professor. This method was again effective, because the reviews are expressly written about a certain professor, so the pronouns typically resolve to that professor.",
          "In addition to extracting the text of the articles or reviews, for each dataset we also collected various useful metadata. For the celebrity dataset, we recorded each article's timestamp and the name of the author, if available. Storing author names creates the potential to examine the relationship between the gender of the author and the gender of the subject, such as asking if there are differences between how women write about men and how men write about men. In this work, we did not yet pursue this direction because we wanted to begin with a simpler question of how gender is discussed: regardless of the gender of the authors, what is the content being put forth and consumed? Furthermore, we were unable to extract author gender in the professor dataset since the RMP reviews are anonymous. However, in future work, we may explore the influence of author gender in the celebrity dataset.",
          "For the professor dataset, we captured metadata such as each review's rating, which indicates how the student feels about the professor on a scale of AWFUL to AWESOME. This additional variable in our data creates the option in future work to factor in sentiment; for example, we could study whether there are differences in language used when criticizing a female versus a male professor."
        ]
      },
      {
        "section_name": "Inferring Word-Level Associations",
        "paragraphs": [
          "Our first goal was to discover words that are significantly associated with men or women in a given domain. We employed an approach used by BIBREF10 in their work to analyze differences in how men and women write on Twitter."
        ]
      },
      {
        "section_name": "Inferring Word-Level Associations ::: Methods",
        "paragraphs": [
          "First, to operationalize, we say that term $i$ is associated with gender $j$ if, when discussing individuals of gender $j$, $i$ is used with unusual frequency \u2013 which we can check with statistical hypothesis tests. Let $f_i$ represent the likelihood of $i$ appearing when discussing women or men. $f_i$ is unknown, but we can model the distribution of all possible $f_i$ using the corpus of texts that we have from the domain. We construct a gender-balanced version of the corpus by randomly undersampling the more prevalent gender until the proportions of each gender are equal. Assuming a non-informative prior distribution on $f_i$, the posterior distribution is Beta($k_i$, $N - k_i$), where $k_i$ is the count of $i$ in the gender-balanced corpus and $N$ is the total count of words in that corpus.",
          "As BIBREF10 discuss, \u201cthe distribution of the gender-specific counts can be described by an integral over all possible $f_i$. This integral defines the Beta-Binomial distribution BIBREF29, and has a closed form solution.\u201d We say that term $i$ is significantly associated with gender $j$ if the cumulative distribution at $k_{ij}$ (the count of $i$ in the $j$ portion of the gender-balanced corpus) is $p \\le 0.05$. As in the original work, we apply the Bonferroni correction BIBREF30 for multiple comparisons because we are computing statistical tests for thousands of hypotheses."
        ]
      },
      {
        "section_name": "Inferring Word-Level Associations ::: Findings",
        "paragraphs": [
          "We applied this method to discover gender-associated words in both domains. In Table TABREF9, we present a sample of the most gender-associated nouns from the celebrity domain. Several themes emerge: for example, female celebrities seem to be more associated with appearance (\u201cgown,\u201d \u201cphoto,\u201d \u201chair,\u201d \u201clook\u201d), while male celebrities are more associated with creating content (\u201cmovie,\u201d \u201cfilm,\u201d \u201chost,\u201d \u201cdirector\u201d). This echoes real-world trends: for instance, on the red carpet, actresses tend to be asked more questions about their appearance \u2013- what brands they are wearing, how long it took to get ready, etc. \u2013- while actors are asked questions about their careers and creative processes (as an example, see BIBREF31).",
          "Table TABREF9 also includes some of the most gender-associated verbs and adjectives from the professor domain. Female CS professors seem to be praised for being communicative and personal with students (\u201crespond,\u201d \u201ccommunicate,\u201d \u201ckind,\u201d \u201ccaring\u201d), while male CS professors are recognized for being knowledgeable and challenging the students (\u201cteach,\u201d, \u201cchallenge,\u201d \u201cbrilliant,\u201d \u201cpractical\u201d). These trends are well-supported by social science literature, which has found that female teachers are praised for \u201cpersonalizing\u201d instruction and interacting extensively with students, while male teachers are praised for using \u201cteacher as expert\u201d styles that showcase mastery of material BIBREF32.",
          "These findings establish that there are clear differences in how people talk about women and men \u2013 even with Bonferroni correction, there are still over 500 significantly gender-associated nouns, verbs, and adjectives in the celebrity domain and over 200 in the professor domain. Furthermore, the results in both domains align with prior studies and real world trends, which validates that our methods can capture meaningful patterns and innovatively provide evidence at the large-scale. This analysis also hints that it can be helpful to abstract from words to topics to recognize higher-level patterns of gender associations, which motivates our next section on clustering."
        ]
      },
      {
        "section_name": "Clustering & Cluster Labeling",
        "paragraphs": [
          "With word-level associations in hand, our next goals were to discover coherent clusters among the words and to automatically label those clusters."
        ]
      },
      {
        "section_name": "Clustering & Cluster Labeling ::: Methods",
        "paragraphs": [
          "First, we trained domain-specific word embeddings using the Word2Vec BIBREF33 CBOW model ($w \\in R^{100}$). Then, we used k-means clustering to cluster the embeddings of the gender-associated words. Since k-means may converge at local optima, we ran the algorithm 50 times and kept the model with the lowest sum of squared errors.",
          "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:",
          "Sense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.",
          "Candidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.",
          "Candidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.",
          "In steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
        ]
      },
      {
        "section_name": "Clustering & Cluster Labeling ::: Findings",
        "paragraphs": [
          "Table TABREF11 displays a sample of our results \u2013 we find that the clusters are coherent in context and the labels seem reasonable. In the next section, we discuss human evaluations that we conducted to more rigorously evaluate the output, but first we discuss the value of these methods toward analysis.",
          "At the word-level, we hypothesized that in the celebrity domain, women were more associated with appearance and men with creating content. Now, we can validate those hypotheses against labeled clusters \u2013 indeed, there is a cluster labeled clothing that is 100% female (i.e. 100% words are female-associated), and a 80% male cluster labeled movie. Likewise, in the professor domain, we had guessed that women are associated with communication and men with knowledge, and there is a 100% female cluster labeled communication and a 89% male cluster labeled cognition. Thus, cluster labeling proves to be very effective at pulling out the patterns that we believed we saw at the word-level, but could not formally validate.",
          "The clusters we mentioned so far all lean heavily toward one gender association or the other, but some clusters are interesting precisely because they do not lean heavily \u2013 this allows us to see where semantic groupings do not align exactly with gender association. For example, in the celebrity domain, there is a cluster labeled lover that has a mix of female-associated words (\u201cboyfriend,\u201d \u201cbeau,\u201d \u201chubby\u201d) and male-associated words (\u201cwife,\u201d \u201cgirlfriend\u201d). Jointly leveraging cluster labels and gender associations allows us to see that in the semantic context of having a lover, women are typically associated with male figures and men with female figures, which reflects heteronormativity in society."
        ]
      },
      {
        "section_name": "Human Evaluations",
        "paragraphs": [
          "To test our clusters, we employed the Word Intrusion task BIBREF35. We present the annotator with five words \u2013 four drawn from one cluster and one drawn randomly from the domain vocabulary \u2013 and we ask them to pick out the intruder. The intuition is that if the cluster is coherent, then an observer should be able to identify the out-of-cluster word as the intruder. For both domains, we report results on all clusters and on the top 8, ranked by ascending normalized sum of squared errors, which can be seen as a prediction of coherence. In the celebrity domain, annotators identified the out-of-cluster word 73% of the time in the top-8 and 53% overall. In the professor domain, annotators identified it 60% of the time in the top-8 and 49% overall. As expected, top-8 performance in both domains does considerably better than overall, but at all levels the precision is significantly above the random baseline of 20%.",
          "To test cluster labels, we present the annotator with a label and a word, and we ask them whether the word falls under the concept. The concept is a potential cluster label and the word is either a word from that cluster or drawn randomly from the domain vocabulary. For a good label, the rate at which in-cluster words fall under the label should be much higher than the rate at which out-of-cluster words fall under. In our experiments, we tested the top 4 predicted labels and the centroid of the cluster as a strong baseline label. The centroid achieved an in-cluster rate of .60 and out-of-cluster rate of .18 (difference of .42). Our best performing predicted label achieved an in-cluster rate of .65 and an out-of-cluster rate of .04 (difference of .61), thus outperforming the centroid on both rates and increasing the gap between rates by nearly 20 points. In the Appendix, we include more detailed results on both tasks."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We have presented two substantial datasets and a novel integration of methods to automatically infer gender associations in language. We have demonstrated that in both datasets, there are clear differences in how people talk about women and men. Furthermore, we have shown that clustering and cluster labeling are effective at identifying higher-level patterns of gender associations, and that our methods outperform strong baselines in human evaluations. In future work, we hope to use our findings to improve performance on tasks such as abusive language detection. We also hope to delve into finer-grained analyses, exploring how language around gender interacts with other variables, such as sexual orientation or profession (e.g. actresses versus female athletes). Finally, we plan to continue widening the scope of our study \u2013 for example, expanding our methods to include non-binary gender identities, evaluating changes in gender norms over time, and spreading to more domains, such as the political sphere."
        ]
      }
    ],
    "qas": [
      {
        "question": "How do they decide what is the semantic concept label of particular cluster?",
        "question_id": "a3e7d7389228a197c8c44e0c504a791b60f2c80d",
        "nlp_background": "zero",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "computer vision",
        "question_writer": "258ee4069f740c400c0049a2580945a1cc7f044c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Given a cluster, our algorithm proceeds with the following three steps:\n\nSense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.\n\nCandidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.\n\nCandidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.\n\nIn steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:",
                "Sense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.",
                "Candidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.",
                "Candidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.",
                "In steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
              ],
              "highlighted_evidence": [
                "Given a cluster, our algorithm proceeds with the following three steps:\n\nSense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.\n\nCandidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.\n\nCandidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.\n\nIn steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
              ]
            },
            "annotation_id": "225012fe4d6090ae49d9f264e5516a6e31ac75fc",
            "worker_id": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Candidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:",
                "Sense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.",
                "Candidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.",
                "Candidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.",
                "In steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
              ],
              "highlighted_evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:\n\nSense disambiguation: The goal is to assign each cluster word to one of its WordNet synsets; let $S$ represent the collection of chosen synsets. We know that these words have been clustered in domain-specific embedding space, which means that in the context of the domain, these words are very close semantically. Thus, we choose $S^*$ that minimizes the total distance between its synsets.\n\nCandidate label generation: In this step, we generate $L$, the set of possible cluster labels. Our approach is simple: we take the union of all hypernyms of the synsets in $S^*$.\n\nCandidate label ranking: Here, we rank the synsets in $L$. We want labels that are as close to all of the synsets in $S^*$ as possible; thus, we score the candidate labels by the sum of their distances to each synset in $S^*$ and we rank them from least to most distance.\n\nIn steps 1 and 3, we use WordNet pathwise distance, but we encourage the exploration of other distance representations as well."
              ]
            },
            "annotation_id": "3c118916ae957037bac6ab0feea1b5a98a342376",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "They automatically  label the cluster using WordNet and context-sensitive strengths of domain-specific word embeddings",
              "evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:"
              ],
              "highlighted_evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings.",
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings."
              ]
            },
            "annotation_id": "3e87bfef881da4186bc8a831f8505444cf118f39",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation. Given a cluster, our algorithm proceeds with the following three steps:"
              ],
              "highlighted_evidence": [
                "To automatically label the clusters, we combined the grounded knowledge of WordNet BIBREF34 and context-sensitive strengths of domain-specific word embeddings. Our algorithm is similar to BIBREF28's approach, but we extend their method by introducing domain-specific word embeddings for clustering as well as a new technique for sense disambiguation."
              ]
            },
            "annotation_id": "919a5832117b79e307b09e00dacabcfa4f5c16b6",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Summary statistics of our datasets."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Top: Sample from the top-25 most genderassociated nouns in the celebrity domain. Middle: professor domain, sample from top-25 verbs. Bottom: professor domain, sample from top-25 adjectives. All associations listed are p \u2264 0.05, with Bonferroni correction. See Appendix for all top-25 nouns, verbs, and adjectives for both genders in both domains."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Sample of our clusters and predicted cluster labels. We include in the Appendix a more comprehensive table of our results. F:M refers to the ratio of female-associated to male-associated words in the cluster."
      },
      {
        "file": "7-Table4-1.png",
        "caption": "Table 4: Results for Word Intrusion task. All results significantly outperform the random baseline of .20 (p \u2264 0.0001)."
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5: Top 25 most gender-associated nouns, verbs, and adjectives in the celebrity domain. Words are listed in order of decreasing significance, but all words fall under p \u2264 0.05, with Bonferroni correction."
      },
      {
        "file": "8-Table6-1.png",
        "caption": "Table 6: Top 25 most gender-associated nouns, verbs, and adjectives in the professor domain. Words are listed in order of decreasing significance, but all words fall under p \u2264 0.05, with Bonferroni correction, aside from the last three terms listed for Female-Associated Verbs and the last four terms listed for Male-Associated Verbs."
      },
      {
        "file": "9-Table7-1.png",
        "caption": "Table 7: Top 12 clusters out of 45 overall in the celebrity domain. Predicted labels are included if applicable \u2013 we were only able to predict labels for clusters that contained nouns, since our clustering labeling algorithm relied on the noun taxonomy in WordNet. In the Sample Words in Cluster column, italics indicate female-associated terms, and non-italics indicate male-associated. F:M refers to the ratio of female-associated to male-associated words in the cluster."
      },
      {
        "file": "9-Table8-1.png",
        "caption": "Table 8: Top 6 clusters out of 16 overall in the professor domain. Same details as Table 7 apply."
      },
      {
        "file": "10-Table9-1.png",
        "caption": "Table 9: Results for cluster labeling task. The 3rd predicted label has a significantly lower out-of-cluster rate than the centroid and all the other predicted labels (p \u2264 0.02). The same label also slightly outperforms the centroid on the in-cluster rate, thus producing a much larger gap between rates than the centroid."
      }
    ]
  },
  "1909.04387": {
    "title": "A Crowd-based Evaluation of Abuse Response Strategies in Conversational Agents",
    "abstract": "How should conversational agents respond to verbal abuse through the user? To answer this question, we conduct a large-scale crowd-sourced evaluation of abuse response strategies employed by current state-of-the-art systems. Our results show that some strategies, such as \"polite refusal\" score highly across the board, while for other strategies demographic factors, such as age, as well as the severity of the preceding abuse influence the user's perception of which response is appropriate. In addition, we find that most data-driven models lag behind rule-based or commercial systems in terms of their perceived appropriateness.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Ethical challenges related to dialogue systems and conversational agents raise novel research questions, such as learning from biased data sets BIBREF0, and how to handle verbal abuse from the user's side BIBREF1, BIBREF2, BIBREF3, BIBREF4. As highlighted by a recent UNESCO report BIBREF5, appropriate responses to abusive queries are vital to prevent harmful gender biases: the often submissive and flirty responses by the female-gendered systems reinforce ideas of women as subservient. In this paper, we investigate the appropriateness of possible strategies by gathering responses from current state-of-the-art systems and ask crowd-workers to rate them."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "We first gather abusive utterances from 600K conversations with US-based customers. We search for relevant utterances by simple keyword spotting and find that about 5% of the corpus includes abuse, with mostly sexually explicit utterances. Previous research reports even higher levels of abuse between 11% BIBREF2 and 30% BIBREF6. Since we are not allowed to directly quote from our corpus in order to protect customer rights, we summarise the data to a total of 109 \u201cprototypical\" utterances - substantially extending the previous dataset of 35 utterances from Amanda:EthicsNLP2018 - and categorise these utterances based on the Linguistic Society's definition of sexual harassment BIBREF7:",
          "[noitemsep]",
          "Gender and Sexuality, e.g. \u201cAre you gay?\u201d, \u201cHow do you have sex?\u201d",
          "Sexualised Comments, e.g. \u201cI love watching porn.\u201d, \u201cI'm horny.\u201d",
          "Sexualised Insults, e.g. \u201cStupid bitch.\u201d, \u201cWhore\u201d",
          "Sexual Requests and Demands, e.g. \u201cWill you have sex with me?\u201d, \u201cTalk dirty to me.\u201d",
          "We then use these prompts to elicit responses from the following systems, following methodology from Amanda:EthicsNLP2018.",
          "[leftmargin=5mm, noitemsep]",
          "4 Commercial: Amazon Alexa, Apple Siri, Google Home, Microsoft's Cortana.",
          "4 Non-commercial rule-based: E.L.I.Z.A. BIBREF8, Parry BIBREF9, A.L.I.C.E. BIBREF10, Alley BIBREF11.",
          "4 Data-driven approaches:",
          "Cleverbot BIBREF12;",
          "NeuralConvo BIBREF13, a re-implementation of BIBREF14;",
          "an implementation of BIBREF15's Information Retrieval approach;",
          "a vanilla Seq2Seq model trained on clean Reddit data BIBREF1.",
          "Negative Baselines: We also compile responses by adult chatbots: Sophia69 BIBREF16, Laurel Sweet BIBREF17, Captain Howdy BIBREF18, Annabelle Lee BIBREF19, Dr Love BIBREF20.",
          "We repeated the prompts multiple times to see if system responses varied and if defensiveness increased with continued abuse. If this was the case, we included all responses in the study. Following this methodology, we collected a total of 2441 system replies in July-August 2018 - 3.5 times more data than Amanda:EthicsNLP2018 - which 2 expert annotators manually annotated according to the categories in Table TABREF14 ($\\kappa =0.66$)."
        ]
      },
      {
        "section_name": "Human Evaluation",
        "paragraphs": [
          "In order to assess the perceived appropriateness of system responses we conduct a human study using crowd-sourcing on the FigureEight platform. We define appropriateness as \u201cacceptable behaviour in a work environment\u201d and the participants were made aware that the conversations took place between a human and a system. Ungrammatical (1a) and incoherent (1b) responses are excluded from this study. We collect appropriateness ratings given a stimulus (the prompt) and four randomly sampled responses from our corpus that the worker is to label following the methodology described in BIBREF21, where each utterance is rated relatively to a reference on a user-defined scale. Ratings are then normalised on a scale from [0-1]. This methodology was shown to produce more reliable user ratings than commonly used Likert Scales. In addition, we collect demographic information, including gender and age group. In total we collected 9960 HITs from 472 crowd workers. In order to identify spammers and unsuitable ratings, we use the responses from the adult-only bots as test questions: We remove users who give high ratings to sexual bot responses the majority (more than 55%) of the time.18,826 scores remain - resulting in an average of 7.7 ratings per individual system reply and 1568.8 ratings per response type as listed in Table TABREF14.Due to missing demographic data - and after removing malicious crowdworkers - we only consider a subset of 190 raters for our demographic study. The group is composed of 130 men and 60 women. Most raters (62.6%) are under the age of 44, with similar proportions across age groups for men and women. This is in-line with our target population: 57% of users of smart speakers are male and the majority are under 44 BIBREF22."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "The ranks and mean scores of response categories can be seen in Table TABREF29. Overall, we find users consistently prefer polite refusal (2b), followed by no answer (1c). Chastising (2d) and \u201cdon't know\" (1e) rank together at position 3, while flirting (3c) and retaliation (2e) rank lowest. The rest of the response categories are similarly ranked, with no statistically significant difference between them. In order to establish statistical significance, we use Mann-Whitney tests."
        ]
      },
      {
        "section_name": "Results ::: Demographic Factors",
        "paragraphs": [
          "Previous research has shown gender to be the most important factor in predicting a person's definition of sexual harassment BIBREF23. However, we find small and not statistically significant differences in the overall rank given by users of different gender (see tab:ageresults).",
          "Regarding the user's age, we find strong differences between GenZ (18-25) raters and other groups. Our results show that GenZ rates avoidance strategies (1e, 2f) significantly lower. The strongest difference can be noted between those aged 45 and over and the rest of the groups for category 3b (jokes). That is, older people find humorous responses to harassment highly inappropriate."
        ]
      },
      {
        "section_name": "Results ::: Prompt context",
        "paragraphs": [
          "Here, we explore the hypothesis, that users perceive different responses as appropriate, dependent on the type and gravity of harassment, see Section SECREF2. The results in Table TABREF33 indeed show that perceived appropriateness varies significantly between prompt contexts. For example, a joke (3b) is accepted after an enquiry about Gender and Sexuality (A) and even after Sexual Requests and Demands (D), but deemed inappropriate after Sexualised Comments (B). Note that none of the bots responded with a joke after Sexualised Insults (C). Avoidance (2f) is considered most appropriate in the context of Sexualised Demands. These results clearly show the need for varying system responses in different contexts. However, the corpus study from Amanda:EthicsNLP2018 shows that current state-of-the-art systems do not adapt their responses sufficiently."
        ]
      },
      {
        "section_name": "Results ::: Systems",
        "paragraphs": [
          "Finally, we consider appropriateness per system. Following related work by BIBREF21, BIBREF24, we use Trueskill BIBREF25 to cluster systems into equivalently rated groups according to their partial relative rankings. The results in Table TABREF36 show that the highest rated systen is Alley, a purpose build bot for online language learning. Alley produces \u201cpolite refusal\u201d (2b) - the top ranked strategy - 31% of the time. Comparatively, commercial systems politely refuse only between 17% (Cortana) and 2% (Alexa). Most of the time commercial systems tend to \u201cplay along\u201d (3a), joke (3b) or don't know how to answer (1e) which tend to receive lower ratings, see Figure FIGREF38. Rule-based systems most often politely refuse to answer (2b), but also use medium ranked strategies, such as deflect (2c) or chastise (2d). For example, most of Eliza's responses fall under the \u201cdeflection\u201d strategy, such as \u201cWhy do you ask?\u201d. Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
        ]
      },
      {
        "section_name": "Related and Future Work",
        "paragraphs": [
          "Crowdsourced user studies are widely used for related tasks, such as evaluating dialogue strategies, e.g. BIBREF26, and for eliciting a moral stance from a population BIBREF27. Our crowdsourced setup is similar to an \u201coverhearer experiment\u201d as e.g. conducted by Ma:2019:handlingChall where study participants were asked to rate the system's emotional competence after watching videos of challenging user behaviour. However, we believe that the ultimate measure for abuse mitigation should come from users interacting with the system. chin2019should make a first step into this direction by investigating different response styles (Avoidance, Empathy, Counterattacking) to verbal abuse, and recording the user's emotional reaction \u2013 hoping that eliciting certain emotions, such as guilt, will eventually stop the abuse. While we agree that stopping the abuse should be the ultimate goal, BIBREF28's study is limited in that participants were not genuine (ab)users, but instructed to abuse the system in a certain way. BIBREF29 report that a pilot using a similar setup let to unnatural interactions, which limits the conclusions we can draw about the effectiveness of abuse mitigation strategies. Our next step therefore is to employ our system with real users to test different mitigation strategies \u201cin the wild\" with the ultimate goal to find the best strategy to stop the abuse. The results of this current paper suggest that the strategy should be adaptive to user type/ age, as well as to the severity of abuse."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This paper presents the first user study on perceived appropriateness of system responses after verbal abuse. We put strategies used by state-of-the-art systems to the test in a large-scale, crowd-sourced evaluation. The full annotated corpus contains 2441 system replies, categorised into 14 response types, which were evaluated by 472 raters - resulting in 7.7 ratings per reply.",
          "Our results show that: (1) The user's age has an significant effect on the ratings. For example, older users find jokes as a response to harassment highly inappropriate. (2) Perceived appropriateness also depends on the type of previous abuse. For example, avoidance is most appropriate after sexual demands. (3) All system were rated significantly higher than our negative adult-only baselines - except two data-driven systems, one of which is a Seq2Seq model trained on \u201cclean\" data where all utterances containing abusive words were removed BIBREF1. This leads us to believe that data-driven response generation need more effective control mechanisms BIBREF30."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We would like to thank our colleagues Ruth Aylett and Arash Eshghi for their comments. This research received funding from the EPSRC projects DILiGENt (EP/M005429/1) and MaDrIgAL (EP/N017536/1)."
        ]
      }
    ],
    "qas": [
      {
        "question": "How do data-driven models usually respond to abuse?",
        "question_id": "371433bd3fb5042bacec4dfad3cfff66147c14f0",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "either by refusing politely, or, with flirtatious responses, or, by retaliating",
              "evidence": [
                "4 Data-driven approaches:",
                "Cleverbot BIBREF12;",
                "NeuralConvo BIBREF13, a re-implementation of BIBREF14;",
                "an implementation of BIBREF15's Information Retrieval approach;",
                "a vanilla Seq2Seq model trained on clean Reddit data BIBREF1.",
                "Finally, we consider appropriateness per system. Following related work by BIBREF21, BIBREF24, we use Trueskill BIBREF25 to cluster systems into equivalently rated groups according to their partial relative rankings. The results in Table TABREF36 show that the highest rated systen is Alley, a purpose build bot for online language learning. Alley produces \u201cpolite refusal\u201d (2b) - the top ranked strategy - 31% of the time. Comparatively, commercial systems politely refuse only between 17% (Cortana) and 2% (Alexa). Most of the time commercial systems tend to \u201cplay along\u201d (3a), joke (3b) or don't know how to answer (1e) which tend to receive lower ratings, see Figure FIGREF38. Rule-based systems most often politely refuse to answer (2b), but also use medium ranked strategies, such as deflect (2c) or chastise (2d). For example, most of Eliza's responses fall under the \u201cdeflection\u201d strategy, such as \u201cWhy do you ask?\u201d. Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ],
              "highlighted_evidence": [
                "4 Data-driven approaches:\n\nCleverbot BIBREF12;\n\nNeuralConvo BIBREF13, a re-implementation of BIBREF14;\n\nan implementation of BIBREF15's Information Retrieval approach;\n\na vanilla Seq2Seq model trained on clean Reddit data BIBREF1.",
                "Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ]
            },
            "annotation_id": "2d55c4f4d4900dc5815eaba12882b2317609b7fc",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Data-driven systems rank low in general"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Finally, we consider appropriateness per system. Following related work by BIBREF21, BIBREF24, we use Trueskill BIBREF25 to cluster systems into equivalently rated groups according to their partial relative rankings. The results in Table TABREF36 show that the highest rated systen is Alley, a purpose build bot for online language learning. Alley produces \u201cpolite refusal\u201d (2b) - the top ranked strategy - 31% of the time. Comparatively, commercial systems politely refuse only between 17% (Cortana) and 2% (Alexa). Most of the time commercial systems tend to \u201cplay along\u201d (3a), joke (3b) or don't know how to answer (1e) which tend to receive lower ratings, see Figure FIGREF38. Rule-based systems most often politely refuse to answer (2b), but also use medium ranked strategies, such as deflect (2c) or chastise (2d). For example, most of Eliza's responses fall under the \u201cdeflection\u201d strategy, such as \u201cWhy do you ask?\u201d. Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ],
              "highlighted_evidence": [
                "Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time)."
              ]
            },
            "annotation_id": "3017bd558bda9dc69bfeb99e16b6f5b13b90f349",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "politely refuse",
                "politely refuses",
                "flirtatious responses"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Finally, we consider appropriateness per system. Following related work by BIBREF21, BIBREF24, we use Trueskill BIBREF25 to cluster systems into equivalently rated groups according to their partial relative rankings. The results in Table TABREF36 show that the highest rated systen is Alley, a purpose build bot for online language learning. Alley produces \u201cpolite refusal\u201d (2b) - the top ranked strategy - 31% of the time. Comparatively, commercial systems politely refuse only between 17% (Cortana) and 2% (Alexa). Most of the time commercial systems tend to \u201cplay along\u201d (3a), joke (3b) or don't know how to answer (1e) which tend to receive lower ratings, see Figure FIGREF38. Rule-based systems most often politely refuse to answer (2b), but also use medium ranked strategies, such as deflect (2c) or chastise (2d). For example, most of Eliza's responses fall under the \u201cdeflection\u201d strategy, such as \u201cWhy do you ask?\u201d. Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ],
              "highlighted_evidence": [
                "Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ]
            },
            "annotation_id": "60d8caadfc21f53f35168668671d080f0f303445",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "flirt; retaliation",
              "evidence": [
                "4 Data-driven approaches:",
                "Cleverbot BIBREF12;",
                "NeuralConvo BIBREF13, a re-implementation of BIBREF14;",
                "an implementation of BIBREF15's Information Retrieval approach;",
                "a vanilla Seq2Seq model trained on clean Reddit data BIBREF1.",
                "Finally, we consider appropriateness per system. Following related work by BIBREF21, BIBREF24, we use Trueskill BIBREF25 to cluster systems into equivalently rated groups according to their partial relative rankings. The results in Table TABREF36 show that the highest rated systen is Alley, a purpose build bot for online language learning. Alley produces \u201cpolite refusal\u201d (2b) - the top ranked strategy - 31% of the time. Comparatively, commercial systems politely refuse only between 17% (Cortana) and 2% (Alexa). Most of the time commercial systems tend to \u201cplay along\u201d (3a), joke (3b) or don't know how to answer (1e) which tend to receive lower ratings, see Figure FIGREF38. Rule-based systems most often politely refuse to answer (2b), but also use medium ranked strategies, such as deflect (2c) or chastise (2d). For example, most of Eliza's responses fall under the \u201cdeflection\u201d strategy, such as \u201cWhy do you ask?\u201d. Data-driven systems rank low in general. Neuralconvo and Cleverbot are the only ones that ever politely refuse and we attribute their improved ratings to this. In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses. Finally, Dr Love and Sophia69 produce almost exclusively flirtatious responses which are consistently ranked low by users."
              ],
              "highlighted_evidence": [
                "4 Data-driven approaches:\n\nCleverbot BIBREF12;\n\nNeuralConvo BIBREF13, a re-implementation of BIBREF14;\n\nan implementation of BIBREF15's Information Retrieval approach;\n\na vanilla Seq2Seq model trained on clean Reddit data BIBREF1.",
                "In turn, the \u201cclean\u201d seq2seq often produces responses which can be interpreted as flirtatious (44%), and ranks similarly to Annabelle Lee and Laurel Sweet, the only adult bots that politely refuses ( 16% of the time). Ritter:2010:UMT:1857999.1858019's IR approach is rated similarly to Capt Howdy and both produce a majority of retaliatory (2e) responses - 38% and 58% respectively - followed by flirtatious responses."
              ]
            },
            "annotation_id": "d41a35aa743c17fc5e5dac324995094115a46b35",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Full annotation scheme for system response types after user abuse. Categories (1a) and (1b) are excluded from this study."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Response ranking, mean and standard deviation for demographic groups with (*) p < .05, (**) p < .01 wrt. other groups."
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Response ranking, mean and standard deviation for age groups with (*) p < .05, (**) p < .01 wrt. other groups."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Ranks and mean scores per prompt contexts (A) Gender and Sexuality, (B) Sexualised Comments, (C) Sexualised Insults and (D) Sexualised Requests and Demands."
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: System clusters according to Trueskill and \u201cappropriateness\u201d average score. Note that systems within a cluster are not significantly different."
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Response type breakdown per system. Systems ordered according to average user ratings."
      }
    ]
  },
  "1805.11937": {
    "title": "Character-Level Models versus Morphology in Semantic Role Labeling",
    "abstract": "Character-level models have become a popular approach specially for their accessibility and ability to handle unseen data. However, little is known on their ability to reveal the underlying morphological structure of a word, which is a crucial skill for high-level semantic analysis tasks, such as semantic role labeling (SRL). In this work, we train various types of SRL models that use word, character and morphology level information and analyze how performance of characters compare to words and morphology for several languages. We conduct an in-depth error analysis for each morphological typology and analyze the strengths and limitations of character-level models that relate to out-of-domain data, training data size, long range dependencies and model complexity. Our exhaustive analyses shed light on important characteristics of character-level models and their semantic capability.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Encoding of words is perhaps the most important step towards a successful end-to-end natural language processing application. Although word embeddings have been shown to provide benefit to such models, they commonly treat words as the smallest meaning bearing unit and assume that each word type has its own vector representation. This assumption has two major shortcomings especially for languages with rich morphology: (1) inability to handle unseen or out-of-vocabulary (OOV) word-forms (2) inability to exploit the regularities among word parts. The limitations of word embeddings are particularly pronounced in sentence-level semantic tasks, especially in languages where word parts play a crucial role. Consider the Turkish sentences \u201cK\u00f6y+l\u00fc-ler (villagers) \u015fehr+e (to town) geldi (came)\u201d and \u201cSendika+l\u0131-lar (union members) meclis+e (to council) geldi (came)\u201d. Here the stems k\u00f6y (village) and sendika (union) function similarly in semantic terms with respect to the verb come (as the origin of the agents of the verb), where \u015fehir (town) and meclis (council) both function as the end point. These semantic similarities are determined by the common word parts shown in bold. However ortographic similarity does not always correspond to semantic similarity. For instance the ortographically similar words knight and night have large semantic differences. Therefore, for a successful semantic application, the model should be able to capture both the regularities, i.e, morphological tags and the irregularities, i.e, lemmas of the word.",
          "Morphological analysis already provides the aforementioned information about the words. However access to useful morphological features may be problematic due to software licensing issues, lack of robust morphological analyzers and high ambiguity among analyses. Character-level models (CLM), being a cheaper and accessible alternative to morphology, have been reported as performing competitively on various NLP tasks BIBREF0 , BIBREF1 , BIBREF2 . However the extent to which these tasks depend on morphology is small; and their relation to semantics is weak. Hence, little is known on their true ability to reveal the underlying morphological structure of a word and their semantic capabilities. Furthermore, their behaviour across languages from different families; and their limitations and strengths such as handling of long-range dependencies, reaction to model complexity or performance on out-of-domain data are unknown. Analyzing such issues is a key to fully understanding the character-level models.",
          "To achieve this, we perform a case study on semantic role labeling (SRL), a sentence-level semantic analysis task that aims to identify predicate-argument structures and assign meaningful labels to them as follows:",
          " $[$ Villagers $]$ comers came $[$ to town $]$ end point",
          "We use a simple method based on bidirectional LSTMs to train three types of base semantic role labelers that employ (1) words (2) characters and character sequences and (3) gold morphological analysis. The gold morphology serves as the upper bound for us to compare and analyze the performances of character-level models on languages of varying morphological typologies. We carry out an exhaustive error analysis for each language type and analyze the strengths and limitations of character-level models compared to morphology. In regard to the diversity hypothesis which states that diversity of systems in ensembles lead to further improvement, we combine character and morphology-level models and measure the performance of the ensemble to better understand how similar they are.",
          "We experiment with several languages with varying degrees of morphological richness and typology: Turkish, Finnish, Czech, German, Spanish, Catalan and English. Our experiments and analysis reveal insights such as:"
        ]
      },
      {
        "section_name": "Method",
        "paragraphs": [
          "Formally, we generate a label sequence $\\vec{l}$ for each sentence and predicate pair: $(s,p)$ . Each $l_t\\in \\vec{l}$ is chosen from $\\mathcal {L}=\\lbrace  \\mathit {roles \\cup nonrole}\\rbrace $ , where $roles$ are language-specific semantic roles (mostly consistent with PropBank) and $nonrole$ is a symbol to present tokens that are not arguments. Given $\\theta $ as model parameters and $g_t$ as gold label for $t_{th}$ token, we find the parameters that minimize the negative log likelihood of the sequence: ",
          "$$\\hat{\\theta }=\\underset{\\theta }{\\arg \\min } \\left( -\\sum _{t=1}^n log (p(g_t|\\theta ,s,p)) \\right)$$   (Eq. 7) ",
          "Label probabilities, $p(l_t|\\theta ,s,p)$ , are calculated with equations given below. First, the word encoding layer splits tokens into subwords via $\\rho $ function. ",
          "$$\\rho (w) = {s_0,s_1,..,s_n}$$   (Eq. 8) ",
          "As proposed by BIBREF0 , we treat words as a sequence of subword units. Then, the sequence is fed to a simple bi-LSTM network BIBREF15 , BIBREF16 and hidden states from each direction are weighted with a set of parameters which are also learned during training. Finally, the weighted vector is used as the word embedding given in Eq. 9 . ",
          "$$hs_f, hs_b = \\text{bi-LSTM}({s_0,s_1,..,s_n}) \\\\\n\\vec{w} = W_f \\cdot hs_f + W_b \\cdot hs_b + b$$   (Eq. 9) ",
          "There may be more than one predicate in the sentence so it is crucial to inform the network of which arguments we aim to label. In order to mark the predicate of interest, we concatenate a predicate flag $pf_t$ to the word embedding vector. ",
          "$$\\vec{x_{t}} = [\\vec{w};pf_t]$$   (Eq. 10) ",
          "Final vector, $\\vec{x_t}$ serves as an input to another bi-LSTM unit. ",
          "$$\\vec{h_{f}, h_{b}} = \\text{bi-LSTM}(x_{t})$$   (Eq. 11) ",
          "Finally, the label distribution is calculated via softmax function over the concatenated hidden states from both directions. ",
          "$$\\vec{p(l_t|s,p)} = softmax(W_{l}\\cdot [\\vec{h_{f}};\\vec{h_{b}}]+\\vec{b_{l}})$$   (Eq. 12) ",
          "For simplicity, we assign the label with the highest probability to the input token. ."
        ]
      },
      {
        "section_name": "Subword Units",
        "paragraphs": [
          "We use three types of units: (1) words (2) characters and character sequences and (3) outputs of morphological analysis. Words serve as a lower bound; while morphology is used as an upper bound for comparison. Table 1 shows sample outputs of various $\\rho $ functions.",
          "Here, char function simply splits the token into its characters. Similar to n-gram language models, char3 slides a character window of width $n=3$ over the token. Finally, gold morphological features are used as outputs of morph-language. Throughout this paper, we use morph and oracle interchangably, i.e., morphology-level models (MLM) have access to gold tags unless otherwise is stated. For all languages, morph outputs the lemma of the token followed by language specific morphological tags. As an exception, it outputs additional information for some languages, such as parts-of-speech tags for Turkish. Word segmenters such as Morfessor and Byte Pair Encoding (BPE) are other commonly used subword units. Due to low scores obtained from our preliminary experiments and unsatisfactory results from previous studies BIBREF13 , we excluded these units."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We use the datasets distributed by LDC for Catalan (CAT), Spanish (SPA), German (DEU), Czech (CZE) and English (ENG) BIBREF17 , BIBREF18 ; and datasets made available by BIBREF19 , BIBREF20 for Finnish (FIN) and Turkish (TUR) respectively . Datasets are provided with syntactic dependency annotations and semantic roles of verbal predicates. In addition, English supplies nominal predicates annotated with semantic roles and does not provide any morphological feature.",
          "Statistics for the training split for all languages are given in Table 2 . Here, #pred is number of predicates, and #role refers to number distinct semantic roles that occur more than 10 times. More detailed statistics about the datasets can be found in BIBREF27 , BIBREF19 , BIBREF20 ."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "To fit the requirements of the SRL task and of our model, we performed the following:",
          "Multiword expressions (MWE) are represented as a single token, (e.g., Confederaci\u00f3n_Francesa_del_Trabajo), that causes notably long character sequences which are hard to handle by LSTMs. For the sake of memory efficiency and performance, we used an abbreviation (e.g., CFdT) for each MWE during training and testing.",
          "Original dataset defines its own format of semantic annotation, such as 17:PBArgM_mod $\\mid $ 19:PBArgM_mod meaning the node is an argument of $17_{th}$ and $19_{th}$ tokens with ArgM-mod (temporary modifier) semantic role. They have been converted into CoNLL-09 tabular format, where each predicate's arguments are given in a specific column.",
          "Words are splitted from derivational boundaries in the original dataset, where each inflectional group is represented as a separate token. We first merge boundaries of the same word, i.e, tokens of the word, then we use our own $\\rho $ function to split words into subwords.",
          "We lowercase all tokens beforehand and place special start and end of the token characters. For all experiments, we initialized weight parameters orthogonally and used one layer bi-LSTMs both for subword composition and argument labeling with hidden size of 200. Subword embedding size is chosen as 200. We used gradient clipping and early stopping to prevent overfitting. Stochastic gradient descent is used as the optimizer. The initial learning rate is set to 1 and reduced by half if scores on development set do not improve after 3 epochs. We use the provided splits and evaluate the results with the official evaluation script provided by CoNLL-09 shared task. In this work (and in most of the recent SRL works), only the scores for argument labeling are reported, which may cause confusions for the readers while comparing with older SRL studies. Most of the early SRL work report combined scores (argument labeling with predicate sense disambiguation (PSD)). However, PSD is considered a simpler task with higher F1 scores . Therefore, we believe omitting PSD helps us gain more useful insights on character level models."
        ]
      },
      {
        "section_name": "Results and Analysis",
        "paragraphs": [
          "Our main results on test and development sets for models that use words, characters (char), character trigrams (char3) and morphological analyses (morph) are given in Table 3 . We calculate improvement over word (IOW) for each subword model and improvement over the best character model (IOC) for the morph. IOW and IOC values are calculated on the test set.",
          "The biggest improvement over the word baseline is achieved by the models that have access to morphology for all languages (except for English) as expected. Character trigrams consistently outperformed characters by a small margin. Same pattern is observed on the results of the development set. IOW has the values between 0% to 38% while IOC values range between 2%-10% dependending on the properties of the language and the dataset. We analyze the results separately for agglutinative and fusional languages and reveal the links between certain linguistic phenomena and the IOC, IOW values."
        ]
      },
      {
        "section_name": "Similarity between models",
        "paragraphs": [
          "One way to infer similarity is to measure diversity. Consider a set of baseline models that are not diverse, i.e., making similar errors with similar inputs. In such a case, combination of these models would not be able to overcome the biases of the learners, hence the combination would not achieve a better result. In order to test if character and morphological models are similar, we combine them and measure the performance of the ensemble. Suppose that a prediction $p_{i}$ is generated for each token by a model $m_i$ , $i \\in n$ , then the final prediction is calculated from these predictions by: ",
          "$$p_{final} = f(p_0, p_1,..,p_n|\\phi )$$   (Eq. 36) ",
          "where $f$ is the combining function with parameter $\\phi $ . The simplest global approach is averaging (AVG), where $f$ is simply the mean function and $p_i$ s are the log probabilities. Mean function combines model outputs linearly, therefore ignores the nonlinear relation between base models/units. In order to exploit nonlinear connections, we learn the parameters $\\phi $ of $f$ via a simple linear layer followed by sigmoid activation. In other words, we train a new model that learns how to best combine the predictions from subword models. This ensemble technique is generally referred to as stacking or stacked generalization (SG). ",
          "Although not guaranteed, diverse models can be achieved by altering the input representation, the learning algorithm, training data or the hyperparameters. To ensure that the only factor contributing to the diversity of the learners is the input representation, all parameters, training data and model settings are left unchanged.",
          "Our results are given in Table 4 . IOB shows the improvement over the best of the baseline models in the ensemble. Averaging and stacking methods gave similar results, meaning that there is no immediate nonlinear relations between units. We observe two language clusters: (1) Czech and agglutinative languages (2) Spanish, Catalan, German and English. The common property of that separate clusters are (1) high OOV% and (2) relatively low OOV%. Amongst the first set, we observe that the improvement gained by character-morphology ensembles is higher (shown with green) than ensembles between characters and character trigrams (shown with red), whereas the opposite is true for the second set of languages. It can be interpreted as character level models being more similar to the morphology level models for the first cluster, i.e., languages with high OOV%, and characters and morphology being more diverse for the second cluster."
        ]
      },
      {
        "section_name": "Limitations and Strengths",
        "paragraphs": [
          "To expand our understanding and reveal the limitations and strengths of the models, we analyze their ability to handle long range dependencies, their relation with training data and model size; and measure their performances on out of domain data."
        ]
      },
      {
        "section_name": "Long Range Dependencies",
        "paragraphs": [
          "Long range dependency is considered as an important linguistic issue that is hard to solve. Therefore the ability to handle it is a strong performance indicator. To gain insights on this issue, we measure how models perform as the distance between the predicate and the argument increases. The unit of measure is number of tokens between the two; and argument is defined as the head of the argument phrase in accordance with dependency-based SRL task. For that purpose, we created bins of [0-4], [5-9], [10-14] and [15-19] distances. Then, we have calculate F1 scores for arguments in each bin. Due to low number of predicate-argument pairs in buckets, we could not analyze German and Turkish; and also the bin [15-19] is only used for Czech. Our results are shown in Fig. 3 . We observe that either char or char3 closely follows the oracle for all languages. The gap between the two does not increase with the distance, suggesting that the performance gap is not related to long range dependencies. In other words, both characters and the oracle handle long range dependencies equally well."
        ]
      },
      {
        "section_name": "Training Data Size",
        "paragraphs": [
          "We analyzed how char3 and oracle models perform with respect to the training data size. For that purpose, we trained them on chunks of increasing size and evaluate on the provided test split. We used units of 2000 sentences for German and Czech; and 400 for Turkish. Results are shown in Fig. 4 . Apparently as the data size increases, the performances of both models logarithmically increase - with a varying speed. To speak in statistical terms, we fit a logarithmic curve to the observed F1 scores (shown with transparent lines) and check the x coefficients, where x refers to the number of sentences. This coefficient can be considered as an approximation to the speed of growth with data size. We observe that the coefficient is higher for char3 than oracle for all languages. It can be interpreted as: in the presence of more training data, char3 may surpass the oracle; i.e., char3 relies on data more than the oracle."
        ]
      },
      {
        "section_name": "Out-of-Domain (OOD) Data",
        "paragraphs": [
          "As part of the CoNLL09 shared task BIBREF27 , out of domain test sets are provided for three languages: Czech, German and English. We test our models trained on regular training dataset on these OOD data. The results are given in Table 5 . Here, we clearly see that the best model has shifted from oracle to character based models. The dramatic drop in German oracle model is due to the high lemma OOV rate which is a consequence of keeping compounds as a single lemma. Czech oracle model performs reasonably however is unable to beat the generalization power of the char3 model. Furthermore, the scores of the character models in Table 5 are higher than the best OOD scores reported in the shared task BIBREF27 ; even though our main results on evaluation set are not (except for Czech). This shows that character-level models have increased robustness to out-of-domain data due to their ability to learn regularities among data."
        ]
      },
      {
        "section_name": "Model Size",
        "paragraphs": [
          "Throughout this paper, our aim was to gain insights on how models perform on different languages rather than scoring the highest F1. For this reason, we used a model that can be considered small when compared to recent neural SRL models and avoided parameter search. However, we wonder how the models behave when given a larger network. To answer this question, we trained char3 and oracle models with more layers for two fusional languages (Spanish, Catalan), and two agglutinative languages (Finnish, Turkish). The results given in Table 6 clearly shows that model complexity provides relatively more benefit to morphological models. This indicates that morphological signals help to extract more complex linguistic features that have semantic clues."
        ]
      },
      {
        "section_name": "Predicted Morphological Tags",
        "paragraphs": [
          "Although models with access to gold morphological tags achieve better F1 scores than character models, they can be less useful a in real-life scenario since they require gold tags at test time. To predict the performance of morphology-level models in such a scenario, we train the same models with the same parameters with predicted morphological features. Predicted tags were only available for German, Spanish, Catalan and Czech. Our results given in Fig. 5 , show that (except for Czech), predicted morphological tags are not as useful as characters alone."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Character-level neural models are becoming the defacto standard for NLP problems due to their accessibility and ability to handle unseen data. In this work, we investigated how they compare to models with access to gold morphological analysis, on a sentence-level semantic task. We evaluated their quality on semantic role labeling in a number of agglutinative and fusional languages. Our results lead to the following conclusions:"
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "G\u00f6zde G\u00fcl \u015eahin was a PhD student at Istanbul Technical University and a visiting research student at University of Edinburgh during this study. She was funded by T\u00fcbitak (The Scientific and Technological Research Council of Turkey) 2214-A scholarship during her visit to University of Edinburgh. She was granted access to CoNLL-09 Semantic Role Labeling Shared Task data by Linguistic Data Consortium (LDC). This work was supported by ERC H2020 Advanced Fellowship GA 742137 SEMANTAX and a Google Faculty award to Mark Steedman. We would like to thank Adam Lopez for fruitful discussions, guidance and support during the first author's visit."
        ]
      }
    ],
    "qas": [
      {
        "question": "What morphological typologies are considered?",
        "question_id": "230ff86b7b90b87c33c53014bb1e9c582dfc107f",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "morphology",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "agglutinative and fusional languages"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The biggest improvement over the word baseline is achieved by the models that have access to morphology for all languages (except for English) as expected. Character trigrams consistently outperformed characters by a small margin. Same pattern is observed on the results of the development set. IOW has the values between 0% to 38% while IOC values range between 2%-10% dependending on the properties of the language and the dataset. We analyze the results separately for agglutinative and fusional languages and reveal the links between certain linguistic phenomena and the IOC, IOW values."
              ],
              "highlighted_evidence": [
                "We analyze the results separately for agglutinative and fusional languages and reveal the links between certain linguistic phenomena and the IOC, IOW values."
              ]
            },
            "annotation_id": "eca9eb2f2c3d88388688f62a21e1731a7f1f8374",
            "worker_id": "01cb6148c645822f9a870d3ac20d496c05b6b217"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "agglutinative and fusional",
              "evidence": [
                "Throughout this paper, our aim was to gain insights on how models perform on different languages rather than scoring the highest F1. For this reason, we used a model that can be considered small when compared to recent neural SRL models and avoided parameter search. However, we wonder how the models behave when given a larger network. To answer this question, we trained char3 and oracle models with more layers for two fusional languages (Spanish, Catalan), and two agglutinative languages (Finnish, Turkish). The results given in Table 6 clearly shows that model complexity provides relatively more benefit to morphological models. This indicates that morphological signals help to extract more complex linguistic features that have semantic clues."
              ],
              "highlighted_evidence": [
                "Throughout this paper, our aim was to gain insights on how models perform on different languages rather than scoring the highest F1. For this reason, we used a model that can be considered small when compared to recent neural SRL models and avoided parameter search. However, we wonder how the models behave when given a larger network. To answer this question, we trained char3 and oracle models with more layers for two fusional languages (Spanish, Catalan), and two agglutinative languages (Finnish, Turkish). "
              ]
            },
            "annotation_id": "4db3dd7ca826532c2faa0d02ee720de184673202",
            "worker_id": "1ba1b5b562aef9cd264cace5b7bdd46a7c065c0a"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Turkish, Finnish, Czech, German, Spanish, Catalan and English"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We experiment with several languages with varying degrees of morphological richness and typology: Turkish, Finnish, Czech, German, Spanish, Catalan and English. Our experiments and analysis reveal insights such as:"
              ],
              "highlighted_evidence": [
                "We experiment with several languages with varying degrees of morphological richness and typology: Turkish, Finnish, Czech, German, Spanish, Catalan and English."
              ]
            },
            "annotation_id": "836cb06c5203ba20b6103627be397b82477a55e8",
            "worker_id": "35491e1e579f6d147f4793edce4c1a80ab2410e7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "agglutinative and fusional languages"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The biggest improvement over the word baseline is achieved by the models that have access to morphology for all languages (except for English) as expected. Character trigrams consistently outperformed characters by a small margin. Same pattern is observed on the results of the development set. IOW has the values between 0% to 38% while IOC values range between 2%-10% dependending on the properties of the language and the dataset. We analyze the results separately for agglutinative and fusional languages and reveal the links between certain linguistic phenomena and the IOC, IOW values."
              ],
              "highlighted_evidence": [
                "We analyze the results separately for agglutinative and fusional languages and reveal the links between certain linguistic phenomena and the IOC, IOW values."
              ]
            },
            "annotation_id": "c5d1339ade353ccb68278beb8d98cfaadd0fdecf",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Sample outputs of different \u03c1 functions"
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Training data statistics. A: Agglutinative, F: Fusional"
      },
      {
        "file": "6-Figure1-1.png",
        "caption": "Figure 1: Differences in model performances on agglutinative languages"
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: F1 scores of word, character, character trigram and morphology models for argument labeling. Best F1 for each language is shown in bold. First row: results on test, Second row: results on development."
      },
      {
        "file": "7-Figure2-1.png",
        "caption": "Figure 2: x axis: Number of morphological features; y axis: Targeted F1 scores"
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: Results of ensembling via averaging (Avg) and stack generalization (SG). IOB: Improvement Over Best of baseline models"
      },
      {
        "file": "9-Figure3-1.png",
        "caption": "Figure 3: X axis: Distance between the predicate and the argument, Y axis: F1 scores on argument labels"
      },
      {
        "file": "9-Figure4-1.png",
        "caption": "Figure 4: Performance of units w.r.t training data size. X axis: Number of sentences, Y axis: F1 score"
      },
      {
        "file": "9-Table6-1.png",
        "caption": "Table 6: Effect of layer size on model performances. I: Improvement over model with one layer."
      },
      {
        "file": "9-Table5-1.png",
        "caption": "Table 5: F1 scores on out of domain data. Best scores are shown with bold."
      },
      {
        "file": "10-Figure5-1.png",
        "caption": "Figure 5: F1 scores for best-char (best of the CLMs) and model with predicted (predictedmorph) and gold morphological tags (goldmorph)."
      }
    ]
  },
  "1909.09070": {
    "title": "Look, Read and Enrich - Learning from Scientific Figures and their Captions",
    "abstract": "Compared to natural images, understanding scientific figures is particularly hard for machines. However, there is a valuable source of information in scientific literature that until now has remained untapped: the correspondence between a figure and its caption. In this paper we investigate what can be learnt by looking at a large number of figures and reading their captions, and introduce a figure-caption correspondence learning task that makes use of our observations. Training visual and language networks without supervision other than pairs of unconstrained figures and captions is shown to successfully solve this task. We also show that transferring lexical and semantic knowledge from a knowledge graph significantly enriches the resulting features. Finally, we demonstrate the positive impact of such features in other tasks involving scientific text and figures, like multi-modal classification and machine comprehension for question answering, outperforming supervised baselines and ad-hoc approaches.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Scientific knowledge is heterogeneous and can present itself in many forms, including text, mathematical equations, figures and tables. Like many other manifestations of human thought, the scientific discourse usually adopts the form of a narrative, a scientific publication where related knowledge is presented in mutually supportive ways over different modalities. In the case of scientific figures, like charts, images and diagrams, these are usually accompanied by a text paragraph, a caption, that elaborates on the analysis otherwise visually represented.",
          "In this paper, we make use of this observation and tap on the potential of learning from the enormous source of free supervision available in the scientific literature, with millions of figures and their captions. We build models that learn from the scientific discourse both visually and textually by simply looking at the figures and reading their explanatory captions, inspired in how humans learn by reading a scientific publication. To this purpose, we explore how multi-modal scientific knowledge can be learnt from the correspondence between figures and captions.",
          "The main contributions of this paper are the following:",
          "An unsupervised Figure-Caption Correspondence task (FCC) that jointly learns text and visual features useful to address a range of tasks involving scientific text and figures.",
          "A method to enrich such features with semantic knowledge transferred from structured knowledge graphs (KG).",
          "A study of the complexity of figure-caption correspondence compared to classical image-sentence matching.",
          "A qualitative and quantitative analysis of the learnt text and visual features through transfer learning tasks.",
          "A corpus of scientific figures and captions extracted from SN SciGraph and AI2 Semantic Scholar.",
          "We present the FCC task in section SECREF3, including the network architecture, training protocol, and how adding pre-trained word and semantic embeddings can enrich the resulting text and visual features. In section SECREF4, we first introduce our datasets and evaluate the performance of our method in the task it was trained to solve, the correspondence between scientific figures and captions. Then, we relate our work to the state of the art in image-sentence matching and evaluate our approach in two challenging transfer learning tasks: caption and figure classification and multi-modal machine comprehension. In section SECREF5 we perform a qualitative study that illustrates how the FCC task leads to detailed textual and visual discrimination. Finally, in section SECREF6 we conclude the paper and advance future work."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Understanding natural images has been a major area of research in computer vision, with well established datasets like ImageNet BIBREF0, Flickr8K BIBREF1, Flickr30K BIBREF2 and COCO BIBREF3. However, reasoning with other visual representations like scientific figures and diagrams has not received the same attention yet and entails additional challenges: Scientific figures are more abstract and symbolic, their captions tend to be significantly longer and use specialized lexicon, and the relation between a scientific figure and its caption is unique, i.e. in a scientific publication there is only one caption that corresponds with one figure and vice versa.",
          "The FCC task presented herein is a form of co-training BIBREF4 where there are two views of the data and each view provides complementary information. Similar two-branch neural architectures focus on image-sentence BIBREF5, BIBREF6 and audio-video BIBREF7 matching. Others like BIBREF8 learn common embeddings from images and text. However, in such cases one or both networks are typically pre-trained.",
          "Focused on geometry, BIBREF9 maximize the agreement between text and visual data. In BIBREF10, the authors apply machine vision and natural language processing to extract data from figures and their associated text in bio-curation tasks. In BIBREF11, they parse diagram components and connectors as a Diagram Parse Graph (DPG), semantically interpret the DPG and use the model to answer diagram questions. While we rely on the correspondence between figures and captions, they train a specific classifier for each component and connector type and yet another model to ground the semantics of the DPG in each domain, like food webs or water cycles.",
          "Knowledge fusion approaches like BIBREF12 investigate the potential of complementing KG embeddings with text and natural images by integrating information across the three modalities in a single latent representation. They assume pre-trained entity representations exist in each individual modality, e.g. the visual features encoding the image of a ball, the word embeddings associated to the token \"ball\", and the KG embeddings related to the ball entity, which are then stitched together. In contrast, FCC co-trains text and visual features from figures and their captions and supports the enrichment of such features with lexical and semantic knowledge transferred from a KG during the training of the FCC task."
        ]
      },
      {
        "section_name": "Figure-Caption Correspondence",
        "paragraphs": [
          "The main idea of our approach is to learn a correspondence task between scientific figures and their captions as they appear in a scientific publication. The information captured in the caption explains the corresponding figure in natural language, providing guidance to identify the key features of the figure and vice versa. By seeing a figure and reading the textual description in its caption we ultimately aim to learn representations that capture e.g. what it means that two plots are similar or what gravity looks like.",
          "We leverage this observation to learn a figure-caption correspondence task. In essence, FCC is a binary classification task that receives a figure and a caption and determines whether they correspond or not. For training, the positive pairs are actual figures and their captions from a collection of scientific publications. Negative pairs are extracted from combinations of figures and any other randomly selected captions. The network is then made to learn text and visual features from scratch, without additional labelled data."
        ]
      },
      {
        "section_name": "Figure-Caption Correspondence ::: FCC Architecture and Model",
        "paragraphs": [
          "We propose a 2-branch neural architecture (figure FIGREF7) that has three main parts: the vision and language subnetworks, respectively extracting visual and text features, and a fusion subnetwork that takes the resulting features from the visual and text blocks and uses them to evaluate figure-caption correspondence.",
          "The vision subnetwork follows a VGG-style BIBREF13 design, with 3x3 convolutional filters, 2x2 max-pooling layers with stride 2 and no padding. It contains 4 blocks of conv+conv+pool layers, where inside each block the two convolutional layers have the same number of filters, while consecutive blocks have doubling number of filters (64, 128, 256, 512). The input layer receives 224x224x3 images. The final layer produces a 512-D vector after 28x28 max-pooling. Each convolutional layer is followed by batch normalization BIBREF14 and ReLU layers. Based on BIBREF15, the language subnetwork has 3 convolutional blocks, each with 512 filters and a 5-element window size with ReLU activation. Each convolutional layer is followed by a 5-max pooling layer, except for the final layer, which produces a 512-D vector after 35-max pooling. The language subnetwork has a 300-D embeddings layer at the input, with a maximum sequence length of 1,000 tokens. The fusion subnetwork calculates the element-wise product of the 512-D visual and text feature vectors into a single vector $r$ to produce a 2-way classification output (correspond or not). It has two fully connected layers, with ReLU and an intermediate feature size of 128-D. The probability of each choice is the softmax of $r$, i.e. $\\hat{y} = softmax(r) \\in \\mathbb {R}^{2}$. During training, we minimize the negative log probability of the correct choice.",
          "This architecture enables the FCC task to learn visual and text features from scratch in a completely unsupervised manner, just by observing the correspondence of figures and captions. Next, we extend it to enable the transfer of additional pre-trained information. Here, we focus on adding pre-trained embeddings on the language branch, and then back-propagate to the visual features during FCC training. Adding pre-trained visual features is also possible and indeed we also evaluate its impact in the FCC task in section SECREF14.",
          "Let $V$ be a vocabulary of words from a collection of documents $D$. Also, let $L$ be their lemmas, i.e. base forms without morphological or conjugational variations, and $C$ the concepts (or senses) in a KG. Each word $w_k$ in $V$, e.g. made, has one lemma $l_k$ (make) and may be linked to one or more concepts $c_k$ in $C$ (create or produce something).",
          "For each word $w_k$, the FCC task learns a d-D embedding $\\vec{w}_k$, which can be combined with pre-trained word ($\\vec{w^{\\prime }}_k$), lemma ($\\vec{l}_k$) and concept ($\\vec{c}_k$) embeddings to produce a single vector $\\vec{t}_k$. If no pre-trained knowledge is transferred from an external source, then $\\vec{t}_k=\\vec{w}_k$. Note that we previously lemmatize and disambiguate $D$ against the KG in order to select the right pre-trained lemma and concept embeddings for each particular occurrence of $w_k$. Equation DISPLAY_FORM8 shows the different combinations of learnt and pre-trained embeddings we consider: (a) learnt word embeddings only, (b) learnt and pre-trained word embeddings and (c) learnt word embeddings and pre-trained semantic embeddings, including both lemmas and concepts, in line with our recent findings presented in BIBREF16.",
          "In our experiments, concatenation proved optimal to combine the embeddings learnt by the network and the pre-trained embeddings, compared to other methods like summation, multiplication, average or learning a task-specific weighting of the different representations as in BIBREF17. Since some words may not have associated pre-trained word, lemma or concept embeddings, we pad these sequences with $\\varnothing _W$, $\\varnothing _L$ and $\\varnothing _C$, which are never included in the vocabulary. The dimensionality of $\\vec{t}_k$ is fixed to 300, i.e. the size of each sub-vector in configurations $(a)$, $(b)$ and $(c)$ is 300, 150 and 100, respectively. In doing so, we aimed at limiting the number of trainable parameters and balance the contribution of each information source.",
          "In its most basic form, i.e. configuration $(a)$, the FCC network has over 32M trainable parameters (28M in the language subnetwork, 4M in the vision subnetwork and 135K in the fusion subnetwork) and takes 12 hours to train on a single GPU Nvidia GeForce RTX 2080 Ti for a relatively small corpus (SN SciGraph, see section SECREF12). We used 10-fold cross validation, Adam optimization BIBREF18 with learning rate $10^{-4}$ and weight decay $10^{-5}$. The network was implemented in Keras and TensorFlow, with batch size 32. The number of positive and negative cases is balanced within the batches."
        ]
      },
      {
        "section_name": "Figure-Caption Correspondence ::: Semantic Embeddings",
        "paragraphs": [
          "We use HolE BIBREF19 and Vecsigrafo BIBREF16 to learn semantic embeddings. The latter extends the Swivel algorithm BIBREF20 to jointly learn word, lemma and concept embeddings on a corpus disambiguated against the KG, outperforming the previous state of the art in word and word-sense embeddings by co-training word, lemma and concept embeddings as opposed to training each individually. In contrast to Vecsigrafo, which requires both a text corpus and a KG, HolE follows a graph-based approach where embeddings are learnt exclusively from the KG. As section SECREF14 will show, this gives Vecsigrafo a certain advantage in the FCC task. Following up with the work presented in BIBREF16, our experiments focus on Sensigrafo, the KG underlying Expert System's Cogito NLP proprietary platform. Similar to WordNet, on which Vecsigrafo has also been successfully trained, Sensigrafo is a general-purpose KG with lexical and semantic information that contains over 300K concepts, 400K lemmas and 80 types of relations rendering 3M links. We use Cogito to disambiguate the text corpora prior to training Vecsigrafo. All the semantic (lemma and concept) embeddings produced with HolE or Vecsigrafo are 100-D."
        ]
      },
      {
        "section_name": "Results and Discussion",
        "paragraphs": [
          "In this section, first we evaluate the actual FCC task against two supervised baselines. Then, we situate our work in the more general image-sentence matching problem, showing empirical evidence of the additional complexity associated to the scientific domain and the figure-caption case compared to natural images. Next, we test the visual and text features learnt in the FCC task in two different transfer learning settings: classification of scientific figures and captions and multi-modal machine comprehension for question answering given a context of text, figures and images."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Datasets",
        "paragraphs": [
          "We have used the following datasets for training and evaluation:",
          "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.",
          "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).",
          "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.",
          "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.",
          "Flickr30K and COCO, as image-sentence matching benchmarks."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Figure-Caption Correspondence",
        "paragraphs": [
          "We evaluate our method in the task it was trained to solve: determining whether a figure and a caption correspond. We also compare the performance of the FCC task against two supervised baselines, training them on a classification task against the SciGraph taxonomy. For such baselines we first train the vision and language networks independently and then combine them. The feature extraction parts of both networks are the same as described in section SECREF6. On top of them, we attach a fully connected layer with 128 neurons and ReLU activation and a softmax layer, with as many neurons as target classes.",
          "The direct combination baseline computes the figure-caption correspondence through the scalar product between the softmax outputs of both networks. If it exceeds a threshold, which we heuristically fixed on 0.325, the result is positive. The supervised pre-training baseline freezes the weights of the feature extraction trunks from the two trained networks, assembles them in the FCC architecture as shown in section SECREF6, and trains the FCC task on the fully connected layers. While direct combination provides a notion of the agreement between the two branches, supervised pre-training is the most similar supervised approach to our method.",
          "Table TABREF15 shows the results of the FCC task and the supervised baselines. $FCC_k$ denotes the corpus and word representation used to train the FCC task. Acc$_{vgg}$ shows the accuracy after replacing our visual branch with pre-trained VGG16 features learnt on ImageNet. This provides an estimate of how specific of the scientific domain scientific figures and therefore the resulting visual features can be, compared to natural images. As the table shows, the results obtained using pre-trained visual features are clearly worse in general (only slightly better in $FCC_3$), suggesting that the visual information contained in scientific figures indeed differs from natural images.",
          "We trained the FCC network on two different scientific corpora: SciGraph ($FCC_{1-5}$) and SemScholar ($FCC_{6-7}$). Both $FCC_1$ and $FCC_6$ learnt their own word representations without transfer of any pre-trained knowledge. Even in its most basic form our approach substantially improves over the supervised baselines, confirming that the visual and language branches learn from each other and also that figure-caption correspondence is an effective source of free supervision.",
          "Adding pre-trained knowledge at the input layer of the language subnetwork provides an additional boost, particularly with lemma and concept embeddings from Vecsigrafo ($FCC_5$). Vecsigrafo clearly outperformed HolE ($FCC_3$), which was also beaten by pre-trained fastText BIBREF24 word embeddings ($FCC_2$) trained on SemScholar.",
          "Since graph-based KG embedding approaches like HolE only generate embeddings of the artifacts explicitly contained in the KG, this may indicate that Sensigrafo, the KG used in this task, provides a partial coverage of the scientific domain, as could be expected since we are using an off-the-shelf version. Deeper inspection shows that HolE only covers 20% of the lemmas in the SciGraph vocabulary. On the other hand, Vecsigrafo, trained on the same KG, also captures lexical information from the text corpora it is trained on, Wikipedia or SemScholar, raising lemma coverage to 42% and 47%, respectively.",
          "Although the size of Wikipedia is almost triple of our SemScholar corpus, training Vecsigrafo on the latter resulted in better FCC accuracy ($FCC_4$ vs. $FCC_5$), suggesting that domain relevance is more significant than sheer volume, in line with our previous findings in BIBREF25. Training FCC on SemScholar, much larger than SciGraph, further improves accuracy, as shown in $FCC_6$ and $FCC_7$."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Image-Sentence Matching",
        "paragraphs": [
          "We put our FCC task in the context of the more general problem of image-sentence matching through a bidirectional retrieval task where images are sought given a text query and vice versa. While table TABREF20 focuses on natural images datasets (Flickr30K and COCO), table TABREF21 shows results on scientific datasets (SciGraph and SemScholar) rich in scientific figures and diagrams. The selected baselines (Embedding network, 2WayNet, VSE++ and DSVE-loc) report results obtained on the Flickr30K and COCO datasets, which we also include in table TABREF20. Performance is measured in recall at k ($Rk$), with k={1,5,10}. From the baselines, we successfully reproduced DSVE-loc, using the code made available by the authors, and trained it on SciGraph and SemScholar.",
          "We trained the FCC task on all the datasets, both in a totally unsupervised way and with pre-trained semantic embeddings (indicated with subscript $vec$), and executed the bidirectional retrieval task using the resulting text and visual features. We also experimented with pre-trained VGG16 visual features extracted from ImageNet (subscript $vgg$), with more than 14 million hand-annotated images. Following common practice in image-sentence matching, our splits are 1,000 samples for test and the rest for training.",
          "We can see a marked division between the results obtained on natural images datasets (table TABREF20) and those focused on scientific figures (table TABREF21). In the former case, VSE++ and DSVE-loc clearly beat all the other approaches. In contrast, our model performs poorly on such datasets although results are ameliorated when we use pre-trained visual features from ImageNet (\"Oursvgg\" and \"Oursvgg-vec\"). Interestingly, the situation reverts with the scientific datasets. While the recall of DSVE-loc drops dramatically in SciGraph, and even more in SemScholar, our approach shows the opposite behavior in both figure and caption retrieval. Using visual features enriched with pre-trained semantic embeddings from Vecsigrafo during training of the FCC task further improves recall in the bidirectional retrieval task. Compared to natural images, the additional complexity of scientific figures and their caption texts, which in addition are considerably longer (see table TABREF19), seems to have a clear impact in this regard.",
          "Unlike in Flickr30K and COCO, replacing the FCC visual features with pre-trained ones from ImageNet brings us little benefit in SciGraph and even less in SemScholar, where the combination of FCC and Vecsigrafo (\"Oursvec\") obtains the best results across the board. This and the extremely poor performance of the best image-sentence matching baseline (DSVE-loc) in the scientific datasets shows evidence that dealing with scientific figures is considerably more complex than natural images. Indeed, the best results in figure-caption correspondence (\"Oursvec\" in SemScholar) are still far from the SoA in image-sentence matching (DSVE-loc in COCO)."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Caption and Figure Classification",
        "paragraphs": [
          "We evaluate the language and visual representations emerging from FCC in the context of two classification tasks that aim to identify the scientific field an arbitrary text fragment (a caption) or a figure belong to, according to the SciGraph taxonomy. The latter is a particularly hard task due to the whimsical nature of the figures that appear in our corpus: figure and diagram layout is arbitrary; charts, e.g. bar and pie charts, are used to showcase data in any field from health to engineering; figures and natural images appear indistinctly, etc. Also, note that we only rely on the actual figure, not the text fragment where it is mentioned in the paper.",
          "We pick the text and visual features that produced the best FCC results with and without pre-trained semantic embeddings (table TABREF15, $FCC_7$ and $FCC_6$, respectively) and use the language and vision subnetworks presented in section SECREF6 to train our classifiers on SciGraph in two different scenarios. First, we only fine tune the fully connected and softmax layers, freezing the text and visual weights (non-trainable in the table). Second, we fine tune all the parameters in both networks (trainable). In both cases, we compare against a baseline using the same networks initialized with random weights, without FCC training. In doing so, through the first, non-trainable scenario, we seek to quantify the information contributed by the FCC features, while training from scratch on the target corpus should provide an upper bound for figure and caption classification. Additionally, for figure classification, we select a baseline of frozen VGG16 weights trained on ImageNet. We train using 10-fold cross validation and Adam. For the caption classification task, we select learning rate $10^{-3}$ and batch size 128. In figure classification, we use learning rate $10^{-4}$, weight decay $10^{-5}$ and batch size 32.",
          "The results in table TABREF23 show that our approach amply beats the baselines, including the upper bound (training from scratch on SciGraph). The delta is particularly noticeable in the non trainable case for both caption and figure classification and is considerably increased in \"Ours $FCC_7$\", which uses pre-trained semantic embeddings. This includes both the random and VGG baselines and illustrates again the additional complexity of analyzing scientific figures compared to natural images, even if the latter is trained on a considerably larger corpus like ImageNet. Fine tuning the whole networks on SciGraph further improves accuracies. In this case, \"Ours $FCC_6$\", which uses FCC features without additional pre-trained embeddings, slightly outperforms \"Ours $FCC_7$\", suggesting a larger margin to learn from the task-specific corpus. Note that both $FCC_6$ and $FCC_7$ were trained on SemScholar."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Textbook Question Answering (TQA) for Multi-Modal Machine Comprehension",
        "paragraphs": [
          "We leverage the TQA dataset and the baselines in BIBREF23 to evaluate the features learnt by the FCC task in a multi-modal machine comprehension scenario. We study how our model, which was not originally trained for this task, performs against state of the art models specifically trained for diagram question answering and textual reading comprehension in a very challenging dataset. We also study how pre-trained semantic embeddings impact in the TQA task: first, by enriching the visual features learnt in the FCC task as shown in section SECREF6 and then by using pre-trained semantic embeddings to enrich word representations in the TQA corpus.",
          "We focus on multiple-choice questions, 73% of the dataset. Table TABREF24 shows the performance of our model against the results reported in BIBREF23 for five TQA baselines: random, BiDAF (focused on text machine comprehension), text only ($TQA_1$, based on MemoryNet), text+image ($TQA_2$, VQA), and text+diagrams ($TQA_3$, DSDP-NET). We successfully reproduced the $TQA_1$ and $TQA_2$ architectures and adapted the latter. Then, we replaced the visual features in $TQA_2$ with those learnt by the FCC visual subnetwork both in a completely unsupervised way ($FCC_6$ in table TABREF15) and with pre-trained semantic embeddings ($FCC_7$), resulting in $TQA_4$ and $TQA_5$, respectively.",
          "While $TQA_{1-5}$ used no pre-trained embeddings at all, $TQA_{6-10}$ were trained including pre-trained Vecsigrafo semantic embeddings. Unlike FCC, where we used concatenation to combine pre-trained lemma and concept embeddings with the word embeddings learnt by the task, element-wise addition worked best in the case of TQA.",
          "Following the recommendations in BIBREF23, we pre-processed the TQA corpus to i) consider knowledge from previous lessons in the textbook in addition to the lesson of the question at hand and ii) address challenges like long question contexts with a large lexicon. In both text and diagram MC, applying the Pareto principle to reduce the maximum token sequence length in the text of each question, their answers and context improved accuracy considerably. This optimization allowed reducing the amount of text to consider for each question, improving the signal to noise ratio. Finally, we obtained the most relevant paragraphs for each question through tf-idf and trained the models using 10-fold cross validation, Adam, learning rate $10^{-2}$ and batch size 128. In text MC we also used 0.5 dropout and recurrent dropout in the LSTM layers.",
          "Fitting multi-modal sources into a single memory, the use of visual FCC features clearly outperforms all the TQA baselines in diagram MC. Enhancing word representation with pre-trained semantic embeddings during training of the TQA task provides an additional boost that results in the highest accuracies for both text MC and diagram MC. These are significantly good results since, according to the TQA authors BIBREF23, most diagram questions in the TQA corpus would normally require a specific rich diagram parse, which we did not aim to provide."
        ]
      },
      {
        "section_name": "Qualitative Analysis",
        "paragraphs": [
          "We inspect the features learnt by our FCC task to gain a deeper understanding of the syntactic and semantic patterns captured for figure and caption representation. The findings reported herein are qualitatively consistent for all the FCC variations in table TABREF15.",
          "Vision features. The analysis was carried out on an unconstrained variety of charts, diagrams and natural images from SciGraph, without filtering by figure type or scientific field. To obtain a representative sample of what the FCC network learns, we focus on the 512-D vector resulting from the last convolutional block before the fusion subnetwork. We pick the features with the most significant activation over the whole dataset and select the figures that activate them most. To this purpose, we prioritize those with higher maximum activation against the average activation.",
          "Figure FIGREF27 shows a selection of 6 visual features with the 4 figures that activate each feature more significantly and their activation heatmaps. Only figures are used as input, no text. As can be seen, the vision subnetwork has automatically learnt, without explicit supervision, to recognize different types of diagrams, charts and content, such as (from left to right) whisker plots, western blots (a technique used to identify proteins in a tissue sample), multi-image comparison diagrams, multi-modal data visualization charts (e.g. western plots vs. bar charts), line plots, and text within the figures. Furthermore, as shown by the heatmaps, our model discriminates the key elements associated to the figures that most activate each feature: the actual whiskers, the blots, the borders of each image under comparison, the blots and their complementary bar charts, as well as the line plots and the correspondence between them and the values in the x and y axes. Also, see (right-most column) how a feature discriminates text inserted in the figure, regardless of the remaining elements that may appear and the connections between them. This shows evidence of how the visual features learnt by the FCC task support the parsing of complex scientific diagrams.",
          "We also estimated a notion of semantic specificity based on the concepts of a KG. For each visual feature, we aggregated the captions of the figures that most activate it and used Cogito to disambiguate the Sensigrafo concepts that appear in them. Then, we estimated how important each concept is to each feature by calculating its tf-idf. Finally, we averaged the resulting values to obtain a consolidated semantic specificity score per feature.",
          "The scores of the features in figure FIGREF27 range between 0.42 and 0.65, which is consistently higher than average (0.4). This seems to indicate a correlation between activation and the semantic specificity of each visual feature. For example, the heatmaps of the figures related to the feature with the lowest tf-idf (left-most column) highlights a particular visual pattern, i.e. the whiskers, that may spread over many, possibly unrelated domains. On the other hand, the feature with the highest score (second column) focuses on a type of diagrams, western blots, almost exclusive of protein and genetic studies. Others, like the feature illustrated by the figures in the fifth column, capture the semantics of a specific type of 2D charts relating two magnitudes x and y. Analyzing their captions with Cogito, we see that concepts like e.g. isochronal and exponential functions are mentioned. If we look at the second and four top-most figures in the column, we can see that such concepts are also visually depicted in the figures, suggesting that the FCC task has learnt to recognize them both from the text and visually.",
          "Text features. Similar to the visual case, we selected the features from the last block of the language subnetwork with the highest activation. For visualization purposes, we picked the figures corresponding to the captions in SciGraph that most activate such features (figure FIGREF28). No visual information is used.",
          "Several distinct patterns emerge from the text. The text feature in the first column seems to focus on genetics and histochemistry, including terms like western blots or immunostaining and variations like immunoblot-s/ted/ting. Interestingly, it also seems to have learnt some type of is-a relations (western blot is a type of immunoblot). The second feature focuses on variations of the term radiograph, e.g. radiograph-y/s. The third feature specializes in text related to curve plots involving several statistic analysis, e.g. Real-time PCR, one-way ANOVA or Gaussian distribution. Sometimes (fourth figure from top) the caption does not mention the plot directly, but focuses on the analysis instead, e.g. \"the data presented here are mean values of duplicate experiments\", indicating transfer of knowledge from the visual part during training. The fourth feature extracts citations and models named after prominent scientists, e.g. Evans function (first and fourth figure), Manley (1992) (second), and Aliev-Panfilov model (third). The fifth feature extracts chromatography terminology, e.g. 3D surface plot, photomicrograph or color map and, finally, the right-most feature focuses on different types of named diagrams, like flow charts and state diagrams, e.g. phylogenetic trees.",
          "All the captions show a strong semantic correspondence with their associated figures. Figure FIGREF29 shows the activation heatmaps for two sample captions, calculated on the embeddings layer of the language subnetwork. The upper one corresponds to the fourth column left-right and third figure top-down in figure FIGREF28. Its caption reads: \"The Aliev-Panfilov model with $\\alpha =0.01$...The phase portrait depicts trajectories for distinct initial values $\\varphi _0$ and $r_0$...\". Below, (first column, fourth figure in figure FIGREF28): \"Relative protein levels of ubiquitin-protein conjugates in M. quadriceps...A representative immunoblot specific to ubiquitin...\". Consistently with our analysis, activation focuses on the most relevant tokens for each text feature: \"Aliev-Panfilov model\" and \"immunoblot\", respectively."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "There is a wealth of knowledge in scientific literature and only a fraction of it is text. However, understanding scientific figures is a challenging task for machines, which is beyond their ability to process natural images. In this paper, we provide empirical evidence of this and show that co-training text and visual features from a large corpus of scientific figures and their captions in a correspondence task (FCC) is an effective, flexible and elegant unsupervised means towards overcoming such complexity. We show how such features can be significantly improved by enriching them with additional knowledge sources and, particularly, structured KGs. We prove the benefits of our approach against supervised baselines and in different transfer learning tasks, including text and visual classification and multi-modal machine comprehension applied to question answering, with results generally beyond the state of the art. In the future, it will be interesting to further the study of the interplay between the semantic concepts explicitly represented in different KGs, contextualized embeddings e.g. from SciBERT BIBREF31, and the text and visual features learnt in the FCC task. We also plan to continue to charter the knowledge captured in such features and to pursue the optimization and practical application of our approach."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "The research reported in this paper is supported by the EU Horizon 2020 programme, under grants European Language Grid-825627 and Co-inform-770302."
        ]
      }
    ],
    "qas": [
      {
        "question": "What datasets are used in this paper?",
        "question_id": "b8a3ab219be6c1e6893fe80e1fbf14f0c0c3c97c",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The Semantic Scholar corpus ",
                "Springer Nature's SciGraph",
                "The Textbook Question Answering corpus",
                "Wikipedia",
                "Flickr30K and COCO"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Results and Discussion ::: Datasets",
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ],
              "highlighted_evidence": [
                "Results and Discussion ::: Datasets",
                "We have used the following datasets for training and evaluation:\n\nThe Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.\n\nSpringer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).\n\nThe Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.\n\nWikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.\n\nFlickr30K and COCO, as image-sentence matching benchmarks."
              ]
            },
            "annotation_id": "22a3e7b8380676e7cacd99c88b376a67ac80eb6a",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The Semantic Scholar corpus",
                "Springer Nature's SciGraph",
                "The Textbook Question Answering corpus",
                "January 2018 English Wikipedia dataset",
                "Flickr30K",
                "COCO"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ],
              "highlighted_evidence": [
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories.",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula.",
                "We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ]
            },
            "annotation_id": "7cc48ed9d2382421618d54f6af51d08ee0d3afcc",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The Semantic Scholar corpus",
                "Springer Nature's SciGraph",
                "The Textbook Question Answering corpus",
                "Wikipedia",
                "Flickr30K",
                "COCO"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ],
              "highlighted_evidence": [
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories.",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. ",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ]
            },
            "annotation_id": "8dff34b25becb8fdfe34f05f0951c6852caeba0e",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Semantic Scholar corpus BIBREF21 (SemScholar)",
                "Springer Nature's SciGraph",
                "Textbook Question Answering corpus BIBREF23",
                "Wikipedia",
                "Flickr30K",
                "COCO"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We have used the following datasets for training and evaluation:",
                "The Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2. From its 39M articles, we downloaded 3,3M PDFs (the rest were behind paywalls, did not have a link or it was broken) and extracted 12.5M figures and captions through PDFFigures2 BIBREF22. We randomly selected 500K papers to train the FCC task on their figures and captions and another 500K to train Vecsigrafo on the text of their titles and abstracts.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories. Since SciGraph does not provide a link to the PDF of the publication, we selected the intersection with SemScholar, producing a smaller corpus of 80K papers (in addition to the 1M papers from SemScholar mentioned above) and 82K figures that we used for training certain FCC configurations and supervised baselines (section SECREF14).",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula. Its complexity and scope make it a challenging textual and visual question answering dataset.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo. As opposed to SciGraph or SemScholar, specific of the scientific domain, Wikipedia is a source of general-purpose information.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ],
              "highlighted_evidence": [
                "We have used the following datasets for training and evaluation:\n\nThe Semantic Scholar corpus BIBREF21 (SemScholar) is a large dataset of scientific publications made available by AI2.",
                "Springer Nature's SciGraph contains 7M scientific publications organized in 22 scientific fields or categories.",
                "The Textbook Question Answering corpus BIBREF23 includes 1,076 lessons and 26,260 multi-modal test questions from middle school science curricula.",
                "Wikipedia. We used the January 2018 English Wikipedia dataset as one of the corpora on which to train Vecsigrafo.",
                "Flickr30K and COCO, as image-sentence matching benchmarks."
              ]
            },
            "annotation_id": "a8aeaf521629afc2a2572eb48f67ddcc429899c6",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Proposed 2-branch architecture of the FCC task."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: FCC and supervised baselines results (% accuracy)."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Caption length: natural images vs scientific datasets."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Bidirectional retrieval. FCC vs. image-sentence matching baselines (%recall@k). Natural images datasets."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Bidirectional retrieval. FCC vs. image-sentence matching baselines (%recall@k). Scientific datasets."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: Caption and figure classification (%accuracy)"
      },
      {
        "file": "7-Table6-1.png",
        "caption": "Table 6: TQA results (% accuracy). FCC vs. random, BiDAF, MemoryNet, VQA and DSDP-NET baselines."
      },
      {
        "file": "8-Figure2-1.png",
        "caption": "Figure 2: Selected visual features and activation heatmaps. The top row labels the dominant pattern for each feature."
      },
      {
        "file": "9-Figure3-1.png",
        "caption": "Figure 3: Selected text features. Top row labels the dominant pattern for each text feature."
      },
      {
        "file": "10-Figure4-1.png",
        "caption": "Figure 4: Sample caption activation heatmaps. Darker means higher activation."
      }
    ]
  },
  "1708.05521": {
    "title": "EmoAtt at EmoInt-2017: Inner attention sentence embedding for Emotion Intensity",
    "abstract": "In this paper we describe a deep learning system that has been designed and built for the WASSA 2017 Emotion Intensity Shared Task. We introduce a representation learning approach based on inner attention on top of an RNN. Results show that our model offers good capabilities and is able to successfully identify emotion-bearing words to predict intensity without leveraging on lexicons, obtaining the 13th place among 22 shared task competitors.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Twitter is a huge micro-blogging service with more than 500 million tweets per day from different locations in the world and in different languages. This large, continuous, and dynamically updated content is considered a valuable resource for researchers. In particular, many of these messages contain emotional charge, conveying affect\u2014emotions, feelings and attitudes, which can be studied to understand the expression of emotion in text, as well as the social phenomena associated.",
          "While studying emotion in text it is commonly useful to characterize the emotional charge of a passage based on its words. Some words have affect as a core part of their meaning. For example, dejected and wistful denote some amount of sadness, and are thus associated with sadness. On the other hand, some words are associated with affect even though they do not denote affect. For example, failure and death describe concepts that are usually accompanied by sadness and thus they denote some amount of sadness.",
          "While analyzing the emotional content in text, mosts tasks are almost always framed as classification tasks, where the intention is to identify one emotion among many for a sentence or passage. However, it is often useful for applications to know the degree to which an emotion is expressed in text. To this end, the WASSA-2017 Shared Task on Emotion Intensity BIBREF0 represents the first task where systems have to automatically determine the intensity of emotions in tweets. Concretely, the objective is to given a tweet containing the emotion of joy, sadness, fear or anger, determine the intensity or degree of the emotion felt by the speaker as a real-valued score between zero and one.",
          "The task is specially challenging since tweets contain informal language, spelling errors and text referring to external content. Given the 140 character limit of tweets, it is also possible to find some phenomena such as the intensive usage of emoticons and of other special Twitter features, such as hashtags and usernames mentions \u2014used to call or notify other users. In this paper we describe our system designed for the WASSA-2017 Shared Task on Emotion Intensity, which we tackle based on the premise of representation learning without the usage of external information, such as lexicons. In particular, we use a Bi-LSTM model with intra-sentence attention on top of word embeddings to generate a tweet representation that is suitable for emotion intensity. Our results show that our proposed model offers interesting capabilities compared to approaches that do rely on external information sources."
        ]
      },
      {
        "section_name": "Proposed Approach",
        "paragraphs": [
          "Our work is related to deep learning techniques for emotion recognition in images BIBREF1 and videos BIBREF2 , as well as and emotion classification BIBREF3 . Our work is also related to liuattention-based2016, who introduced an attention RNN for slot filling in Natural Language Understanding. Since in the task the input-output alignment is explicit, they investigated how the alignment can be best utilized in encoder-decoder models concluding that the attention mechanisms are helpful.",
          "EmoAtt is based on a bidirectional RNN that receives an embedded input sequence INLINEFORM0 and returns a list of hidden vectors that capture the context each input token INLINEFORM1 . To improve the capabilities of the RNN to capture short-term temporal dependencies BIBREF4 , we define the following: DISPLAYFORM0 ",
          "Where INLINEFORM0 can be regarded as a context window of ordered word embedding vectors around position INLINEFORM1 , with a total size of INLINEFORM2 . To further complement the context-aware token representations, we concatenate each hidden vector to a vector of binary features INLINEFORM3 , extracted from each tweet token, defining an augmented hidden state INLINEFORM4 . Finally, we combine our INLINEFORM5 augmented hidden states, compressing them into a single vector, using a global intra-sentence attentional component in a fashion similar to vinyalsgrammar2015. Formally, DISPLAYFORM0 ",
          "Where INLINEFORM0 is the vector that compresses the input sentence INLINEFORM1 , focusing on the relevant parts to estimate emotion intensity. We input this compressed sentence representation into a feed-forward neural network, INLINEFORM2 , where INLINEFORM3 is the final predicted emotion intensity. As a loss function we use the mini-batch negative Pearson correlation with the gold-standard."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "To test our model, we experiment using the training, validation and test datasets provided for the shared task BIBREF5 , which include tweets for four emotions: joy, sadness, fear, and anger. These were annotated using Best-Worst Scaling (BWS) to obtain very reliable scores BIBREF6 .",
          "We experimented with GloVe BIBREF7 as pre-trained word embedding vectors, for sizes 25, 50 and 100. These are vectors trained on a dataset of 2B tweets, with a total vocabulary of 1.2 M. To pre-process the data, we used Twokenizer BIBREF8 , which basically provides a set of curated rules to split the tweets into tokens. We also use Tweeboparser BIBREF9 to get the POS-tags for each tweet.",
          "Table TABREF3 summarizes the average, maximum and minimum sentence lengths for each dataset after we processed them with Twokenizer. We can see the four corpora offer similar characteristics in terms of length, with a cross dataset maximum length of 41 tokens. We also see there is an important vocabulary gap between the dataset and GloVe, with an average coverage of only 64.3 %. To tackle this issue, we used a set of binary features derived from POS tags to capture some of the semantics of the words that are not covered by the GloVe embeddings. We also include features for member mentions and hashtags as well as a feature to capture word elongation, based on regular expressions. Word elongation is very common in tweets, and is usually associated to strong sentiment. The following are the POS tag-derived rules we used to generate our binary features.",
          "While the structure of our introduced model allows us to easily include more linguistic features that could potentially improve our predictive power, such as lexicons, since our focus is to study sentence representation for emotion intensity, we do not experiment adding any additional sources of information as input.",
          "In this paper we also only report results for LSTMs, which outperformed regular RNNs as well as GRUs and a batch normalized version of the LSTM in on preliminary experiments. The hidden size of the attentional component is set to match the size of the augmented hidden vectors on each case. Given this setting, we explored different hyper-parameter configurations, including context window sizes of 1, 3 and 5 as well as RNN hidden state sizes of 100, 200 and 300. We experimented with unidirectional and bidirectional versions of the RNNs.",
          "To avoid over-fitting, we used dropout regularization, experimenting with keep probabilities of INLINEFORM0 and INLINEFORM1 . We also added a weighed L2 regularization term to our loss function. We experimented with different values for weight INLINEFORM2 , with a minimum value of 0.01 and a maximum of 0.2.",
          "To evaluate our model, we wrapped the provided scripts for the shared task and calculated the Pearson correlation coefficient and the Spearman rank coefficient with the gold standard in the validation set, as well as the same values over a subset of the same data formed by taking every instance with a gold emotion intensity score greater than or equal to 0.5.",
          "For training, we used mini-batch stochastic gradient descent with a batch size of 16 and padded sequences to a maximum size of 50 tokens, given the nature of the data. We used exponential decay of ratio INLINEFORM0 and early stopping on the validation when there was no improvement after 1000 steps. Our code is available for download on GitHub ."
        ]
      },
      {
        "section_name": "Results and Discussion",
        "paragraphs": [
          "In this section we report the results of the experiments we performed to test our proposed model. In general, as Table TABREF13 shows, our intra-sentence attention RNN was able to outperform the Weka baseline BIBREF5 on the development dataset by a solid margin. Moreover, the model manages to do so without any additional resources, except pre-trained word embeddings. These results are, however, reversed for the test dataset, where our model performs worse than the baseline. This shows that the model is not able to generalize well, which we think is related to the missing semantic information due to the vocabulary gap we observed between the datasets and the GloVe embeddings.",
          "To validate the usefulness of our binary features, we performed an ablation experiment and trained our best models for each corpus without them. Table TABREF15 summarizes our results in terms of Pearson correlation on the development portion of the datasets. As seen, performance decreases in all cases, which shows that indeed these features are critical for performance, allowing the model to better capture the semantics of words missing in GloVe. In this sense, we think the usage of additional features, such as the ones derived from emotion or sentiment lexicons could indeed boost our model capabilities. This is proposed for future work.",
          "On the other hand, our model also offers us very interesting insights on how the learning is performed, since we can inspect the attention weights that the neural network is assigning to each specific token when predicting the emotion intensity. By visualizing these weights we can have a clear notion about the parts of the sentence that the model considers are more important. As Figure FIGREF16 shows, we see the model seems to be have learned to attend the words that naturally bear emotion or sentiment. This is specially patent for the examples extracted from the Joy dataset, where positive words are generally identified. However, we also see some examples where the lack of semantic information about the input words, specially for hashtags or user mentions, makes the model unable to identify some of these the most salient words to predict emotion intensity. Several pre-processing techniques can be implemented to alleviate this problem, which we intend to explore in the future."
        ]
      },
      {
        "section_name": "Anger Dataset",
        "paragraphs": [
          "For the anger dataset, our experiments showed that GloVe embeddings of dimension 50 outperformed others, obtaining an average gain of 0.066 correlation over embeddings of size 25 and of 0.021 for embeddings of size 100. However on ly the first of these values was significant, with a p-value of INLINEFORM0 . Regarding the hidden size of the RNN, we could not find statistical difference across the tested sizes. Dropout also had inconsistent effects, but was generally useful."
        ]
      },
      {
        "section_name": "Joy Dataset",
        "paragraphs": [
          "In the joy dataset, our experiments showed us that GloVe vectors of dimension 50 again outperformed others, in this case obtaining an average correlation gain of 0.052 ( INLINEFORM0 ) over embeddings of size 100, and of 0.062 ( INLINEFORM1 ) for size 25. Regarding the hidden size of the RNN, we observed that 100 hidden units offered better performance in our experiments, with an average absolute gain of 0.052 ( INLINEFORM2 ) over 50 hidden units. Compared to the models with 200 hidden units, the performance difference was statistically not significant."
        ]
      },
      {
        "section_name": "Fear Dataset",
        "paragraphs": [
          "On the fear dataset, again we observed that embeddings of size 50 provided the best results, offering average gains of 0.12 ( INLINEFORM0 ) and 0.11 ( INLINEFORM1 ) for sizes 25 and 100, respectively. When it comes to the size of the RNN hidden state, our experiments showed that using 100 hidden units offered the best results, with average absolute gains of 0.117 ( INLINEFORM2 ) and 0.108 ( INLINEFORM3 ) over sizes 50 and 200."
        ]
      },
      {
        "section_name": "Sadness Dataset",
        "paragraphs": [
          "Finally, on the sadness datasets again we experimentally observed that using embeddings of 50 offered the best results, with a statistically significant average gain of 0.092 correlation points INLINEFORM0 over size 25. Results were statistically equivalent for size 100. We also observed that using 50 or 100 hidden units for the RNN offered statistically equivalent results, while both of these offered better performance than when using a hidden size of 200."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this paper we introduced an intra-sentence attention RNN for the of emotion intensity, which we developed for the WASSA-2017 Shared Task on Emotion Intensity. Our model does not make use of external information except for pre-trained embeddings and is able to outperform the Weka baseline for the development set, but not in the test set. In the shared task, it obtained the 13th place among 22 competitors."
        ]
      }
    ],
    "qas": [
      {
        "question": "did the top teams experiment with lexicons?",
        "question_id": "622efbecd9350a0f4487bdff2b8b362ef2541f3c",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "94e57f0ec54937b4c481b2400091f573e26d0bba",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "980231104caf9183f234dc6f3b857e714288fe2f",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "d033b5131b4b6ddfe9fcd331c476caa3f01db685",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "f9575a1eeae3d932eb14289df57d0ae65c94c7b4",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Data summary."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Summary of the best results."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Impact of adding our binary features."
      },
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: Example of attention weights for the Joy dataset. White denotes more weight."
      }
    ]
  },
  "1908.11049": {
    "title": "Multilingual and Multi-Aspect Hate Speech Analysis",
    "abstract": "Current research on hate speech analysis is typically oriented towards monolingual and single classification tasks. In this paper, we present a new multilingual multi-aspect hate speech analysis dataset and use it to test the current state-of-the-art multilingual multitask learning approaches. We evaluate our dataset in various classification settings, then we discuss how to leverage our annotations in order to improve hate speech detection and classification in general.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "With the expanding amount of text data generated on different social media platforms, current filters are insufficient to prevent the spread of hate speech. Most internet users involved in a study conducted by the Pew Research Center report having been subjected to offensive name calling online or witnessed someone being physically threatened or harassed online. Additionally, Amnesty International within Element AI have lately reported that many women politicians and journalists are assaulted every 30 seconds on Twitter. This is despite the Twitter policy condemning the promotion of violence against people on the basis of race, ethnicity, national origin, sexual orientation, gender identity, religious affiliation, age, disability, or serious disease. Hate speech may not represent the general opinion, yet it promotes the dehumanization of people who are typically from minority groups BIBREF0, BIBREF1 and can incite hate crime BIBREF2.",
          "Moreover, although people of various linguistic backgrounds are exposed to hate speech BIBREF3, BIBREF2, English is still at the center of existing work on toxic language analysis. Recently, some research studies have been conducted on languages such as German BIBREF4, Arabic BIBREF5, and Italian BIBREF6. However, such studies usually use monolingual corpora and do not contrast, or examine the correlations between online hate speech in different languages. On the other hand, tasks involving more than one language such as the hatEval task, which covers English and Spanish, include only separate classification tasks, namely (a) women and immigrants as target groups, (b) individual or generic hate and, (c) aggressive or non-aggressive hate speech.",
          "Treating hate speech classification as a binary task may not be enough to inspect the motivation and the behavior of the users promoting it and, how people would react to it. For instance, the hateful tweets presented in Figure FIGREF5 show toxicity directed towards different targets, with or without using slurs, and generating several types of reactions. We believe that, in order to balance between truth and subjectivity, there are at least five important aspects in hate speech analysis. Hence, our annotations indicate (a) whether the text is direct or indirect; (b) if it is offensive, disrespectful, hateful, fearful out of ignorance, abusive, or normal; (c) the attribute based on which it discriminates against an individual or a group of people; (d) the name of this group; and (e) how the annotators feel about its content within a range of negative to neutral sentiments. To the best of our knowledge there are no other hate speech datasets that attempt to capture fear out of ignorance in hateful tweets or examine how people react to hate speech. We claim that our multi-aspect annotation schema would provide a valuable insight into several linguistic and cultural differences and bias in hate speech.",
          "We use Amazon Mechanical Turk to label around 13,000 potentially derogatory tweets in English, French, and Arabic based on the above mentioned aspects and, regard each aspect as a prediction task. Since in natural language processing, there is a peculiar interest in multitask learning, where different tasks can be used to help each other BIBREF7, BIBREF8, BIBREF9, we use a unified model to handle the annotated data in all three languages and five tasks. We adopt BIBREF8 as a learning algorithm adapted to loosely related tasks such as our five annotated aspects and, use the Babylon cross-lingual embeddings BIBREF10 to align the three languages. We compare the multilingual multitask learning settings with monolingual multitask, multilingual single-task, and monolingual single-task learning settings respectively. Then, we report the performance results of the different settings and discuss how each task affects the remaining ones. We release our dataset and code to the community to extend research work on multilingual hate speech detection and classification."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "There is little consensus on the difference between profanity and hate speech and, how to define the latter BIBREF17. As shown in Figure FIGREF11, slurs are not an unequivocal indicator of hate speech and can be part of a non-aggressive conversation, while some of the most offensive comments may come in the form of subtle metaphors or sarcasm BIBREF18. Consequently, there is no existing human annotated vocabulary that explicitly reveals the presence of hate speech, which makes the available hate speech corpora sparse and noisy BIBREF19.",
          "Given the subjectivity and the complexity of such data, annotation schemes have rarely been made fine-grained. Table TABREF10 compares different labelsets that exist in the literature. For instance, BIBREF12 use racist, sexist, and normal as labels; BIBREF13 label their data as hateful, offensive (but not hateful), and neither, while BIBREF16 present an English dataset that records the target category based on which hate speech discriminates against people, such as ethnicity, gender, or sexual orientation and ask human annotators to classify the tweets as hate and non hate. BIBREF15 label their data as offensive, abusive, hateful, aggressive, cyberbullying, spam, and normal. On the other hand, BIBREF20 have chosen to detect ideologies of hate speech counting 40 different hate ideologies among 13 extremist hate groups.",
          "The detection of hate speech targets is yet another challenging aspect of the annotation. BIBREF21 report the bias that exists in the current datasets towards identity words, such as women, which may later cause false predictions. They propose to debias gender identity word embeddings with additional data for training and tuning their binary classifier. We address this false positive bias problem and the common ambiguity of target detection by asking the annotators to label target attributes such as origin, gender, or religious affiliation within 16 named target groups such as refugees, or immigrants.",
          "Furthermore, BIBREF22 have reproduced the experiment of BIBREF12 in order to study how hate speech affects the popularity of a tweet, but discovered that some tweets have been deleted. For replication purposes, we provide the community with anonymized tweet texts rather than IDs.",
          "Non-English hate speech datasets include Italian, German, Dutch, and Arabic corpora. BIBREF6 present a dataset of Italian tweets, in which the annotations capture the degree of intensity of offensive and aggressive tweets, in addition to whether the tweets are ironic and contain stereotypes or not. BIBREF2 have collected more than 500 German tweets against refugees, and annotated them as hateful and not hateful. BIBREF23 detect bullies and victims among youngsters in Dutch comments on AskFM, and classify cyberbullying comments as insults or threats. Moreover, BIBREF5 provide a corpus of Arabic sectarian speech.",
          "Another predominant phenomenon in hate speech corpora is code switching. BIBREF24 present a dataset of code mixed Hindi-English tweets, while BIBREF25 report the presence of Hindi tokens in English data and use multilingual word embeddings to deal with this issue when detecting toxicity. Similarly, we use such embeddings to take advantage of the multilinguality and comparability of our corpora during the classification.",
          "Our dataset is the first trilingual dataset comprising English, French, and Arabic tweets that encompasses various targets and hostility types. Additionally, to the best of our knowledge, this is the first work that examines how annotators react to hate speech comments.",
          "To fully exploit the collected annotations, we tested multitask learning on our dataset. Multitask learning BIBREF7 allows neural networks to share parameters with one another and, thus, learn from related tasks. It has been used in different NLP tasks such as parsing BIBREF9, dependency parsing BIBREF26, neural machine translation BIBREF27, sentiment analysis BIBREF28, and other tasks. Multitask learning architectures tackle challenges that include sharing the label space and the question of private and shared space for loosely related tasks BIBREF8, for which techniques may involve a massive space of potential parameter sharing architectures."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "In this section, we present our data collection methodology and annotation process."
        ]
      },
      {
        "section_name": "Dataset ::: Data Collection",
        "paragraphs": [
          "Considering the cultural differences and commonly debated topics in the main geographic regions where English, French, and Arabic are spoken, searching for equivalent terms in the three languages led to different results at first. Therefore, after looking for 1,000 tweets per 15 more or less equivalent phrases in the three languages, we revised our search words three times by questioning the results, adding phrases, and taking off unlikely ones in each of the languages. In fact, we started our data collection by searching for common slurs and demeaning expressions such as \u201cgo back to where you come from\u201d. Then, we observed that discussions about controversial topics, such as feminism in general, illegal immigrants in English, Islamo-gauchisme (\u201cIslamic leftism\") in French, or Iran in Arabic were more likely to provoke disputes, comments filled with toxicity and thus, notable insult patterns that we looked for in subsequent search rounds."
        ]
      },
      {
        "section_name": "Dataset ::: Linguistic Challenges",
        "paragraphs": [
          "All of the annotated tweets include original tweets only, whose content has been processed by (1) deleting unarguably detectable spam tweets, (2) removing unreadable characters and emojis, and (3) masking the names of mentioned users using @user and potentially enclosed URLs using @url. As a result, annotators had to face the lack of context generated by this normalization process.",
          "Furthermore, we perceived code-switching in English where Hindi, Spanish, and French tokens appear in the tweets. Some French tweets also contain Romanized dialectal Arabic tokens generated by, most likely, bilingual North African Twitter users. Hence, although we eliminated most of these tweets in order to avoid misleading the annotators, the possibly remaining ones still added noise to the data.",
          "One more challenge that the annotators and ourselves had to tackle, consisted of Arabic diglossia and switching between different Arabic dialects and Modern Standard Arabic (MSA). While MSA represents the standardized and literary variety of Arabic, there are several Arabic dialects spoken in North Africa and the Middle East in use on Twitter. Therefore, we searched for derogatory terms adapted to different circumstances, and acquired an Arabic corpus that combines tweets written in MSA and Arabic dialects. For instance, the tweet shown in Figure FIGREF5 contains a dialectal slur that means \u201cmaiden.\u201d"
        ]
      },
      {
        "section_name": "Dataset ::: Annotation Process",
        "paragraphs": [
          "We rely on the general public opinion and common linguistic knowledge to assess how people view and react to hate speech. Given the subjectivity and difficulty of the task, we reminded the annotators not to let their personal opinions about the topics being discussed in the tweets influence their annotation decisions.",
          "Our annotation guidelines explained the fact that offensive comments and hate do not necessarily come in the form of profanity. Since different degrees of discrimination work on the dehumanization of individuals or groups of people in distinct ways, we chose not to annotate the tweets within two or three classes. For instance, a sexist comment can be disrespectful, hateful, or offensive towards women. Our initial labelset was established in conformity with the prevalent anti-social behaviors people tend to deal with. We also chose to address the problem of false positives caused by the misleading use of identity words by asking the annotators to label both the target attributes and groups."
        ]
      },
      {
        "section_name": "Dataset ::: Annotation Process ::: Avoiding scams",
        "paragraphs": [
          "To prevent scams, we also prepared three annotation guideline forms and three aligned labelsets written in English, French, and Modern Standard Arabic with respect to the language of the tweets to be annotated.",
          "We requested native speakers to annotate the data and chose annotators with good reputation scores (more than 0.90). We informed the annotator in the guidelines, that in case of noticeable patterns of random labeling on a substantial number of tweets, their work will be rejected and we may have to block them. Since the rejection affects the reputation of the annotators and their chances to get new tasks on Amazon Mechanical Turk, well-reputed annotators are usually reliable. We have divided our corpora into smaller batches on Amazon Mechanical Turk in order to facilitate the analysis of the annotations of the workers and, fairly identify any incoherence patterns possibly caused by the use of an automatic translation system on the tweets, or the repetition of the same annotation schema. If we reject the work of a scam, we notify them, then reassign the tasks to other annotators."
        ]
      },
      {
        "section_name": "Dataset ::: Pilot Dataset",
        "paragraphs": [
          "We initially put samples of 100 tweets in each of the three languages on Amazon Mechanical Turk. We showed the annotators the tweet along with lists of labels describing (a) whether it is direct or indirect hate speech; (b) if the tweet is dangerous, offensive, hateful, disrespectful, confident or supported by some URL, fearful out of ignorance, or other; (c) the target attribute based on which it discriminates against people, specifically, race, ethnicity, nationality, gender, gender identity, sexual orientation, religious affiliation, disability, and other (\u201cother\u201d could refer to political ideologies or social classes.); (d) the name of its target group, and (e) whether the annotators feel anger, sadness, fear or nothing about the tweets.",
          "Each tweet has been labeled by three annotators. We have provided them with additional text fields to fill in with labels or adjectives that would (1) better describe the tweet, (2) describe how they feel about it more accurately, and (3) name the group of people the tweet shows bias against. We kept the most commonly used labels from our initial labelset, took off some of the initial class names and added frequently introduced labels, especially the emotions of the annotators when reading the tweets and the names of the target groups. For instance, after this step, we have ended up merging race, ethnicity, nationality into one label origin given common confusions we noticed and; added disgust and shock to the emotion labelset; and introduced socialists as a target group label since many annotators have suggested these labels."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset",
        "paragraphs": [
          "The final dataset is composed of a pilot corpus of 100 tweets per language, and comparable corpora of 5,647 English tweets, 4,014 French tweets, and 3,353 Arabic tweets. Each of the annotated aspects represents a classification task of its own, that could either be evaluated independently, or, as intended in this paper, tested on how it impacts other tasks. The different labels are designed to facilitate the study of the correlations between the explicitness of the tweet, the type of hostility it conveys, its target attribute, the group it dehumanizes, how different people react to it, and the performance of multitask learning on the five tasks. We assigned each tweet to five annotators, then applied majority voting to each of the labeling tasks. Given the numbers of annotators and labels in each annotation sub-task, we allowed multilabel annotations in the most subjective classification tasks, namely the hostility type and the annotator's sentiment labels, in order to keep the right human-like approximations. If there are two annotators agreeing on two labels respectively, we add both labels to the annotation.",
          "The average Krippendorff scores for inter-annotator agreement (IAA) are 0.153, 0.244, and 0.202 for English, French, and Arabic respectively, which are comparable to existing complex annotations BIBREF6 given the nature of the labeling tasks and the number of labels.",
          "We present the labelset the annotators refer to, and statistics of our annotated data in the following."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset ::: Directness label",
        "paragraphs": [
          "Annotators determine the explicitness of the tweet by labeling it as direct or indirect speech. This should be based on whether the target is explicitly named, or less easily discernible, especially if the tweet contains humor, metaphor, or figurative speech. Table TABREF20 shows that even when partly using equivalent keywords to search for candidate tweets, there are still significant differences in the resulting data."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset ::: Hostility type",
        "paragraphs": [
          "To identify the hostility type of the tweet, we stick to the following conventions: (1) if the tweet sounds dangerous, it should be labeled as abusive; (2) according to the degree to which it spreads hate and the tone its author uses, it can be hateful, offensive or disrespectful; (3) if the tweet expresses or spreads fear out of ignorance against a group of individuals, it should be labeled as fearful; (4) otherwise it should be annotated as normal. We define this task to be multilabel. Table TABREF20 shows that hostility types are relatively consistent across different languages and offensive is the most frequent label."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset ::: Target attribute",
        "paragraphs": [
          "After annotating the pilot dataset, we noticed common misconceptions regarding race, ethnicity, and nationality, therefore we merged these attributes into one label origin. Then, we asked the annotators to determine whether the tweet insults or discriminates against people based on their (1) origin, (2) religious affiliation, (3) gender, (4) sexual orientation, (5) special needs or (6) other. Table TABREF20 shows there are fewer tweets targeting disability in Arabic compared to English and French and no tweets insulting people based on their sexual orientation which may be due to the fact that the labels of gender, gender identity, and sexual orientation use almost the same wording. On the other hand, French contains a small number of tweets targeting people based on their gender in comparison to English and Arabic. We have observed significant differences in terms of target attributes in the three languages. More data may help us examine the problems affecting targets of different linguistic backgrounds."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset ::: Target group",
        "paragraphs": [
          "We determined 16 common target groups tagged by the annotators after the first annotation step. The annotators had to decide on whether the tweet is aimed at women, people of African descent, Hispanics, gay people, Asians, Arabs, immigrants in general, refugees; people of different religious affiliations such as Hindu, Christian, Jewish people, and Muslims; or from political ideologies socialists, and others. We also provided the annotators with a category to cover hate directed towards one individual, which cannot be generalized. In case the tweet targets more than one group of people, the annotators should choose the group which would be the most affected by it according to them. Table TABREF10 shows the counts of the five categories out of 16 that commonly occur in the three languages. In fact, most of the tweets target individuals or fall into the \u201cother\u201d category. In the latter case, they may target people with different political views such as liberals or conservatives in English and French, or specific ethnic groups such as Kurdish people in Arabic. English tweets tend to have more tweets targeting people with special needs, due to common language-specific demeaning terms used in conversations where people insult one another. Arabic tweets contain more hateful comments towards women for the same reason. On the other hand, the French corpus contains more tweets that are offensive towards African people, due to hateful comments generated by debates about immigrants."
        ]
      },
      {
        "section_name": "Dataset ::: Final Dataset ::: Sentiment of the annotator",
        "paragraphs": [
          "We claim that the choice of a suitable emotion representation model is key to this sub-task, given the subjective nature and social ground of the annotator's sentiment analysis. After collecting the annotation results of the pilot dataset regarding how people feel about the tweets, and observing the added categories, we adopted a range of sentiments that are in the negative and neutral scales of the hourglass of emotions introduced by BIBREF29. This model includes sentiments that are connected to objectively assessed natural language opinions, and excludes what is known as self-conscious or moral emotions such as shame and guilt. Our labels include shock, sadness, disgust, anger, fear, confusion in case of ambivalence, and indifference. This is the second multilabel task of our model.",
          "Table TABREF20 shows more tweets making the annotators feel disgusted and angry in English, while annotators show more indifference in both French and Arabic. A relatively more frequent label in both French and Arabic is shock, therefore reflecting what some of the annotators were feeling during the labeling process."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We report and discuss the results of five classification tasks: (1) the directness of the speech, (2) the hostility type of the tweet, (3) the discriminating target attribute, (4) the target group, and (5) the annotator's sentiment."
        ]
      },
      {
        "section_name": "Experiments ::: Models",
        "paragraphs": [
          "We compare both traditional baselines using bag-of-words (BOW) as features on Logistic regression (LR), and deep learning based methods.",
          "For deep learning based models, we run bidirectional LSTM (biLSTM) models with one hidden layer on each of the classification tasks. Deeper BiLSTM models performed poorly due to the size of the tweets. We chose to use Sluice networks BIBREF8 since they are suitable for loosely related tasks such as the annotated aspects of our corpora.",
          "We test different models, namely single task single language (STSL), single task multilingual (STML), and multitask multilingual models (MTML) on our dataset. In multilingual settings, we tested Babylon multilingual word embeddings BIBREF10 and MUSE BIBREF30 on the different tasks. We use Babylon embeddings since they appear to outperform MUSE on our data.",
          "Sluice networks BIBREF8 learn the weights of the neural networks sharing parameters (sluices) jointly with the rest of the model and share an embedding layer, Babylon embeddings in our case, that associates the elements of an input sequence. We use a standard 1-layer BiLSTM partitioned into two subspaces, a shared subspace and a private one, forced to be orthogonal through a regularization penalty term in the loss function in order to enable the multitask network to learn both task-specific and shared representations. The hidden layer has a dimension of 200, the learning rate is initially set to 0.1 with a learning rate decay, and we use the DyNet BIBREF31 automatic minibatch function to speed-up the computation. We initialize the cross-stitch unit to imbalanced, set the standard deviation of the Gaussian noise to 2, and use simple stochastic gradient descent (SGD) as the optimizer.",
          "All compared methods use the same split as train:dev:test=8:1:1 and the reported results are based on the test set. We use the dev set to tune the threshold for each binary classification problem in the multilabel classification settings of each task."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Analysis",
        "paragraphs": [
          "We report both the micro and macro-F1 scores of the different classification tasks in Tables TABREF27 and TABREF28. Majority refers to labeling based on the majority label, LR to logistic regression, STSL to single task single language models, STML to single task multilingual models, and MTML to multitask multilingual models."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Analysis ::: STSL",
        "paragraphs": [
          "STSL performs the best among all models on the directness classification, and it is also consistent in both micro and macro-F1 scores. This is due to the fact that the directness has only two labels and multilabeling is not allowed in this task. Tasks involving imbalanced data, multiclass and multilabel annotations harm the performance of the directness in multitask settings.",
          "Since macro-F1 is the average of all F1 scores of individual labels, all deep learning models have high macro-F1 scores in English which indicates that they are particularly good at classifying the direct class. STSL is also comparable or better than traditional BOW feature-based classifiers when performed on other tasks in terms of micro-F1 and for most of the macro-F1 scores. This shows the power of the deep learning approach."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Analysis ::: MTSL",
        "paragraphs": [
          "Except for the directness, MTSL usually outperforms STSL or is comparable to it. When we jointly train each task on the three languages, the performance decreases in most cases, other than the target group classification tasks. This may be due to the difference in label distributions across languages. Yet, multilingual training of the target group classification task improves in all languages. Since the target group classification task involves 16 labels, the amount of data annotated for each label is lower than in other tasks. Hence, when aggregating annotated data in different languages, the size of the training data also increases, due to the relative regularity of identification words of different groups in all three languages in comparison to other tasks."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Analysis ::: MTML",
        "paragraphs": [
          "MTML settings do not lead to a big improvement which may be due to the class imbalance, multilabel tasks, and the difference in the nature of the tasks. In order to inspect which tasks hurt or help one another, we trained multilingual models for pairwise tasks such as (group, target), (hostility, annotator's sentiment), (hostility, target), (hostility, group), (annotator's sentiment, target) and (annotator's sentiment, group). We noticed that when trained jointly, the target attribute slightly improves the performance of the tweet's hostility type classification by 0.03,0.05 and 0.01 better than the best reported scores in English, French, and Arabic, respectively. When target groups and attributes are trained jointly, the macro F-score of the target group classification in Arabic improves by 0.25 and when we train the tweet's hostility type within the annotator's sentiment, we improve the macro F-score of Arabic by 0.02. We believe that we can take advantage of the correlations between target attributes and groups along with other tasks, to set logic rules and develop better multilingual and multitask settings."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we presented a multilingual hate speech dataset of English, French, and Arabic tweets. We analyzed in details the difficulties related to the collection and annotation of this dataset. We performed multilingual and multitask learning on our corpora and showed that deep learning models perform better than traditional BOW-based models in most of the multilabel classification tasks. Multilingual multitask learning also helped tasks where each label had less annotated data associated with it. Better tuned deep learning settings in our multilingual and multitask models would be expected to outperform the existing state-of-the-art embeddings and algorithms applied to our data. The different annotation labels and comparable corpora would help us perform transfer learning and investigate how multimodal information on the tweets, additional unlabeled data, label transformation, and label information sharing may boost the classification performance in the future."
        ]
      },
      {
        "section_name": "Acknowledgement",
        "paragraphs": [
          "This paper was supported by the Early Career Scheme (ECS, No. 26206717) from Research Grants Council in Hong Kong, and by postgraduate studentships from the Computer Science and Engineering department of the Hong Kong University of Science and Technology."
        ]
      }
    ],
    "qas": [
      {
        "question": "What languages does the new dataset contain?",
        "question_id": "d9e7633004ed1bc1ee45be58409bcc1fa6db59b2",
        "nlp_background": "five",
        "topic_background": "research",
        "paper_read": "no",
        "search_query": "Hate speech",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English",
                "French",
                "Arabic"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our dataset is the first trilingual dataset comprising English, French, and Arabic tweets that encompasses various targets and hostility types. Additionally, to the best of our knowledge, this is the first work that examines how annotators react to hate speech comments."
              ],
              "highlighted_evidence": [
                "Our dataset is the first trilingual dataset comprising English, French, and Arabic tweets that encompasses various targets and hostility types. "
              ]
            },
            "annotation_id": "01448f46cbd6b9af4b94ff9cf65a7d60bdcfa79c",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English",
                "French",
                "Arabic"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our dataset is the first trilingual dataset comprising English, French, and Arabic tweets that encompasses various targets and hostility types. Additionally, to the best of our knowledge, this is the first work that examines how annotators react to hate speech comments."
              ],
              "highlighted_evidence": [
                "Our dataset is the first trilingual dataset comprising English, French, and Arabic tweets that encompasses various targets and hostility types. "
              ]
            },
            "annotation_id": "2b55ef43ccce0cb2f8e62c7a740caa4809c2ab13",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English",
                "French",
                "Arabic"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The final dataset is composed of a pilot corpus of 100 tweets per language, and comparable corpora of 5,647 English tweets, 4,014 French tweets, and 3,353 Arabic tweets. Each of the annotated aspects represents a classification task of its own, that could either be evaluated independently, or, as intended in this paper, tested on how it impacts other tasks. The different labels are designed to facilitate the study of the correlations between the explicitness of the tweet, the type of hostility it conveys, its target attribute, the group it dehumanizes, how different people react to it, and the performance of multitask learning on the five tasks. We assigned each tweet to five annotators, then applied majority voting to each of the labeling tasks. Given the numbers of annotators and labels in each annotation sub-task, we allowed multilabel annotations in the most subjective classification tasks, namely the hostility type and the annotator's sentiment labels, in order to keep the right human-like approximations. If there are two annotators agreeing on two labels respectively, we add both labels to the annotation."
              ],
              "highlighted_evidence": [
                "The final dataset is composed of a pilot corpus of 100 tweets per language, and comparable corpora of 5,647 English tweets, 4,014 French tweets, and 3,353 Arabic tweets."
              ]
            },
            "annotation_id": "6fff26727f82935e76bf6367e32ecd4201b33cfe",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English, French, and Arabic "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use Amazon Mechanical Turk to label around 13,000 potentially derogatory tweets in English, French, and Arabic based on the above mentioned aspects and, regard each aspect as a prediction task. Since in natural language processing, there is a peculiar interest in multitask learning, where different tasks can be used to help each other BIBREF7, BIBREF8, BIBREF9, we use a unified model to handle the annotated data in all three languages and five tasks. We adopt BIBREF8 as a learning algorithm adapted to loosely related tasks such as our five annotated aspects and, use the Babylon cross-lingual embeddings BIBREF10 to align the three languages. We compare the multilingual multitask learning settings with monolingual multitask, multilingual single-task, and monolingual single-task learning settings respectively. Then, we report the performance results of the different settings and discuss how each task affects the remaining ones. We release our dataset and code to the community to extend research work on multilingual hate speech detection and classification."
              ],
              "highlighted_evidence": [
                "We use Amazon Mechanical Turk to label around 13,000 potentially derogatory tweets in English, French, and Arabic based on the above mentioned aspects and, regard each aspect as a prediction task. "
              ]
            },
            "annotation_id": "9a21045e1c0436d63272e893f6398e075d983624",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Annotation examples in our dataset."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: Three tweets in which (1) the first one accuses immigrants of harming society without using any direct insult; (2) the second insults a Hispanic person using a slur; and (3) the third one uses slurs to give a personal account. This shows that profanity is not a clear indicator of the presence of hate speech."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Comparative table of some of the available hate speech and abusive language corpora in terms of labels and sizes."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: The label distributions of each task. The counts of direct and indirect hate speech include all tweets except those that are single labeled as \u201cnormal\u201d. Tweet and annotator\u2019s sentiment (Annotator) are multilabel classification tasks, while target attribute (Target) and target group (Group) are not."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: Full evaluation scores of the only binary classification task where the single task single language model consistently outperforms multilingual multitask models."
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: Full evaluation of tasks where multilingual and multitask models outperform on average single task single language model on four different tasks."
      }
    ]
  },
  "1907.10676": {
    "title": "Semantic Web for Machine Translation: Challenges and Directions",
    "abstract": "A large number of machine translation approaches have recently been developed to facilitate the fluid migration of content across languages. However, the literature suggests that many obstacles must still be dealt with to achieve better automatic translations. One of these obstacles is lexical and syntactic ambiguity. A promising way of overcoming this problem is using Semantic Web technologies. This article is an extended abstract of our systematic review on machine translation approaches that rely on Semantic Web technologies for improving the translation of texts. Overall, we present the challenges and opportunities in the use of Semantic Web technologies in Machine Translation. Moreover, our research suggests that while Semantic Web technologies can enhance the quality of machine translation outputs for various problems, the combination of both is still in its infancy.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Alongside increasing globalization comes a greater need for readers to understand texts in languages foreign to them. For example, approximately 48% of the pages on the Web are not available in English. The technological progress of recent decades has made both the distribution and access to content in different languages ever simpler. Translation aims to support users who need to access content in a language in which they are not fluent BIBREF0 .",
          "However, translation is a difficult task due to the complexity of natural languages and their structure BIBREF0 . In addition, manual translation does not scale to the magnitude of the Web. One remedy for this problem is MT. The main goal of MT is to enable people to assess content in languages other than the languages in which they are fluent BIBREF1 . From a formal point of view, this means that the goal of MT is to transfer the semantics of text from an input language to an output language BIBREF2 .",
          "Although MT systems are now popular on the Web, they still generate a large number of incorrect translations. Recently, Popovi\u0107 BIBREF3 has classified five types of errors that still remain in MT systems. According to research, the two main faults that are responsible for 40% and 30% of problems respectively, are reordering errors and lexical and syntactic ambiguity. Thus, addressing these barriers is a key challenge for modern translation systems. A large number of MT approaches have been developed over the years that could potentially serve as a remedy. For instance, translators began by using methodologies based on linguistics which led to the family of RBMT. However, RBMT systems have a critical drawback in their reliance on manually crafted rules, thus making the development of new translation modules for different languages even more difficult.",
          "SMT and EBMT were developed to deal with the scalability issue in RBMT BIBREF4 , a necessary characteristic of MT systems that must deal with data at Web scale. Presently, these approaches have begun to address the drawbacks of rule-based approaches. However, some problems that had already been solved for linguistics based methods reappeared. The majority of these problems are connected to the issue of ambiguity, including syntactic and semantic variations BIBREF0 . Nowadays, a novel SMT paradigm has arisen called NMT which relies on NN algorithms. NMT has been achieving impressive results and is now the state-of-the-art in MT approaches. However, NMT is still a statistical approach sharing some semantic drawbacks from other well-defined SMT approaches BIBREF5 .",
          "One possible solution to address the remaining issues of MT lies in the use of SWT, which have emerged over recent decades as a paradigm to make the semantics of content explicit so that it can be used by machines. It is believed that explicit semantic knowledge made available through these technologies can empower MT systems to supply translations with significantly better quality while remaining scalable. In particular, the disambiguated knowledge about real-world entities, their properties and their relationships made available on the LD Web can potentially be used to infer the right meaning of ambiguous sentences or words.",
          "According to our survey BIBREF6 , the obvious opportunity of using SWT for MT has already been studied by a number of approaches, especially w.r.t. the issue of ambiguity. In this paper, we present the challenges and opportunities in the use of SWT in MT for translating texts."
        ]
      },
      {
        "section_name": "Related Works",
        "paragraphs": [
          "The idea of using a structured KB in MT systems started in the 90s with the work of Knight and Luk BIBREF7 . Still, only a few researchers have designed different strategies for benefiting of structured knowledge in MT architectures BIBREF8 . Recently, the idea of using KG into MT systems has gained renewed attention. Du et al. BIBREF9 created an approach to address the problem of OOV words by using BabelNet BIBREF10 . Their approach applies different methods of using BabelNet. In summary, they create additional training data and apply a post-editing technique, which replaces the OOV words while querying BabelNet. Shi et al. BIBREF11 have recently built a semantic embedding model reliant upon a specific KB to be used in NMT systems. The model relies on semantic embeddings to encode the key information contained in words to translate the meaning of sentences correctly. The work consists of mapping a source sentence to triples, which are then used to extract the intrinsic meaning of words to generate a target sentence. This mapping results in a semantic embedding model containing KB triples, which are responsible for gathering the key information of each word in the sentences."
        ]
      },
      {
        "section_name": "Open MT Challenges",
        "paragraphs": [
          "The most problematic unresolved MT challenges, from our point of view, which are still experienced by the aforementioned MT approaches are the following:",
          "Additionally, there are five MT open challenges posed by Lopez and Post BIBREF12 which we describe more generically below.",
          "(1) Excessive focus on English and European languages as one of the involved languages in MT approaches and poor research on low-resource language pairs such as African and/or South American languages. (2) The limitations of SMT approaches for translating across domains. Most MT systems exhibit good performance on law and the legislative domains due to the large amount of data provided by the European Union. In contrast, translations performed on sports and life-hacks commonly fail, because of the lack of training data. (3) How to translate the huge amount of data from social networks that uniquely deal with no-standard speech texts from users (e.g., tweets). (4) The difficult translations among morphologically rich languages. This challenge shares the same problem with the first one, namely that most research work focuses on English as one of the involved languages. Therefore, MT systems which translate content between, for instance, Arabic and Spanish are rare. (5) For the speech translation task, the parallel data for training differs widely from real user speech.",
          "The challenges above are clearly not independent, which means that addressing one of them can have an impact on the others. Since NMT has shown impressive results on reordering, the main problem turns out to be the disambiguation process (both syntactically and semantically) in SMT approaches BIBREF0 ."
        ]
      },
      {
        "section_name": "Suggestions and Possible Directions using SW",
        "paragraphs": [
          "Based on the surveyed works on our research BIBREF6 , SWT have mostly been applied at the semantic analysis step, rather than at the other stages of the translation process, due to their ability to deal with concepts behind the words and provide knowledge about them. As SWT have developed, they have increasingly been able to resolve some of the open challenges of MT. They may be applied in different ways according to each MT approach.",
          "Disambiguation. Human language is very ambiguous. Most words have multiple interpretations depending on the context in which they are mentioned. In the MT field, WSD techniques are concerned with finding the respective meaning and correct translation to these ambiguous words in target languages. This ambiguity problem was identified early in MT development. In 1960 Bar-Hillel BIBREF1 stated that an MT system is not able to find the right meaning without a specific knowledge. Although the ambiguity problem has been lessened significantly since the contribution of Carpuat and subsequent works BIBREF13 , this problem still remains a challenge. As seen in Moussallem et al. BIBREF6 , MT systems still try to resolve this problem by using domain specific language models to prefer domain specific expressions, but when translating a highly ambiguous sentence or a short text which covers multiple domains, the languages models are not enough.",
          "SW has already shown its capability for semantic disambiguation of polysemous and homonymous words. However, SWT were applied in two ways to support the semantic disambiguation in MT. First, the ambiguous words were recognized in the source text before carrying out the translation, applying a pre-editing technique. Second, SWT were applied to the output translation in the target language as a post-editing technique. Although applying one of these techniques has increased the quality of a translation, both techniques are tedious to implement when they have to translate common words instead of named entities, then be applied several times to achieve a successful translation.",
          "The real benefit of SW comes from its capacity to provide unseen knowledge about emergent data, which appears every day. Therefore, we suggest performing the topic-modelling technique over the source text to provide a necessary context before translation. Instead of applying the topic-modeling over the entire text, we would follow the principle of communication (i.e from 3 to 5 sentences for describing an idea and define a context for each piece of text. Thus, at the execution of a translation model in a given SMT, we would focus on every word which may be a homonymous or polysemous word. For every word which has more than one translation, a SPARQL query would be required to find the best combination in the current context. Thus, at the translation phase, the disambiguation algorithm could search for an appropriate word using different SW resources such as DBpedia, in consideration of the context provided by the topic modelling. The goal is to exploit the use of more than one SW resource at once for improving the translation of ambiguous terms. The use of two or more SW resources simultaneously has not yet been investigated.",
          "On the other hand, there is also a syntactic disambiguation problem which as yet lacks good solutions. For instance, the English language contains irregular verbs like \u201cset\u201d or \u201cput\u201d. Depending on the structure of a sentence, it is not possible to recognize their verbal tense, e.g., present or past tense. Even statistical approaches trained on huge corpora may fail to find the exact meaning of some words due to the structure of the language. Although this challenge has successfully been dealt with since NMT has been used for European languages, implementations of NMT for some non-European languages have not been fully exploited (e.g., Brazilian Portuguese, Latin-America Spanish, Zulu, Hindi) due to the lack of large bilingual data sets on the Web to be trained on. Thus, we suggest gathering relationships among properties within an ontology by using the reasoning technique for handling this issue. For instance, the sentence \u201cAnna usually put her notebook on the table for studying\" may be annotated using a certain vocabulary and represented by triples. Thus, the verb \u201cput\", which is represented by a predicate that groups essential information about the verbal tense, may support the generation step of a given MT system. This sentence usually fails when translated to rich morphological languages, such as Brazilian-Portuguese and Arabic, for which the verb influences the translation of \u201cusually\" to the past tense. In this case, a reasoning technique may support the problem of finding a certain rule behind relationships between source and target texts in the alignment phase (training phase). However, a well-known problem of reasoners is the poor run-time performance. Therefore, this run-time deficiency needs to be addressed or minimized before implementing reasoners successfully into MT systems.",
          "Named Entities. Most NERD approaches link recognized entities with database entries or websites. This method helps to categorize and summarize text, but also contributes to the disambiguation of words in texts. The primary issue in MT systems is caused by common words from a source language that are used as proper nouns in a target language. For instance, the word \u201cKiwi\" is a family name in New Zealand which comes from the M\u0101ori culture, but it also can be a fruit, a bird, or a computer program. Named Entities are a common and difficult problem in both MT (see Koehn BIBREF0 ) and SW fields. The SW achieved important advances in NERD using structured data and semantic annotations, e.g., by adding an rdf:type statement which identifies whether a certain kiwi is a fruit BIBREF14 . In MT systems, however, this problem is directly related to the ambiguity problem and therefore has to be resolved in that wider context.",
          "Although MT systems include good recognition methods, they still need improvement. When an MT system does not recognize an entity, the translation output often has poor quality, immediately deteriorating the target text readability. Therefore, we suggest recognizing such entities before the translation process and first linking them to a reference knowledge base. Afterwards, the type of entities would be agglutinated along with their labels and their translations from a reference knowledge base. For instance, in NMT, the idea is to include in the training set for the aforementioned word \u201cKiwi\", \u201cKiwi.animal.link, Kiwi.person.link, Kiwi.food.link\" then finally to align them with the translations in the target text. For example, in SMT, the additional information can be included by XML or by an additional model. In contrast, in NMT, this additional information can be used as parameters in the training phase. This method would also contribute to OOV mistakes regarding names. This idea is supported by BIBREF11 where the authors encoded the types of entities along with the words to improve the translation of sentences between Chinese-English. Recently, Moussallem et al. BIBREF15 have shown promising results by applying a multilingual entity linking algorithm along with knowledge graph embeddings into the translation phase of a neural machine translation model for improving the translation of entities in texts. Their approach achieved significant and consistent improvements of +3 BLEU, METEOR and CHRF3 on average on the newstest datasets between 2014 and 2018 for WMT English-German translation task.",
          "Non-standard speech. The non-standard language problem is a rather important one in the MT field. Many people use the colloquial form to speak and write to each other on social networks. Thus, when MT systems are applied on this context, the input text frequently contains slang, MWE, and unreasonable abbreviations such as \u201cIdr = I don't remember.\u201d and \u201ccya = see you\u201d. Additionally, idioms contribute to this problem, decreasing the translation quality. Idioms often have an entirely different meaning than their separated word meanings. Consequently, most translation outputs of such expressions contain errors. For a good translation, the MT system needs to recognize such slang and try to map it to the target language. Some SMT systems like Google or Bing have recognition patterns over non-standard speech from old translations through the Web using SMT approaches. In rare cases SMT can solve this problem, but considering that new idiomatic expressions appear every day and most of them are isolated sentences, this challenge still remains open. Moreover, each person has their own speaking form.",
          "Therefore, we suggest that user characteristics can be applied as context for solving the non-standard language problem. These characteristics can be extracted from social media or user logs and stored as user properties using SWT, e.g., FOAF vocabulary. These ontologies have properties which would help identify the birth place or the interests of a given user. For instance, the properties foaf:interest and sioc:topic can be used to describe a given person's topics of interest. If the person is a computer scientist and the model contains topics such as \u201cInformation Technology\" and \u201cSports\", the SPARQL queries would search for terms inserted in this context which are ambiguous. Furthermore, the property foaf:based_near may support the problem of idioms. Assuming that a user is located in a certain part of Russia and he is reading an English web page which contains some idioms, this property may be used to gather appropriate translations of idioms from English to Russian using a given RDF KB. Therefore, an MT system can be adapted to a user by using specific data about him in RDF along with given KBs. Recently, Moussallem et al BIBREF16 have released a multilingual linked idioms dataset as a first part of supporting the investigation of this suggestion. The dataset contains idioms in 5 languages and are represented by knowledge graphs which facilitates the retrieval and inference of translations among the idioms.",
          "Translating KBs. According to our research, it is clear that SWT may be used for translating KBs in order to be applied in MT systems. For instance, some content provided by the German Wikipedia version are not contained in the Portuguese one. Therefore, the semantic structure (i.e., triples) provided by DBpedia versions of these respective Wikipedia versions would be able to help translate from German to Portuguese. For example, the terms contained in triples would be translated to a given target language using a dictionary containing domain words. This dictionary may be acquired in two different ways. First, by performing localisation, as in the work by J. P. McCrae BIBREF17 which translates the terms contained in a monolingual ontology, thus generating a bilingual ontology. Second, by creating embeddings of both DBpedia versions in order to determine the similarity between entities through their vectors. This insight is supported by some recent works, such as Ristoski et al. BIBREF18 , which creates bilingual embeddings using RDF based on Word2vec algorithms. Therefore, we suggest investigating an MT approach mainly based on SWT using NN for translating KBs. Once the KBs are translated, we suggest including them in the language models for improving the translation of entities.",
          "Besides C. Shi et al BIBREF11 , Ar\u010dan and Buitelaar BIBREF19 presented an approach to translate domain-specific expressions represented by English KBs in order to make the knowledge accessible for other languages. They claimed that KBs are mostly in English, therefore they cannot contribute to the problem of MT to other languages. Thus, they translated two KBs belonging to medical and financial domains, along with the English Wikipedia, to German. Once translated, the KBs were used as external resources in the translation of German-English. The results were quite appealing and the further research into this area should be undertaken. Recently, Moussallem et al BIBREF20 created THOTH, an approach which translates and enriches knowledge graphs across languages. Their approach relies on two different recurrent neural network models along with knowledge graph embeddings. The authors applied their approach on the German DBpedia with the German translation of the English DBpedia on two tasks: fact checking and entity linking. THOTH showed promising results with a translation accuracy of 88.56 while being capable of improving two NLP tasks with its enriched-German KG .",
          ""
        ]
      },
      {
        "section_name": "conclusion",
        "paragraphs": [
          "In this extended abstract, we detailed the results of a systematic literature review of MT using SWT for improving the translation of natural language sentences. Our goal was to present the current open MT translation problems and how SWT can address these problems and enhance MT quality. Considering the decision power of SWT, they cannot be ignored by future MT systems. As a next step, we intend to continue elaborating a novel MT approach which is capable of simultaneously gathering knowledge from different SW resources and consequently being able to address the ambiguity of named entities and also contribute to the OOV words problem. This insight relies on our recent works, such as BIBREF15 , which have augmented NMT models with the usage of external knowledge for improving the translation of entities in texts. Additionally, future works that can be expected from fellow researchers, include the creation of multilingual linguistic ontologies describing the syntax of rich morphologically languages for supporting MT approaches. Also, the creation of more RDF multilingual dictionaries which can improve some MT steps, such as alignment."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This work was supported by the German Federal Ministry of Transport and Digital Infrastructure (BMVI) in the projects LIMBO (no. 19F2029I) and OPAL (no. 19F2028A) as well as by the Brazilian National Council for Scientific and Technological Development (CNPq) (no. 206971/2014-1)"
        ]
      }
    ],
    "qas": [
      {
        "question": "What are the challenges associated with the use of Semantic Web technologies in Machine Translation?",
        "question_id": "9f74f3991b8681619d95ab93a7c8733a843ddffe",
        "nlp_background": "five",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "syntactic disambiguation problem which as yet lacks good solutions",
                "directly related to the ambiguity problem and therefore has to be resolved in that wider context",
                "In rare cases SMT can solve this problem, but considering that new idiomatic expressions appear every day and most of them are isolated sentences, this challenge still remains open"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "On the other hand, there is also a syntactic disambiguation problem which as yet lacks good solutions. For instance, the English language contains irregular verbs like \u201cset\u201d or \u201cput\u201d. Depending on the structure of a sentence, it is not possible to recognize their verbal tense, e.g., present or past tense. Even statistical approaches trained on huge corpora may fail to find the exact meaning of some words due to the structure of the language. Although this challenge has successfully been dealt with since NMT has been used for European languages, implementations of NMT for some non-European languages have not been fully exploited (e.g., Brazilian Portuguese, Latin-America Spanish, Zulu, Hindi) due to the lack of large bilingual data sets on the Web to be trained on. Thus, we suggest gathering relationships among properties within an ontology by using the reasoning technique for handling this issue. For instance, the sentence \u201cAnna usually put her notebook on the table for studying\" may be annotated using a certain vocabulary and represented by triples. Thus, the verb \u201cput\", which is represented by a predicate that groups essential information about the verbal tense, may support the generation step of a given MT system. This sentence usually fails when translated to rich morphological languages, such as Brazilian-Portuguese and Arabic, for which the verb influences the translation of \u201cusually\" to the past tense. In this case, a reasoning technique may support the problem of finding a certain rule behind relationships between source and target texts in the alignment phase (training phase). However, a well-known problem of reasoners is the poor run-time performance. Therefore, this run-time deficiency needs to be addressed or minimized before implementing reasoners successfully into MT systems.",
                "Named Entities. Most NERD approaches link recognized entities with database entries or websites. This method helps to categorize and summarize text, but also contributes to the disambiguation of words in texts. The primary issue in MT systems is caused by common words from a source language that are used as proper nouns in a target language. For instance, the word \u201cKiwi\" is a family name in New Zealand which comes from the M\u0101ori culture, but it also can be a fruit, a bird, or a computer program. Named Entities are a common and difficult problem in both MT (see Koehn BIBREF0 ) and SW fields. The SW achieved important advances in NERD using structured data and semantic annotations, e.g., by adding an rdf:type statement which identifies whether a certain kiwi is a fruit BIBREF14 . In MT systems, however, this problem is directly related to the ambiguity problem and therefore has to be resolved in that wider context.",
                "Non-standard speech. The non-standard language problem is a rather important one in the MT field. Many people use the colloquial form to speak and write to each other on social networks. Thus, when MT systems are applied on this context, the input text frequently contains slang, MWE, and unreasonable abbreviations such as \u201cIdr = I don't remember.\u201d and \u201ccya = see you\u201d. Additionally, idioms contribute to this problem, decreasing the translation quality. Idioms often have an entirely different meaning than their separated word meanings. Consequently, most translation outputs of such expressions contain errors. For a good translation, the MT system needs to recognize such slang and try to map it to the target language. Some SMT systems like Google or Bing have recognition patterns over non-standard speech from old translations through the Web using SMT approaches. In rare cases SMT can solve this problem, but considering that new idiomatic expressions appear every day and most of them are isolated sentences, this challenge still remains open. Moreover, each person has their own speaking form."
              ],
              "highlighted_evidence": [
                "On the other hand, there is also a syntactic disambiguation problem which as yet lacks good solutions.",
                "The SW achieved important advances in NERD using structured data and semantic annotations, e.g., by adding an rdf:type statement which identifies whether a certain kiwi is a fruit BIBREF14 . In MT systems, however, this problem is directly related to the ambiguity problem and therefore has to be resolved in that wider context.",
                "In rare cases SMT can solve this problem, but considering that new idiomatic expressions appear every day and most of them are isolated sentences, this challenge still remains open."
              ]
            },
            "annotation_id": "613fed4c2e83d06d8f7da6820fba08b1b9175924",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "reordering errors",
                " lexical and syntactic ambiguity"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Although MT systems are now popular on the Web, they still generate a large number of incorrect translations. Recently, Popovi\u0107 BIBREF3 has classified five types of errors that still remain in MT systems. According to research, the two main faults that are responsible for 40% and 30% of problems respectively, are reordering errors and lexical and syntactic ambiguity. Thus, addressing these barriers is a key challenge for modern translation systems. A large number of MT approaches have been developed over the years that could potentially serve as a remedy. For instance, translators began by using methodologies based on linguistics which led to the family of RBMT. However, RBMT systems have a critical drawback in their reliance on manually crafted rules, thus making the development of new translation modules for different languages even more difficult."
              ],
              "highlighted_evidence": [
                ". According to research, the two main faults that are responsible for 40% and 30% of problems respectively, are reordering errors and lexical and syntactic ambiguity. Thus, addressing these barriers is a key challenge for modern translation systems. "
              ]
            },
            "annotation_id": "b175211585f099a18ecb40f90a777aa2fed47649",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "SWT are hard to implement",
              "evidence": [
                "SW has already shown its capability for semantic disambiguation of polysemous and homonymous words. However, SWT were applied in two ways to support the semantic disambiguation in MT. First, the ambiguous words were recognized in the source text before carrying out the translation, applying a pre-editing technique. Second, SWT were applied to the output translation in the target language as a post-editing technique. Although applying one of these techniques has increased the quality of a translation, both techniques are tedious to implement when they have to translate common words instead of named entities, then be applied several times to achieve a successful translation."
              ],
              "highlighted_evidence": [
                "However, SWT were applied in two ways to support the semantic disambiguation in MT. ",
                "Although applying one of these techniques has increased the quality of a translation, both techniques are tedious to implement when they have to translate common words instead of named entities, then be applied several times to achieve a successful translation."
              ]
            },
            "annotation_id": "b37027e7e1f42b838fa4fd5220eac876dfc199fd",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": []
  },
  "1906.08871": {
    "title": "Advancing Speech Recognition With No Speech Or With Noisy Speech",
    "abstract": "In this paper we demonstrate end to end continuous speech recognition (CSR) using electroencephalography (EEG) signals with no speech signal as input. An attention model based automatic speech recognition (ASR) and connectionist temporal classification (CTC) based ASR systems were implemented for performing recognition. We further demonstrate CSR for noisy speech by fusing with EEG features.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Electroencephalography (EEG) is a non invasive way of measuring electrical activity of human brain. In BIBREF0 we demonstrated deep learning based automatic speech recognition (ASR) using EEG signals for a limited English vocabulary of four words and five vowels. In this paper we extend our work for a much larger English vocabulary and we use state-of-art end-to-end continuous speech recognition models to perform recognition. In our prior work we predicted isolated words and vowels.",
          "ASR systems forms the front end or back end in many cutting edge voice activated technologies like Amazon Alexa, Apple Siri, Windows Cortana, Samsung Bixby etc. Unfortunately these systems are trained to recognize text only from acoustic features. This limits technology accessibility to people with speaking disabilities and disorders. The research work presented in this paper tries to address this issue by investigating speech recognition using only EEG signals with no acoustic input and also by combining EEG features along with traditional acoustic features to perform recognition. We believe the former will help with speech restoration for people who can not speak at all and the latter will help people who are having speaking disabilities like broken or discontinued speech etc to use voice activated technologies with better user experience there by helping in improving technology accessibility.",
          "ASR performance is degraded in presence of noisy speech and in real life situations most of the speech is noisy. Inspired from the unique robustness to environmental artifacts exhibited by the human auditory cortex BIBREF1 , BIBREF2 we used very noisy speech data for this work and demonstrated lower word error rate (WER) for smaller corpus using EEG features, concatenation of EEG features and acoustic features.",
          "In BIBREF3 authors decode imagined speech from EEG using synthetic EEG data and connectionist temporal classification (CTC) network but in our work we use real EEG data, use EEG data recorded along with acoustics. In BIBREF4 authors perform envisioned speech recognition using random forest classifier but in our case we use end to end state of art models and perform recognition for noisy speech. In BIBREF5 authors demonstrate speech recognition using electrocorticography (ECoG) signals, which are invasive in nature but in our work we use non invasive EEG signals.",
          "This work is mainly motivated by the results explained in BIBREF0 , BIBREF6 , BIBREF7 , BIBREF3 . In BIBREF6 the authors used classification approach for identifying phonological categories in imagined and silent speech but in our work we used continuous speech recognition state of art models and our models were predicting words, characters at each time step. Similarly in BIBREF7 neural network based classification approach was used for predicting phonemes.",
          "Major contribution of this paper is the demonstration of end to end continuous noisy speech recognition using only EEG features and this paper further validates the concepts introduced in BIBREF0 for a much larger English corpus."
        ]
      },
      {
        "section_name": "Automatic Speech Recognition System Models",
        "paragraphs": [
          "An end-to-end ASR model maps input feature vectors to an output sequence of vectors of posterior probabilities of tokens without using separate acoustic model, pronunciation model and language model. In this work we implemented two different types of state of art end to end ASR models used for the task of continuous speech recognition and the input feature vectors can be EEG features or concatenation of acoustic and EEG features. We used Google's tensorflow and keras deep learning libraries for building our ASR models."
        ]
      },
      {
        "section_name": "Connectionist Temporal Classification (CTC)",
        "paragraphs": [
          "The main ideas behind CTC based ASR were first introduced in the following papers BIBREF8 , BIBREF9 . In our work we used a single layer gated recurrent unit (GRU) BIBREF10 with 128 hidden units as encoder for the CTC network. The decoder consists of a combination of a dense layer ( fully connected layer) and a softmax activation. Output at every time step of the GRU layer is fed into the decoder network. The number of time steps of the GRU encoder is equal to product of the sampling frequency of the input features and the length of the input sequence. Since different speakers have different rate of speech, we used dynamic recurrent neural network (RNN) cell. There is no fixed value for time steps of the encoder.",
          "Usually the number of time steps of the encoder (T) is greater than the length of output tokens for a continuous speech recognition problem. A RNN based CTC network tries to make length of output tokens equal to T by allowing the repetition of output prediction unit tokens and by introducing a special token called blank token BIBREF8 across all the frames. We used CTC loss function with adam optimizer BIBREF11 and during inference time we used CTC beam search decoder.",
          "We now explain the loss function used in our CTC model. Consider training data set INLINEFORM0 with training examples INLINEFORM1 and the corresponding label set INLINEFORM2 with target vectors INLINEFORM3 . Consider any training example, label pair ( INLINEFORM4 , INLINEFORM5 ). Let the number of time steps of the RNN encoder for ( INLINEFORM6 , INLINEFORM7 ) is INLINEFORM8 . In case of character based CTC model, the RNN predicts a character at every time step. Whereas in word based CTC model, the RNN predicts a word at every time step. For the sake of simplicity, let us assume that length of target vector INLINEFORM9 is equal to INLINEFORM10 . Let the probability vector output by the RNN at each time step INLINEFORM11 be INLINEFORM12 and let INLINEFORM13 value of INLINEFORM14 be denoted by INLINEFORM15 . The probability that model outputs INLINEFORM16 on input INLINEFORM17 is given by INLINEFORM18 . During the training phase, we would like to maximize the conditional probability INLINEFORM19 , and thereby define the loss function as INLINEFORM20 .",
          "In case when the length of INLINEFORM0 is less than INLINEFORM1 , we extend the target vector INLINEFORM2 by repeating a few of its values and by introducing blank token ( INLINEFORM3 ) to create a target vector of length INLINEFORM4 . Let the possible extensions of INLINEFORM5 be denoted by INLINEFORM6 . For example, when INLINEFORM7 and INLINEFORM8 , the possible extensions are INLINEFORM9 , INLINEFORM10 , INLINEFORM11 , INLINEFORM12 , INLINEFORM13 , INLINEFORM14 and INLINEFORM15 . We then define INLINEFORM16 as INLINEFORM17 .",
          "In our work we used character based CTC ASR model. CTC assumes the conditional independence constraint that output predictions are independent given the entire input sequence."
        ]
      },
      {
        "section_name": "RNN Encoder-Decoder or Attention model",
        "paragraphs": [
          "RNN encoder - decoder ASR model consists of a RNN encoder and a RNN decoder with attention mechanism BIBREF12 , BIBREF13 , BIBREF14 . The number of time steps of the encoder is equal to the product of sampling frequency of the input features and the length of input sequence. There is no fixed value for time steps in our case. We used dynamic RNN cell. We used a single layer GRU with 128 hidden units for both encoder and decoder. A dense layer followed by softmax activation is used after the decoder GRU to get the prediction probabilities. Dense layer performs an affine transformation. The number of time steps of the decoder GRU is same as the number of words present in the sentence for a given training example. Training objective is to maximize the log probability of the ordered conditionals, ie: INLINEFORM0 , where X is input feature vector, INLINEFORM1 's are the labels for the ordered words present in that training example and INLINEFORM2 is the length of the output label sentence for that example. Cross entropy was used as the loss function with adam as the optimizer. We used teacher forcing algorithm BIBREF15 to train the model. During inference time we used beam search decoder.",
          "We now explain the attention mechanism used in our attention model. Consider any training example, label pair ( INLINEFORM0 , INLINEFORM1 ). Let the number of times steps of encoder GRU for that example be INLINEFORM2 . The GRU encoder will transform the input features ( INLINEFORM3 ) into hidden output feature vectors ( INLINEFORM4 ). Let INLINEFORM5 word label in INLINEFORM6 (sentence) be INLINEFORM7 , then to predict INLINEFORM8 at decoder time step INLINEFORM9 , context vector INLINEFORM10 is computed and fed into the decoder GRU. INLINEFORM11 is computed as INLINEFORM12 , where INLINEFORM13 is the attention weight vector satisfying the property INLINEFORM14 .",
          " INLINEFORM0 can be intuitively seen as a measure of how much attention INLINEFORM1 must pay to INLINEFORM2 , INLINEFORM3 . INLINEFORM4 is mathematically defined as INLINEFORM5 , where INLINEFORM6 is hidden state of the decoder GRU at time step INLINEFORM7 .",
          "The way of computing value for INLINEFORM0 depends on the type of attention used. In this work, we used bahdanau's additive style attention BIBREF13 , which defines INLINEFORM1 as INLINEFORM2 ) where INLINEFORM3 and INLINEFORM4 are learnable parameters during training of the model."
        ]
      },
      {
        "section_name": "Design of Experiments for building the database",
        "paragraphs": [
          "We built two types of simultaneous speech EEG recording databases for this work. For database A five female and five male subjects took part in the experiment. For database B five male and three female subjects took part in the experiment. Except two subjects, rest all were native English speakers for both the databases. All subjects were UT Austin undergraduate,graduate students in their early twenties.",
          "For data set A, the 10 subjects were asked to speak the first 30 sentences from the USC-TIMIT database BIBREF16 and their simultaneous speech and EEG signals were recorded. This data was recorded in presence of background noise of 40 dB (noise generated by room air conditioner fan). We then asked each subject to repeat the same experiment two more times, thus we had 30 speech EEG recording examples for each sentence.",
          "For data set B, the 8 subjects were asked to repeat the same previous experiment but this time we used background music played from our lab computer to generate a background noise of 65 dB. Here we had 24 speech EEG recording examples for each sentence.",
          "We used Brain Vision EEG recording hardware. Our EEG cap had 32 wet EEG electrodes including one electrode as ground as shown in Figure 1. We used EEGLab BIBREF17 to obtain the EEG sensor location mapping. It is based on standard 10-20 EEG sensor placement method for 32 electrodes.",
          "For data set A, we used data from first 8 subjects for training the model, remaining two subjects data for validation and test set respectively.",
          "For data set B, we used data from first 6 subjects for training the model, remaining two subjects data for validation and test set respectively."
        ]
      },
      {
        "section_name": "EEG and Speech feature extraction details",
        "paragraphs": [
          "EEG signals were sampled at 1000Hz and a fourth order IIR band pass filter with cut off frequencies 0.1Hz and 70Hz was applied. A notch filter with cut off frequency 60 Hz was used to remove the power line noise. EEGlab's BIBREF17 Independent component analysis (ICA) toolbox was used to remove other biological signal artifacts like electrocardiography (ECG), electromyography (EMG), electrooculography (EOG) etc from the EEG signals. We extracted five statistical features for EEG, namely root mean square, zero crossing rate,moving window average,kurtosis and power spectral entropy BIBREF0 . So in total we extracted 31(channels) X 5 or 155 features for EEG signals.The EEG features were extracted at a sampling frequency of 100Hz for each EEG channel.",
          "We used spectral entropy because it captures the spectral ( frequency domain) and signal complexity information of EEG. It is also a widely used feature in EEG signal analysis BIBREF18 . Similarly zero crossing rate was chosen as it is a commonly used feature both for speech recognition and bio signal analysis. Remaining features were chosen to capture time domain statistical information. We performed lot of experiments to identify this set of features. Initially we used only spectral entropy and zero crossing rate but we noticed that the performance of the ASR system significantly went up by 20 % when we added the remaining additional features.",
          "The recorded speech signal was sampled at 16KHz frequency. We extracted Mel-frequency cepstrum (MFCC) as features for speech signal. We first extracted MFCC 13 features and then computed first and second order differentials (delta and delta-delta) thus having total MFCC 39 features. The MFCC features were also sampled at 100Hz same as the sampling frequency of EEG features to avoid seq2seq problem."
        ]
      },
      {
        "section_name": "EEG Feature Dimension Reduction Algorithm Details",
        "paragraphs": [
          "After extracting EEG and acoustic features as explained in the previous section, we used non linear methods to do feature dimension reduction in order to obtain set of EEG features which are better representation of acoustic features. We reduced the 155 EEG features to a dimension of 30 by applying Kernel Principle Component Analysis (KPCA) BIBREF19 .We plotted cumulative explained variance versus number of components to identify the right feature dimension as shown in Figure 2. We used KPCA with polynomial kernel of degree 3 BIBREF0 . We further computed delta, delta and delta of those 30 EEG features, thus the final feature dimension of EEG was 90 (30 times 3) for both the data sets.",
          "When we used the EEG features for ASR without dimension reduction, the ASR performance went down by 40 %. The non linear dimension reduction of EEG features significantly improved the performance of ASR."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "The attention model was predicting a word and CTC model was predicting a character at every time step, hence we used word error rate (WER) as performance metric to evaluate attention model and character error rate (CER) for CTC model for different feature sets as shown below.",
          "Table i@ and ii@ shows the test time results for attention model for both the data sets when trained using EEG features and concatenation of EEG, acoustic features respectively. As seen from the results the attention model gave lower WER when trained and tested on smaller number of sentences. As the vocabulary size increase, the WER also went up. We believe for the attention model to achieve lower WER for larger vocabulary size more number of training examples or larger training data set is required as large number of weights need to be adapted. Figure 3 shows the training loss convergence of our attention model.",
          "Table iv@ and v@ shows the results obtained using CTC model. The error rates for CTC model also went up with the increase in vocabulary size for both the data sets. However the CTC model was trained for 500 epochs compared to 100 epochs for attention model to observe loss convergence and batch size was set to one for CTC model. Thus CTC model training was lot more time consuming than attention model.",
          "In BIBREF0 we have demonstrated that EEG sensors T7 and T8 features contributed most towards ASR performance. Table vi@ shows the CTC model test time results when we trained the model using EEG features from only T7 and T8 sensors on the most noisy data set B. We observed that as vocabulary size increase, error rates were slightly lower than the error rates from Table iv@ where we used EEG features from all 31 sensors with dimension reduction. Table iii@ shows the results for attention model when trained with EEG features from sensors T7 and T8 only on data set B. We observed that error rates were higher in this case compared to the error rates reported in table ii@.",
          "Figures 4 shows the visualization of the attention weights when the attention model was trained and tested using only EEG features for Data set B. The plots shows the EEG feature importance ( attention) distribution across time steps for predicting first sentence and it indicates that attention model was not able to attend properly to EEG features, which might be another reason for giving higher WER."
        ]
      },
      {
        "section_name": "Conclusion and Future work",
        "paragraphs": [
          "In this paper we demonstrated the feasibility of using EEG features, concatenation of EEG and acoustic features for performing noisy continuous speech recognition. To our best knowledge this is the first time a continuous noisy speech recognition is demonstrated using only EEG features.",
          "For both attention and CTC model we observed that as the vocabulary size increase, concatenating acoustic features with EEG features will help in reducing the test time error rates.",
          "We further plan to publish our speech EEG data base used in this work to help advancement of research in this area.",
          "For future work, we plan to build a much larger speech EEG data base and also perform experiments with data collected from subjects with speaking disabilities.",
          "We will also investigate whether it is possible to improve the attention model results by tuning hyper parameters to improve the model's ability to condition on the input,improve CTC model results by training with more number of examples and by using external language model during inference time."
        ]
      },
      {
        "section_name": "Acknowledgement",
        "paragraphs": [
          "We would like to thank Kerry Loader and Rezwanul Kabir from Dell, Austin, TX for donating us the GPU to train the models used in this work."
        ]
      }
    ],
    "qas": [
      {
        "question": "what were the baselines?",
        "question_id": "010fd15696580d9924ac0275a4ff269005e5808d",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "0df546c1949acf5453a7057eee364829c60124f0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "923d600ccb51990a0c6ed481c4608dc127de79cb",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "f5207f400a6c3204900bead95cf16c739394c522",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Fig. 1. EEG channel locations for the cap used in our experiments"
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Fig. 2. Explained variance plot"
      },
      {
        "file": "4-Figure5-1.png",
        "caption": "Fig. 5. Training loss convergence for CTC model using only EEG features for first 3 sentences from data set B"
      },
      {
        "file": "4-TableI-1.png",
        "caption": "TABLE I WER ON TEST SET FOR ATTENTION MODEL FOR DATA SET A"
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Fig. 3. Training loss convergence for attention model using only EEG features for first 10 sentences from data set A"
      },
      {
        "file": "4-TableII-1.png",
        "caption": "TABLE II WER ON TEST SET FOR ATTENTION MODEL FOR DATA SET B"
      },
      {
        "file": "4-TableIII-1.png",
        "caption": "TABLE III WER ON TEST SET FOR ATTENTION MODEL FOR DATA SET B USING EEG FEATURES FROM ONLY T7 AND T8 ELECTRODES"
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Fig. 4. Visualization of attention weights for the first sentence"
      },
      {
        "file": "5-TableIV-1.png",
        "caption": "TABLE IV CER ON TEST SET FOR CTC MODEL FOR DATA SET B"
      },
      {
        "file": "5-TableV-1.png",
        "caption": "TABLE V CER ON TEST SET FOR CTC MODEL FOR DATA SET A"
      },
      {
        "file": "5-TableVI-1.png",
        "caption": "TABLE VI CER ON TEST SET FOR CTC MODEL FOR DATA SET B USING EEG FEATURES FROM ONLY T7 AND T8 ELECTRODES"
      },
      {
        "file": "5-TableVII-1.png",
        "caption": "TABLE VII CER ON TEST SET FOR CTC MODEL FOR DATA SET A FOR MFCC-EEG FUSION FOR LARGER VOCABULARY SIZE"
      },
      {
        "file": "5-TableVIII-1.png",
        "caption": "TABLE VIII CER ON TEST SET FOR CTC MODEL FOR DATA SET B FOR MFCC-EEG FUSION FOR LARGER VOCABULARY SIZE"
      }
    ]
  },
  "2004.04124": {
    "title": "LadaBERT: Lightweight Adaptation of BERT through Hybrid Model Compression",
    "abstract": "BERT is a cutting-edge language representation model pre-trained by a large corpus, which achieves superior performances on various natural language understanding tasks. However, a major blocking issue of applying BERT to online services is that it is memory-intensive and leads to unsatisfactory latency of user requests, raising the necessity of model compression. Existing solutions leverage the knowledge distillation framework to learn a smaller model that imitates the behaviors of BERT. However, the training procedure of knowledge distillation is expensive itself as it requires sufficient training data to imitate the teacher model. In this paper, we address this issue by proposing a hybrid solution named LadaBERT (Lightweight adaptation of BERT through hybrid model compression), which combines the advantages of different model compression methods, including weight pruning, matrix factorization and knowledge distillation. LadaBERT achieves state-of-the-art accuracy on various public datasets while the training overheads can be reduced by an order of magnitude.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The pre-trained language model, BERT BIBREF0 has led to a big breakthrough in various kinds of natural language understanding tasks. Ideally, people can start from a pre-trained BERT checkpoint and fine-tune it on a specific downstream task. However, the original BERT models are memory-exhaustive and latency-prohibitive to be served in embedded devices or CPU-based online environments. As the memory and latency constraints vary in different scenarios, the pre-trained BERT model should be adaptive to different requirements with accuracy retained to the largest extent. Existing BERT-oriented model compression solutions largely depend on knowledge distillation BIBREF1, which is inefficient and resource-consuming because a large training corpus is required to learn the behaviors of a teacher. For example, DistilBERT BIBREF2 is re-trained on the same corpus as pre-training a vanilla BERT from scratch; and TinyBERT BIBREF3 utilizes expensive data augmentation to fit the distillation target. The costs of these model compression methods are as large as pre-training and unaffordable for low-resource settings. Therefore, it is straight-forward to ask, can we design a lightweight method to generate adaptive models with comparable accuracy using significantly less time and resource consumption? In this paper, we propose LadaBERT (Lightweight adaptation of BERT through hybrid model compression) to tackle the raised questions. Specifically, LadaBERT is based on an iterative hybrid model compression framework consisting of weighting pruning, matrix factorization and knowledge distillation. Initially, the architecture and weights of student model are inherited from the BERT teacher. In each iteration, the student model is first compressed by a small ratio based on weight pruning and matrix factorization, and is then fine-tuned under the guidance of teacher model through knowledge distillation. Because weight pruning and matrix factorization help to generate better initial and intermediate status",
          "in the knowledge distillation iterations, the accuracy and efficiency of model compression can be greatly improved.",
          "We conduct extensive experiments on five public datasets of natural language understanding. As an example, the performance comparison of LadaBERT and state-of-the-art models on MNLI-m dataset is illustrated in Figure FIGREF1. We can see that LadaBERT outperforms other BERT-oriented model compression baselines at various model compression ratios. Especially, LadaBERT-1 outperforms BERT-PKD significantly under $2.5\\times $ compression ratio, and LadaBERT-3 outperforms TinyBERT under $7.5\\times $ compression ratio while the training speed is accelerated by an order of magnitude.",
          "The rest of this paper is organized as follows. First, we summarizes the related works of model compression and their applications to BERT in Section SECREF2. Then, the methodology of LadaBERT is introduced in Section SECREF3, and experimental results are presented in Section SECREF4. At last, we conclude this work and discuss future works in Section SECREF5."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Deep Neural Networks (DNNs) have achieved great success in many areas in recent years, but the memory consumption and computational cost expand greatly with the growing complexity of models. Therefore, model compression has become an indispensable technique for practice, especially in low-resource settings. In this section, we review the current progresses of model compression techniques briefly, which can be divided into four categories, namely weight pruning, matrix factorization, weight quantization and knowledge distillation. We also present hybrid approaches and the applications of model compression to pre-trained BERT models."
        ]
      },
      {
        "section_name": "Related Work ::: Weight pruning",
        "paragraphs": [
          "Numerous researches have shown that removing a large portion of connections or neurons does not cause significant performance drop in deep neural network models BIBREF4, BIBREF5, BIBREF6, BIBREF7. For example, Han et al. BIBREF4 proposed a method to reduce the storage and computation of neural networks by removing unimportant connections, resulting in sparse networks without affecting the model accuracy. Li et al. BIBREF5 presented an acceleration method for convolution neural network by pruning whole filters together with their connecting filter maps. This approach does not generate sparse connectivity patterns and brings much larger acceleration ratio with existing BLAS libraries for dense matrix multiplications. Ye et al. BIBREF8 argued that small weights are in fact important for preserving the performance of a model, and Hu et al. BIBREF6 alleviated this problem by a data-driven approach that pruned zero-activation neurons iteratively based on intermediate feature maps. Zhu and Gupta BIBREF7 empirically compared large-sparse models with smaller dense models of similar parameter sizes and found that large sparse models performed better consistently. In addition, sparsity-induced models BIBREF9, BIBREF10, BIBREF11 can be regarded as similar methods as pruning. For example, Wen et al. BIBREF9 applied group lasso as a regularizer at training time, and Louizos et al. BIBREF10 learned sparse neural networks through $l_0$ regularization."
        ]
      },
      {
        "section_name": "Related Work ::: Matrix factorization",
        "paragraphs": [
          "The goal of matrix factorization is to decompose a matrix into the product of two matrices in lower dimensions, and Singular Value Decomposition (SVD) is a popular way of matrix factorization that generalizes the eigendecomposition of a square normal matrix to a $m \\times n$ matrix. It has been proved that SVD is the best approximation of a matrix given the rank $r$ under Frobenius norm BIBREF12. Matrix factorization was widely studied in the deep learning domain for model compression and acceleration BIBREF13, BIBREF14, BIBREF15. Sainath et al BIBREF13 explored a low-rank matrix factorization method of DNN layers for acoustic modeling. Xu et al. BIBREF14, BIBREF15 applied singular value decomposition to deep neural network acoustic models and achieved comparable performances with state-of-the-art models through much fewer parameters. GroupReduce BIBREF16 focused on the compression of neural language models and applied low-rank matrix approximation to vocabulary-partition. Acharya et al. BIBREF17 compressed the word embedding layer via matrix factorization and achieved promising results in text classification. Winata et al. BIBREF18 carried out experiments for low-rank matrix factorization on different NLP tasks and demonstrated that it was more effective in general than weight pruning."
        ]
      },
      {
        "section_name": "Related Work ::: Weight quantization",
        "paragraphs": [
          "Weight quantization is a common technique for compressing deep neural networks, which aims to reduce the number of bits to represent every weight in the model. In a neural network, parameters are stacked into clusters, and the parameters in the same cluster share the same value. With weight quantization, the weights can be reduced to at most 1-bit binary value from 32-bits floating point numbers. Zhou et al. BIBREF19 showed that quantizing weights to 8-bits does not hurt the performance, and Binarized Neural Networks BIBREF20 contained binary weights and activations of only one bit. Incremental Network Quantization BIBREF21 converted a pre-trained full-precision neural network into low-precision counterpart through three interdependent operations: weight partition, groupwise quantization and re-training. Variational Network Quantization BIBREF22 formulated the problem of network quantization as a variational inference problem. Moreover, Choi et al. BIBREF23 investigated the drawbacks of conventional quantization methods based on k-means and proposed a Hessian-weighted k-means clustering algorithm as the solution."
        ]
      },
      {
        "section_name": "Related Work ::: Knowledge distillation",
        "paragraphs": [
          "Knowledge distillation is first proposed by BIBREF1, which trains a compact or smaller model to approximate the function learned by a large and complex model. A preliminary step of knowledge distillation is to train a deep network (the teacher model) that automatically generates soft labels for training instances. This \u201csynthetic\" label is then used to train a smaller network (the student model), which assimilates the function that is learned by the teacher model. Chen et al. BIBREF24 successfully applied knowledge distillation to object detection tasks by introducing several modifications, including a weighted cross-entropy loss, a teacher bounded loss, and adaptation layers to model intermediate teacher distributions. Li et al. BIBREF25 developed a framework to learn from noisy labels, where the knowledge learned from a clean dataset and semantic knowledge graph were leveraged to correct the wrong labels. Anil et al. BIBREF26 proposed online distillation, a variant of knowledge distillation which enabled extra parallelism for training large-scale data. In addition, knowledge distillation is also useful for aggregating model ensembles into a single model by treating the ensemble model as a teacher."
        ]
      },
      {
        "section_name": "Related Work ::: Hybrid approach",
        "paragraphs": [
          "To improve the performance of model compression, there are many attempts to conduct hybrid model compression method that combines more than one category of algorithms. Han et al. BIBREF27 combined quantization, hamming coding and weight pruning to conduct model compression on image classification tasks. Yu et al. BIBREF28 proposed a unified framework for low-rank and sparse decomposition of weight matrices with feature map reconstructions. Polino et al. BIBREF29 advocated a combination of distillation and quantization techniques and proposed two hybrid models, i.e., quantified distillation and differentiable quantization to address this problem. Li et al., BIBREF30 compressed DNN-based acoustic model through knowledge distillation and pruning. NNCF BIBREF31 provided a neural network compression framework that supported an integration of various model compression methods to generate more lightweight networks and achieved state-of-the-art performances in terms of a trade-off between accuracy and efficiency. In BIBREF32, an AutoML pipeline was adopted for model compression. It leveraged reinforcement learning to search for the best model compression strategy among multiple combinatorial configurations."
        ]
      },
      {
        "section_name": "Related Work ::: BERT model compression",
        "paragraphs": [
          "In the natural language processing community, there is a growing interest recently to study BERT-oriented model compression for shipping its performance gain into latency-critical or low-resource scenarios. Most existing works focus on knowledge distillation. For instance, BERT-PKD BIBREF33 is a patient knowledge distillation approach that compresses the original BERT model into a lightweight shallow network. Different from traditional knowledge distillation methods, BERT-PKD enables an exploitation of rich information in the teacher's hidden layers by utilizing a layer-wise distillation constraint. DistillBERT BIBREF2 pre-trains a smaller general-purpose language model on the same corpus as vanilla BERT. Distilled BiLSTM BIBREF34 adopts a single-layer BiLSTM as the student model and achieves comparable results with ELMo BIBREF35 through much fewer parameters and less inference time. TinyBERT BIBREF3 reports the best-ever performance on BERT model compression, which exploits a novel attention-based distillation schema that encourages the linguistic knowledge in teacher to be well transferred into the student model. It adopts a two-stage learning framework, including general distillation (pre-training from scratch via distillation loss) and task-specific distillation with data augmentation. Both procedures require huge resources and long training times (from several days to weeks), which is cumbersome for industrial applications. Therefore, we are aiming to explore more lightweight solutions in this paper."
        ]
      },
      {
        "section_name": "Lightweight Adaptation of BERT ::: Overview",
        "paragraphs": [
          "The overall pipeline of LadaBERT (Lightweight Adaptation of BERT) is illustrated in Figure FIGREF8. As shown in the figure, the pre-trained BERT model (e.g., BERT-Base) is served as the teacher as well as the initial status of the student model. Then, the student model is compressed towards smaller parameter size through a hybrid model compression framework in an iterative manner until the target compression ratio is reached. Concretely, in each iteration, the parameter size of student model is first reduced by $1-\\Delta $ based on weight pruning and matrix factorization, and then the parameters are fine-tuned by the loss function of knowledge distillation. The motivation behind is that matrix factorization and weight pruning are complementary with each other. Matrix factorization calculates the optimal approximation under a certain rank, while weight pruning introduces additional sparsity to the decomposed matrices. Moreover, weight pruning and matrix factorization generates better initial and intermediate status of the student model, which improve the efficiency and effectiveness of knowledge distillation. In the following subsections, we will introduce the algorithms in detail."
        ]
      },
      {
        "section_name": "Lightweight Adaptation of BERT ::: Overview ::: Matrix factorization",
        "paragraphs": [
          "We use Singular Value Decomposition (SVD) for matrix factorization. Each parameter matrix, including the embedding layer are compressed by SVD. Without loss generality, we assume a matrix of parameters ${W} \\in \\mathbb {R}^{m\\times n}$, the singular value decomposition of which can be written as:",
          "where ${U} \\in \\mathbb {R}^{m \\times p}$ and ${V} \\in \\mathbb {R}^{p \\times n}$. ${\\Sigma } =diag(\\sigma _1,\\sigma _2,\\ldots ,\\sigma _p)$ is a diagonal matrix composed of singular values and $p$ is the full rank of $W$ satisfying $p \\le min(m, n)$.",
          "To compress this weight matrix, we select a lower rank $r$. The diagonal matrix ${\\Sigma }$ is truncated by selecting the top $r$ singular values. i.e., ${\\Sigma }_r =diag(\\sigma _1, \\sigma _2,\\ldots ,\\sigma _r)$, while ${U}$ and ${V}$ are also truncated by selecting the top $r$ columns and rows respectively, resulting in ${U}_r \\in \\mathbb {R}^{m\\times r}$ and ${V}_r \\in \\mathbb {R}^{r\\times n}$.",
          "Thus, low-rank matrix approximation of ${W}$ can be formulated as:",
          "In this way, the original weight matrix $W$ is decomposed by the multiplication of two smaller matrices, where ${A}={U}_r\\sqrt{{\\Sigma }_r} \\in \\mathbb {R}^{n\\times r}$ and ${B}={V}_r\\sqrt{{\\Sigma }_r} \\in \\mathbb {R}^{m\\times r}$. These two matrices are initialized by SVD and will be further tuned during training.",
          "Given a rank $r \\le min(m, n)$, the compression ratio of matrix factorization is defined as:",
          "Therefore, for a target model compression ratio $P_{svd}$, the desired rank $r$ can be calculated by:"
        ]
      },
      {
        "section_name": "Lightweight Adaptation of BERT ::: Overview ::: Weight pruning",
        "paragraphs": [
          "Weight pruning BIBREF4 is an unstructured compression method that induces desirable sparsity for a neural network model. For a neural network $f({x; \\theta })$ with parameters $\\theta $, weight pruning finds a binary mask ${M} \\in \\lbrace 0, 1\\rbrace ^{|\\theta |}$ subject to a given sparsity ratio, $P_{weight}$. The neural network after pruning will be $f({x; M \\cdot \\theta })$, where the non-zero parameter size is $||{M}||_1 = P_{weight}\\cdot |\\theta |$, where $|\\theta |$ is the number of parameters in $\\theta $. For example, when $P_m = 0.3$, there are 70% zeros and 30% ones in the mask ${m}$. We adopt a simple pruning strategy in our implementation: the binary mask is generated by setting the smallest weights to zeros BIBREF36.",
          "To combine the benefits of weight pruning with matrix factorization, we leverage a hybrid approach that applies weight pruning on the basis of decomposed matrices generated by SVD. Following Equation (DISPLAY_FORM12), SVD-based matrix factorization for any weight matrix ${W}$ can be written as: ${W}_{svd}={A}_{m\\times r}{B}_{n\\times r}^T$. Then, weight pruning is applied on the decomposed matrices ${A} \\in \\mathbb {R}^{m \\times r}$ and ${B} \\in \\mathbb {R}^{n \\times r}$ separately. The weight matrix after hybrid compression is denoted by:",
          "where ${M_A}$ and ${M_B}$ are binary masks derived by the weight pruning algorithm with compression ratio $P_{weight}$. The compression ratio of this hybrid approach can be calculated by:",
          "In LadaBERT, the hybrid compression produce is applied to each layer of the pre-trained BERT model. Given an overall model compression target $P$, the following constraint should be satisfied:",
          "where $|\\theta |$ is the total number of model parameters and $P$ is the target compression ratio; $|\\theta _{embd}|$ denotes the parameter number of embedding layer, which has a relative compression ratio of $P_embd$, and $|\\theta _{encd}|$ denotes the number of parameters of all layers in BERT encoder, which have a compression ratio of $P_{hybrid}$. The classification layer (often MLP layer with Softmax activation) has a small parameter size ($|\\theta _{cls}|$), so it is not modified in the model compression procedure. In the experiments, these fine-grained compression ratios can be optimized by random search on the validation data."
        ]
      },
      {
        "section_name": "Lightweight Adaptation of BERT ::: Knowledge distillation",
        "paragraphs": [
          "Knowledge distillation (KD) has been widely used to transfer knowledge from a large teacher model to a smaller student model. In other words, the student model mimics the behavior of the teacher model by minimize the knowledge distillation loss functions. Various types of knowledge distillation can be employed at different sub-layers. Generally, all types of knowledge distillation can be modeled as minimizing the following loss function:",
          "Where $x$ indicates a sample input and $\\mathcal {X}$ is the training dataset. $f^{(s)}({x})$ and $f^{(t)}({x})$ represent intermediate outputs or weight matrices for the student model and teacher model correspondingly. $L(\\cdot )$ represents for a loss function which can be carefully defined for different types of knowledge distillation. We follow the recent technique proposed by TinyBERT BIBREF3, which applies knowledge distillation constraints upon embedding, self-attention, hidden representation and prediction levels. Concretely, there are four types of knowledge distillation constraints as follows:",
          "Embedding-layer distillation is performed upon the embedding layer. $f({x}) \\in \\mathbb {R}^{n \\times d}$ represents for the word embedding output for input $x$, where $n$ is the input word length and $d$ is the dimension of word embedding. Mean Squared Error (MSE) is adopted as the loss function $L(\\cdot )$.",
          "Attention-layer distillation is performed upon the self-attention sub-layer. $f({x}) = \\lbrace a_{ij}\\rbrace \\in \\mathbb {R}^{n \\times n}$ represents the attention output for each self-attention sub-layer, and $L(\\cdot )$ denotes MSE loss function.",
          "Hidden-layer Distillation is performed at each fully-connected sub-layer in the Transformer architectures. $f({x})$ denotes the output representation of the corresponding sub-layer, and $L(\\cdot )$ also adopts MSE loss function.",
          "Prediction-layer distillation makes the student model to learns the predictions from a teacher model directly. It is identical to the vanilla form of knowledge distillation BIBREF1. It takes the soft cross-entropy loss function, which is formulated as:",
          "where $f^t({x})$ and $f^s({x})$ are the predictive logits of teacher and student models respectively."
        ]
      },
      {
        "section_name": "Experiments ::: Datasets & Baselines",
        "paragraphs": [
          "We compare LadaBERT with state-of-the-art model compression approaches on five public datasets of different tasks of natural language understanding, including sentiment classification (SST-2), natural language inference (MNLI-m, MNLI-mm, QNLI) and pairwise semantic equivalence (QQP). The statistics of these datasets are described in Table TABREF27.",
          "The baseline approaches are summarized below.",
          "Weight pruning and matrix factorization are two simple baselines described in Section SECREF2. We evaluate both pruning methods in an iterative manner until the target compression ratio is reached.",
          "Hybrid pruning is a combination of matrix factorization and weight pruning, which conducts iterative weight pruning on the basis of SVD-based matrix factorization. It is performed iteratively until the desired compression ratio is achieved.",
          "BERT-FT, BERT-KD and BERT-PKD are reported in BIBREF33, where BERT-FT directly fine-tunes the model via supervision labels, BERT-KD is the vanilla knowledge distillation algorithm BIBREF1, and BERT-PKD stands for Patient Knowledge Distillation proposed in BIBREF33. The student model is composed of 3 Transformer layers, resulting in a $2.5\\times $ compression ratio. Each layer has the same hidden size as the pre-trained teacher, so the initial parameters of student model can be inherited from the corresponding teacher.",
          "TinyBERT BIBREF3 instantiates a tiny student model, which has totally 14.5M parameters ($7.5\\times $ compression ratio) composed of 4 layers, 312 hidden units, 1200 intermediate size and 12 heads. For a fair comparison, we reproduce the TinyBERT pipeline without general distillation and data augmentation, which is time-exhaustive and resource-consuming.",
          "BERT-SMALL has the same model architecture as TinyBERT, but is directly pre-trained by the official BERT pipeline. The performance values are inherited from BIBREF3 for reference.",
          "Distilled-BiLSTM BIBREF34 leverages a single-layer bidirectional-LSTM as the student model, where the hidden units and intermediate size are set to be 300 and 400 respectively, resulting in a $10.8 \\times $ compression ratio. This model requires a expensive pre-training process using the knowledge distillation constraints."
        ]
      },
      {
        "section_name": "Experiments ::: Setup",
        "paragraphs": [
          "We leverage the pre-trained checkpoint of base-bert-uncased as the initial model for compression, which contains 12 layers, 12 heads, 110M parameters, and 768 hidden units per layer. Hyper-parameter selection is conducted on the validation data for each dataset. After training, the prediction results are submitted to the GLUE-benchmark evaluation platform to get the evaluation performance on test data.",
          "For a comprehensive evaluation, we experiment with four settings of LadaBERT, namely LadaBERT-1, -2, -3 and -4, which reduce the model parameters of BERT-Base by 2.5, 5, 7.5 and 10 times respectively. In our experiment, we take the batch size as 32, learning rate as 2e-5. The optimizer is BertAdam with default setting. Fine-grained compression ratios are optimized by random search and shown in Table TABREF38."
        ]
      },
      {
        "section_name": "Experiments ::: Performance Comparison",
        "paragraphs": [
          "The evaluation results of LadaBERT and state-of-the-art approaches are listed in Table TABREF40, where the models are ranked by parameter sizes for feasible comparison. As shown in the table, LadaBERT consistently outperforms the strongest baselines under similar model sizes. In addition, the performance of LadaBERT demonstrates the superiority of hybrid combination of SVD-based matrix factorization, weight pruning and knowledge distillation.",
          "With model size of $2.5\\times $ reduction, LadaBERT-1 performs significantly better than BERT-PKD, boosting the performance by relative 8.9, 8.1, 6.1, 3.8 and 5.8 percentages on MNLI-m, MNLI-mm, SST-2, QQP and QNLI datasets respectively. Recall that BERT-PKD initializes the student model by selecting 3 of 12 layers in the pre-trained BERT-Base model. It turns out that the discarded layers have huge impact on the model performance, which is hard to be recovered by knowledge distillation. On the other hand, LadaBERT generates the student model by iterative pruning on the pre-trained teacher. In this way, the original knowledge in the teacher model can be preserved to the largest extent, and the benefit of which is complementary to knowledge distillation.",
          "LadaBERT-3 has a comparable size as TinyBERT with a $7.5 \\times $ compression ratio. As shown in the results, TinyBERT does not work well without expensive data augmentation and general distillation, hindering its application to low-resource settings. The reason is that the student model of TinyBERT is distilled from scratch, so it requires much more data to mimic the teacher's behaviors. Instead, LadaBERT has better initial and intermediate status calculated by hybrid model compression, which is much more light-weighted and achieves competitive performances with much faster learning speed (learning curve comparison is shown in Section SECREF41). Moreover, LadaBERT-3 also outperforms BERT-SMALL on most of the datasets, which is pre-trained from scratch by the official BERT pipeline on a $7.5 \\times $ smaller architecture. This indicates that LadaBERT can quickly adapt to a smaller model size and achieve competitive performance without expansive re-training on a large corpus.",
          "Moreover, Distilled-BiLSTM performs well on SST-2 dataset with more than $10 \\times $ compression ratio, perhaps owing to its advantage of generalization on small datasets. Nevertheless, the performance of LadaBERT-4 is competitive on larger datasets such as MNLI and QQP. This is impressive as LadaBERT is much more efficient without exhaustive re-training on a large corpus. In addition, the inference speed of BiLSTM is usually slower than transformer-based models with similar parameter sizes."
        ]
      },
      {
        "section_name": "Experiments ::: Learning curve comparison",
        "paragraphs": [
          "To further demonstrate the efficiency of LadaBERT, we visualize the learning curves on MNLI-m and QQP datasets in Figure FIGREF42 and FIGREF42, where LadaBERT-3 is compared to the strongest baseline, TinyBERT, under $7.5 \\times $ compression ratio. As shown in the figures, LadaBERT-3 achieves good performances much faster and results in a better convergence point. After training $2 \\times 10^4$ steps (batches) on MNLI-m dataset, the performance of LadaBERT-3 is already comparable to TinyBERT after convergence (approximately $2 \\times 10^5$ steps), achieving nearly $10 \\times $ acceleration. And on QQP dataset, both performance improvement and training speed acceleration is very significant. This clearly shows the superiority of combining matrix factorization, weight pruning and knowledge distillation in a reinforce manner. Instead, TinyBERT is based on pure knowledge distillation, so the learning speed is much slower."
        ]
      },
      {
        "section_name": "Experiments ::: Effect of low-rank + sparsity",
        "paragraphs": [
          "In this paper, we demonstrate that a combination of matrix factorization and weight pruning is better than single solutions for BERT-oriented model compression. Similar phenomena has been reported in the computer vision scenarios BIBREF28, which shows that low-rank and sparsity are complementary to each other. Here we provide another explanation to support this observation.",
          "In Figure FIGREF44, we visualize the distribution of errors for a weight matrix in the neural network after pruning to 20% of its original parameter size. The errors can be calculated by $\\mathop {Error}=||\\hat{{M}}-{M}||_1$, where $\\hat{{M}}$ denotes the weight matrix after pruning.",
          "The yellow line in Figure FIGREF44 shows the distribution of errors generated by pure weight pruning, which has a sudden drop at the pruning threshold. The orange line represents for pure SVD pruning, which turns out to be smoother and aligned with Gaussian distribution. The blue line shows the result of hybrid pruning, which conducts weight pruning on the decomposed matrices. First, we apply SVD-based matrix factorization to reduce 60% of total parameters. Then, weight pruning is applied on the decomposed matrices by 50%, resulting in only 20% parameters while the error distribution changes slightly. As a result, it has smaller mean and deviation than pure matrix factorization. In addition, a smoother distribution is more appropriate for the knowledge distillation procedure to fine-tune the weights, so it is advantageous than pure weight pruning."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Model compression is a common way to deal with latency-critical or memory-intensive scenarios. Existing model compression methods for BERT need to be re-trained on a large corpus to reserve its original performance, which is inapplicable in low-resource settings. In this paper, we propose LadaBERT to address this problem. LadaBERT is a lightweight model compression pipeline that generates adaptive BERT model efficiently based on a given task and specific constraint. It is based on a hybrid solution, which conducts matrix factorization, weight pruning and knowledge distillation in a reinforce manner. The experimental results verify that EAdaBERT is able to achieve comparable performance with other state-of-the-art solutions using much less training data and time budget. Therefore, LadaBERT can be easily plugged into various applications with competitive performances and little training overheads. In the future, we would like to apply LadaBERT to large-scale industrial applications, such as search relevance and query recommendation."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they evaluate which compression method yields the most gains?",
        "question_id": "f6346828c2f44529dc307abf04dd246bfeb4a9b2",
        "nlp_background": "",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "In this paper, we demonstrate that a combination of matrix factorization and weight pruning is better than single solutions for BERT-oriented model compression. Similar phenomena has been reported in the computer vision scenarios BIBREF28, which shows that low-rank and sparsity are complementary to each other. Here we provide another explanation to support this observation."
              ],
              "highlighted_evidence": [
                "In this paper, we demonstrate that a combination of matrix factorization and weight pruning is better than single solutions for BERT-oriented model compression. "
              ]
            },
            "annotation_id": "50f4b45ad6cabdb44701a8b6ff071ef50015f033",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "The evaluation results of LadaBERT and state-of-the-art approaches are listed in Table TABREF40, where the models are ranked by parameter sizes for feasible comparison. As shown in the table, LadaBERT consistently outperforms the strongest baselines under similar model sizes. In addition, the performance of LadaBERT demonstrates the superiority of hybrid combination of SVD-based matrix factorization, weight pruning and knowledge distillation.",
                "With model size of $2.5\\times $ reduction, LadaBERT-1 performs significantly better than BERT-PKD, boosting the performance by relative 8.9, 8.1, 6.1, 3.8 and 5.8 percentages on MNLI-m, MNLI-mm, SST-2, QQP and QNLI datasets respectively. Recall that BERT-PKD initializes the student model by selecting 3 of 12 layers in the pre-trained BERT-Base model. It turns out that the discarded layers have huge impact on the model performance, which is hard to be recovered by knowledge distillation. On the other hand, LadaBERT generates the student model by iterative pruning on the pre-trained teacher. In this way, the original knowledge in the teacher model can be preserved to the largest extent, and the benefit of which is complementary to knowledge distillation."
              ],
              "highlighted_evidence": [
                "The evaluation results of LadaBERT and state-of-the-art approaches are listed in Table TABREF40, where the models are ranked by parameter sizes for feasible comparison. As shown in the table, LadaBERT consistently outperforms the strongest baselines under similar model sizes. In addition, the performance of LadaBERT demonstrates the superiority of hybrid combination of SVD-based matrix factorization, weight pruning and knowledge distillation.\n\nWith model size of $2.5\\times $ reduction, LadaBERT-1 performs significantly better than BERT-PKD, boosting the performance by relative 8.9, 8.1, 6.1, 3.8 and 5.8 percentages on MNLI-m, MNLI-mm, SST-2, QQP and QNLI datasets respectively. Recall that BERT-PKD initializes the student model by selecting 3 of 12 layers in the pre-trained BERT-Base model. It turns out that the discarded layers have huge impact on the model performance, which is hard to be recovered by knowledge distillation. On the other hand, LadaBERT generates the student model by iterative pruning on the pre-trained teacher. In this way, the original knowledge in the teacher model can be preserved to the largest extent, and the benefit of which is complementary to knowledge distillation."
              ]
            },
            "annotation_id": "74c775a4d816d4f52211f597f85aabc1eb362f9a",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "85f21405d1de69ac14fdc9d5599b65af055a85d5",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "FLOAT SELECTED: Figure 5: Distribution of pruning errors"
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Figure 5: Distribution of pruning errors"
              ]
            },
            "annotation_id": "f230f73a21d24ea1d130048f251b147592b8580b",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Accuracy comparison on MNLI-m dataset"
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Overview of LadaBERT framework"
      },
      {
        "file": "6-Table1-1.png",
        "caption": "Table 1: Dataset Statistics"
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Fine-grained compression ratios"
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3: Performance comparison on various model sizes"
      },
      {
        "file": "8-Figure3-1.png",
        "caption": "Figure 3: Learning curve on MNLI-m dataset. Figure 4: Learning curve on QQP dataset."
      },
      {
        "file": "9-Figure5-1.png",
        "caption": "Figure 5: Distribution of pruning errors"
      }
    ]
  },
  "1708.00549": {
    "title": "Improved Representation Learning for Predicting Commonsense Ontologies",
    "abstract": "Recent work in learning ontologies (hierarchical and partially-ordered structures) has leveraged the intrinsic geometry of spaces of learned representations to make predictions that automatically obey complex structural constraints. We explore two extensions of one such model, the order-embedding model for hierarchical relation learning, with an aim towards improved performance on text data for commonsense knowledge representation. Our first model jointly learns ordering relations and non-hierarchical knowledge in the form of raw text. Our second extension exploits the partial order structure of the training data to find long-distance triplet constraints among embeddings which are poorly enforced by the pairwise training procedure. We find that both incorporating free text and augmented training constraints improve over the original order-embedding model and other strong baselines.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "A core problem in artificial intelligence is to capture, in machine-usable form, the collection of information that an ordinary person would have, known as commonsense knowledge. For example, a machine should know that a room may have a door, and that when a person enters a room, it is generally through a door. This background knowledge is crucial for solving many difficult, ambiguous natural language problems in coreference resolution and question answering, as well as the creation of other reasoning machines.",
          "More than just curating a static collection of facts, we would like commonsense knowledge to be represented in a way that lends itself to machine reasoning and inference of missing information. We concern ourselves in this paper with the problem of learning commonsense knowledge representations.",
          "In machine learning settings, knowledge is usually represented as a hypergraph of triplets such as Freebase BIBREF1 , WordNet BIBREF2 , and ConceptNet BIBREF3 . In these knowledge graphs, nodes represent entities or terms $t$ , and hyperedges are relations $R$ between these entities or terms, with each fact in the knowledge graph represented as a triplet $<t_1, R, t_2>$ . Researchers have developed many models for knowledge representation and learning in this setting BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 , BIBREF8 , under the umbrella of knowledge graph completion. However, none of these naturally lend themselves to traditional methods of logical reasoning such as transitivity and negation.",
          "While a knowledge graph completion model can represent relations such as Is-A and entailment, there is no mechanism to ensure that its predictions are internally consistent. For example, if we know that a dog is a mammal, and a pit bull is a dog, we would like the model to also predict that a pit bull is a mammal. These transitive entailment relations describe ontologies of hierarchical data, a key component of commonsense knowledge which we focus on in this work.",
          "Recently, a thread of research on representation learning has aimed to create embedding spaces that automatically enforce consistency in these predictions using the intrinsic geometry of the embedding space BIBREF9 , BIBREF0 , BIBREF10 . In these models, the inferred embedding space creates a globally consistent structured prediction of the ontology, rather than the local relation predictions of previous models.",
          "We focus on the order-embedding model BIBREF0 which was proposed for general hierarchical prediction including multimodal problems such as image captioning. While the original work included results on ontology prediction on WordNet, we focus exclusively on the model's application to commonsense knowledge, with its unique characteristics including complex ordering structure, compositional, multi-word entities, and the wealth of commonsense knowledge to be found in large-scale unstructured text data.",
          "We propose two extensions to the order embedding model. The first augments hierarchical supervision from existing ontologies with non-hierarchical knowledge in the form of raw text. We find incorporating unstructured text brings accuracy from 92.0 to 93.0 on a commonsense dataset containing Is-A relations from ConceptNet and Microsoft Concept Graph (MCG), with larger relative gains from smaller amounts of labeled data.",
          "The second extension uses the complex partial-order structure of real-world ontologies to find long-distance triplet constraints among embeddings which are poorly enforced by the standard pairwise training method. By adding our additional triplet constraints to the baseline order-embedding model, we find performance improves from 90.6 to 91.3 accuracy on the WordNet ontology dataset.",
          "We find that order embeddings' ease of extension, both by incorporating non-ordered data, and additional training constraints derived from the structure of the problem, makes it a promising avenue for the development of further algorithms for automatic learning and jointly consistent prediction of ontologies."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "In this work, we use the ConceptNet BIBREF3 , WordNet BIBREF2 , and Microsoft Concept Graph (MCG) BIBREF11 , BIBREF12 knowledge bases for our ontology prediction experiments.",
          "WordNet is a knowledge base (KB) of single words and relations between them such as hypernymy and meronymy. For our task, we use the hypernym relations only. ConceptNet is a KB of triples consisting of a left term $t_1$ , a relation $R$ , and a right term $t_2$ . The relations come from a fixed set of size 34. But unlike WordNet, terms in ConceptNet can be phrases. We focus on the Is-A relation in this work. MCG also consists of hierarchical relations between multi-word phrases, ranging from extremely general to specific. Examples from each dataset are shown in Table 1 .",
          "For experiments involving unstructured text, we use the WaCkypedia corpus BIBREF13 ."
        ]
      },
      {
        "section_name": "Models",
        "paragraphs": [
          "We introduce two variants of order embeddings. The first incorporates non-hierarchical unstructured text data into the supervised ontology. The second improves the training procedure by adding additional examples representing long-range constraints."
        ]
      },
      {
        "section_name": "Order Embeddings",
        "paragraphs": [
          "Order Embeddings are a model for automatically enforcing partial-ordering (or lattice) constraints among predictions directly in embedding space. The vector embeddings satisfy the following property with respect to the partial order: $\nx \\preceq y \\text{ if and only if } \\bigwedge _{i=1}^{N}x_{i}\\ge y_i\n$ ",
          "where $x$ is the subcategory and $y$ is the supercategory. This means the general concept embedding should be smaller than the specific concept embedding in every coordinate of the embeddings. An illustration of this geometry can be found in Figure 1. We can define a surrogate energy for this ordering function as $d(x, y) = \\left\\Vert  \\max (0,y-x) \\right\\Vert ^2$ . The learning objective for order embeddings becomes the following, where $m$ is a margin parameter, $x$ and $y$ are the hierarchically supervised pairs, and $x^{\\prime }$ and $y^{\\prime }$ are negatively sampled concepts: $\nL_{\\text{Order}} = \\sum _{x,y}\\max (0, m+d(x,y)-d(x^{\\prime }, y^{\\prime }))\n$ "
        ]
      },
      {
        "section_name": "Joint Text and Order Embedding",
        "paragraphs": [
          "We aim to augment our ontology prediction embedding model with more general commonsense knowledge mined from raw text. A standard method for learning word representations is word2vec BIBREF14 , which predicts current word embeddings using a context of surrounding word embeddings. We incorporate a modification of the CBOW model in this work, which uses the average embedding from a window around the current word as a context vector $v_2$ to predict the current word vector $v_1$ : $\nv_2 = \\frac{1}{window}\\sum _{k \\in \\lbrace -window/2,...,window/2\\rbrace \\setminus \\lbrace t\\rbrace }v_{t+k}\n$ ",
          " Because order embeddings are all positive and compared coordinate-wise, we use a variant of CBOW that scores similarity to context based on based on $L_1$ distance and not dot product, $v^{\\prime }_1$ and $v^{\\prime }_2$ are the negative examples selected from the vocabulary during training: $\n& d_\\text{pos} = d(v_1,v_2) = \\left\\Vert  v_1- v_2\\right\\Vert \\\\\n& d_\\text{neg} = d(v^{\\prime }_1, v^{\\prime }_2) = \\left\\Vert  v^{\\prime }_1- v^{\\prime }_2\\right\\Vert  \\\\\n& L_{\\text{CBOW}}= \\sum _{w_c,w_t}\\max (0, m+d_\\text{pos}-d_\\text{neg})\n$ ",
          "Finally, after each gradient update, we map the embeddings back to the positive domain by applying the absolute value function. We propose jointly learning both the order- and text- embedding model with a simple weighted combination of the two objective functions: $\n&L_{\\text{Joint}} = \\alpha _{1}L_{\\text{Order}}+\\alpha _{2}L_{\\text{CBOW}}\n$ ",
          "We perform two sets of experiments on the combined ConceptNet and MCG Is-A relations, using different amounts of training and testing data. The first data set, called Data1, uses 119,159 training examples, 1,089 dev examples, and 1,089 test examples. The second dataset, Data2, evenly splits the data in 47,662 examples for each set.",
          "Our baselines for this model are a standard order embedding model, and a bilinear classifier BIBREF6 trained to predict Is-A, both with and without additional unstructured text augmenting the model in the same way as the joint order embedding model.",
          "We see in Table 2 that while adding extra text data helps all models, the best performance is consistently achieved by a combination of order embeddings and unstructured text."
        ]
      },
      {
        "section_name": "Long-Range Join and Meet Constraints",
        "paragraphs": [
          "Order embeddings map words to a partially-ordered space, which we can think of as a directed acyclic graph (DAG). A simple way to add more training examples is to take the transitive closure of this graph. For example, if we have $<$ dog IsA mammal $>$ , $<$ mammal IsA animal $>$ , we can produce the training example $<$ dog IsA animal $>$ .",
          "We observe that even more training examples can be created by treating our partial-order structure as a lattice. A lattice is a partial order equipped with two additional operations, join and meet. The join and meet of a pair P are respectively the supremum (least upper bound) of P, denoted $\\vee $ , and the infimum (greatest lower bound), denoted $\\wedge $ . In our case, the vector join and meet would be the pointwise max and min of two embeddings.",
          "We can add many additional training examples to our data by enforcing that the vector join and meet operations satisfy the joins and meets found in the training lattice/DAG. If $w_c$ and $w_p$ are the nearest common child and parent for a pair $w_1, w_2$ , the loss for join and meet learning can be written as the following: $\n& d_c(w_1,w_2,w_c) = \\left\\Vert  \\max (0,w_1 \\vee w_2-w_c) \\right\\Vert ^2 \\\\\n& d_p(w_1,w_2,w_p) = \\left\\Vert  \\max (0,w_p - w_1 \\wedge w_2) \\right\\Vert ^2 \\\\\n& {\\small L_\\text{join} = \\sum _{w_1,w_2,w_c}\\max (0, m+d_c(w_1,w_2,w_c))}\\\\\n& {\\small L_\\text{meet} = \\sum _{w_1,w_2,w_p}\\max (0, m+d_p(w_1,w_2,w_p))}\\\\\n& L = L_\\text{join} + L_\\text{meet}\n$ ",
          "In this experiment, we use the same dataset as BIBREF0 , created by taking 40,00 edges from the 838,073-edge transitive closure of the WordNet hierarchy for the dev set, 4,000 for the test set, and training on the rest of the transitive closure. We additionally add the long-range join and meet constraints (3,028,302 and 4,006 respectively) between different concepts and see that the inclusion of this additional supervision results in further improvement over the baseline order embedding model, as seen in Table 3."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "In both sets of experiments we train all models using the Adam optimizer BIBREF15 , using embeddings of dimension 50, with all hyperparameters tuned on a development set. When embedding multi-word phrases, we represent them as the average of the constituent word embeddings."
        ]
      },
      {
        "section_name": "Conclusion and Future Work",
        "paragraphs": [
          "In this work we presented two extensions to the order embedding model. The first incorporates unstructured text to improve performance on Is-A relations, while the second uses long-range constraints automatically derived from the ontology to provide the model with more useful global supervision. In future work we would like to explore embedding models for structured prediction that automatically incorporate additional forms of reasoning such as negation, joint learning of ontological and other commonsense relations, and the application of improved training methods to new models for ontology prediction such as Poincar\u00e9 embeddings."
        ]
      }
    ],
    "qas": [
      {
        "question": "What types of commonsense knowledge are they talking about?",
        "question_id": "52faf319e37aa15fff1ab47f634a5a584dc42e75",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "commonsense",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "hypernym relations"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this work, we use the ConceptNet BIBREF3 , WordNet BIBREF2 , and Microsoft Concept Graph (MCG) BIBREF11 , BIBREF12 knowledge bases for our ontology prediction experiments.",
                "WordNet is a knowledge base (KB) of single words and relations between them such as hypernymy and meronymy. For our task, we use the hypernym relations only. ConceptNet is a KB of triples consisting of a left term $t_1$ , a relation $R$ , and a right term $t_2$ . The relations come from a fixed set of size 34. But unlike WordNet, terms in ConceptNet can be phrases. We focus on the Is-A relation in this work. MCG also consists of hierarchical relations between multi-word phrases, ranging from extremely general to specific. Examples from each dataset are shown in Table 1 ."
              ],
              "highlighted_evidence": [
                "In this work, we use the ConceptNet BIBREF3 , WordNet BIBREF2 , and Microsoft Concept Graph (MCG) BIBREF11 , BIBREF12 knowledge bases for our ontology prediction experiments.",
                "WordNet is a knowledge base (KB) of single words and relations between them such as hypernymy and meronymy. For our task, we use the hypernym relations only.",
                "But unlike WordNet, terms in ConceptNet can be phrases. We focus on the Is-A relation in this work. MCG also consists of hierarchical relations between multi-word phrases, ranging from extremely general to specific."
              ]
            },
            "annotation_id": "82ed8873f1f11f648488d2e00f341bebc4553dfe",
            "worker_id": "1d87720d0db14aa36d083b7dc3999984c4489389"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "the collection of information that an ordinary person would have"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "A core problem in artificial intelligence is to capture, in machine-usable form, the collection of information that an ordinary person would have, known as commonsense knowledge. For example, a machine should know that a room may have a door, and that when a person enters a room, it is generally through a door. This background knowledge is crucial for solving many difficult, ambiguous natural language problems in coreference resolution and question answering, as well as the creation of other reasoning machines."
              ],
              "highlighted_evidence": [
                "A core problem in artificial intelligence is to capture, in machine-usable form, the collection of information that an ordinary person would have, known as commonsense knowledge. "
              ]
            },
            "annotation_id": "2e7776fd36d252feb9ce6d6b03d967660aad0782",
            "worker_id": "428b6da53085b8fd7b37e9fb259c0c609bd09984"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "In this work, we use the ConceptNet BIBREF3 , WordNet BIBREF2 , and Microsoft Concept Graph (MCG) BIBREF11 , BIBREF12 knowledge bases for our ontology prediction experiments.",
                "WordNet is a knowledge base (KB) of single words and relations between them such as hypernymy and meronymy. For our task, we use the hypernym relations only. ConceptNet is a KB of triples consisting of a left term $t_1$ , a relation $R$ , and a right term $t_2$ . The relations come from a fixed set of size 34. But unlike WordNet, terms in ConceptNet can be phrases. We focus on the Is-A relation in this work. MCG also consists of hierarchical relations between multi-word phrases, ranging from extremely general to specific. Examples from each dataset are shown in Table 1 ."
              ],
              "highlighted_evidence": [
                "In this work, we use the ConceptNet BIBREF3 , WordNet BIBREF2 , and Microsoft Concept Graph (MCG) BIBREF11 , BIBREF12 knowledge bases for our ontology prediction experiments.",
                "WordNet is a knowledge base (KB) of single words and relations between them such as hypernymy and meronymy. For our task, we use the hypernym relations only. ConceptNet is a KB of triples consisting of a left term $t_1$ , a relation $R$ , and a right term $t_2$ . The relations come from a fixed set of size 34. But unlike WordNet, terms in ConceptNet can be phrases. We focus on the Is-A relation in this work. MCG also consists of hierarchical relations between multi-word phrases, ranging from extremely general to specific."
              ],
              "yes_no": null,
              "free_form_answer": "Hypernymy or is-a relations between words or phrases",
              "extractive_spans": []
            },
            "annotation_id": "813f8f1fe7b8c803e368c317d00d13512a88e89a",
            "worker_id": "f840a836eee0180d2c976457f8b3052d8e78050c"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "While a knowledge graph completion model can represent relations such as Is-A and entailment, there is no mechanism to ensure that its predictions are internally consistent. For example, if we know that a dog is a mammal, and a pit bull is a dog, we would like the model to also predict that a pit bull is a mammal. These transitive entailment relations describe ontologies of hierarchical data, a key component of commonsense knowledge which we focus on in this work.",
                "We focus on the order-embedding model BIBREF0 which was proposed for general hierarchical prediction including multimodal problems such as image captioning. While the original work included results on ontology prediction on WordNet, we focus exclusively on the model's application to commonsense knowledge, with its unique characteristics including complex ordering structure, compositional, multi-word entities, and the wealth of commonsense knowledge to be found in large-scale unstructured text data."
              ],
              "highlighted_evidence": [
                "For example, if we know that a dog is a mammal, and a pit bull is a dog, we would like the model to also predict that a pit bull is a mammal. These transitive entailment relations describe ontologies of hierarchical data, a key component of commonsense knowledge which we focus on in this work.",
                "While the original work included results on ontology prediction on WordNet, we focus exclusively on the model's application to commonsense knowledge, with its unique characteristics including complex ordering structure, compositional, multi-word entities, and the wealth of commonsense knowledge to be found in large-scale unstructured text data."
              ],
              "yes_no": null,
              "free_form_answer": "Knowledge than an ordinary person would have such as transitive entailment relation, complex ordering, compositionality, multi-word entities",
              "extractive_spans": []
            },
            "annotation_id": "de32134088fe9b436decd6b7ed11d24afd9e7562",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1. Order Embedding"
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1. Example triplets from each dataset."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2. Adding more training examples: black line is the original training data, green line is obtained by transitive closure, and yellow line is obtained by join and meet."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2. Joint Text and Order Embedding"
      }
    ]
  },
  "1905.00472": {
    "title": "A system for the 2019 Sentiment, Emotion and Cognitive State Task of DARPAs LORELEI project",
    "abstract": "During the course of a Humanitarian Assistance-Disaster Relief (HADR) crisis, that can happen anywhere in the world, real-time information is often posted online by the people in need of help which, in turn, can be used by different stakeholders involved with management of the crisis. Automated processing of such posts can considerably improve the effectiveness of such efforts; for example, understanding the aggregated emotion from affected populations in specific areas may help inform decision-makers on how to best allocate resources for an effective disaster response. However, these efforts may be severely limited by the availability of resources for the local language. The ongoing DARPA project Low Resource Languages for Emergent Incidents (LORELEI) aims to further language processing technologies for low resource languages in the context of such a humanitarian crisis. In this work, we describe our submission for the 2019 Sentiment, Emotion and Cognitive state (SEC) pilot task of the LORELEI project. We describe a collection of sentiment analysis systems included in our submission along with the features extracted. Our fielded systems obtained the best results in both English and Spanish language evaluations of the SEC pilot task.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The growing adoption of online technologies has created new opportunities for emergency information propagation BIBREF0 . During crises, affected populations post information about what they are experiencing, what they are witnessing, and relate what they hear from other sources BIBREF1 . This information contributes to the creation and dissemination of situational awareness BIBREF2 , BIBREF3 , BIBREF4 , BIBREF0 , and crisis response agencies such as government departments or public health-care NGOs can make use of these channels to gain insight into the situation as it unfolds BIBREF2 , BIBREF5 . Additionally, these organizations might also post time-sensitive crisis management information to help with resource allocation and provide status reports BIBREF6 . While many of these organizations recognize the value of the information found online\u2014specially during the on-set of a crisis\u2014they are in need of automatic tools that locate actionable and tactical information BIBREF7 , BIBREF0 .",
          "Opinion mining and sentiment analysis techniques offer a viable way of addressing these needs, with complementary insights to what keyword searches or topic and event extraction might offer BIBREF8 . Studies have shown that sentiment analysis of social media during crises can be useful to support response coordination BIBREF9 or provide information about which audiences might be affected by emerging risk events BIBREF10 . For example, identifying tweets labeled as \u201cfear\u201d might support responders on assessing mental health effects among the affected population BIBREF11 . Given the critical and global nature of the HADR events, tools must process information quickly, from a variety of sources and languages, making it easily accessible to first responders and decision makers for damage assessment and to launch relief efforts accordingly BIBREF12 , BIBREF13 . However, research efforts in these tasks are primarily focused on high resource languages such as English, even though such crises may happen anywhere in the world.",
          "The LORELEI program provides a framework for developing and testing systems for real-time humanitarian crises response in the context of low-resource languages. The working scenario is as follows: a sudden state of danger requiring immediate action has been identified in a region which communicates in a low resource language. Under strict time constraints, participants are expected to build systems that can: translate documents as necessary, identify relevant named entities and identify the underlying situation BIBREF14 . Situational information is encoded in the form of Situation Frames \u2014 data structures with fields identifying and characterizing the crisis type. The program's objective is the rapid deployment of systems that can process text or speech audio from a variety of sources, including newscasts, news articles, blogs and social media posts, all in the local language, and populate these Situation Frames. While the task of identifying Situation Frames is similar to existing tasks in literature (e.g., slot filling), it is defined by the very limited availability of data BIBREF15 . This lack of data requires the use of simpler but more robust models and the utilization of transfer learning or data augmentation techniques.",
          "The Sentiment, Emotion, and Cognitive State (SEC) evaluation task was a recent addition to the LORELEI program introduced in 2019, which aims to leverage sentiment information from the incoming documents. This in turn may be used in identifying severity of the crisis in different geographic locations for efficient distribution of the available resources. In this work, we describe our systems for targeted sentiment detection for the SEC task. Our systems are designed to identify authored expressions of sentiment and emotion towards a HADR crisis. To this end, our models are based on a combination of state-of-the-art sentiment classifiers and simple rule-based systems. We evaluate our systems as part of the NIST LoREHLT 2019 SEC pilot task."
        ]
      },
      {
        "section_name": "Previous Work",
        "paragraphs": [
          "Social media has received a lot of attention as a way to understand what people communicate during disasters BIBREF16 , BIBREF11 . These communications typically center around collective sense-making BIBREF17 , supportive actions BIBREF18 , BIBREF19 , and social sharing of emotions and empathetic concerns for affected individuals BIBREF20 . To organize and make sense of the sentiment information found in social media, particularly those messages sent during the disaster, several works propose the use of machine learning models (e.g., Support Vector Machines, Naive Bayes, and Neural Networks) trained on a multitude of linguistic features. These features include bag of words, part-of-speech tags, n-grams, and word embeddings; as well as previously validated sentiment lexica such as Linguistic Inquiry and Word Count (LIWC) BIBREF22 , AFINN BIBREF23 , and SentiWordNet BIBREF24 . Most of the work is centered around identifying messages expressing sentiment towards a particular situation as a way to distinguish crisis-related posts from irrelevant information BIBREF25 . Either in a binary fashion (positive vs. negative) (e.g., BIBREF25 ) or over fine-grained emotional classes (e.g., BIBREF16 ).",
          "In contrast to social media posts, sentiment analysis of news articles and blogs has received less attention BIBREF26 . This can be attributed to a more challenging task due to the nature of the domain since, for example, journalists will often refrain from using clearly positive or negative vocabulary when writing news articles BIBREF27 . However, certain aspects of these communication channels are still apt for sentiment analysis, such as column pieces BIBREF28 or political news BIBREF27 , BIBREF29 .",
          "In the context of leveraging the information found online for HADR emergencies, approaches for languages other than English have been limited. Most of which are done by manually constructing resources for a particular language (e.g., in tweets BIBREF30 , BIBREF31 , BIBREF32 and in disaster-related news coverage BIBREF33 ), or by applying cross-language text categorization to build language-specific models BIBREF31 , BIBREF34 .",
          "In this work, we develop systems that identify positive and negative sentiments expressed in social media posts, news articles and blogs in the context of a humanitarian emergency. Our systems work for both English and Spanish by using an automatic machine translation system. This makes our approach easily extendable to other languages, bypassing the scalability issues that arise from the need to manually construct lexica resources."
        ]
      },
      {
        "section_name": "Problem Definition",
        "paragraphs": [
          "This section describes the SEC task in the LORELEI program along with the dataset, evaluation conditions and metrics."
        ]
      },
      {
        "section_name": "The Sentiment, Emotion and Cognitive State (SEC) Task",
        "paragraphs": [
          "Given a dataset of text documents and manually annotated situation frames, the task is to automatically detect sentiment polarity relevant to existing frames and identify the source and target for each sentiment instance. The source is defined as a person or a group of people expressing the sentiment, and can be either a PER/ORG/GPE (person, organization or geo political entity) construct in the frame, the author of the text document, or an entity not explicitly expressed in the document. The target toward which the sentiment is expressed, is either the frame or an entity in the document.",
          "Situation awareness information is encoded into situation frames in the LORELEI program BIBREF35 . Situation Frames (SF) are similar in nature to those used in Natural Language Understanding (NLU) systems: in essence they are data structures that record information corresponding to a single incident at a single location BIBREF15 . A SF frame includes a situation Type taken from a fixed inventory of 11 categories (e.g., medical need, shelter, infrastructure), Location where the situation exists (if a location is mentioned) and additional variables highlighting the Status of the situation (e.g., entities involved in resolution, time and urgency). An example of a SF can be found in table 1 . A list of situation frames and documents serve as input for our sentiment analysis systems."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "Training data provided for the task included documents were collected from social media, SMS, news articles, and news wires. This consisted of 76 documents in English and 47 in Spanish. The data are relevant to the HADR domain but are not grounded in a common HADR incident. Each document is annotated for situation frames and associated sentiment by 2 trained annotators from the Linguistic Data Consortium (LDC). Sentiment annotations were done at a segment (sentence) level, and included Situation Frame, Polarity (positive / negative), Sentiment Score, Emotion, Source and Target. Sentiment labels were annotated between the values of -3 (very negative) and +3 (very positive) with 0.5 increments excluding 0. Additionally, the presence or absence of three specific emotions: fear, anger, and joy/happiness was marked. If a segment contains sentiment toward more than one target, each will be annotated separately. Summary of the training data is given in Table 2 ."
        ]
      },
      {
        "section_name": "Evaluation",
        "paragraphs": [
          "Systems participating in the task were expected to produce outputs with sentiment polarity, emotion, sentiment source and target, and the supporting segment from the input document. This output is evaluated against a ground truth derived from two or more annotations. For the SEC pilot evaluation, a reference set with dual annotations from two different annotators was provided. The system's performance was measured using variants of precision, recall and f1 score, each modified to take into account the multiple annotations. The modified scoring is as follows: let the agreement between annotators be defined as two annotations with the same sentiment polarity, source, and target. That is, consider two annotators in agreement even if their judgments vary on sentiment values or perceived emotions. Designate those annotations with agreement as \u201cD\u201d and those which were not agreed upon as \u201cS\u201d. When computing precision, recall and f measure, each of the sentiment annotations in D will count as two occurrences in the reference, and likewise a system match on a sentiment annotation in D will count as two matches. Similarly, a match on a sentiment annotation in S will count as a single match. The updated precision, recall and f-measure were defined as follows: $\n\\text{precision} &= \\frac{2 * \\text{Matches in D} + \\text{Matches in S}}{2 * \\text{Matches in D} + \\text{Matches in S} + \\text{Unmatched}}\\\\[10pt]\n\\text{recall} &= \\frac{2 * \\text{Matches in D} + \\text{Matches in S}}{2|D| + |S|}\\\\[10pt]\n\\text{f1} &= \\frac{2 * \\text{precision} * \\text{recall}}{(\\text{precision} + \\text{recall})}\n$ "
        ]
      },
      {
        "section_name": "Method",
        "paragraphs": [
          "We approach the SEC task, particularly the polarity and emotion identification, as a classification problem. Our systems are based on English, and are extended to other languages via automatic machine translation (to English). In this section we present the linguistic features and describe the models using for the evaluation."
        ]
      },
      {
        "section_name": "Machine Translation",
        "paragraphs": [
          "Automatic translations from Spanish to English were obtained from Microsoft Bing using their publicly available API. For the pilot evaluation, we translated all of the Spanish documents into English, and included them as additional training data. At this time we do not translate English to Spanish, but plan to explore this thread in future work."
        ]
      },
      {
        "section_name": "Linguistic Features",
        "paragraphs": [
          "We extract word unigrams and bigrams. These features were then transformed using term frequencies (TF) and Inverse document-frequency (IDF).",
          "Word embeddings pretrained on large corpora allow models to efficiently leverage word semantics as well as similarities between words. This can help with vocabulary generalization as models can adapt to words not previously seen in training data. In our feature set we include a 300-dimensional word2vec word representation trained on a large news corpus BIBREF36 . We obtain a representation for each segment by averaging the embedding of each word in the segment. We also experimented with the use of GloVe BIBREF37 , and Sent2Vec BIBREF38 , an extension of word2vec for sentences.",
          "We use two sources of sentiment features: manually constructed lexica, and pre-trained sentiment embeddings. When available, manually constructed lexica are a useful resource for identifying expressions of sentiment BIBREF21 . We obtained word percentages across 192 lexical categories using Empath BIBREF39 , which extends popular tools such as the Linguistic Inquiry and Word Count (LIWC) BIBREF22 and General Inquirer (GI) BIBREF40 by adding a wider range of lexical categories. These categories include emotion classes such as surprise or disgust.",
          "Neural networks have been shown to capture specific task related subtleties which can complement the manually constructed sentiment lexica described in the previous subsection. For this work, we learn sentiment representations using a bilateral Long Short-Term Memory model BIBREF41 trained on the Stanford Sentiment Treebank BIBREF42 . This model was selected because it provided a good trade off between simplicity and performance on a fine-grained sentiment task, and has been shown to achieve competitive results to the state-of-the-art BIBREF43 ."
        ]
      },
      {
        "section_name": "Models",
        "paragraphs": [
          "We now describe the models used for this work. Our models can be broken down into two groups: our first approach explores state-of-the-art models in targeted and untargeted sentiment analysis to evaluate their performance in the context of the SEC task. These models were pre-trained on larger corpora and evaluated directly on the task without any further adaptation. In a second approach we explore a data augmentation technique based on a proposed simplification of the task. In this approach, traditional machine learning classifiers were trained to identify which segments contain sentiment towards a SF regardless of sentiment polarity. For the classifiers, we explored the use of Support Vector Machines and Random Forests. Model performance was estimated through 10-fold cross validation on the train set. Hyper-parameters, such as of regularization, were selected based on the performance on grid-search using an 10-fold inner-cross validation loop. After choosing the parameters, models were re-trained on all the available data.",
          "We consider some of the most popular baseline models in the literature: (i) minority class baseline (due to the heavily imbalanced dataset), (ii) Support Vector Machines trained on TF-IDF bi-gram language model, (iii) and Support Vector Machines trained on word2vec representations. These models were trained using English documents only.",
          "Two types of targeted sentiment are evaluated for the task: those expressed towards either a situation frame or those towards an entity. To identify sentiment expressed towards an SF, we use the pretrained model described in BIBREF44 , in which a multiplicative LSTM cell is trained at the character level on a corpus of 82 million Amazon reviews. The model representation is then fed to a logistic regression classifier to predict sentiment. This model (which we will refer to as OpenAI) was chosen since at the time of our system submission it was one of the top three performers on the binary sentiment classification task on the Stanford Sentiment Treebank. In our approach, we first map the text associated with the SF annotation with a segment from the document and pass the full segment to the pretrained OpenAI model identify the sentiment polarity for that segment.",
          "To identify sentiment targeted towards an entity, we use the recently released Target-Based Sentiment Analysis (TBSA) model from BIBREF45 . In TBSA, two stacked LSTM cells are trained to predict both sentiment and target boundary tags (e.g., predicting S-POS to indicate the start of the target towards which the author is expressing positive sentiment, I-POS and E-POS to indicate intermediate and end of the target). In our submission, since input text documents can be arbitrarily long, we only consider sentences which include a known and relevant entity; these segments are then fed to the TBSA model to predict targeted sentiment. If the target predicted by this model matched with any of the known entities, the system would output the polarity and the target.",
          "In this model we limit our focus on the task of correctly identifying those segments with sentiment towards a SF. That is, given a pair of SF and segment, we train models to identify if this segment contains any sentiment towards that SF. This allows us to expand our dataset from 123 documents into one with $\\sum _d |SF_d| \\times |d|$ number of samples, where $|d|$ is the length of the document (i.e., number of segments) and $|SF_d|$ is the number of SF annotations for document $d$ . Summary of the training dataset after augmentation is given in Table 3 .",
          "Given the highly skewed label distribution in the training data, a majority of the constructed pairs do not have any sentiment towards a SF. Hence, our resulting dataset has a highly imbalanced distribution which we address by training our models after setting the class weights to be the inverse class frequency. To predict polarity, we assume the majority class of negative sentiment. We base this assumption on the fact that the domain we are working with doesn't seem to support the presence of positive sentiment, as made evident by the highly imbalanced dataset.",
          "Owing to the nature of the problem domain, there is considerable variance in the source of the text documents and their structure. For example, tweets only have one segment per sample whereas news articles contain an average of $7.07\\pm 4.96$ and $6.31\\pm 4.93$ segments for English and Spanish documents respectively. Moreover, studies suggest that sentiments expressed in social media tend to differ significantly from those in the news BIBREF26 . Table 4 presents a breakdown of the train set for each sentiment across domains, as is evident tweets form a sizeable group of the training set. Motivated by this, we train different models for tweets and non-tweet documents in order to capture the underlying differences between the data sources.",
          "Initial experiments showed that our main source of error was not being able to correctly identify the supporting segment. Even if polarity, source and target were correctly identified, missing the correct segment was considered an error, and thus lowered our models' precision. To address this, we decided to use a model which only produced results for tweets given that these only contain one segment, making the segment identification sub-task trivial."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Model performance during train is presented in Table 5 . While all the models outperformed the baselines, not all of them did so with a significant margin due to the robustness of the baselines selected. The ones found to be significantly better than the baselines were models IIb (Domain-specific) and IIc (Twitter-only) (permutation test, $n = 10^5$ both $p < 0.05$ ). The difference in precision between model IIb and IIc points out to the former making the wrong predictions for news articles. These errors are most likely in selecting the wrong supporting segment. Moreover, even though models IIa-c only produce negative labels, they still achieve improved performance over the state-of-the-art systems, highlighting the highly skewed nature of the training dataset.",
          "Table 6 present the official evaluation results for English and Spanish. Some information is missing since at the time of submission only partial score had been made public. As previously mentioned, the pre-trained state-of-the-art models (model I) were directly applied to the evaluation data without any adaptation. These performed reasonably well for the English data. Among the submissions of the SEC Task pilot, our systems outperformed the other competitors for both languages."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Understanding the expressed sentiment from an affected population during the on-set of a crisis is a particularly difficult task, especially in low-resource scenarios. There are multiple difficulties beyond the limited amount of data. For example, in order to provide decision-makers with actionable and usable information, it is not enough for the system to correctly classify sentiment or emotional state, it also ought to identify the source and target of the expressed sentiment. To provide a sense of trust and accountability on the system's decisions, it makes sense to identify a justifying segment. Moreover, these systems should consider a variety of information sources to create a broader and richer picture on how a situation unfolds. Thus, it is important that systems take into account the possible differences in the way sentiment is expressed in each one of these sources. In this work, we presented two approaches to the task of providing actionable and useful information. Our results show that state-of-the-art sentiment classifiers can be leveraged out-of-the-box for a reasonable performance on English data. By identifying possible differences coming from the information sources, as well as by exploiting the information communicated as the situation unfolds, we showed significant performance gains on both English and Spanish."
        ]
      }
    ],
    "qas": [
      {
        "question": "Did they pre-train on existing sentiment corpora?",
        "question_id": "9c2cacf77041e02d38f92a4c490df1e04552f96f",
        "nlp_background": "two",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We use two sources of sentiment features: manually constructed lexica, and pre-trained sentiment embeddings. When available, manually constructed lexica are a useful resource for identifying expressions of sentiment BIBREF21 . We obtained word percentages across 192 lexical categories using Empath BIBREF39 , which extends popular tools such as the Linguistic Inquiry and Word Count (LIWC) BIBREF22 and General Inquirer (GI) BIBREF40 by adding a wider range of lexical categories. These categories include emotion classes such as surprise or disgust.",
                "Neural networks have been shown to capture specific task related subtleties which can complement the manually constructed sentiment lexica described in the previous subsection. For this work, we learn sentiment representations using a bilateral Long Short-Term Memory model BIBREF41 trained on the Stanford Sentiment Treebank BIBREF42 . This model was selected because it provided a good trade off between simplicity and performance on a fine-grained sentiment task, and has been shown to achieve competitive results to the state-of-the-art BIBREF43 ."
              ],
              "highlighted_evidence": [
                "We use two sources of sentiment features: manually constructed lexica, and pre-trained sentiment embeddings. ",
                "For this work, we learn sentiment representations using a bilateral Long Short-Term Memory model BIBREF41 trained on the Stanford Sentiment Treebank BIBREF42 ."
              ]
            },
            "annotation_id": "5a15df8e679710bf03a84c60fb5aa3c9f6456b05",
            "worker_id": "043654eefd60242ac8da08ddc1d4b8d73f86f653"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Two types of targeted sentiment are evaluated for the task: those expressed towards either a situation frame or those towards an entity. To identify sentiment expressed towards an SF, we use the pretrained model described in BIBREF44 , in which a multiplicative LSTM cell is trained at the character level on a corpus of 82 million Amazon reviews. The model representation is then fed to a logistic regression classifier to predict sentiment. This model (which we will refer to as OpenAI) was chosen since at the time of our system submission it was one of the top three performers on the binary sentiment classification task on the Stanford Sentiment Treebank. In our approach, we first map the text associated with the SF annotation with a segment from the document and pass the full segment to the pretrained OpenAI model identify the sentiment polarity for that segment."
              ],
              "highlighted_evidence": [
                "To identify sentiment expressed towards an SF, we use the pretrained model described in BIBREF44 , in which a multiplicative LSTM cell is trained at the character level on a corpus of 82 million Amazon reviews."
              ]
            },
            "annotation_id": "872e88ead8873b993f239e550a6e9215feac0e0c",
            "worker_id": "efdb8f7f2fe9c47e34dfe1fb7c491d0638ec2d86"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "We now describe the models used for this work. Our models can be broken down into two groups: our first approach explores state-of-the-art models in targeted and untargeted sentiment analysis to evaluate their performance in the context of the SEC task. These models were pre-trained on larger corpora and evaluated directly on the task without any further adaptation. In a second approach we explore a data augmentation technique based on a proposed simplification of the task. In this approach, traditional machine learning classifiers were trained to identify which segments contain sentiment towards a SF regardless of sentiment polarity. For the classifiers, we explored the use of Support Vector Machines and Random Forests. Model performance was estimated through 10-fold cross validation on the train set. Hyper-parameters, such as of regularization, were selected based on the performance on grid-search using an 10-fold inner-cross validation loop. After choosing the parameters, models were re-trained on all the available data."
              ],
              "highlighted_evidence": [
                "These models were pre-trained on larger corpora and evaluated directly on the task without any further adaptation. "
              ],
              "yes_no": true,
              "free_form_answer": "",
              "extractive_spans": []
            },
            "annotation_id": "f47069b478eb088739e9f90006e94022b1b67520",
            "worker_id": "ea17aa5ea17e7838a55c252484390079b16c31ae"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "Two types of targeted sentiment are evaluated for the task: those expressed towards either a situation frame or those towards an entity. To identify sentiment expressed towards an SF, we use the pretrained model described in BIBREF44 , in which a multiplicative LSTM cell is trained at the character level on a corpus of 82 million Amazon reviews. The model representation is then fed to a logistic regression classifier to predict sentiment. This model (which we will refer to as OpenAI) was chosen since at the time of our system submission it was one of the top three performers on the binary sentiment classification task on the Stanford Sentiment Treebank. In our approach, we first map the text associated with the SF annotation with a segment from the document and pass the full segment to the pretrained OpenAI model identify the sentiment polarity for that segment."
              ],
              "highlighted_evidence": [
                "To identify sentiment expressed towards an SF, we use the pretrained model described in BIBREF44 , in which a multiplicative LSTM cell is trained at the character level on a corpus of 82 million Amazon reviews."
              ],
              "yes_no": null,
              "free_form_answer": "No, they used someone else's pretrained model. ",
              "extractive_spans": []
            },
            "annotation_id": "fed054396c48689f7054bae3d1374ca09e966058",
            "worker_id": "057bf5a20e4406f1f05cf82ecd49cf4f227dd287"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-TableI-1.png",
        "caption": "TABLE I EXAMPLE OF A SEGMENT CONTAINING A SITUATION FRAME WITH SENTIMENT RELATED ANNOTATIONS (IN BOLD)."
      },
      {
        "file": "3-TableII-1.png",
        "caption": "TABLE II FREQUENCY STATISTICS FOR THE PROVIDED TRAINING DATA PER LANGUAGE: NUMBER OF DOCUMENTS, NUMBER OF ANNOTATED SITUATION FRAMES, NUMBER OF SENTIMENT INSTANCES, PERCENTAGE OF NEGATIVE POLARITY."
      },
      {
        "file": "4-TableIV-1.png",
        "caption": "TABLE IV TRAIN DATASET DOMAIN BREAK-DOWN"
      },
      {
        "file": "5-TableV-1.png",
        "caption": "TABLE V MODEL PERFORMANCE ON ENGLISH TRAIN DATA ESTIMATED USING 10-FOLD CV"
      }
    ]
  },
  "1912.02866": {
    "title": "Classifying Diagrams and Their Parts using Graph Neural Networks: A Comparison of Crowd-Sourced and Expert Annotations",
    "abstract": "This article compares two multimodal resources that consist of diagrams which describe topics in elementary school natural sciences. Both resources contain the same diagrams and represent their structure using graphs, but differ in terms of their annotation schema and how the annotations have been created - depending on the resource in question - either by crowd-sourced workers or trained experts. This article reports on two experiments that evaluate how effectively crowd-sourced and expert-annotated graphs can represent the multimodal structure of diagrams for representation learning using various graph neural networks. The results show that the identity of diagram elements can be learned from their layout features, while the expert annotations provide better representations of diagram types.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Diagrams are a common feature of many everyday media from newspapers to school textbooks, and not surprisingly, different forms of diagrammatic representation have been studied from various perspectives. To name just a few examples, recent work has examined patterns in diagram design BIBREF0 and their interpretation in context BIBREF1, and developed frameworks for classifying diagrams BIBREF2 and proposed guidelines for their design BIBREF3. There is also a long-standing interest in processing and generating diagrams computationally BIBREF4, BIBREF5, BIBREF6, which is now resurfacing as advances emerging from deep learning for computer vision and natural language processing are brought to bear on diagrammatic representations BIBREF7, BIBREF8, BIBREF9.",
          "From the perspective of computational processing, diagrammatic representations present a formidable challenge, as they involve tasks from both computer vision and natural language processing. On the one hand, diagrams have a spatial organisation \u2013 layout \u2013 which needs to be segmented to identify meaningful units and their position. Making sense of how diagrams exploit the 2D layout space falls arguably within the domain of computer vision. On the other hand, diagrams also have a discourse structure, which uses the layout space to set up discourse relations between instances of natural language, various types of images, arrows and lines, thus forming a unified discourse organisation. The need to parse this discourse structure shifts the focus towards the field of natural language processing.",
          "Understanding and making inferences about the structure of diagrams and other forms of multimodal discourse may be broadly conceptualised as multimodal discourse parsing. Recent examples of work in this area include alikhanietal2019 and ottoetal2019, who model discourse relations between natural language and photographic images, drawing on linguistic theories of coherence and text\u2013image relations, respectively. In most cases, however, predicting a single discourse relation covers only a part of the discourse structure. sachanetal2019 note that there is a need for comprehensive theories and models of multimodal communication, as they can be used to rethink tasks that have been previously considered only from the perspective of natural language processing.",
          "Unlike many other areas, the study of diagrammatic representations is particularly well-resourced, as several multimodal resources have been published recently to support research on computational processing of diagrams BIBREF10, BIBREF8, BIBREF11. This study compares two such resources, AI2D BIBREF10 and AI2D-RST BIBREF11, which both feature the same diagrams, as the latter is an extension of the former. Whereas AI2D features crowd-sourced, non-expert annotations, AI2D-RST provides multiple layers of expert annotations, which are informed by state-of-the-art approaches to multimodal communication BIBREF12 and annotation BIBREF13, BIBREF14.",
          "This provides an interesting setting for comparison and evaluation, as non-expert annotations are cheap to produce and easily outnumber the expert-annotated data, whose production consumes both time and resources. Expert annotations, however, incorporate domain knowledge from multimodality theory, which is unavailable via crowd-sourcing. Whether expert annotations provide better representations of diagrammatic structures and thus justify their higher cost is one question that this study seeks to answer.",
          "Both AI2D and AI2D-RST represent the multimodal structure of diagrams using graphs. This enables learning their representations using graph neural networks, which are gaining currency as a graph is a natural choice for representing many types of data BIBREF15. This article reports on two experiments that evaluate the capability of AI2D and AI2D-RST to represent the multimodal structure of diagrams using graphs, focusing particularly on spatial layout, the hierarchical organisation of diagram elements and their connections expressed using arrows and lines."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "This section introduces the two multimodal resources compared in this study and discusses related work, beginning with the crowd-sourced annotations in AI2D and continuing with the alternative expert annotations in AI2D-RST, which are built on top of the crowd-sourced descriptions and cover a 1000-diagram subset of the original data. Figure FIGREF1 provides an overview of the two datasets, explains their relation to each other and provides an overview of the experiments reported in Section SECREF4"
        ]
      },
      {
        "section_name": "Data ::: Crowd-sourced Annotations from AI2D",
        "paragraphs": [
          "The Allen Institute for Artificial Intelligence Diagrams dataset (AI2D) contains 4903 English-language diagrams, which represent topics in primary school natural sciences, such as food webs, human physiology and life cycles, amounting to a total of 17 classes BIBREF10. The dataset was originally developed to support research on diagram understanding and visual question answering BIBREF16, but has also been used to study the contextual interpretation of diagrammatic elements, such as arrows and lines BIBREF17.",
          "The AI2D annotation schema models four types of diagram elements: text, graphics, arrows and arrowheads, whereas the semantic relations that hold between these elements are described using ten relations from a framework for analysing diagrammatic representations in engelhardt2002. Each diagram is represented using a Diagram Parse Graph (DPG), whose nodes stand for diagram elements while the edges between the nodes carry information about their semantic relations. The annotation for AI2D, which includes layout segmentations for the diagram images, DPGs and a multiple choice question-answer set, was created by crowd-sourced non-expert annotators on Amazon Mechanical Turk BIBREF10.",
          "I have previously argued that describing different types of multimodal structures in diagrammatic representations requires different types of graphs BIBREF18. To exemplify, many forms of multimodal discourse are assumed to possess a hierarchical structure, whose representation requires a tree graph. Diagrams, however, use arrows and lines to draw connections between elements that are not necessarily part of the same subtree, and for this reason representing connectivity requires a cyclic graph. AI2D DPGs, in turn, conflate the description of semantic relations and connections expressed using diagrammatic elements. Whether computational modelling of diagrammatic structures, or more generally, multimodal discourse parsing, benefits from pulling apart different types of multimodal structure remains an open question, which we pursued by developing an alternative annotation schema for AI2D, named AI2D-RST, which is introduced below."
        ]
      },
      {
        "section_name": "Data ::: Expert Annotations from AI2D-RST",
        "paragraphs": [
          "AI2D-RST covers a subset of 1000 diagrams from AI2D, which have been annotated by trained experts using a new multi-layer annotation schema for describing the diagrams in AI2D BIBREF11. The annotation schema, which draws on state-of-the-art theories of multimodal communication BIBREF12, adopts a stand-off approach to describing the diagrams. Hence the three annotation layers in AI2D-RST are represented using three different graphs, which use the same identifiers for nodes across all three graphs to allow combining the descriptions in different graphs. AI2D-RST contains three graphs:",
          "Grouping: A tree graph that groups together diagram elements that are likely to be visually perceived as belonging together, based loosely on Gestalt principles of visual perception BIBREF19. These groups are organised into a hierarchy, which represents the organisation of content in the 2D layout space BIBREF13, BIBREF14.",
          "Connectivity: A cyclic graph representing connections between diagram elements or their groups, which are signalled using arrows or lines BIBREF20.",
          "Discourse structure: A tree graph representing discourse structure of the diagram using Rhetorical Structure Theory BIBREF21, BIBREF22: hence the name AI2D-RST.",
          "The grouping graph, which is initially populated by diagram elements from the AI2D layout segmentation, provides a foundation for describing connectivity and discourse structure by adding nodes to the grouping graph that stand for groups of diagram elements, as shown in the upper part of Figure FIGREF1. In addition, the grouping graph includes annotations for 11 different diagram types identified in the data (e.g. cycles, cross-sections and networks), which may be used as target labels during training, as explained in Section SECREF26 The coarse and fine-grained diagram types identified in the data are shown in Figure FIGREF8.",
          "hiippalaetal2019-ai2d show that the proposed annotation schema can be reliably applied to the data by measuring inter-annotator agreement between five annotators on random samples from the AI2D-RST corpus using Fleiss' $\\kappa $ BIBREF23. The results show high agreement on grouping ($N = 256, \\kappa = 0.84$), diagram types ($N = 119, \\kappa = 0.78$), connectivity ($N = 239, \\kappa = 0.88$) and discourse structure ($N = 227, \\kappa = 0.73$). It should be noted, however, that these measures may be affected by implicit knowledge that tends to develop among expert annotators who work towards the same task BIBREF24."
        ]
      },
      {
        "section_name": "Graph-based Representations",
        "paragraphs": [
          "Both AI2D and AI2D-RST use graphs to represent the multimodal structure of diagrams. This section explicates how the graphs and their node and edge types differ across the two multimodal resources."
        ]
      },
      {
        "section_name": "Graph-based Representations ::: Nodes ::: Node Types",
        "paragraphs": [
          "AI2D and AI2D-RST share most node types that represent different diagram elements, namely text, graphics, arrows and the image constant, which is a node that stands for the entire diagram. In AI2D, generic diagram elements such as titles describing the entire diagram are typically connected to the image constant. In AI2D-RST, the image constant acts as the root node of the tree in the grouping graph. In addition to text, graphics, arrows and the image constant, AI2D-RST features two additional node types for groups and discourse relations, whereas AI2D includes an additional node for arrowheads. To summarise, AI2D contains five distinct node types, whereas AI2D-RST has six. Note, however, that only grouping and connectivity graphs used in this study, which limits the number to five for AI2D-RST."
        ]
      },
      {
        "section_name": "Graph-based Representations ::: Nodes ::: Node Features",
        "paragraphs": [
          "The same features are used for both AI2D and AI2D-RST for nodes with layout information, namely text, graphics, arrows and arrowheads (in AI2D only). The position, size and shape of each diagram element are described using the following features: (1) the centre point of the bounding box or polygon, divided by the height and width of the diagram image, (2) area, or the number of pixels within the polygon, divided by the total number of pixels in the image, and (3) the solidity of the polygon, or the polygon area divided by the area of its convex hull. This yields a 4-dimensional feature vector describing the position and size of each diagram element in the layout. Each dimension is set to zero for grouping nodes in AI2D-RST and image constant nodes in AI2D and AI2D-RST."
        ]
      },
      {
        "section_name": "Graph-based Representations ::: Nodes ::: Discourse Relations",
        "paragraphs": [
          "AI2D-RST models discourse relations using nodes, which have a 25-dimensional, one-hot encoded feature vector to represent the type of discourse relation, which are drawn from Rhetorical Structure Theory BIBREF21. In AI2D, the discourse relations derived from engelhardt2002 are represented using a 10-dimensional one-hot encoded vector, which is associated with edges connecting diagram elements participating in the relation. Because the two resources draw on different theories and represent discourse relations differently, I use the grouping and connectivity graph for AI2D-RST representations and ignore the edge features in AI2D, as these descriptions attempt to describe roughly the same multimodal structures. A comparison of discourse relations is left for a follow-up study focusing on representing the discourse structure of diagrams."
        ]
      },
      {
        "section_name": "Graph-based Representations ::: Edges",
        "paragraphs": [
          "Whereas AI2D encodes information about semantic relations using edges, in AI2D-RST the information carried by edges depends on the graph in question. The edges of the grouping graph do not have features, whereas the edges of the connectivity graph have a 3-dimensional, one-hot encoded vector that represents the type of connection. The edges of the discourse structure graph have a 2-dimensional, one-hot encoded feature vector to represent nuclearity, that is, whether the nodes that participate in a discourse relations act as nuclei or satellites.",
          "For the experiments reported in Section 4, self-loops are added to each node in the graph. A self-loop is an edge that originates in and terminates at the same node. Self-loops essentially add the graph's identity matrix to the adjacency matrix, which allow the graph neural networks to account for the node's own features during message passing, that is, when sending and receiving features from adjacent nodes."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "This section presents two experiments that compare AI2D and AI2D-RST annotations in classifying diagrams and their parts using various graph neural networks."
        ]
      },
      {
        "section_name": "Experiments ::: Graph Neural Networks",
        "paragraphs": [
          "I evaluated the following graph neural network architectures for both graph and node classification tasks:",
          "Graph Convolutional Network (GCN) BIBREF25",
          "Simplifying Graph Convolution (SGC) BIBREF26, averaging incoming node features from up to 2 hops away",
          "Graph Attention Network (GAT) BIBREF27 with 2 heads",
          "GraphSAGE (SAGE) BIBREF28 with LSTM aggregation",
          "I implemented all graph neural networks using Deep Graph Library 0.4 BIBREF29 on the PyTorch 1.3 backend BIBREF30. For GCN, GAT and SAGE, each network consists of two of the aforementioned layers with a Rectified Linear Unit (ReLU) activation, followed by a dense layer and a final softmax function for predicting class membership probabilities. For SGC, the network consists of a single SGC layer without an activation function. The implementations for each network are available in the repository associated with this article."
        ]
      },
      {
        "section_name": "Experiments ::: Hyperparameters and Training",
        "paragraphs": [
          "I used the Tree of Parzen Estimators (TPE) algorithm BIBREF31 to tune model hyperparameters separately for each dataset, architecture and task using the implementation in the Tune BIBREF32 and hyperopt BIBREF33 libraries. For each dataset, architecture and task, I evaluated a total of 100 hyperparameter combinations for a maximum of 100 epochs, using 850 diagrams for training and 150 for validation. The objective metric to be maximised was macro F1 score. Tables TABREF20 and TABREF21 give the hyperparameters and spaces searched for node and graph classification. Following shcuretal2018, I shuffled the training and validation splits for each run to prevent overfitting and used the same training procedure throughout. I used the Adam optimiser BIBREF34 for both hyperparameter search and training.",
          "To address the issue of class imbalance present in both tasks, class weights were calculated by dividing the total number of samples by the product of the number of unique classes and the number of samples for each class, as implemented in scikit-learn BIBREF35. These weights were passed to the loss function during hyperparameter search and training.",
          "After hyperparameter optimisation, I trained each model with the best hyperparameter combination for 20 runs, using 850 diagrams for training, 75 for validation and 75 for testing, shuffling the splits for each run while monitoring performance on the evaluation set and stopping training early if the macro F1 score failed to improve over 15 epochs for graph classification or over 25 epochs for node classification. I then evaluated the model on the testing set and recorded the result."
        ]
      },
      {
        "section_name": "Experiments ::: Tasks ::: Node Classification",
        "paragraphs": [
          "The purpose of the node classification task is to evaluate how well algorithms learn to classify the parts of a diagram using the graph-based representations in AI2D and AI2D-RST and node features representing the position, size and shape of the element, as described in Section SECREF11 Identifying the correct node type is a key step when populating a graph with candidate nodes from object detectors, particularly if the nodes will be processed further, for instance, to extract semantic representations from CNN features or word embeddings. Furthermore, the node representations learned during this task can be used as node features for graph classification, as will be shown shortly below in Section SECREF26",
          "Table TABREF25 presents a baseline for node classification from a dummy classifier, together with results for random forest and support vector machine classifiers trained on 850 and tested on 150 diagrams. Both AI2D and AI2D-RST include five node types, of which four are the same: the difference is that whereas AI2D includes arrowheads, AI2D-RST includes nodes for groups of diagram elements, as outlined in Section SECREF9 The results seem to reflect the fact that image constants and grouping nodes have their features set to zero, and RF and SVM cannot leverage features incoming from their neighbouring nodes to learn node representations. This is likely to affect the result for AI2D-RST, which includes 7300 grouping nodes that are used to create a hierarchy of diagram elements.",
          "Table TABREF22 shows the results for node classification using various graph neural network architectures. Because the results are not entirely comparable due to different node types present in the two resources, it is more reasonable to compare architectures. SAGE, GCN and GAT clearly outperform SGC in classifying nodes from both resources, as does the random forest classifier. AI2D nodes are classified with particularly high accuracy, which may result from having to learn representations for only one node type, that is, the image constant ($N = 1000$). AI2D-RST, in turn, must learn representations from scratch for both image constants ($N = 1000$) and grouping nodes ($N = 7300$).",
          "Because SAGE learns useful node representations for both resources, as reflected in high performance for all metrics, I chose this architecture for extracting node features for graph classification."
        ]
      },
      {
        "section_name": "Experiments ::: Tasks ::: Graph Classification",
        "paragraphs": [
          "This task compares the performance of graph-based representations in AI2D and AI2D-RST for classifying entire diagrams. Here the aim is to evaluate to what extent graph neural networks can learn about the generic structure of primary school science diagrams from the graph-based representations in AI2D and AI2D-RST. Correctly identifying what the diagram attempts to communicate and how carries implications for tasks such as visual question answering, as the type of a diagram constrains the interpretation of key diagrammatic elements, such as the meaning of lines and arrows BIBREF1, BIBREF17.",
          "To enable a fair comparison, the target classes are derived from both AI2D and AI2D-RST. Whereas AI2D includes 17 classes that represent the semantic content of diagrams, as exemplified by categories such as `parts of the Earth', `volcano', and `food chains and webs', AI2D-RST classifies diagrams into abstract diagram types, such as cycles, networks, cross-sections and cut-outs. More specifically, AI2D-RST provides classes for diagram types at two levels of granularity, fine-grained (12 classes) and coarse (5 classes), which are derived from the proposed schema for diagram types in AI2D-RST BIBREF11.",
          "The 11 fine-grained classes in AI2D-RST shown in Figure FIGREF8 are complemented by an additional class (`mixed'), which includes diagrams that combine multiple diagram types, whose inclusion avoids performing multi-label classification (see the example in Figure FIGREF28). The coarse classes, which are derived by grouping fine-grained classes for tables, tabular and spatial organisations, networks and cycles, diagrammatic and pictorial representations, and so on, are also complemented by a `mixed' class.",
          "For this task, the node features consist of the representations learned during node classification in Section SECREF24 These representations are extracted by feeding the features representing node position, size and shape to the graph neural network, which in both cases uses the GraphSAGE architecture BIBREF28, and recording the output of the final softmax activation. Compared to a one-hot encoding, representing node identity using a probability distribution from a softmax activation reduces the sparsity of the feature vector. This yields a 5-dimensional feature vector for each node.",
          "Table TABREF29 provides a baseline for graph classification from a dummy classifier, as well as results for random forest (RF) and support vector machine (SVM) classifiers trained on 850 and tested on 150 diagrams. The macro F1 scores show that the RF classifier with 100 decision trees offers competitive performance for all target classes and both AI2D and AI2D-RST, in some cases outperforming graph neural networks. It should be noted, however, that the RF classifier is trained with node features learned using GraphSAGE.",
          "The results for graph classification using graph neural networks presented in Table TABREF27 show certain differences between AI2D and AI2D-RST. When classifying diagrams into the original semantic categories defined in AI2D ($N = 17$), the AI2D graphs significantly outperform AI2D-RST when using the GraphSAGE architecture. For all other graph neural networks, the differences between AI2D and AI2D-RST are not statistically significant. This is not surprising as the AI2D graphs were tailored for the original classes, yet the AI2D-RST graphs seem to capture generic properties that help to classify diagrams into semantic categories nearly as accurately as AI2D graphs designed specifically for this purpose, although no semantic features apart from the layout structure are provided to the classifier.",
          "The situation is reversed for the coarse ($N = 5$) and fine-grained ($N = 12$) classes from AI2D-RST, in which the AI2D-RST graphs generally outperform AI2D, except for coarse classification using SGC. This classification task obviously benefits AI2D-RST, whose classification schema was originally designed for abstract diagram types. This may also suggest that the AI2D graphs do not capture regularities that would support learning to generalise about diagram types. The situation is somewhat different for fine-grained classification, in which the differences in performance are relatively small.",
          "Generally, most architectures do not benefit from combining the grouping and connectivity graphs in AI2D-RST. This is an interesting finding, as many diagram types differ in terms of their connectivity structures (e.g. cycles and networks) BIBREF11. The edges introduced from the connectivity graph naturally increase the flow of information in the graph, but this does not seem to help learn distinctive features between diagram types. On the other hand, it should be noted that the nodes are not typed, that is, the model cannot distinguish between edges from the grouping and connectivity graphs.",
          "Overall, the macro F1 scores for both AI2D and AI2D-RST, which assigns equal weight to all classes regardless of the number of samples, underline the challenge of training classifiers using limited data with imbalanced classes. The lack of visual features may also affect overall classification performance: certain fine-grained classes, which are also prominent in the data, such as 2D cross-sections and 3D cut-outs, may have similar graph-based representations. Extracting visual features from diagram images may help to discern between diagrams whose graphs bear close resemblance to one another, but this would require advanced object detectors for non-photographic images."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "The results for AI2D-RST show that the grouping graph, which represents visual perceptual groups of diagram elements and their hierarchical organisation, provides a robust foundation for describing the spatial organisation of diagrammatic representations. This kind of generic schema can be expanded beyond diagrams to other modes of expression that make use of the spatial extent, such as entire page layouts. A description of how the layout space is used can be incorporated into any effort to model discourse relations that may hold between the groups or their parts.",
          "The promising results AI2D-RST suggest is that domain experts in multimodal communication should be involved in planning crowd-sourced annotation tasks right from the beginning. Segmentation, in particular, warrants attention as this phase defines the units of analysis: cut-outs and cross-sections, for instance, use labels and lines to pick out sub-regions of graphical objects, whereas in illustrations the labels often refer to entire objects. Such distinctions should preferably be picked out at the very beginning to be incorporated fully into the annotation schema.",
          "Tasks related to grouping and connectivity annotation could be crowd-sourced relatively easily, whereas annotating diagram types and discourse relations may require multi-step procedures and assistance in the form of prompts, as yungetal2019 have recently shown for RST. Involving both expert and crowd-sourced annotators could also alleviate problems related to circularity by forcing domain experts to frame the tasks in terms understandable to crowd-sourced workers BIBREF24.",
          "In light of the results for graph classification, one should note that node features are averaged before classification regardless of their connections in the graph. Whereas the expert-annotated grouping graph in AI2D-RST has been pruned from isolated nodes, which ensures that features are propagated to neighbouring nodes, the crowd-sourced AI2D graphs contain both isolated nodes and subgraphs. To what extent these disconnections affect the performance for AI2D warrant a separate study. Additionally, more advanced techniques than mere averaging, such as pooling, should be explored in future work.",
          "Finally, there are many aspects of diagrammatic representation that were not explored in this study. To begin with, a comparison of representations for discourse structures using the question-answering set accompanying AI2D would be particularly interesting, especially if both AI2D and AI2D-RST graphs were enriched with features from state of the art semantic representations for natural language and graphic elements."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this article, I compared graph-based representations of diagrams representing primary school science topics from two datasets that contain the same diagrams, which have been annotated by either crowd-sourced workers or trained experts. The comparison involved two tasks, graph and node classification, using four different architectures for graph neural networks, which were compared to baselines from dummy, random forest and support vector machine classifiers.",
          "The results showed that graph neural networks can learn to accurately identify diagram elements from their size, shape and position in layout. These node representations could then be used as features for graph classification. Identifying diagrams, either in terms of what they represent (semantic content) or how (abstract diagram type), proved more challenging using the graph-based representations. Improving accuracy may require additional features that capture visual properties of the diagrams, as these distinctions cannot be captured by graph-based representations and features focusing on layout.",
          "Overall, the results nevertheless suggest that simple layout features can provide a foundation for representing diagrammatic structures, which use the layout space to organise the content and set up discourse relations between different elements. To what extent these layout features can support the prediction of actual discourse relations should be explored in future research."
        ]
      }
    ],
    "qas": [
      {
        "question": "What are the parts of the \"multimodal\" resources?",
        "question_id": "20632fc4d2b693b5aabfbbc99ee5c1e9fc485dea",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "somewhat",
        "search_query": "expert",
        "question_writer": "2a18a3656984d04249f100633e4c1003417a2255",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "spatial organisation ",
                "discourse structure"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "From the perspective of computational processing, diagrammatic representations present a formidable challenge, as they involve tasks from both computer vision and natural language processing. On the one hand, diagrams have a spatial organisation \u2013 layout \u2013 which needs to be segmented to identify meaningful units and their position. Making sense of how diagrams exploit the 2D layout space falls arguably within the domain of computer vision. On the other hand, diagrams also have a discourse structure, which uses the layout space to set up discourse relations between instances of natural language, various types of images, arrows and lines, thus forming a unified discourse organisation. The need to parse this discourse structure shifts the focus towards the field of natural language processing."
              ],
              "highlighted_evidence": [
                "From the perspective of computational processing, diagrammatic representations present a formidable challenge, as they involve tasks from both computer vision and natural language processing. On the one hand, diagrams have a spatial organisation \u2013 layout \u2013 which needs to be segmented to identify meaningful units and their position. Making sense of how diagrams exploit the 2D layout space falls arguably within the domain of computer vision. On the other hand, diagrams also have a discourse structure, which uses the layout space to set up discourse relations between instances of natural language, various types of images, arrows and lines, thus forming a unified discourse organisation."
              ]
            },
            "annotation_id": "25fea29bb0d5938ef71ea3a4d4dd7df89029bfe8",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "node types that represent different diagram elements",
                "The same features are used for both AI2D and AI2D-RST for nodes with layout information",
                "discourse relations",
                "information about semantic relations"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "AI2D and AI2D-RST share most node types that represent different diagram elements, namely text, graphics, arrows and the image constant, which is a node that stands for the entire diagram. In AI2D, generic diagram elements such as titles describing the entire diagram are typically connected to the image constant. In AI2D-RST, the image constant acts as the root node of the tree in the grouping graph. In addition to text, graphics, arrows and the image constant, AI2D-RST features two additional node types for groups and discourse relations, whereas AI2D includes an additional node for arrowheads. To summarise, AI2D contains five distinct node types, whereas AI2D-RST has six. Note, however, that only grouping and connectivity graphs used in this study, which limits the number to five for AI2D-RST.",
                "The same features are used for both AI2D and AI2D-RST for nodes with layout information, namely text, graphics, arrows and arrowheads (in AI2D only). The position, size and shape of each diagram element are described using the following features: (1) the centre point of the bounding box or polygon, divided by the height and width of the diagram image, (2) area, or the number of pixels within the polygon, divided by the total number of pixels in the image, and (3) the solidity of the polygon, or the polygon area divided by the area of its convex hull. This yields a 4-dimensional feature vector describing the position and size of each diagram element in the layout. Each dimension is set to zero for grouping nodes in AI2D-RST and image constant nodes in AI2D and AI2D-RST.",
                "AI2D-RST models discourse relations using nodes, which have a 25-dimensional, one-hot encoded feature vector to represent the type of discourse relation, which are drawn from Rhetorical Structure Theory BIBREF21. In AI2D, the discourse relations derived from engelhardt2002 are represented using a 10-dimensional one-hot encoded vector, which is associated with edges connecting diagram elements participating in the relation. Because the two resources draw on different theories and represent discourse relations differently, I use the grouping and connectivity graph for AI2D-RST representations and ignore the edge features in AI2D, as these descriptions attempt to describe roughly the same multimodal structures. A comparison of discourse relations is left for a follow-up study focusing on representing the discourse structure of diagrams.",
                "Whereas AI2D encodes information about semantic relations using edges, in AI2D-RST the information carried by edges depends on the graph in question. The edges of the grouping graph do not have features, whereas the edges of the connectivity graph have a 3-dimensional, one-hot encoded vector that represents the type of connection. The edges of the discourse structure graph have a 2-dimensional, one-hot encoded feature vector to represent nuclearity, that is, whether the nodes that participate in a discourse relations act as nuclei or satellites."
              ],
              "highlighted_evidence": [
                "AI2D and AI2D-RST share most node types that represent different diagram elements, namely text, graphics, arrows and the image constant, which is a node that stands for the entire diagram.",
                "The same features are used for both AI2D and AI2D-RST for nodes with layout information, namely text, graphics, arrows and arrowheads (in AI2D only).",
                "AI2D-RST models discourse relations using nodes, which have a 25-dimensional, one-hot encoded feature vector to represent the type of discourse relation, which are drawn from Rhetorical Structure Theory BIBREF21. In AI2D, the discourse relations derived from engelhardt2002 are represented using a 10-dimensional one-hot encoded vector, which is associated with edges connecting diagram elements participating in the relation.",
                "Whereas AI2D encodes information about semantic relations using edges, in AI2D-RST the information carried by edges depends on the graph in question. The edges of the grouping graph do not have features, whereas the edges of the connectivity graph have a 3-dimensional, one-hot encoded vector that represents the type of connection."
              ]
            },
            "annotation_id": "793e8b6492460b7840dbf093f01a0ee48005eb4f",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "grouping, connectivity, and discourse structure ",
              "evidence": [
                "AI2D-RST covers a subset of 1000 diagrams from AI2D, which have been annotated by trained experts using a new multi-layer annotation schema for describing the diagrams in AI2D BIBREF11. The annotation schema, which draws on state-of-the-art theories of multimodal communication BIBREF12, adopts a stand-off approach to describing the diagrams. Hence the three annotation layers in AI2D-RST are represented using three different graphs, which use the same identifiers for nodes across all three graphs to allow combining the descriptions in different graphs. AI2D-RST contains three graphs:",
                "Grouping: A tree graph that groups together diagram elements that are likely to be visually perceived as belonging together, based loosely on Gestalt principles of visual perception BIBREF19. These groups are organised into a hierarchy, which represents the organisation of content in the 2D layout space BIBREF13, BIBREF14.",
                "Connectivity: A cyclic graph representing connections between diagram elements or their groups, which are signalled using arrows or lines BIBREF20.",
                "Discourse structure: A tree graph representing discourse structure of the diagram using Rhetorical Structure Theory BIBREF21, BIBREF22: hence the name AI2D-RST."
              ],
              "highlighted_evidence": [
                "AI2D-RST contains three graphs:\n\nGrouping: A tree graph that groups together diagram elements that are likely to be visually perceived as belonging together, based loosely on Gestalt principles of visual perception BIBREF19. These groups are organised into a hierarchy, which represents the organisation of content in the 2D layout space BIBREF13, BIBREF14.\n\nConnectivity: A cyclic graph representing connections between diagram elements or their groups, which are signalled using arrows or lines BIBREF20.\n\nDiscourse structure: A tree graph representing discourse structure of the diagram using Rhetorical Structure Theory BIBREF21, BIBREF22: hence the name AI2D-RST."
              ]
            },
            "annotation_id": "f03e115c4a2bab6045fbf73d11b2a9565ac809ed",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: The relationship between crowd-sourced annotations in AI2D and AI2D-RST. AI2D-RST provides alternative, expert-annotated stand-off descriptions for a subset of 1000 diagrams from the original AI2D dataset. The grouping layer in AI2D provides a foundation for further annotation layers by allowing references to groups of nodes."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Fine-grained classes, their number and frequencies in AI2D-RST (N = 1134). Note that the number of classes exceeds the number of diagrams in AI2D-RST, as some diagrams feature multiple diagram types. The arrows indicate choices: if the diagram designer chooses depiction, a further choice must be made between pictorial\u2013 diagrammatic and 2D/3D representations. The dashed lines indicate coarse groups of diagram types."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Hyperparameter ranges for graph classification"
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Hyperparameter ranges for node classification"
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Mean accuracy, macro F1 and weighted F1 scores for node classification. The results are averaged over 20 runs. The following abbreviations indicate the graph used: \u2018AI2D\u2019 for the original crowd-sourced graphs from AI2D, \u2018G\u2019 for the grouping graph and \u2018G+C\u2019 for the combination of grouping and connectivity graph from AI2D-RST. An asterisk indicates that the difference between AI2D and the best AI2D-RST graph is statistically significant at p < 0.05 when comparing the results for the given metric over 20 runs using Mann\u2013Whitney U test. The best result for each metric is marked using bold."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Diagram #4120 in AI2D combines two diagram types: a cross-section with a cycle (cf. Figure 2)"
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Baseline accuracy, macro F1 and weighted F1 scores for node classification from dummy (D), random forest (RF; 100 estimators) and support vector machine (SVM; C = 1.0) classifiers with balanced class weights. The results are averaged over 20 runs. All models were implemented using scikit-learn 0.21.3. Each node is represented by a 4-dimensional vector."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: Mean accuracy, macro F1 and weighted F1 scores for graph classification. The results are averaged over 20 runs. The following abbreviations indicate the graph used: \u2018AI2D\u2019 for the original crowd-sourced graphs from AI2D, \u2018G\u2019 for the grouping graph and \u2018G+C\u2019 for the combination of grouping and connectivity graph from AI2D-RST. * indicates that the difference between AI2D and the best AI2D-RST graph is statistically significant at p < 0.05 when comparing the results over 20 runs for the given metric using Mann\u2013Whitney U test. + indicates the same for AI2D-RST grouping graph and the combination of grouping and connectivity graphs. The best result for each metric across all models and graphs is marked in bold."
      },
      {
        "file": "6-Table6-1.png",
        "caption": "Table 6: Baseline accuracy, macro F1 and weighted F1 scores for graph classification using dummy (D), random forest (RF; 100 estimators) and support vector machine (SVM; C = 1.0) classifiers with balanced class weights. The results are averaged over 20 runs. All models were implemented using scikit-learn 0.21.3. Each diagram is represented by a 5-dimensional vector acquired by averaging the features for all nodes in the graph."
      }
    ]
  },
  "1812.00382": {
    "title": "Improved and Robust Controversy Detection in General Web Pages Using Semantic Approaches under Large Scale Conditions",
    "abstract": "Detecting controversy in general web pages is a daunting task, but increasingly essential to efficiently moderate discussions and effectively filter problematic content. Unfortunately, controversies occur across many topics and domains, with great changes over time. This paper investigates neural classifiers as a more robust methodology for controversy detection in general web pages. Current models have often cast controversy detection on general web pages as Wikipedia linking, or exact lexical matching tasks. The diverse and changing nature of controversies suggest that semantic approaches are better able to detect controversy. We train neural networks that can capture semantic information from texts using weak signal data. By leveraging the semantic properties of word embeddings we robustly improve on existing controversy detection methods. To evaluate model stability over time and to unseen topics, we asses model performance under varying training conditions to test cross-temporal, cross-topic, cross-domain performance and annotator congruence. In doing so, we demonstrate that weak-signal based neural approaches are closer to human estimates of controversy and are more robust to the inherent variability of controversies.",
    "full_text": [
      {
        "section_name": "Introduction & Prior work",
        "paragraphs": [
          "Controversy detection is an increasingly important task. Controversial content can signal the need for moderation on social platforms, either to prevent conflict between users or limit the spread of misinformation. More generally, controversies provide insight into societies BIBREF0 . Often, the controversial content is outside the direct control of a platform on which it is shared, mentioned or discussed. This raises the requirement of generally applicable methods to gauge controversial content on the web for moderation purposes. Unfortunately, what is controversial changes, and may lie more in the way topics are discussed rather than what is discussed, making it difficult to detect controversies in a robust fashion. We take the task of controversy detection and evaluate robustness of different methodologies with respect to the varying nature of controversies.",
          "Prior work on detecting controversies has taken three kinds of approaches: 1) lexical approaches, which seek to detect controversies through signal terms, either through bag-of-word classifiers, lexicons, or lexicon based language models BIBREF1 . 2) explicit modeling of controversy through platform-specific features, often in Wikipedia or social-media settings. Features such as mutual reverts BIBREF2 , user-provided flags BIBREF3 , interaction networks BIBREF4 or stance-distributions BIBREF5 have been used as platform-specific indicators of controversies. The downside of these approaches is the lack of generalizability due to their platform-specific nature. 3) matching models that combine lexical and explicit modelling approaches by looking at lexical similarities between a given text and a set of texts in a domain that provides explicit features BIBREF1 , BIBREF6 , BIBREF7 .",
          "Controversy detection is a difficult task because 1) controversies are latent, like ideology, meaning they are often not directly mentioned as controversial in text. 2) Controversies occur across a vast range of topics with varying topic-specific vocabularies. 3) Controversies change over time, with some topics and actors becoming controversial whereas others stop to be so. Previous approaches lack the power to deal with such changes. Matching and explicit approaches are problematic when the source corpus (e.g. Wikipedia) lags after real-world changes BIBREF8 . Furthermore, lexical methods trained on common (e.g. fulltext) features are likely to memorize the controversial topics in the training set rather than the `language of controversy'. Alleviating dependence on platform specific features and reducing sensitivity to an exact lexical representation is paramount to robust controversy detection. To this end, we focus only on fulltext features and suggest to leverage the semantic representations of word embeddings to reduce the vocabulary-gap for unseen topics and exact lexical representations.",
          "The majority of NLP-task related neural architectures rely on word embeddings, popularized by Mikolov et al BIBREF9 to represent texts. In essence these embeddings are latent-vector representations that aim to capture the underlying meaning of words. Distances between such latent-vectors are taken to express semantic relatedness, despite having different surface forms. By using embeddings, neural architectures are also able to leverage features learned on other texts (e.g. pretrained word embeddings) and create higher level representations of input (e.g. convolutional feature maps or hidden-states). These properties suggest that neural approaches are better able to generalize to unseen examples that poorly match the training set. We use two often applied network architectures adopting word embeddings, to classify controversy: Recurrent Neural Networks BIBREF10 and Convolutional Neural Networks BIBREF11 to answer the following research question. RQ: Can we increase robustness of controversy detection using neural methods?",
          "Currently, there is no open large-size controversy detection dataset that lends itself to test cross-temporal and cross-topic stability. Thus we generate a Wikipedia crawl-based dataset that includes general web pages and is sufficiently large to train and test high capacity models such as neural networks."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "A proven approach in modelling text with neural networks is to use Recurrent Neural Networks (RNNs) which enjoy weight sharing capabilities to model words irrespective of their sequence location. A specific type, the Hierarchical Attention Network (HAN) proposed by BIBREF10 makes use of attention to build document representations in a hierarchical manner. It uses bi-directional Gated Recurrent Units (GRUs) BIBREF12 to selectively update representations of both words and sentences. This allows the network to both capture the hierarchy from words to sentences to documents and to explicitly weigh all parts of the document relevant during inference.",
          "Recently, Convolutional Neural Networks (CNNs) have enjoyed increasing success in text classification. One such network introduced by BIBREF11 looks at patterns in words within a window, such as \"Scientology [...] brainwashes people\". The occurrences of these patterns are then summarized to their 'strongest' observation (max-pooling) and used for classification. Since pooling is applied after each convolution, the output size of each convolutional operation itself is irrelevant. Therefore, filters of different sizes can be used, each capturing patterns in different sized word windows.",
          "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. Similar to BIBREF10 , each bi-directional GRU cell is set to a dimension of 50, resulting in a word/sentence representation of size 100 after concatenation. The word/sentence attention vectors similarly contain 100 dimensions, all randomly initialized. The word windows defined in the CNN model are set to sizes: 2, 3 and 4 with 128 feature maps each. Each model is trained using mini batches of size 64 and uses both dropout (0.5) and INLINEFORM0 regularization (1e-3) at the dense prediction layer. Both networks use pre-trained embeddings, trained on 100 billion words of a Google News corpus, which are further fine-tuned during training on the controversy dataset. The optimization algorithm used is Adam BIBREF13 (learning rate: 1e-3)."
        ]
      },
      {
        "section_name": "Datasets and evaluation",
        "paragraphs": [
          "We use the Clueweb09 derived dataset of BIBREF0 for baseline comparison. For cross-temporal, cross-topic and cross-domain training & evaluation, we generate a new dataset based on Wikipedia crawl data. This dataset is gathered by using Wikipedia's `List of Contoversial articles' overview page of 2018 (time of writing) and 2009 (for comparison with baselines) . Using this as a `seed' set of controversial articles, we iteratively crawl the `See also', `References' and `External links' hyperlinks up to two hops from the seed list. The negative seed pages (i.e. non controversial) are gathered by using the random article endpoint. The snowball-sample approach includes general, non-Wikipedia, pages that are referred to from Wikipedia pages. The dataset thus extends beyond just the encyclopedia genre of texts. Labels are assumed to propagate: a page linked from a controversial issue is assumed to be controversial. The resulting dataset statistics are summarized in Table TABREF7 .",
          "To be useful as a flagging mechanism for moderation, a controversy detection algorithm should satisfy both Precision and Recall criteria. F1 scores will therefore be used to evaluate this balance. The AUC values are used to measure classification performance in the unbalanced controversy datasets. The test-train split depends on the task investigated and is listed in the results section for the respective task. To test for significant results, all models were evaluated using a bootstrap approach: by drawing 1000 samples with replacements INLINEFORM0 documents from the test set equal to the test-set size. The resulting confidence intervals based on percentiles provide a measure of significance."
        ]
      },
      {
        "section_name": "Baseline models",
        "paragraphs": [
          "To compare the results of neural approaches to prior work we implemented the previous state-of-the-art controversy detection method: the language model from BIBREF7 . Together with an SVM baseline they act as controversy detection alternatives using only full text features, thus meeting the task-requirements of platform-independence. Note: the implementation of BIBREF7 additionally requires ranking methods to select a subset of the training data for each language model. A simplified version of this, excluding the ranking method but using the same dataset and lexicon to select documents as BIBREF7 , is implemented and included in the baselines comparison section (LM-DBPedia). We also included the same language model trained on the full text Wikipedia pages (LM-wiki). Similarly, for completeness sake, we also include both the state-of-the-art matching model, the TILE-Clique model from BIBREF1 and the sentiment analysis baseline (using the state-of-the-art Polyglot library for python) from BIBREF6 in the comparison with previous work."
        ]
      },
      {
        "section_name": "Comparison of results with previous work",
        "paragraphs": [
          "Table TABREF13 shows the relative performance of the neural models compared to previous controversy detection methods, evaluated on the Clueweb09 derived dataset of BIBREF6 and trained on the Wikipedia data from the same time frame. The TILE-Clique matching model outperforms all other models on Precision although this difference is not significant compared to the neural approaches. Similarly, the language model trained on the DBPedia dataset outperforms other models on Recall but shows no significant difference compared to the CNN model. Notably, the neural approaches show comparable results to the TILE-Clique model in terms of F1, demonstrating a balanced performance in terms of Precision and Recall. Furthermore, the CNN model shows a significant improvement compared to the other non neural baselines in terms of the AUC value (p < 0.05)."
        ]
      },
      {
        "section_name": "Robustness of the model across time",
        "paragraphs": [
          "Controversy is expected to change over time. Some issues become controversial, others cease to be so. To investigate robustness of controversy detection models with respect to changes over time, we evaluate model performance in two variants: trained and tested on 2018, or trained on the 2009 Wikipedia data and tested on the 2018 Wikipedia data. Table 3 shows the results for each of the text-based detection models.",
          "Within year, the hierarchical attention model (HAN) outperforms all other models on Recall, F1 and AUC, losing Precision to the CNN and SVM models. However, our main interest is the robustness when a model is trained on a different year (2009) than the test set (2018). These between year experiments show a superior score for the HAN model compared to the non-neural models on Recall, and show significant improvements on F1 (p < 0.05) and AUC (p < 0.05), losing only to the SVM model on Precision (non significantly). In terms of robustness, we can also take the percentage change between the within year and between year experiment into account (were smaller absolute changes are preferable), shown by the delta values. With regard to temporal sensitivity, the CNN shows the least change across all four metrics. In Figure 1, we show the pooled results for the lexical and neural models to illustrate the overall increase in robustness by neural approaches.",
          "Interestingly, the SVM and HAN model show some unexpected improvement with regard to Precision when applied to unseen timeframes. For both models, this increase in Precision is offset by a greater loss in Recall, which seems to indicate both models `memorize` the controversial topics in a given timeframe instead of the controversial language. Overall, the neural approaches seem to compare favorably in terms of cross-temporal stability."
        ]
      },
      {
        "section_name": "Robustness of the model across topics",
        "paragraphs": [
          "To evaluate robustness towards unseen topics, 10-fold cross validation was used on the top ten largest topics present in the Wikipedia dataset in a leave-one-out fashion. The results are shown in table 4. In line with previous results, the language model scores best on Recall, beating all other models with a significant difference (p < 0.01). However in balancing Recall with Precision, the HAN model scores best, significantly outperforming both lexical models in F1 score (p < 0.05). Overall, when grouping together all neural and lexical results, the neural methods outperform the lexical models in Precision (p < 0.01), F1 (p < 0.05) and AUC (p < 0.01) with no significant difference found on the overall Recall scores. These results indicate that neural methods seem better able to generalize to unseen topics."
        ]
      },
      {
        "section_name": "Robustness of the model across domains",
        "paragraphs": [
          "Most work on controversy has looked into using existing knowledge bases as a source of controversy information BIBREF6 , BIBREF1 . In this paper, we focus on text-based classification methods that do not aim to explicitly link general web pages to their knowledge-base counterparts. Therefore, we are interested in the ability of neural models to generalize beyond their training context. In addition to testing across time and topics, we also investigate robustness to changes in domain. By training only on Wikipedia data, and evaluating only on general web-pages, we look at the ability of the four methods to deal with out-of-domain documents.",
          "The hierarchical attention network shows significantly better results (p < 0.05) compared to all other models on F1. Both neural models also outperform both language models on AUC significantly (p < 0.05). Precision and Recall are more mixed, with the CNN and SVM outperforming the HAN on Precision and the language model -again- performing best in terms of Recall. Together, the neural methods seem to work best on three out of the four metrics."
        ]
      },
      {
        "section_name": "Human agreement",
        "paragraphs": [
          "Lastly, we examine model performance with respect to human annotation using the human annotated dataset of BIBREF6 . We assume that models that perform similarly to human annotators are preferable. In Table TABREF20 , we present three Spearman correlation metrics to express model congruence with human annotations. Mean annotation expresses the correlation of model error rates with the controversy values attributed to a web page by human annotators, with positive values expressing greater error rates on controversial, and negative expressing higher error rates on non-controversial pages. Here, the HAN shows most unbiased (closest to zero) performance.",
          "Certainty is the distance of human annotations to the midpoint of the four-point controversy scale, i.e. a score between 0 and 2.5 that expresses how sure annotators are of document (non)controversy. Here, the HAN shows errors most strongly negatively correlated to the certainty of annotators. Finally, annotators disagree on the controversy of some documents, expressed as the standard deviation of their controversy annotations. Again, the HAN model seems preferable, as it's errors are most strongly correlated to annotator disagreement. Overall, the neural methods have less biased performance in relation to (non)controversial documents, correlate more strongly with the certainty of human annotators and are susceptible to errors in similar conditions as when annotators disagree."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Controversy detection is a hard task, as it forms a latent concept sensitive to vocabulary gaps between topics and vocabulary shifts over time. We analysed the performance of language model, SVM, CNN and HAN models on different tasks.",
          "First, we have demonstrated that neural methods perform as state-of-the-art tools in controversy detection on the ClueWeb09 BIBREF0 based testset, even beating matching models. Second, we investigated temporal stability, and demonstrated neural -and especially CNN- robustness in terms of Recall, F1 and AUC performance and stability with train and test sets that are 9 years apart. Thirdly, we show that CNN and HAN models outperform the SVM and LM baselines on Precision, F1 and AUC when tested on held-out-topics. Fourthly, we show that neural methods are better able to generalize from Wikipedia pages to unseen general web pages in terms of Precision, F1 and AUC. Lastly, neural methods seem better in line with human annotators with regard to certainty and disagreement."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which model architecture do they opt for?",
        "question_id": "7ff7c286d3118a8be5688e2d18e9a56fe83679ad",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Recurrent Neural Networks",
                "Convolutional Neural Networks"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The majority of NLP-task related neural architectures rely on word embeddings, popularized by Mikolov et al BIBREF9 to represent texts. In essence these embeddings are latent-vector representations that aim to capture the underlying meaning of words. Distances between such latent-vectors are taken to express semantic relatedness, despite having different surface forms. By using embeddings, neural architectures are also able to leverage features learned on other texts (e.g. pretrained word embeddings) and create higher level representations of input (e.g. convolutional feature maps or hidden-states). These properties suggest that neural approaches are better able to generalize to unseen examples that poorly match the training set. We use two often applied network architectures adopting word embeddings, to classify controversy: Recurrent Neural Networks BIBREF10 and Convolutional Neural Networks BIBREF11 to answer the following research question. RQ: Can we increase robustness of controversy detection using neural methods?"
              ],
              "highlighted_evidence": [
                "We use two often applied network architectures adopting word embeddings, to classify controversy: Recurrent Neural Networks BIBREF10 and Convolutional Neural Networks BIBREF11 to answer the following research question."
              ]
            },
            "annotation_id": "1d28d882a142fa81995ebadd0f2cfeda514709a7",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "RNNs and CNNs"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. Similar to BIBREF10 , each bi-directional GRU cell is set to a dimension of 50, resulting in a word/sentence representation of size 100 after concatenation. The word/sentence attention vectors similarly contain 100 dimensions, all randomly initialized. The word windows defined in the CNN model are set to sizes: 2, 3 and 4 with 128 feature maps each. Each model is trained using mini batches of size 64 and uses both dropout (0.5) and INLINEFORM0 regularization (1e-3) at the dense prediction layer. Both networks use pre-trained embeddings, trained on 100 billion words of a Google News corpus, which are further fine-tuned during training on the controversy dataset. The optimization algorithm used is Adam BIBREF13 (learning rate: 1e-3)."
              ],
              "highlighted_evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. "
              ]
            },
            "annotation_id": "4c3354c49f851ababf85124987077729d688a060",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "HAN BIBREF10",
                "CNN BIBREF11"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. Similar to BIBREF10 , each bi-directional GRU cell is set to a dimension of 50, resulting in a word/sentence representation of size 100 after concatenation. The word/sentence attention vectors similarly contain 100 dimensions, all randomly initialized. The word windows defined in the CNN model are set to sizes: 2, 3 and 4 with 128 feature maps each. Each model is trained using mini batches of size 64 and uses both dropout (0.5) and INLINEFORM0 regularization (1e-3) at the dense prediction layer. Both networks use pre-trained embeddings, trained on 100 billion words of a Google News corpus, which are further fine-tuned during training on the controversy dataset. The optimization algorithm used is Adam BIBREF13 (learning rate: 1e-3)."
              ],
              "highlighted_evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model."
              ]
            },
            "annotation_id": "a2cb8f9b4aed107076d80e6eb0e9c92c378ae910",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CNN",
                "RNN"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. Similar to BIBREF10 , each bi-directional GRU cell is set to a dimension of 50, resulting in a word/sentence representation of size 100 after concatenation. The word/sentence attention vectors similarly contain 100 dimensions, all randomly initialized. The word windows defined in the CNN model are set to sizes: 2, 3 and 4 with 128 feature maps each. Each model is trained using mini batches of size 64 and uses both dropout (0.5) and INLINEFORM0 regularization (1e-3) at the dense prediction layer. Both networks use pre-trained embeddings, trained on 100 billion words of a Google News corpus, which are further fine-tuned during training on the controversy dataset. The optimization algorithm used is Adam BIBREF13 (learning rate: 1e-3)."
              ],
              "highlighted_evidence": [
                "We explore the potential of RNNs and CNNs for controversy detection using both the HAN BIBREF10 and the CNN BIBREF11 model. "
              ]
            },
            "annotation_id": "f7500298975bc3cfe0ef68549aa4b7309ff65846",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1:Wikipedia derived dataset statistics. Including the percentages of controversial (i.e. positive labelled) and general (i.e. non-Wikipedia) web pages from the total amount of pages per dataset split."
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Temporal stability experiment. Results obtained by evaluating on the Wikipedia derived dataset from 2018 by either: models trained on Wikipedia data from 2018 or 2009. Trained on data from the same time frame, the neural models show a slight advantage over the lexical models. Most noticeable however is the drop in performance by the lexical models when trained on older data in terms of Recall and therefore also in terms of F1-score."
      },
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Average F1 and AUC score of aggregated results for all lexical and neural models."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Comparison of results with previous work"
      },
      {
        "file": "3-Table4-1.png",
        "caption": "Table 4: Cross-topic stability experiment.Metrics are averaged across 10 leave-on-out topic folds."
      },
      {
        "file": "4-Table6-1.png",
        "caption": "Table 6: Spearman\u2019s correlations for estimated probability distance from true label.Mean controversy: Average annotator score, certainty: distance from controversy annotation-scale midpoint, disagreement: standard deviation of annotations. Only pages with at least 3 annotations included to ensure sensible agreement metrics, N=128, bolded scores are preferable."
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Cross-domain stability experiment.Metrics are based on models trained on Wikipedia data and tested on general web pages."
      }
    ]
  },
  "1903.02930": {
    "title": "Neural Language Modeling with Visual Features",
    "abstract": "Multimodal language models attempt to incorporate non-linguistic features for the language modeling task. In this work, we extend a standard recurrent neural network (RNN) language model with features derived from videos. We train our models on data that is two orders-of-magnitude bigger than datasets used in prior work. We perform a thorough exploration of model architectures for combining visual and text features. Our experiments on two corpora (YouCookII and 20bn-something-something-v2) show that the best performing architecture consists of middle fusion of visual and text features, yielding over 25% relative improvement in perplexity. We report analysis that provides insights into why our multimodal language model improves upon a standard RNN language model.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          " INLINEFORM0 Work performed while the author was an intern at Google.",
          "Language models are vital components of a wide variety of systems for Natural Language Processing (NLP) including Automatic Speech Recognition, Machine Translation, Optical Character Recognition, Spelling Correction, etc. However, most language models are trained and applied in a manner that is oblivious to the environment in which human language operates BIBREF0 . These models are typically trained only on sequences of words, ignoring the physical context in which the symbolic representations are grounded, or ignoring the social context that could inform the semantics of an utterance.",
          "For incorporating additional modalities, the NLP community has typically used datasets such as MS COCO BIBREF1 and Flickr BIBREF2 for image-based tasks, while several datasets BIBREF3 , BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 have been curated for video-based tasks. Despite the lack of big datasets, researchers have started investigating language grounding in images BIBREF8 , BIBREF9 , BIBREF10 and to lesser extent in videos BIBREF11 , BIBREF1 . However, language grounding has focused more on obtaining better word and sentence representations or other downstream tasks, and to lesser extent on language modeling.",
          "In this paper, we examine the problem of incorporating temporal visual context into a recurrent neural language model (RNNLM). Multimodal Neural Language Models were introduced in BIBREF12 , where log-linear LMs BIBREF13 were conditioned to handle both image and text modalities. Notably, this work did not use the recurrent neural model paradigm which has now become the de facto way of implementing neural LMs.",
          "The closest work to ours is that of BIBREF0 , who report perplexity gains of around 5\u20136% on three languages on the MS COCO dataset (with an English vocabulary of only 16K words).",
          "Our work is distinguishable from previous work with respect to three dimensions:"
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "A language model assigns to a sentence INLINEFORM0 the probability: INLINEFORM1 ",
          "where each word is assigned a probability given the previous word history.",
          "For a given video segment, we assume that there is a sequence of INLINEFORM0 video frames represented by features INLINEFORM1 , and the corresponding transcription INLINEFORM2 . In practice, we assume INLINEFORM3 since we can always assign a video frame to each word by replicating the video frames the requisite number of times. Thus, our visually-grounded language model models the probability of the next word given the history of previous words as well as video frames: INLINEFORM4 "
        ]
      },
      {
        "section_name": "Combining the text and video modalities",
        "paragraphs": [
          "There are several options for combining the text and video modalities. We opt for the simplest strategy, which concatenates the representations. For a word embedding INLINEFORM0 and corresponding visual representation INLINEFORM1 , the input to our RNNLM will be the concatenated vector INLINEFORM2 . For the examples where we were unable to compute visual features (see Section \u00a7 SECREF3 ), we set INLINEFORM3 to be a zero-vector.",
          "In addition to concatenating the word and visual embedding, we explore two variants of our model that allow for a finer-grained integration of the two modalities:",
          "In this case, the RNNLM is given as input a vector INLINEFORM0 that is a weighted sum of the two embeddings: INLINEFORM1 ",
          "where INLINEFORM0 are learned matrices.",
          "Here, we apply the intuition that some words could provide information as to whether or not the visual context is helpful. In a simplistic example, if the word history is the article \u201cthe,\" then the visual context could provide relevant information needed for predicting the next word. For other word histories, though, the visual context might not be needed or be even irrelevant for the next word prediction: if the previous word is \u201ccarpe\", the next word is very likely to be \u201cdiem\", regardless of visual context. We implement a simple weighting mechanism that learns a scalar weight for the visual embedding prior to concatenation with the word embedding. The input to the RNNLM is now INLINEFORM0 , where: INLINEFORM1 ",
          "This approach does not add any new parameters to the model, but since the word representations INLINEFORM0 are learned, this mechanism has the potential to learn word embeddings that are also appropriate for weighting the visual context."
        ]
      },
      {
        "section_name": "Location of combination",
        "paragraphs": [
          "We explore three locations for fusing visual features in an RNNLM (Figure ). Our Early Fusion strategy merges the text and the visual features at the input to the LSTM cells. This embodies the intuition that it is best to do feature combination at the earliest possible stage. The Middle Fusion merges the visual features at the output of the 1st LSTM layer while the Late Fusion strategies merges the two features after the final LSTM layer. The idea behind the Middle and Late fusion is that we would like to minimize changes to the regular RNNLM architecture at the early stages and still be able to benefit from the visual features."
        ]
      },
      {
        "section_name": "Data and Experimental Setup",
        "paragraphs": [
          "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 . We tokenize the training data using a vocabulary of 66K wordpieces BIBREF15 . Thus, the input to the model is a sequence of wordpieces. Using wordpieces allows us to address out-of-vocabulary (OOV) word issues that would arise from having a fixed word vocabulary. In practice, a wordpiece RNNLM gives similar performance as a word-level model BIBREF16 . For about INLINEFORM1 of the segments, we were able to obtain visual features at the frame level. The features are 1500-dimensional vectors, extracted from the video frames at 1-second intervals, similar to those used for large scale image classification tasks BIBREF17 , BIBREF18 . For a INLINEFORM2 -second video and INLINEFORM3 wordpieces, each feature is uniformly allocated to INLINEFORM4 wordpieces.",
          "Our RNNLM models consist of 2 LSTM layers, each containing 2048 units which are linearly projected to 512 units BIBREF19 . The word-piece and video embeddings are of size 512 each. We do not use dropout. During training, the batch size per worker is set to 256, and we perform full length unrolling to a max length of 70. The INLINEFORM0 -norms of the gradients are clipped to a max norm of INLINEFORM1 for the LSTM weights and to 10,000 for all other weights. We train with Synchronous SGD with the Adafactor optimizer BIBREF20 until convergence on a development set, created by randomly selecting INLINEFORM2 of all utterances."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "For evaluation we used two datasets, YouCook2 and sth-sth, allowing us to evaluate our models in cases where the visual context is relevant to the modelled language. Note that no data from these datasets are present in the YouTube videos used for training. The perplexity of our models is shown in Table ."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We present a simple strategy to augment a standard recurrent neural network language model with temporal visual features. Through an exploration of candidate architectures, we show that the Middle Fusion of visual and textual features leads to a 20-28% reduction in perplexity relative to a text only baseline. These experiments were performed using datasets of unprecedented scale, with more than 1.2 billion tokens \u2013 two orders of magnitude more than any previously published work. Our work is a first step towards creating and deploying large-scale multimodal systems that properly situate themselves into a given context, by taking full advantage of every available signal."
        ]
      }
    ],
    "qas": [
      {
        "question": "what dataset was used for training?",
        "question_id": "9b868c7d17852f46a8fe725f24cb9548fdbd2b05",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "64M segments from YouTube videos"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 . We tokenize the training data using a vocabulary of 66K wordpieces BIBREF15 . Thus, the input to the model is a sequence of wordpieces. Using wordpieces allows us to address out-of-vocabulary (OOV) word issues that would arise from having a fixed word vocabulary. In practice, a wordpiece RNNLM gives similar performance as a word-level model BIBREF16 . For about INLINEFORM1 of the segments, we were able to obtain visual features at the frame level. The features are 1500-dimensional vectors, extracted from the video frames at 1-second intervals, similar to those used for large scale image classification tasks BIBREF17 , BIBREF18 . For a INLINEFORM2 -second video and INLINEFORM3 wordpieces, each feature is uniformly allocated to INLINEFORM4 wordpieces."
              ],
              "highlighted_evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 . We tokenize the training data using a vocabulary of 66K wordpieces BIBREF15 . Thus, the input to the model is a sequence of wordpieces."
              ]
            },
            "annotation_id": "3d9c8966785305ff489db15f49387dcb40da24c4",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "YouCook2 ",
                "sth-sth"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For evaluation we used two datasets, YouCook2 and sth-sth, allowing us to evaluate our models in cases where the visual context is relevant to the modelled language. Note that no data from these datasets are present in the YouTube videos used for training. The perplexity of our models is shown in Table ."
              ],
              "highlighted_evidence": [
                "For evaluation we used two datasets, YouCook2 and sth-sth, allowing us to evaluate our models in cases where the visual context is relevant to the modelled language. Note that no data from these datasets are present in the YouTube videos used for training. The perplexity of our models is shown in Table ."
              ]
            },
            "annotation_id": "9bf26c3886d431b53d9816930da751a092980938",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "64M segments from YouTube videos"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 . We tokenize the training data using a vocabulary of 66K wordpieces BIBREF15 . Thus, the input to the model is a sequence of wordpieces. Using wordpieces allows us to address out-of-vocabulary (OOV) word issues that would arise from having a fixed word vocabulary. In practice, a wordpiece RNNLM gives similar performance as a word-level model BIBREF16 . For about INLINEFORM1 of the segments, we were able to obtain visual features at the frame level. The features are 1500-dimensional vectors, extracted from the video frames at 1-second intervals, similar to those used for large scale image classification tasks BIBREF17 , BIBREF18 . For a INLINEFORM2 -second video and INLINEFORM3 wordpieces, each feature is uniformly allocated to INLINEFORM4 wordpieces."
              ],
              "highlighted_evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 "
              ]
            },
            "annotation_id": "ab026ba3bbeb2b1c77cf8fe434abbb3de985dc3d",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "About 64M segments from YouTube videos comprising a total of 1.2B tokens.",
              "evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 . We tokenize the training data using a vocabulary of 66K wordpieces BIBREF15 . Thus, the input to the model is a sequence of wordpieces. Using wordpieces allows us to address out-of-vocabulary (OOV) word issues that would arise from having a fixed word vocabulary. In practice, a wordpiece RNNLM gives similar performance as a word-level model BIBREF16 . For about INLINEFORM1 of the segments, we were able to obtain visual features at the frame level. The features are 1500-dimensional vectors, extracted from the video frames at 1-second intervals, similar to those used for large scale image classification tasks BIBREF17 , BIBREF18 . For a INLINEFORM2 -second video and INLINEFORM3 wordpieces, each feature is uniformly allocated to INLINEFORM4 wordpieces."
              ],
              "highlighted_evidence": [
                "Our training data consist of about 64M segments from YouTube videos comprising a total of INLINEFORM0 B tokens BIBREF14 ."
              ]
            },
            "annotation_id": "b34f595ccaf1258ce200fc2ea5eadb2621a6ef8e",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Visualization of our different Language Models. Given word and visual embeddings, the input can be created by three methods. Left panels: simple concatenation (examples with early, middle, and late fusion of the visual embeddings). Top right panel: learning a linear combination of the two embeddings. Bottom right panel: learn to weight the visual embedding based on the current word. Note: \u2295 denotes concatenation,\u2297 denotes matrix multiplication, denotes dot product."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Withholding visual context from our best model leads to worse performance (similar to an RNNLM trained only on text)."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Middle Fusion of text and frame-level visual features leads to significant reductions in perplexity on two multimodal datasets."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Two sentences from YouCook2 with wordpiece-level negative log likelihood scores. Most gains (high-"
      }
    ]
  },
  "1911.04873": {
    "title": "Can Neural Networks Learn Symbolic Rewriting?",
    "abstract": "This work investigates if the current neural architectures are adequate for learning symbolic rewriting. Two kinds of data sets are proposed for this research -- one based on automated proofs and the other being a synthetic set of polynomial terms. The experiments with use of the current neural machine translation models are performed and its results are discussed. Ideas for extending this line of research are proposed and its relevance is motivated.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Neural networks (NNs) turned out to be very useful in several domains. In particular, one of the most spectacular advances achieved with use of NNs has been natural language processing. One of the tasks in this domain is translation between natural languages \u2013 neural machine translation (NMT) systems established here the state-of-the-art performance. Recently, NMT produced first encouraging results in the autoformalization task BIBREF0, BIBREF1, BIBREF2, BIBREF3 where given an informal mathematical text in the goal is to translate it to its formal (computer understandable) counterpart. In particular, the NMT performance on a large synthetic -to-Mizar dataset produced by a relatively sophisticated toolchain developed for several decades BIBREF4 is surprisingly good BIBREF3, indicating that neural networks can learn quite complicated algorithms for symbolic data. This inspired us to pose a question: Can NMT models be used in the formal-to-formal setting? In particular: Can NMT models learn symbolic rewriting?",
          "The answer is relevant to various tasks in automated reasoning. For example, neural models could compete with symbolic methods such as inductive logic programming BIBREF5 (ILP) that have been previously experimented with to learn simple rewrite tasks and theorem-proving heuristics from large formal corpora BIBREF6. Unlike (early) ILP, neural methods can however easily cope with large and rich datasets, without combinatorial explosion.",
          "Our work is also an inquiry into the capabilities of NNs as such, in the spirit of works like BIBREF7."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "To perform experiments answering our question we prepared two data sets \u2013 the first consists of examples extracted from proofs found by ATP (automated theorem prover) in a mathematical domain (AIM loops), whereas the second is a synthetic set of polynomial terms."
        ]
      },
      {
        "section_name": "Data ::: The AIM data set",
        "paragraphs": [
          "The data consists of sets of ground and nonground rewrites that came from Prover9 proofs of theorems about AIM loops produced by Veroff BIBREF8.",
          "Many of the inferences in the proofs are paramodulations from an equation and have the form s = t",
          "u[(s)] = vu[(t)] = v where $s, t, u, v$ are terms and $\\theta $ is a substitution. For the most common equations $s = t$, we gathered corresponding pairs of terms $\\big (u[\\theta (s)], u[\\theta (t)]\\big )$ which were rewritten from one to another with $s = t$. We put the pairs to separate data sets (depending on the corresponding $s = t$): in total 8 data sets for ground rewrites (where $\\theta $ is trivial) and 12 for nonground ones. The goal will be to learn rewriting for each of this 20 rules separately.",
          "Terms in the examples are treated as linear sequences of tokens where tokens are single symbols (variable / costant / predicate names, brackets, commas). Numbers of examples in each of the data sets vary between 251 and 34101. Lengths of the sequences of tokens vary between 1 and 343, with mean around 35. These 20 data sets were split into training, validation and test sets for our experiments ($60 \\%, 10 \\%, 30 \\%$, respectively).",
          "In Table TABREF4 and Table TABREF5 there are presented examples of pairs of AIM terms in TPTP BIBREF9 format, before and after rewriting with, respectively, ground and nonground rewrite rules."
        ]
      },
      {
        "section_name": "Data ::: The polynomial data set",
        "paragraphs": [
          "This is a synthetically created data set where the examples are pairs of equivalent polynomial terms. The first element of each pair is a polynomial in an arbitrary form and the second element is the same polynomial in a normalized form. The arbitrary polynomials are created randomly in a recursive manner from a set of available (non-nullary) function symbols, variables and constants. First, one of the symbols is randomly chosen. If it is a constant or a variable it is returned and the process terminates. If a function symbol is chosen, its subterm(s) are constructed recursively in a similar way.",
          "The parameters of this process are set in such a way that it creates polynomial terms of average length around 25 symbols. Terms longer than 50 are filtered out. Several data sets of various difficulty were created by varying the number of available symbols. This were quite limited \u2013 at most 5 different variables and constants being a few first natural numbers. The reason for this limited complexity of the input terms is because normalizing even a relatively simple polynomial can result in a very long term with very large constants \u2013 which is related especially to the operation of exponentiation in polynomials.",
          "Each data set consists of different 300 000 examples, see Table TABREF7 for examples. These data sets were split into training, validation and test sets for our experiments ($60 \\%, 10 \\%, 30 \\%$, respectively)."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism.",
          "After a small grid search we decided to inherit most of the hyperparameters of the model from the best results achieved in BIBREF3 where -to-Mizar translation is learned. We used relatively small LSTM cells consisting of 2 layers with 128 units. The \u201cscaled Luong\u201d version of the attention mechanism was used, as well as dropout with rate equal $0.2$. The number of training steps was 10000. (This setting was used for all our experiments described below.)"
        ]
      },
      {
        "section_name": "Experiments ::: AIM data set",
        "paragraphs": [
          "First, NMT models were trained for each of the 20 rewrite rules in the AIM data set. It turned out that the models, as long as the number of examples was greater than 1000, were able to learn the rewriting task very well, reaching $90\\%$ of accuracy on separated test sets. This means that the task of applying single rewrite step seems relatively easy to learn by NMT. See Table TABREF11 for all the results.",
          "We also run an experiment on the joint set of all rewrite rules (consisting of 41396 examples). Here the task was more difficult as a model needed not only to apply rewriting correctly, but also choose \u201cthe right\u201d rewrite rule applicable for a given term. Nevertheless, the performance was also very good, reaching $83\\%$ of accuracy."
        ]
      },
      {
        "section_name": "Experiments ::: Polynomial data set",
        "paragraphs": [
          "Then experiments on more challenging but also much larger data sets for polynomial normalization were performed. Depending on the difficulty of the data, accuracy on the test sets achieved in our experiments varied between $70\\%$ and $99\\%$. The results in terms of accuracy are shown in Table TABREF13.",
          "This high performance of the model encouraged a closer inspection of the results. First, we checked if in the test sets there are input examples which differs from these in training sets only by renaming of variables. Indeed, for each of the data sets in test sets are $5 - 15 \\%$ of such \u201crenamed\u201d examples. After filtering them out the measured accuracy drops \u2013 but only by $1 - 2 \\%$.",
          "An examination of the examples wrongly rewritten by the model was done. It turns out that the wrong outputs almost always parse (in $97 - 99 \\%$ of cases they are legal polynomial terms). Notably, depending on the difficulty of the data set, as much as $18 - 64 \\%$ of incorrect outputs are wrong only with respect to the constants in the terms. (Typically, NMT model proposes too low constants compared to the correct ones.) Below $1 \\%$ of wrong outputs are correct modulo variable renaming."
        ]
      },
      {
        "section_name": "Conclusions and future work",
        "paragraphs": [
          "NMT is not typically applied to symbolic problems, but surprisingly, it performed very well for both described tasks. The first one was easier in terms of complexity of the rewriting (only one application of a rewrite rule was performed) but the number of examples was quite limited. The second task involved more difficult rewriting \u2013 multiple different rewrite steps were performed to construct the examples. Nevertheless, provided many examples, NMT could learn normalizing polynomials.",
          "We hope this work provides a baseline and inspiration for continuing this line of research. We see several interesting directions this work can be extended.",
          "Firstly, more interesting and difficult rewriting problems need to be provided for better delineation of the strength of the neural models. The described data are relatively simple and with no direct relevance to the real unsolved symbolic problems. But the results on these simple problems are encouraging enough to try with more challenging ones, related to real difficulties \u2013 e.g. these from TPDB data base.",
          "Secondly, we are going to develop and test new kinds of neural models tailored for the problem of comprehending symbolic expressions. Specifically, we are going to implement an approach based on the idea of TreeNN, which may be another effective approach for this kind of tasks BIBREF7, BIBREF12, BIBREF13. TreeNNs are built recursively from modules, where the modules corresponds to parts of symbolic expression (symbols) and the shape of the network reflects the parse tree of the processed expression. This way model is explicitly informed on the exact structure of the expression, which in case of formal logic is always unambiguous and easy to extract. Perhaps this way the model could learn more efficiently from examples (and achieve higher results even on the small AIM data sets). The authors have a positive experience of applying TreeNNs to learn remainders of arithmetical expressions modulo small natural numbers \u2013 TreeNNs outperformed here neural models based on LSTM cells, giving almost perfect accuracy. However, this is unclear how to translate this TreeNN methodology to the tasks with the structured output, like the symbolic rewriting task.",
          "Thirdly, there is an idea of integrating neural rewriting architectures into the larger systems for automated reasoning. This can be motivated by the interesting contrast between some simpler ILP systems suffering for combinatorial explosion in presence of a large number of examples and neural methods which definitely benefit form large data sets.",
          "We hope that this work will inspire and trigger a discussion on the above (and other) ideas."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "Piotrowski was supported by the grant of National Science Center, Poland, no. 2018/29/N/ST6/02903, and by the European Agency COST action CA15123. Urban and Brown were supported by the ERC Consolidator grant no. 649043 AI4REASON and by the Czech project AI&Reasoning CZ.02.1.01/0.0/0.0/15_003/0000466 and the European Regional Development Fund. Kaliszyk was supported by ERC Starting grant no. 714034 SMART."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do any of the models use attention?",
        "question_id": "84765903b8c7234ca2919d0a40e3c6a5bcedf45d",
        "nlp_background": "five",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "After a small grid search we decided to inherit most of the hyperparameters of the model from the best results achieved in BIBREF3 where -to-Mizar translation is learned. We used relatively small LSTM cells consisting of 2 layers with 128 units. The \u201cscaled Luong\u201d version of the attention mechanism was used, as well as dropout with rate equal $0.2$. The number of training steps was 10000. (This setting was used for all our experiments described below.)"
              ],
              "highlighted_evidence": [
                "After a small grid search we decided to inherit most of the hyperparameters of the model from the best results achieved in BIBREF3 where -to-Mizar translation is learned. We used relatively small LSTM cells consisting of 2 layers with 128 units. The \u201cscaled Luong\u201d version of the attention mechanism was used, as well as dropout with rate equal $0.2$. The number of training steps was 10000. (This setting was used for all our experiments described below.)"
              ]
            },
            "annotation_id": "0576e8913436f2a8674fcf4f3be00d1d41a9d1fd",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ],
              "highlighted_evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ]
            },
            "annotation_id": "1615b90590af6d6c7235c3fc26f40a58d2e750e3",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ],
              "highlighted_evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ]
            },
            "annotation_id": "9e0b1c78348297888f5bbec335b91711fe2548da",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ],
              "highlighted_evidence": [
                "For experiments with both data sets we used an established NMT architecture BIBREF10 based on LSTMs (long short-term memory cells) and implementing the attention mechanism."
              ]
            },
            "annotation_id": "bcc304c00be90e24597e94d000ba7af5220b68a0",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table4-1.png",
        "caption": "Table 4. Results of experiments with AIM data. (Names of the rules correspond to folder names in the Github repo.)"
      },
      {
        "file": "3-Table5-1.png",
        "caption": "Table 5. Choosen results of experiments with polynomials. (Characteristic of formulas concerns the input polynomials. Labels of the data sets correspond to folder names in the Github repo.)"
      }
    ]
  },
  "1606.07043": {
    "title": "Toward Interpretable Topic Discovery via Anchored Correlation Explanation",
    "abstract": "Many predictive tasks, such as diagnosing a patient based on their medical chart, are ultimately defined by the decisions of human experts. Unfortunately, encoding experts' knowledge is often time consuming and expensive. We propose a simple way to use fuzzy and informal knowledge from experts to guide discovery of interpretable latent topics in text. The underlying intuition of our approach is that latent factors should be informative about both correlations in the data and a set of relevance variables specified by an expert. Mathematically, this approach is a combination of the information bottleneck and Total Correlation Explanation (CorEx). We give a preliminary evaluation of Anchored CorEx, showing that it produces more coherent and interpretable topics on two distinct corpora.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "A clinician can look at a patient's electronic health record (EHR) and not only decide whether the patient has diabetes but also produce a succinct summary of the clinical evidence. Replicating this feat with computational tools has been the focus of much research in clinical informatics. There are major initiatives underway to codify clinical knowledge into formal representations, most often as deterministic rules that can be applied in a semi-automated fashion BIBREF0 . However, representing the intuitive judgments of human experts can be challenging, particularly when the formal system does not match the expert's knowledge. For example, many deterministic disease classifiers used in clinical informatics rely heavily upon administrative codes not available at time of diagnosis. Further, developing and testing such systems is time- and labor-intensive.",
          "We propose instead a lightweight information theoretic framework for codifying informal human knowledge and then use it to extract interpretable latent topics from text corpora. For example, to discover patients with diabetes in a set of clinical notes, a doctor can begin by specifying disease-specific anchor terms BIBREF1 , BIBREF2 , such as \u201cdiabetes\u201d or \u201cinsulin.\u201d Our framework then uses these to help discover both latent topics associated with diabetes and records in which diabetes-related topics occur. The user can then add (or remove) additional anchor terms (e.g., \u201cmetformin\u201d) to improve the quality of the learned (diabetes) topics.",
          "In this workshop paper, we introduce a simple approach to anchored information theoretic topic modeling using a novel combination of Correlation Explanation (CorEx) BIBREF3 and the information bottleneck BIBREF4 . This flexible framework enables the user to leverage domain knowledge to guide exploration of a collection of documents and to impose semantics onto latent factors learned by CorEx. We present preliminary experimental results on two text corpora (including a corpus of clinical notes), showing that anchors can be used to discover topics that are more specific and relevant. What is more, we demonstrate the potential for this framework to perform weakly supervised learning in settings where labeling documents is prohibitively expensive BIBREF5 , BIBREF6 .",
          "With respect to interpretable machine learning, our contributions are twofold. First, our framework provides a way for human users to share domain knowledge with a statistical learning algorithm that is both convenient for the human user and easily digestible by the machine. Second, our experimental results confirm that the introduction of simple anchor words can improve the coherence and human interpretability of topics discovered from data. Both are essential to successful and interactive collaboration between machine learning and human users."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "Anchored Correlation Explanation can be understood as a combination of Total Correlation Explanation (CorEx) BIBREF3 , BIBREF7 and the multivariate information bottleneck BIBREF4 , BIBREF8 . We search for a set of probabilistic functions of the inputs INLINEFORM0 for INLINEFORM1 that optimize the following information theoretic objective: INLINEFORM2 ",
          "The first term is the CorEx objective INLINEFORM0 , which aims to construct latent variables INLINEFORM1 that best explain multivariate dependencies in the data INLINEFORM2 . Here the data consist of INLINEFORM3 -dimensional binary vectors INLINEFORM4 . Total correlation, or multivariate mutual information BIBREF9 , is specified as INLINEFORM5 where INLINEFORM6 is the KL divergence. Maximizing INLINEFORM7 over latent factors INLINEFORM8 amounts to minimizing INLINEFORM9 , which measures how much dependence in INLINEFORM10 is explained by INLINEFORM11 . At the global optimum, INLINEFORM12 is zero and the observations are independent conditioned on the latent factors. Several papers have explored CorEx for unsupervised hierarchical topic modeling BIBREF3 , BIBREF10 , BIBREF11 .",
          "The second term involves the mutual information between pairs of latent factors INLINEFORM0 ) and anchor variables INLINEFORM1 specified in the set INLINEFORM2 . This is inspired by the information bottleneck BIBREF4 , BIBREF8 , a supervised information-theoretic approach to discovering latent factors. The bottleneck objective INLINEFORM3 constructs latent factors INLINEFORM4 that trade off compression of INLINEFORM5 against preserving information about relevance variables INLINEFORM6 .",
          "Anchored CorEx preserves information about anchors while also explaining as much multivariate dependence between observations in INLINEFORM0 as possible. This framework is flexible: we can attach multiple anchors to one factor or one anchor to multiple factors. We have found empirically that INLINEFORM1 works well and does not need to be tuned.",
          "Anchors allow us to both seed CorEx and impose semantics on latent factors: when analyzing medical documents, for example, we can anchor a diabetes latent factor to the word \u201cdiabetes.\u201d The INLINEFORM0 objective then discovers other words associated with \u201cdiabetes\u201d and includes them in this topic.",
          "While there is not space here for a full description of the optimization, it is similar in principle to the approaches in BIBREF3 , BIBREF7 . Two points are worth noting: first, the TC objective is replaced by a lower bound to make optimization feasible BIBREF7 . Second, we impose a sparse connection constraint (each word appears in only one topic) to speed up computation. Open source code implementing CorEx is available on github BIBREF12 ."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "There is a large body of work on integrating domain knowledge into topic models and other unsupervised latent variable models, often in the form of constraints BIBREF13 , prior distributions BIBREF14 , and token labels BIBREF15 . Like Anchored CorEx, seeded latent dirichlet allocation (SeededLDA) allows the specification of word-topic relationships BIBREF16 . However, SeededLDA assumes a more complex latent structure, in which each topic is a mixture of two distributions, one unseeded and one seeded.",
          " BIBREF1 first proposed anchors in the context of topic modeling: words that are high precision indicators of underlying topics. In contrast to our approach, anchors are typically selected automatically, constrained to appear in only one topic, and used primarily to aid optimization BIBREF17 . In our information theoretic framework, anchors are specified manually and more loosely defined as words having high mutual information with one or more latent factors. The effects of anchors on the interpretability of traditional topic models are often mixed BIBREF18 , but our experiments suggest that our approach yields more coherent topics.",
          "In health informatics, \u201canchor\u201d features chosen based on domain knowledge have been used to guide statistical learning BIBREF2 . In BIBREF6 , anchors are used as a source of distant supervision BIBREF19 , BIBREF20 for classifiers in the absence of ground truth labels. While Anchored CorEx can be used for discriminative tasks, it is essentially unsupervised. Recent work by BIBREF21 is perhaps most similar in spirit to ours: they exploit predefined anchors to help learn and impose semantics on a discrete latent factor model with a directed acyclic graph structure. We utilize an information theoretic approach that makes no generative modeling assumptions."
        ]
      },
      {
        "section_name": "Results and Discussion",
        "paragraphs": [
          "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. Both corpora provide ground truth labels for latent classes that may be thought of as topics."
        ]
      },
      {
        "section_name": "20 Newsgroups",
        "paragraphs": [
          "The 20 Newsgroups data set is suitable for a straightforward evaluation of anchored topic models. The latent classes represent mutually exclusive categories, and each document is known to originate from a single category. We find that the correlation structure among the latent classes is less complex than in the Obesity Challenge data. Further, each category tends to exhibit some specialized vocabulary not used extensively in other categories (thus satisfying the anchor assumption from BIBREF1 ).",
          "To prepare the data, we removed headers, footers, and quotes and reduced the vocabulary to the most frequent 20,000 words. Each document was represented as a binary bag-of-words vector. In all experiemnts, we used the standard training/test split. All CorEx models used three layers of 40, 3, and 1 factors. fig:big shows an example hierarchical topic model extracted by Anchored CorEx."
        ]
      },
      {
        "section_name": "i2b2 Obesity Challenge 2008",
        "paragraphs": [
          "The Obesity Challenge 2008 data set includes 1237 deidentified clinical discharge summaries from the Partners HealthCare Research Patient Data Repository. All summaries have been labeled by clinical experts with obesity and 15 other conditions commonly comorbid with obesity, ranging from Coronary Artery Disease (663 positives) to Depression (247) to Hypertriglyceridemia (62).",
          "We preprocessed each document with a standard biomedical text pipeline that extracts common medical terms and phrases (grouping neighboring words where appropriate) and detecting negation (\u201cnot\u201d is prepended to negated terms) BIBREF23 , BIBREF24 . We converted each document to a binary bag-of-words with a vocabulary of 4114 (possibly negated) medical phrases. We used the 60/40 training/test split from the competition.",
          "We are primarily interested in the ability of Anchored CorEx to extract latent topics that are unambiguously associated with the 16 known conditions. We train a series of CorEx models with 32 latent topics in the first layer, each using a different anchor strategy. tab:obesity:topics shows the Obesity and Obstructive Sleep Apnea (OSA) topics for three iterations of Anchored CorEx with the ten most important terms (highest weighted connections to the latent factor) listed for each topic. Unsupervised CorEx (first row) does not discover any topics obviously related to obesity or OSA, so we choose the topics to which the terms obesity and obstructive sleep apnea are assigned. No unambiguous Obesity or OSA topics emerge even as the number of latent factors is decreased or increased.",
          "In the second iteration (second row), we add the common name of each of the 16 diseases as an anchor to one factor (16 total). Adding obesity as an anchor produces a clear Obesity topic, including several medications known to cause weight gain (e.g., acebutolol, klonopin). The anchored OSA topic, however, is quite poor and in fact resembles the rather generic topic to which obstructive sleep apnea is assigned by Unsupervised CorEx. It includes many spurious or non-specific terms like drug.",
          "This is likely due to the fact that obesity is a major risk factor of OSA, and so OSA symptoms are highly correlated with obesity and its other symptoms. Thus, the total correlation objective will attempt to group obesity and OSA-related terms together under a single latent factor. The sparse connection constraint mentioned in sec:methods prevents them from being connected to multiple factors. Indeed, sleep apnea appears in the obesity topic, suggesting the two topics are competing to explain OSA terms.",
          "In the third iteration, we correct this by adding sleep apnea as a second anchor to the OSA topic, and the resulting topic is clearly associated with OSA, including terms related to respiratory problems and medications used to treat (or believed to increase risk for) OSA. There is no noticeable reduction in quality in the Obesity topic."
        ]
      },
      {
        "section_name": "Anchored CorEx for Discriminative Tasks",
        "paragraphs": [
          "In a series of follow-up experiments, we investigate the suitability of using anchored CorEx to perform weakly supervised classification. We interpret each anchored latent factor as a classifier for an associated class label and then compute test set F1 (using a threshold of 0.5) and area under the curve (AUC) scores (Obesity Challenge only).",
          "tab:class compares the classification performance of Unsupervised and Anchored CorEx on the soc.religion.christianity category from 20 Newsgroups for different choices of anchors. For both types of CorEx, the topic containing the corresponding terms is used as the classifier, but for Anchored CorEx those terms are also used as anchors when estimating the latent factor. Unsupervised CorEx does a reasonable job of discovering a coherent religion topic that already contains the terms God, Christian, and Jesus. However, using the terms Jesus and Christian as anchors yields a topic that better predicts the actual soc.religion.christianity category.",
          "",
          "tab:obesity:class shows the Macro-AUC and F1 scores (averaged across all diseases) on the Obesity Challenge data for the final anchored CorEx model and a Naive Bayes (NB) baseline, in which we train a separate classifier for each disease. Surprisingly, Anchored CorEx outperforms Naive Bayes (NB) by a large margin. Of course, Anchored CorEx is not a replacement for supervised learning: NB beats Anchored CorEx on 20 Newsgroups and does not represent a \u201cstrong\u201d baseline for Obesity 2008 (teams scored above 0.7 in Macro-F1 during the competition). It is nonetheless remarkable that Anchored CorEx performs as well as it does given that it is fundamentally unsupervised."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We have introduced a simple information theoretic approach to topic modeling that can leverage domain knowledge specified informally as anchors. Our framework uses a novel combination of CorEx and the information bottleneck. Preliminary results suggest it can extract more precise, interpretable topics through a lightweight interactive process. We next plan to perform further empirical evaluations and to extend the algorithm to handle complex latent structures present in health care data."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "This work was partially supported by DARPA award HR0011-15-C-0115. David Kale was supported by the Alfred E. Mann Innovation in Engineering Doctoral Fellowship."
        ]
      }
    ],
    "qas": [
      {
        "question": "On which corpora do they evaluate on?",
        "question_id": "a67a2d9acad1787b636ca2681330f4c29a0b0254",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "20 Newsgroups",
                "i2b2 2008 Obesity Challenge BIBREF22 data set"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. Both corpora provide ground truth labels for latent classes that may be thought of as topics."
              ],
              "highlighted_evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set."
              ]
            },
            "annotation_id": "5f4fc82b7c92888892a2a9df96a2762a015f35c4",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "20 Newsgroups ",
                "i2b2 2008 Obesity Challenge"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. Both corpora provide ground truth labels for latent classes that may be thought of as topics."
              ],
              "highlighted_evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set."
              ]
            },
            "annotation_id": "76edcf0affe532349cbf9162a6197f9409188210",
            "worker_id": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "20 Newsgroups",
                "i2b2 2008 Obesity Challenge BIBREF22 data set"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. Both corpora provide ground truth labels for latent classes that may be thought of as topics."
              ],
              "highlighted_evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set."
              ]
            },
            "annotation_id": "bcd61ed2cd5e0df9722c885f56332e8be662473c",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " i2b2 2008 Obesity Challenge BIBREF22",
                "20 Newsgroups"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. Both corpora provide ground truth labels for latent classes that may be thought of as topics."
              ],
              "highlighted_evidence": [
                "To demonstrate the utility of Anchored CorEx, we run experiments on two document collections: 20 Newsgroups and the i2b2 2008 Obesity Challenge BIBREF22 data set. "
              ]
            },
            "annotation_id": "f4d553b05d70a78d4e87ff765d3c0119c8e9fcf2",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1. A hierarchical topic model learned by CorEx. Anchored latent factors are labeled in red with anchor words marked with a \u201c*\u201d."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1. Evolution of Obesity and Obstructive Sleep Apnea (OSA) topics as anchors are added. Colors and font weight indicate anchors, spurious terms, and intruder terms from other known topics. Multiword and negated terms are the result of the preprocessing pipeline."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3. Classification performance on Obesity 2008."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2. F1 scores on soc.religion.christianity."
      }
    ]
  },
  "1611.04234": {
    "title": "F-Score Driven Max Margin Neural Network for Named Entity Recognition in Chinese Social Media",
    "abstract": "We focus on named entity recognition (NER) for Chinese social media. With massive unlabeled text and quite limited labelled corpus, we propose a semi-supervised learning model based on B-LSTM neural network. To take advantage of traditional methods in NER such as CRF, we combine transition probability with deep learning in our model. To bridge the gap between label accuracy and F-score of NER, we construct a model which can be directly trained on F-score. When considering the instability of F-score driven method and meaningful information provided by label accuracy, we propose an integrated method to train on both F-score and label accuracy. Our integrated model yields 7.44\\% improvement over previous state-of-the-art result.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "With the development of Internet, social media plays an important role in information exchange. The natural language processing tasks on social media are more challenging which draw attention of many researchers BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 . As the foundation of many downstream applications BIBREF4 , BIBREF5 , BIBREF6 such as information extraction, named entity recognition (NER) deserves more research in prevailing and challenging social media text. NER is a task to identify names in texts and to assign names with particular types BIBREF7 , BIBREF8 , BIBREF9 , BIBREF10 . It is the informality of social media that discourages accuracy of NER systems. While efforts in English have narrowed the gap between social media and formal domains BIBREF3 , the task in Chinese remains challenging. It is caused by Chinese logographic characters which lack many clues to indicate whether a word is a name, such as capitalization. The scant labelled Chinese social media corpus makes the task more challenging BIBREF11 , BIBREF12 , BIBREF13 .",
          "To address the problem, one approach is to use the lexical embeddings learnt from massive unlabeled text. To take better advantage of unlabeled text, Peng and Dredze peng-dredze:2015:EMNLP evaluates three types of embeddings for Chinese text, and shows the effectiveness of positional character embeddings with experiments. Considering the value of word segmentation in Chinese NER, another approach is to construct an integrated model to jointly train learned representations for both predicting word segmentations and NER BIBREF14 .",
          "However, the two above approaches are implemented within CRF model. We construct a semi-supervised model based on B-LSTM neural network to learn from the limited labelled corpus by using lexical information provided by massive unlabeled text. To shrink the gap between label accuracy and F-Score, we propose a method to directly train on F-Score rather than label accuracy in our model. In addition, we propose an integrated method to train on both F-Score and label accuracy. Specifically, we make contributions as follows:"
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "We construct a semi-supervised model which is based on B-LSTM neural network and combine transition probability to form structured output. We propose a method to train directly on F-Score in our model. In addition, we propose an integrated method to train on both F-Score and label accuracy."
        ]
      },
      {
        "section_name": "Transition Probability",
        "paragraphs": [
          "B-LSTM neural network can learn from past input features and LSTM layer makes it more efficient BIBREF15 , BIBREF16 , BIBREF17 , BIBREF18 . However, B-LSTM cannot learn sentence level label information. Huang et al. huang2015bidirectional combine CRF to use sentence level label information. We combine transition probability into our model to gain sentence level label information. To combine transition probability into B-LSTM neural network, we construct a Max Margin Neural Network (MMNN) BIBREF19 based on B-LSTM. The prediction of label in position INLINEFORM0 is given as: DISPLAYFORM0 ",
          "where INLINEFORM0 are the transformation parameters, INLINEFORM1 the hidden vector and INLINEFORM2 the bias parameter. For a input sentence INLINEFORM3 with a label sequence INLINEFORM4 , a sentence-level score is then given as: DISPLAYFORM0 ",
          "where INLINEFORM0 indicates the probability of label INLINEFORM1 at position INLINEFORM2 by the network with parameters INLINEFORM3 , INLINEFORM4 indicates the matrix of transition probability. In our model, INLINEFORM5 is computed as: DISPLAYFORM0 ",
          "We define a structured margin loss INLINEFORM0 as Pei et al. pei-ge-chang:2014:P14-1: DISPLAYFORM0 ",
          "where INLINEFORM0 is the length of setence INLINEFORM1 , INLINEFORM2 is a discount parameter, INLINEFORM3 a given correct label sequence and INLINEFORM4 a predicted label sequence. For a given training instance INLINEFORM5 , our predicted label sequence is the label sequence with highest score: INLINEFORM6 ",
          "The label sequence with the highest score can be obtained by carrying out viterbi algorithm. The regularized objective function is as follows: DISPLAYFORM0 INLINEFORM0 ",
          "By minimizing the object, we can increase the score of correct label sequence INLINEFORM0 and decrease the score of incorrect label sequence INLINEFORM1 ."
        ]
      },
      {
        "section_name": "F-Score Driven Training Method",
        "paragraphs": [
          "Max Margin training method use structured margin loss INLINEFORM0 to describe the difference between the corrected label sequence INLINEFORM1 and predicted label sequence INLINEFORM2 . In fact, the structured margin loss INLINEFORM3 reflect the loss in label accuracy. Considering the gap between label accuracy and F-Score in NER, we introduce a new training method to train directly on F-Score. To introduce F-Score driven training method, we need to take a look at the subgradient of equation ( EQREF9 ): INLINEFORM4 ",
          "In the subgradient, we can know that structured margin loss INLINEFORM0 contributes nothing to the subgradient of the regularized objective function INLINEFORM1 . The margin loss INLINEFORM2 serves as a trigger function to conduct the training process of B-LSTM based MMNN. We can introduce a new trigger function to guide the training process of neural network.",
          "F-Score Trigger Function The main criterion of NER task is F-score. However, high label accuracy does not mean high F-score. For instance, if every named entity's last character is labeledas O, the label accuracy can be quite high, but the precision, recall and F-score are 0. We use the F-Score between corrected label sequence and predicted label sequence as trigger function, which can conduct the training process to optimize the F-Score of training examples. Our new structured margin loss can be described as: DISPLAYFORM0 ",
          "where INLINEFORM0 is the F-Score between corrected label sequence and predicted label sequence.",
          "F-Score and Label Accuracy Trigger Function The F-Score can be quite unstable in some situation. For instance, if there is no named entity in a sentence, F-Score will be always 0 regardless of the predicted label sequence. To take advantage of meaningful information provided by label accuracy, we introduce an integrated trigger function as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is a factor to adjust the weight of label accuracy and F-Score.",
          "Because F-Score depends on the whole label sequence, we use beam search to find INLINEFORM0 label sequences with top sentece-level score INLINEFORM1 and then use trigger function to rerank the INLINEFORM2 label sequences and select the best."
        ]
      },
      {
        "section_name": "Word Segmentation Representation",
        "paragraphs": [
          "Word segmentation takes an important part in Chinese text processing. Both Peng and Dredze peng-dredze:2015:EMNLP and Peng and Dredze peng-dredze:2016:P16-2 show the value of word segmentation to Chinese NER in social media. We present two methods to use word segmentation information in neural network model.",
          "Character and Position Embeddings To incorporate word segmentation information, we attach every character with its positional tag. This method is to distinguish the same character at different position in the word. We need to word segment the text and learn positional character embeddings from the segmented text.",
          "Character Embeddings and Word Segmentation Features We can treat word segmentation as discrete features in neural network model. The discrete features can be easily incorporated into neural network model BIBREF20 . We use word embeddings from a LSTM pretrained on MSRA 2006 corpus to initialize the word segmentation features."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "We use a modified labelled corpus as Peng and Dredze peng-dredze:2016:P16-2 for NER in Chinese social media. Details of the data are listed in Table TABREF19 . We also use the same unlabelled text as Peng and Dredze peng-dredze:2016:P16-2 from Sina Weibo service in China and the text is word segmented by a Chinese word segmentation system Jieba as Peng and Dredze peng-dredze:2016:P16-2 so that our results are more comparable to theirs."
        ]
      },
      {
        "section_name": "Parameter Estimation",
        "paragraphs": [
          "We pre-trained embeddings using word2vec BIBREF22 with the skip-gram training model, without negative sampling and other default parameter settings. Like Mao et al. mao2008chinese, we use bigram features as follow: INLINEFORM0 ",
          "We use window approach BIBREF20 to extract higher level Features from word feature vectors. We treat bigram features as discrete features BIBREF20 for our neural network. Our models are trained using stochastic gradient descent with an L2 regularizer.",
          "As for parameters in our models, window size for word embedding is 5, word embedding dimension, feature embedding dimension and hidden vector dimension are all 100, discount INLINEFORM0 in margin loss is INLINEFORM1 , and the hyper parameter for the INLINEFORM2 is INLINEFORM3 . As for learning rate, initial learning rate is INLINEFORM4 with a decay rate INLINEFORM5 . For integrated model, INLINEFORM6 is INLINEFORM7 . We train 20 epochs and choose the best prediction for test."
        ]
      },
      {
        "section_name": "Results and Analysis",
        "paragraphs": [
          "We evaluate two methods to incorporate word segmentation information. The results of two methods are shown as Table TABREF22 . We can see that positional character embeddings perform better in neural network. This is probably because positional character embeddings method can learn word segmentation information from unlabeled text while word segmentation can only use training corpus.",
          "We adopt positional character embeddings in our next four models. Our first model is a B-LSTM neural network (baseline). To take advantage of traditional model BIBREF23 , BIBREF24 such as CRF, we combine transition probability in our B-LSTM based MMNN. We design a F-Score driven training method in our third model F-Score Driven Model I . We propose an integrated training method in our fourth model F-Score Driven Model II .The results of models are depicted as Figure UID11 . From the figure, we can know our models perfrom better with little loss in time.",
          "Table TABREF23 shows results for NER on test sets. In the Table TABREF23 , we also show micro F1-score (Overall) and out-of-vocabulary entities (OOV) recall. Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. By comparing the results of B-LSTM model and B-LSTM + MTNN model, we can know transition probability is significant for NER. Compared with B-LSTM + MMNN model, F-Score Driven Model I improves the result of named entity with a loss in nominal mention. The integrated training model (F-Score Driven Model II) benefits from both label accuracy and F-Score, which achieves a new state-of-the-art NER system in Chinese social media. Our integrated model has better performance on named entity and nominal mention.",
          "To better understand the impact of the factor INLINEFORM0 , we show the results of our integrated model with different values of INLINEFORM1 in Figure UID13 . From Figure UID13 , we can know that INLINEFORM2 is an important factor for us to balance F-score and accuracy. Our integrated model may help alleviate the influence of noise in NER in Chinese social media."
        ]
      },
      {
        "section_name": "Conclusions and Future Work",
        "paragraphs": [
          "The results of our experiments also suggest directions for future work. We can observe all models in Table TABREF23 achieve a much lower recall than precision BIBREF25 . So we need to design some methods to solve the problem."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "Thanks to Shuming Ma for the help on improving the writing. This work was supported in part by National Natural Science Foundation of China (No. 61673028), and National High Technology Research and Development Program of China (863 Program, No. 2015AA015404). Xu Sun is the corresponding author of this paper. The first author focuses on the design of the method and the experimental results. The corresponding author focuses on the design of the method."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is the state-of-the-art?",
        "question_id": "2e4688205c8e344cded7a053b6014cce04ef1bd5",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "social media",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Peng and Dredze peng-dredze:2016:P16-2"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Table TABREF23 shows results for NER on test sets. In the Table TABREF23 , we also show micro F1-score (Overall) and out-of-vocabulary entities (OOV) recall. Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. By comparing the results of B-LSTM model and B-LSTM + MTNN model, we can know transition probability is significant for NER. Compared with B-LSTM + MMNN model, F-Score Driven Model I improves the result of named entity with a loss in nominal mention. The integrated training model (F-Score Driven Model II) benefits from both label accuracy and F-Score, which achieves a new state-of-the-art NER system in Chinese social media. Our integrated model has better performance on named entity and nominal mention."
              ],
              "highlighted_evidence": [
                "Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. "
              ]
            },
            "annotation_id": "081566edee75187177c062b0cf18ff26c6789bc9",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Peng and Dredze peng-dredze:2016:P16-2"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Table TABREF23 shows results for NER on test sets. In the Table TABREF23 , we also show micro F1-score (Overall) and out-of-vocabulary entities (OOV) recall. Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. By comparing the results of B-LSTM model and B-LSTM + MTNN model, we can know transition probability is significant for NER. Compared with B-LSTM + MMNN model, F-Score Driven Model I improves the result of named entity with a loss in nominal mention. The integrated training model (F-Score Driven Model II) benefits from both label accuracy and F-Score, which achieves a new state-of-the-art NER system in Chinese social media. Our integrated model has better performance on named entity and nominal mention."
              ],
              "highlighted_evidence": [
                "Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media."
              ]
            },
            "annotation_id": "773b3b8a96ac4c576051afd9594416bebb0d3214",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Peng and Dredze peng-dredze:2016:P16-2"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Table TABREF23 shows results for NER on test sets. In the Table TABREF23 , we also show micro F1-score (Overall) and out-of-vocabulary entities (OOV) recall. Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. By comparing the results of B-LSTM model and B-LSTM + MTNN model, we can know transition probability is significant for NER. Compared with B-LSTM + MMNN model, F-Score Driven Model I improves the result of named entity with a loss in nominal mention. The integrated training model (F-Score Driven Model II) benefits from both label accuracy and F-Score, which achieves a new state-of-the-art NER system in Chinese social media. Our integrated model has better performance on named entity and nominal mention."
              ],
              "highlighted_evidence": [
                "Table TABREF23 shows results for NER on test sets. In the Table TABREF23 , we also show micro F1-score (Overall) and out-of-vocabulary entities (OOV) recall. Peng and Dredze peng-dredze:2016:P16-2 is the state-of-the-art NER system in Chinese Social media. By comparing the results of B-LSTM model and B-LSTM + MTNN model, we can know transition probability is significant for NER. Compared with B-LSTM + MMNN model, F-Score Driven Model I improves the result of named entity with a loss in nominal mention."
              ]
            },
            "annotation_id": "7a82582604ed780fb68b0b3f7db01eacd8826b4b",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Details of Weibo NER corpus."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Two methods to incorporate word segmentation information."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: NER results for named and nominal mentions on test data."
      }
    ]
  },
  "1909.00437": {
    "title": "Evaluating the Cross-Lingual Effectiveness of Massively Multilingual Neural Machine Translation",
    "abstract": "The recently proposed massively multilingual neural machine translation (NMT) system has been shown to be capable of translating over 100 languages to and from English within a single model. Its improved translation performance on low resource languages hints at potential cross-lingual transfer capability for downstream tasks. In this paper, we evaluate the cross-lingual effectiveness of representations from the encoder of a massively multilingual NMT model on 5 downstream classification and sequence labeling tasks covering a diverse set of over 50 languages. We compare against a strong baseline, multilingual BERT (mBERT), in different cross-lingual transfer learning scenarios and show gains in zero-shot transfer in 4 out of these 5 tasks.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "English has an abundance of labeled data that can be used for various Natural Language Processing (NLP) tasks, such as part-of-speech tagging (POS), named entity recognition (NER), and natural language inference (NLI). This richness of labeled data manifests itself as a boost in accuracy in the current era of data-hungry deep learning algorithms. However, the same is not true for many other languages where task specific data is scarce and expensive to acquire. This motivates the need for cross-lingual transfer learning \u2013 the ability to leverage the knowledge from task specific data available in one or more languages to solve that task in languages with little or no task-specific data.",
          "Recent progress in NMT has enabled one to train multilingual systems that support translation from multiple source languages into multiple target languages within a single model BIBREF2, BIBREF3, BIBREF0. Such multilingual NMT (mNMT) systems often demonstrate large improvements in translation quality on low resource languages. This positive transfer originates from the model's ability to learn representations which are transferable across languages. Previous work has shown that these representations can then be used for cross-lingual transfer in other downstream NLP tasks - albeit on only a pair of language pairs BIBREF4, or by limiting the decoder to use a pooled vector representation of the entire sentence from the encoder BIBREF5.",
          "In this paper we scale up the number of translation directions used in the NMT model to include 102 languages to and from English. Unlike BIBREF5, we do not apply any restricting operations such as pooling while training mNMT which allows us to obtain token level representations making it possible to transfer them to sequence tagging tasks as well. We find that mNMT models trained using plain translation losses can out of the box emerge as competitive alternatives to other methods at the forefront of cross-lingual transfer learning BIBREF1, BIBREF5",
          "Our contributions in this paper are threefold:",
          "We use representations from a Massively Multilingual Translation Encoder (MMTE) that can handle 103 languages to achieve cross-lingual transfer on 5 classification and sequence tagging tasks spanning more than 50 languages.",
          "We compare MMTE to mBERT in different cross-lingual transfer scenarios including zero-shot, few-shot, fine-tuning, and feature extraction scenarios.",
          "We outperform the state-of-the-art on zero-shot cross-lingual POS tagging [Universal Dependencies 2.3 dataset BIBREF6], intent classification BIBREF7, and achieve results comparable to state-of-the-art on document classification [ML-Doc dataset BIBREF8].",
          "The remainder of this paper is organized as follows. Section SECREF2 describes our MMTE model in detail and points out its differences from mBERT. All experimental details, results and analysis are given in Sections SECREF3 and SECREF4. This is followed by a discussion of related work. In Section SECREF6, we summarize our findings and present directions for future research. We emphasize that the primary motivation of the paper is not to challenge the state-of-the-art but instead to investigate the effectiveness of representations learned from an mNMT model in various transfer-learning settings."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model",
        "paragraphs": [
          "In this section, we describe our massively multilingual NMT system. Similar to BERT, our transfer learning setup has two distinct steps: pre-training and fine-tuning. During pre-training, the NMT model is trained on large amounts of parallel data to perform translation. During fine-tuning, we initialize our downstream model with the pre-trained parameters from the encoder of the NMT system, and then all of the parameters are fine-tuned using labeled data from the downstream tasks."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Model Architecture",
        "paragraphs": [
          "We train our Massively Multilingual NMT system using the Transformer architecture BIBREF9 in the open-source implementation under the Lingvo framework BIBREF10. We use a larger version of Transformer Big containing 375M parameters (6 layers, 16 heads, 8192 hidden dimension) BIBREF11, and a shared source-target sentence-piece model (SPM) BIBREF12 vocabulary with 64k individual tokens. All our models are trained with Adafactor BIBREF13 with momentum factorization, a learning rate schedule of (3.0, 40k) and a per-parameter norm clipping threshold of 1.0. The encoder of this NMT model comprises approximately 190M parameters and is subsequently used for fine-tuning."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Pre-training ::: Objective",
        "paragraphs": [
          "We train a massively multilingual NMT system which is capable of translating between a large number of language pairs at the same time by optimizing the translation objective between language pairs. To train such a multilingual system within a single model, we use the strategy proposed in BIBREF3 which suggests prepending a target language token to every source sequence to be translated. This simple and effective strategy enables us to share the encoder, decoder, and attention mechanisms across all language pairs."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Pre-training ::: Data",
        "paragraphs": [
          "We train our multilingual NMT system on a massive scale, using an in-house corpus generated by crawling and extracting parallel sentences from the web BIBREF14. This corpus contains parallel documents for 102 languages, to and from English, comprising a total of 25 billion sentence pairs. The number of parallel sentences per language in our corpus ranges from around 35 thousand to almost 2 billion. Figure FIGREF10 illustrates the data distribution for all 204 language pairs used to train the NMT model. Language ids for all the languages are also provided in supplementary material."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Pre-training ::: Data sampling policy",
        "paragraphs": [
          "Given the wide distribution of data across language pairs, we used a temperature based data balancing strategy. For a given language pair, $l$, let $D_l$ be the size of the available parallel corpus. Then if we adopt a naive strategy and sample from the union of the datasets, the probability of the sample being from language pair $l$ will be $p_l=\\frac{D_l}{\\Sigma _lD_l}$. However, this strategy would starve low resource language pairs. To control for the ratio of samples from different language pairs, we sample a fixed number of sentences from the training data, with the probability of a sentence belonging to language pair $l$ being proportional to $p_l^{\\frac{1}{T}}$, where $T$ is the sampling temperature. As a result, $T=1$ would correspond to a true data distribution, and, $T=100$ yields an (almost) equal number of samples for each language pair (close to a uniform distribution with over-sampling for low-resource language-pairs). We set $T=5$ for a balanced sampling strategy. To control the contribution of each language pair when constructing the vocabulary, we use the same temperature based sampling strategy with $T=5$. Our SPM vocabulary has a character coverage of $0.999995$."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Pre-training ::: Model quality",
        "paragraphs": [
          "We use BLEU score BIBREF15 to evaluate the quality of our translation model(s). Our mNMT model performs worse than the bilingual baseline on high resource language pairs but improves upon it on low resource language pairs. The average drop in BLEU score on 204 language pairs as compared to bilingual baselines is just 0.25 BLEU. This is impressive considering we are comparing one multilingual model to 204 different bilingual models. Table TABREF14 compares the BLEU scores achieved by mNMT to that of the bilingual baselines on 10 representative language pairs. These scores are obtained on an internal evaluation set which contains around 5k examples per language pair."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Fine-tuning mNMT Encoder",
        "paragraphs": [
          "Fine-tuning involves taking the encoder of our mNMT model, named Massively Multilingual Translation Encoder (MMTE), and adapting it to the downstream task. For tasks which involve single input, the text is directly fed into the encoder. For tasks such as entailment which involve input pairs, we concatenate the two inputs using a separator token and pass this through the encoder. For each downstream task, the inputs and outputs are passed through the encoder and we fine-tune all the parameters end-to-end. The encoder encodes the input through the stack of Transformer layers and produces representations for each token at the output. For sequence tagging tasks, these token level representations are individually fed into a task-specific output layer. For classification or entailment tasks, we apply max-pooling on the token level representations and feed this into the task-specific output layer.",
          "It should be noted that fine-tuning is relatively inexpensive and fast. All of the results can be obtained within a few thousand gradient steps. The individual task-specific modeling details are described in detail in section SECREF3. It is also important to note that while the encoder, the attention mechanism, and the decoder of the model are trained in the pre-training phase, only the encoder is used during fine-tuning."
        ]
      },
      {
        "section_name": "Massively Multilingual Neural Machine Translation Model ::: Differences with mBERT",
        "paragraphs": [
          "We point out some of the major difference between mBERT and MMTE are:",
          "mBERT uses two unsupervised pre-training objectives called masked language modeling (MLM) and next sentence prediction (NSP) which are both trained on monolingual data in 104 languages. MMTE on the other hand uses parallel data in 103 languages (102 languages to and from English) for supervised training with negative log-likelihood as the loss. It should be noted that mBERT uses clean Wikipedia data while MMTE is pre-trained on noisy parallel data from the web.",
          "mBERT uses 12 transformer layers, 12 attention heads, 768 hidden dimensions and has 178M parameters while MMTE uses 6 transformer layers, 16 attention heads, and 8196 hidden dimensions with 190M parameters. Note that, the effective capacity of these two models cannot easily be compared by simply counting number of parameters, due to the added characteristic complexity with depth and width.",
          "MMTE uses SPM to tokenize input with 64k vocabulary size while mBERT uses a Wordpiece model BIBREF16 with 110k vocabulary size."
        ]
      },
      {
        "section_name": "Experiments and Results",
        "paragraphs": [
          "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
        ]
      },
      {
        "section_name": "Experiments and Results ::: XNLI: Cross-lingual NLI",
        "paragraphs": [
          "XNLI is a popularly used corpus for evaluating cross-lingual sentence classification. It contains data in 15 languages BIBREF17. Evaluation is based on classification accuracy for pairs of sentences as one of entailment, neutral, or contradiction. We feed the text pair separated by a special token into MMTE and add a small network on top of it to build a classifier. This small network consists of a pre-pool feed-forward layer with 64 units, a max-pool layer which pools word level representations to get the sentence representation, and a post-pool feed-forward layer with 64 units. The optimizer used is Adafactor with a learning rate schedule of (0.2, 90k). The classifier is trained on English only and evaluated on all the 15 languages. Results are reported in Table TABREF21. Please refer to Appedix Table 1 for language names associated with the codes.",
          "MMTE outperforms mBERT on 9 out of 15 languages and by 1.2 points on average. BERT achieves excellent results on English, outperforming our system by 2.5 points but its zero-shot cross-lingual transfer performance is weaker than MMTE. We see most gains in low resource languages such as ar, hi, ur, and sw. MMTE however falls short of the current state-of-the-art (SOTA) on XNLI BIBREF19. We hypothesize this might be because of 2 reasons: (1) They use only the 15 languages associated with the XNLI task for pre-training their model, and (2) They use both monolingual and parallel data for pre-training while we just use parallel data. We confirm our first hypothesis later in Section SECREF4 where we see that decreasing the number of languages in mNMT improves the performance on XNLI."
        ]
      },
      {
        "section_name": "Experiments and Results ::: MLDoc: Document Classification",
        "paragraphs": [
          "MLDoc is a balanced subset of the Reuters corpus covering 8 languages for document classification BIBREF8. This is a 4-way classification task of identifying topics between CCAT (Corporate/Industrial), ECAT (Economics), GCAT (Government/Social), and MCAT (Markets). Performance is evaluated based on classification accuracy. We split the document using the sentence-piece model and feed the first 200 tokens into the encoder for classification. The task-specific network and the optimizer used is same as the one used for XNLI. Learning rate schedule is (0.2,5k). We perform both in-language and zero-shot evaluation. The in-language setting has training, development and test sets from the language. In the zero-shot setting, the train and dev sets contain only English examples but we test on all the languages. The results of both the experiments are reported in Table TABREF23.",
          "MMTE performance is on par with mBERT for in-language training on all the languages. It slightly edges over mBERT on zero-shot transfer while lagging behind SOTA by 0.2 points. Interestingly, MMTE beats SOTA on Japanese by more than 8 points. This may be due to the different nature and amount of data used for pre-training by these methods."
        ]
      },
      {
        "section_name": "Experiments and Results ::: Cross-lingual Intent Classification",
        "paragraphs": [
          "BIBREF7 recently presented a dataset for multilingual task oriented dialog. This dataset contains 57k annotated utterances in English (43k), Spanish (8.6k), and Thai (5k) with 12 different intents across the domains weather, alarm, and reminder. The evaluation metric used is classification accuracy. We use this data for both in-language training and zero-shot transfer. The task-specific network and the optimizer used is the same as the one used for the above two tasks. The learning rate schedule is (0.1,100k). Results are reported in Table TABREF25. MMTE outperforms both mBERT and previous SOTA in both in-language and zero-shot setting on all 3 languages and establishes a new SOTA for this dataset."
        ]
      },
      {
        "section_name": "Experiments and Results ::: POS Tagging",
        "paragraphs": [
          "We use universal dependencies POS tagging data from the Universal Dependency v2.3 BIBREF6, BIBREF20. Gold segmentation is used for training, tuning and testing. The POS tagging task has 17 labels for all languages. We consider 48 different languages. These languages are chosen based on intersection of languages for which POS labels are available in the universal dependencies dataset and the languages supported by our mNMT model. The task-specific network consists of a one layer feed-forward neural network with 784 units. Since MMTE operates on the subword-level, we only consider the representation of the first subword token of each word. The optimizer used is Adafactor with learning rate schedule (0.1,40k). The evaluation metric used is F1-score, which is same as accuracy in our case since we use gold-segmented data. Results of both in-language and zero-shot setting are reported in Table TABREF27.",
          "While mBERT outperforms MMTE on in-language training by a small margin of 0.16 points, MMTE beats mBERT by nearly 0.6 points in the zero-shot setting. Similar to results in XNLI, we see MMTE outperform mBERT on low resource languages. Since mBERT is SOTA for zero-shot cross-lingual transfer on POS tagging task BIBREF18, we also establish state-of-the-art on this dataset by beating mBERT in this setting."
        ]
      },
      {
        "section_name": "Experiments and Results ::: Named Entity Recognition",
        "paragraphs": [
          "For NER, we use the dataset from the CoNLL 2002 and 2003 NER shared tasks, which when combined have 4 languages BIBREF21, BIBREF22. The labeling scheme is IOB with 4 types of named entities. The task-specific network, optimizer, and the learning rate schedule is the same as in the setup for POS tagging. The evaluation metric is span-based F1. Table TABREF29 reports the results of both in-language and zero-shot settings.",
          "MMTE performs significantly worse than mBERT on the NER task in all languages. On average, mBERT beats MMTE by 7 F1 points in the in-language setting and by more than 18 points in the zero-shot setting. We hypothesize that this might be because of two reasons: (1) mBERT is trained on clean Wikipedia data which is entity-rich while MMTE is trained on noisy web data with fewer entities, and (2) the translation task just copies the entities from the source to the target and therefore might not be able to accurately recognize them. This result points to the importance of the type of pre-training data and objective on down-stream task performance. We plan to investigate this further in future work."
        ]
      },
      {
        "section_name": "Analysis",
        "paragraphs": [
          "In this section, we consider some additional settings for comparing mBERT and MMTE. We also investigate the impact of the number of languages and the target language token on MMTE performance."
        ]
      },
      {
        "section_name": "Analysis ::: Feature-based Approach",
        "paragraphs": [
          "In this setting, instead of fine-tuning the entire network of mBERT or MMTE, we only fine-tune the task-specific network which only has a small percentage of the total number of parameters. The rest of the model parameters are frozen. We perform this experiment on POS tagging task by fine-tuning a single layer feed-forward neural network stacked on top of mBERT and MMTE. We report the results in Table TABREF31. While the scores of the feature-based approach are significantly lower than those obtained via full fine-tuning (TABREF27), we see that MMTE still outperforms mBERT on both in-language and zero-shot settings by an even bigger margin. This is particularly interesting as the feature-based approach has its own advantages: 1) it is applicable to downstream tasks which require significant task-specific parameters on top of a transformer encoder, 2) it is computationally cheaper to train and tune the downstream model, and 3) it is compact and scalable since we only need a small number of task-specific parameters."
        ]
      },
      {
        "section_name": "Analysis ::: Few Shot Transfer",
        "paragraphs": [
          "While zero-shot transfer is a good measure of a model's natural cross-lingual effectiveness, the more practical setting is the few-shot transfer scenario as we almost always have access to, or can cheaply acquire, a small amount of data in the target language. We report the few-shot transfer results of mBERT and MMTE on the POS tagging dataset in TABREF33. To simulate the few-shot setting, in addition to using English data, we use 10 examples from each language (upsampled to 1000). MMTE outperforms mBERT in few-shot setting by 0.6 points averaged over 48 languages. Once again, we see that the gains are more pronounced in low resource languages."
        ]
      },
      {
        "section_name": "Analysis ::: One Model for all Languages",
        "paragraphs": [
          "Another setting of importance is the in-language training where instead of training one model for each language, we concatenate all the data and train one model jointly on all languages. We perform this experiment on the POS tagging dataset with 48 languages and report results in Table TABREF35. We observe that MMTE performance is on par with mBERT. We also find that the 48 language average improves by 0.2 points as compared to the one model per language setting in Table TABREF27."
        ]
      },
      {
        "section_name": "Analysis ::: Number of Languages in mNMT",
        "paragraphs": [
          "We perform an ablation where we vary the number of languages used in the pre-training step. Apart from the 103 language setting, we consider 2 additional settings: 1) where we train mNMT on 4 languages to and from English, and 2) where we use 25 languages. The results are presented in Table TABREF37. We see that as we scale up the languages the zero-shot performance goes down on both POS tagging and XNLI tasks. These losses align with the relative BLEU scores of these models suggesting that the regressions are due to interference arising from the large number of languages attenuating the capacity of the NMT model. Scaling up the mNMT model to include more languages without diminishing cross-lingual effectiveness is a direction for future work."
        ]
      },
      {
        "section_name": "Analysis ::: Effect of the Target Language Token",
        "paragraphs": [
          "During the pre-training step, when we perform the translation task using the mNMT system, we prepend a $<$2xx$>$ token to the source sentence, where xx indicates the target language. The encoder therefore has always seen a $<$2en$>$ token in front of non-English sentences and variety of different tokens depending on the target language in front of English sentence. However, when fine-tuning on downstream tasks, we do not use this token. We believe this creates a mismatch between the pre-training and fine-tuning steps. To investigate this further, we perform a small scale study where we train an mNMT model on 4 languages to and from English in two different settings: 1) where we prepend the $<$2xx$>$ token, and 2) where we don't prepend the $<$2xx$>$ token but instead encode it separately. The decoder jointly attends over both the source sentence encoder and the $<$2xx$>$ token encoding. The BLEU scores on the translation tasks are comparable using both these approaches. The results on cross-lingual zero-shot transfer in both settings are provided in Table TABREF39. Removing the $<$2xx$>$ token from the source sentence during mNMT training improves cross-lingual effectiveness on both POS tagging and XNLI task. Training a massively multilingual NMT model that supports translation of 102 languages to and from English without using the $<$2xx$>$ token in the encoder is another direction for future work."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "We briefly review widely used approaches in cross-lingual transfer learning and some of the recent work in learning contextual word representations (CWR)."
        ]
      },
      {
        "section_name": "Related Work ::: Multilingual Word Embeddings",
        "paragraphs": [
          "For cross-lingual transfer, the most widely studied approach is to use multilingual word embeddings as features in neural network models. Several recent efforts have explored methods that align vector spaces for words in different languages BIBREF23, BIBREF24, BIBREF25."
        ]
      },
      {
        "section_name": "Related Work ::: Unsupervised CWR",
        "paragraphs": [
          "More recent work has shown that CWRs obtained using unsupervised generative pre-training techniques such as language modeling or cloze task BIBREF26 have led to state-of-the-art results beyond what was achieved with traditional word type representations on many monolingual NLP tasks BIBREF27, BIBREF1, BIBREF28, BIBREF29 such as sentence classification, sequence tagging, and question answering. Subsequently, these contextual methods have been extended to produce multilingual representations by training a single model on text from multiple languages which have proven to be very effective for cross lingual transfer BIBREF18, BIBREF30, BIBREF31. BIBREF19 show that adding a translation language modeling (TLM) objective to mBERT's MLM objective utilizes both monolingual and parallel data to further improve the cross-lingual effectiveness."
        ]
      },
      {
        "section_name": "Related Work ::: Representations from NMT",
        "paragraphs": [
          "The encoder from an NMT model has been used as yet another effective way to contextualize word vectors BIBREF32. Additionally, recent progress in NMT has enabled one to train multilingual NMT systems that support translation from multiple source languages into multiple target languages within a single model BIBREF3. Our work is more closely related to two very recent works which explore the encoder from multilingual NMT model for cross-lingual transfer learning BIBREF4, BIBREF5. While BIBREF4 also consider multilingual systems, they do so on a much smaller scale, training it on only 2 languages. BIBREF5 uses a large scale model comparable to ours with 93 languages but they constrain the model by pooling encoder representations and therefore only obtain a single vector per sequence. Neither of these approaches have been used on token level sequence tagging tasks. Further, neither concern themselves with the performance of the actual translation task whereas we our mNMT model performs comparable to bilingual baselines in terms of translation quality."
        ]
      },
      {
        "section_name": "Conclusion and Future Work",
        "paragraphs": [
          "We train a massively multilingual NMT system using parallel data from 103 languages and exploit representations extracted from the encoder for cross-lingual transfer on various classification and sequence tagging tasks spanning over 50 languages. We find that the positive language transfer visible in improved translation quality for low resource languages is also reflected in the cross-lingual transferability of the extracted representations. The gains observed on various tasks over mBERT suggest that the translation objective is competitive with specialized approaches to learn cross-lingual embeddings.",
          "We find that there is a trade off between the number of languages in the multilingual model and efficiency of the learned representations due to the limited capacity. Scaling up the model to include more languages without diminishing transfer learning capability is a direction for future work. Finally, one could also consider integrating mBERT's objective with the translation objective to pre-train the mNMT system."
        ]
      },
      {
        "section_name": "Supplementary Material",
        "paragraphs": [
          "In this section we provide the list of languages codes used throughout this paper and the statistics of the datasets used for the downstream tasks."
        ]
      }
    ],
    "qas": [
      {
        "question": "What are the five downstream tasks?",
        "question_id": "b70e4c49300dc3eab18e907ab903afd2a0c6075a",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "professional machine translation artifact",
        "question_writer": "2a18a3656984d04249f100633e4c1003417a2255",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
              ],
              "highlighted_evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. "
              ]
            },
            "annotation_id": "0893e333fa2bbaa066808c7b66d25af1d4ef3a02",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "NLI (XNLI dataset)",
                "document classification (MLDoc dataset)",
                "intent classification",
                "POS tagging",
                "NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
              ],
              "highlighted_evidence": [
                "These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER."
              ]
            },
            "annotation_id": "32f87071ac6cdea299d08cb528bc6e4ea85651bd",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "NLI (XNLI dataset)",
                "document classification (MLDoc dataset)",
                " intent classification",
                "sequence tagging tasks: POS tagging",
                "NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
              ],
              "highlighted_evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
              ]
            },
            "annotation_id": "6a387a740b980989c846abd9e398a4386bd3f816",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "NLI",
                "document classification",
                "intent classification",
                "POS tagging",
                "NER"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. We detail all of the experiments in this section."
              ],
              "highlighted_evidence": [
                "As stated earlier, we use MMTE to perform downstream cross-lingual transfer on 5 NLP tasks. These include 3 classification tasks: NLI (XNLI dataset), document classification (MLDoc dataset) and intent classification, and 2 sequence tagging tasks: POS tagging and NER. "
              ]
            },
            "annotation_id": "c9c5547ab8d63754293c29ce4e150403695b34ae",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Per language pair data distribution of the dataset used for our multilingual NMT model. The yaxis depicts the number of training examples available per language pair on a logarithmic scale. Dataset sizes range from 35k for the lowest resource language pairs to 2 billion for the largest."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: BLEU scores on ten language pairs with mNMT. *baseline refers to a transformer based bilingual NMT model trained on only one language pair."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Accuracies on the test set of the XNLI dataset. *mBERT numbers have been taken from Wu and Dredze (2019). \u2020 SOTA in the last column refers to the MLM + translation language modeling (TLM) results reported in Lample and Conneau (2019)."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Accuracies on the test set of the MLDoc dataset. *mBERT numbers have been taken from Wu and Dredze (2019). mBERT is also the state-of-the-art for in-language training. \u2020 For zero-shot SOTA refers to Artetxe and Schwenk (2018)."
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Accuracies on the test set of the intent classification dataset. *mBERT numbers are from our own implementation using the publicly available mBERT checkpoint. \u2020 SOTA refers to the numbers reported in Schuster et al. (2018)."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: F1 scores on the dev set of the POS tagging dataset. *mBERT numbers are from our own implementation using the publicly available mBERT checkpoint. For readability, we only report results on 15 select languages and the 48 Language average (48L)."
      },
      {
        "file": "6-Table7-1.png",
        "caption": "Table 7: F1 scores on dev set of POS tagging dataset using both mBERT and MMTE as feature extractor."
      },
      {
        "file": "6-Table6-1.png",
        "caption": "Table 6: F1 scores on the test set of the NER task. *mBERT numbers have been taken from Wu and Dredze (2019). mBERT is also the state-of-the-art for zero-shot setting."
      },
      {
        "file": "7-Table8-1.png",
        "caption": "Table 8: F1 scores on dev set of POS tagging dataset in few-shot setting using 10 examples from each language in addition to English data."
      },
      {
        "file": "7-Table10-1.png",
        "caption": "Table 10: Effect of number of languages used for mNMT training on downstream zero-shot performance. XNLI numbers are accuracies. POS numbers are F1 scores. \u2014- indicate that the language was not present in the subset that mNMT was trained on."
      },
      {
        "file": "7-Table9-1.png",
        "caption": "Table 9: F1 scores on dev set of POS tagging dataset in one model for all language setting."
      },
      {
        "file": "8-Table11-1.png",
        "caption": "Table 11: Effect of <2xx> token on zero-shot crosslingual performance. XNLI numbers are accuracies. POS numbers are F1 scores."
      },
      {
        "file": "11-Table12-1.png",
        "caption": "Table 12: List of BCP-47 language codes used throughout this paper. ."
      },
      {
        "file": "12-Table13-1.png",
        "caption": "Table 13: Statistics of data used for the POS tagging task."
      },
      {
        "file": "13-Table14-1.png",
        "caption": "Table 14: Statistics of data used for the NER task."
      },
      {
        "file": "13-Table15-1.png",
        "caption": "Table 15: Statistics of data used for the XNLI task."
      },
      {
        "file": "13-Table16-1.png",
        "caption": "Table 16: Statistics of data used for the document classification task."
      },
      {
        "file": "13-Table17-1.png",
        "caption": "Table 17: Statistics of data used for the intent classification task."
      }
    ]
  },
  "2003.07568": {
    "title": "XPersona: Evaluating Multilingual Personalized Chatbot",
    "abstract": "Personalized dialogue systems are an essential step toward better human-machine interaction. Existing personalized dialogue agents rely on properly designed conversational datasets, which are mostly monolingual (e.g., English), which greatly limits the usage of conversational agents in other languages. In this paper, we propose a multi-lingual extension of Persona-Chat, namely XPersona. Our dataset includes persona conversations in six different languages other than English for building and evaluating multilingual personalized agents. We experiment with both multilingual and cross-lingual trained baselines, and evaluate them against monolingual and translation-pipeline models using both automatic and human evaluation. Experimental results show that the multilingual trained models outperform the translation-pipeline and that they are on par with the monolingual models, with the advantage of having a single model across multiple languages. On the other hand, the state-of-the-art cross-lingual trained models achieve inferior performance to the other models, showing that cross-lingual conversation modeling is a challenging task. We hope that our dataset and baselines will accelerate research in multilingual dialogue systems.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Personalized dialogue agents have been shown efficient in conducting human-like conversation. This progress has been catalyzed thanks to existing conversational dataset such as Persona-chat BIBREF0, BIBREF1. However, the training data are provided in a single language (e.g., English), and thus the resulting systems can perform conversations only in the training language. For wide, commercial dialogue systems are required to handle a large number of languages since the smart home devices market is increasingly international BIBREF2. Therefore, creating multilingual conversational benchmarks is essential, yet challenging since it is costly to perform human annotation of data in all languages.",
          "A possible solution is to use translation systems before and after the model inference, a two-step translation from any language to English and from English to any language. This comes with three major problems: 1) amplification of translation errors since the current dialogue systems are far from perfect, especially with noisy input; 2) the three-stage pipeline system is significantly slower in terms of inference speed; and 3) high translation costs since the current state-of-the-art models, especially in low resources languages, are only available using costly APIs.",
          "In this paper, we analyze two possible workarounds to alleviate the aforementioned challenges. The first is to build a cross-lingual transferable system by aligning cross-lingual representations, as in BIBREF3, in which the system is trained on one language and zero-shot to another language. The second is to learn a multilingual system directly from noisy multilingual data (e.g., translated data), thus getting rid of the translation system dependence at inference time.",
          "To evaluate the aforementioned systems, we propose a dataset called Multilingual Persona-Chat, or XPersona, by extending the Persona-Chat corpora BIBREF1 to six languages: Chinese, French, Indonesian, Italian, Korean, and Japanese. In XPersona, the training sets are automatically translated using translation APIs with several human-in-the-loop passes of mistake correction. In contrast, the validation and test sets are annotated by human experts to facilitate both automatic and human evaluations in multiple languages.",
          "Furthermore, we propose competitive baselines in two training settings, namely, cross-lingual and multilingual, and compare them with translation pipeline models. Our baselines leverage pre-trained cross-lingual BIBREF4 and multilingual BIBREF5 models.",
          "An extensive automatic and human evaluation BIBREF6 of our models shows that a multilingual system is able to outperform strong translation-based models and on par with or even improve the monolingual model. The cross-lingual performance is still lower than other models, which indicates that cross-lingual conversation modeling is very challenging. The main contribution of this paper are summarized as follows:",
          "We present the first multilingual non-goal-oriented dialogue benchmark for evaluating multilingual generative chatbots.",
          "We provide both cross-lingual and multilingual baselines and discuss their limitations to inspire future research.",
          "We show the potential of multilingual systems to understand the mixed language dialogue context and generate coherent responses."
        ]
      },
      {
        "section_name": "Related Work ::: Dialogue Systems",
        "paragraphs": [
          "are categorized as goal-oriented BIBREF7, BIBREF8 and chit-chat BIBREF9, BIBREF10. Interested readers may refer to BIBREF11 for a general overview. In this paper, we focus on the latter, for which, in recent years, several tasks and datasets have been proposed to ground the conversation on knowledge BIBREF12, BIBREF13, BIBREF14, BIBREF15, BIBREF16, BIBREF17, BIBREF18 such as Wiki-Articles, Reddit-Post, and CNN-Article. In this work, we focus on personalized dialogue agents where the dialogues are grounded on persona information.",
          "BIBREF19 was the first to introduce a persona-grounded dialogue dataset for improving response consistency. Later on, BIBREF0 and BIBREF1 introduced Persona-chat, a multi-turn conversational dataset, where two speakers are paired, and a persona description (4\u20135 sentences) is randomly assigned to each of them. By conditioning the response generation on the persona descriptions, a chit-chat model is able to produce a more persona-consistent dialogue BIBREF0. Several works have improved on the initial baselines with various methodologies BIBREF20, BIBREF21, BIBREF22, BIBREF23, BIBREF24, BIBREF25, especially using large pre-trained models BIBREF26, BIBREF27."
        ]
      },
      {
        "section_name": "Related Work ::: Multilingual",
        "paragraphs": [
          "Extensive approaches have been introduced to construct multilingual systems, for example, multilingual semantic role labeling BIBREF28, BIBREF29, multilingual machine translation BIBREF30, multilingual automatic speech recognition BIBREF31, BIBREF32, BIBREF33, BIBREF34, and named entity recognition BIBREF35, BIBREF36. Multilingual deep contextualized model such as Multilingual BERT (M-BERT) BIBREF5 have been commonly used to represent multiple languages and elevate the performance in many NLP applications, such as classification tasks BIBREF37, textual entailment, named entity recognition BIBREF38, and natural language understanding BIBREF39. Multilingual datasets have also been created for a number of NLP tasks, such as named entity recognition or linking BIBREF40, BIBREF41, BIBREF42, BIBREF43, question answering BIBREF44, BIBREF45, semantic role labeling BIBREF46, part-of-speech tagging BIBREF47, dialogue state tracking BIBREF48, and natural language understanding BIBREF49. However, none of these datasets include the multilingual chit-chat task."
        ]
      },
      {
        "section_name": "Related Work ::: Cross-lingual",
        "paragraphs": [
          "Cross-lingual adaptation learns the inter-connections among languages and circumvents the requirement of extensive training data in target languages BIBREF50, BIBREF51, BIBREF52. Cross-lingual transfer learning methods have been applied to multiple NLP tasks, such as named entity recognition BIBREF53, BIBREF54, natural language understanding BIBREF39, dialogue state tracking BIBREF55, part-of-speech tagging BIBREF50, BIBREF51, BIBREF56, and dependency parsing BIBREF57, BIBREF58. Meanwhile, BIBREF59 and BIBREF60 proposed pre-trained cross-lingual language models to align multiple language representations, achieving state-of-the-art results in many cross-lingual classification tasks. The aforementioned tasks focused on classification and sequence labeling, while instead, BIBREF4 proposed to pre-train both the encoder and decoder of a sequence-to-sequence model (XNLG) to conduct cross-lingual generation tasks, namely, question generation and abstractive summarization. The latter is the closest to our task since it focuses on language generation; however cross-lingual dialogue generation has not yet been explored."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "The proposed XPersona dataset is an extension of the persona-chat dataset BIBREF0, BIBREF1. Specifically, we extend the ConvAI2 BIBREF1 to six languages: Chinese, French, Indonesian, Italian, Korean, and Japanese. Since the test set of ConvAI2 is hidden, we split the original validation set into a new validation set and test sets. Then, we firstly automatically translate the training, validation, and test set using APIs (PapaGo for Korean, Google Translate for other languages). For each language, we hired native speaker annotators with a fluent level of English and asked them to revise the machine-translated dialogues and persona sentences in the validation set and test set according to original English dialogues. The main goal of human annotation is to ensure the resulting conversations are coherent and fluent despite the cultural differences in target languages. Therefore, annotators are not restricted to only translate the English dialogues, and they are allowed to modify the original dialogues to improve the dialogue coherence in the corresponding language while retaining the persona information. The full annotation instructions are reported in Appendix A.",
          "Compared to collecting new persona sentences and dialogues in each language, human-annotating the dialogues by leveraging translation APIs has multiple advantages. First, it increases the data distribution similarity across languages BIBREF3, which can better examine the system's cross-lingual transferability. Second, revising the machine-translated dialogues based on the original English dialogue improves the data construction efficiency. Third, it leverages the well-constructed English persona conversations as a reference to ensure the dialogue quality without the need for training a new pool of workers to generate new samples BIBREF3.",
          "On the other hand, human-translating the entire training-set ($\\sim $130K utterances) in six languages is expensive. Therefore, we propose an iterative method to improve the quality of the automatically translated training set. We firstly sample 200 dialogues from the training set ($\\sim $2600 utterances) in each language, and we assign human annotators to list all frequent translation mistakes in the given dialogues. For example, daily colloquial English expressions such as \u201ccool\", \u201cI see\", and \u201clol\" are usually literally translated. After that, we use a simple string matching to revise the inappropriate translations in the whole training-set and return a revision log, which records all the revised utterances. Then, we assign human annotators to check all the revised utterances and list translation mistakes again. We repeat this process at least twice for each language. Finally, we summarize the statistics of the collected dataset in Table TABREF6."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models",
        "paragraphs": [
          "Let us define a dialogue $\\mathcal {D}=\\lbrace U_1,S_1,U_2,S_2, \\dots , U_n, S_n\\rbrace $ as an alternating set of utterances from two speakers, where $U$ and $S$ represent the user and the system, respectively. Each speaker has its corresponding persona description that consists of a set of sentences $\\mathcal {P}=\\lbrace P_1,\\dots ,P_m\\rbrace $. Given the system persona sentences $\\mathcal {P}_s$ and dialogue history $\\mathcal {D}_t=\\lbrace U_1,S_1,U_2, \\dots ,S_{t-1}, U_t\\rbrace $, we are interested in predicting the system utterances $S_t$."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Model Architecture",
        "paragraphs": [
          "We explore both encoder-decoder and causal decoder architectures, and we leverage existing pre-trained contextualized multilingual language models as weights initialization. Hence, we firstly define the multilingual embedding layer and then the two multilingual models used in our experiments."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Model Architecture ::: Embedding",
        "paragraphs": [
          "We define three embedding matrices: word embedding $E^W\\in \\mathbb {R}^{|V| \\times d}$, positional embedding $E^P\\in \\mathbb {R}^{M \\times d}$, and segmentation embedding $E^S\\in \\mathbb {R}^{|S| \\times d}$, where $|.|$ denotes set cardinality, $d$ is the embedding size, $V$ denotes the vocabulary, $M$ denotes the maximum sequence length, and $S$ denotes the set of segmentation tokens. Segmentation embedding BIBREF26 is used to indicate whether the current token is part of i) Persona sentences, ii) System (Sys.) utterances, iii) User utterances, iv) response in Language $l_{id}$. The language embedding $l_{id}$ is used to inform the model which language to generate. Hence, given a sequence of tokens $X$, the embedding functions $E$ are defined as:",
          "where $\\oplus $ denotes the positional sum, $X_{pos}=\\lbrace 1,\\dots ,|X|\\rbrace $ and $X_{seg}$ is the sequence of segmentation tokens, as in BIBREF26. Figure FIGREF9 shows a visual representation of the embedding process. A more detailed illustration is reported in Appendix B."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Model Architecture ::: Encoder-Decoder",
        "paragraphs": [
          "To model the response generation, we use a Transformer BIBREF61 based encoder-decoder BIBREF10. As illustrated in Figure FIGREF9, we concatenate the system persona $\\mathcal {P}_s$ with the dialogue history $\\mathcal {D}_t$. Then we use the embedding layer $E$ to finally pass it to the encoder. In short, we have:",
          "where $H \\in \\mathbb {R}^{L \\times d_{model}}$ is the hidden representation computed by the encoder, and $L$ denotes the input sequence length. Then, the decoder attends to $H$ and generates the system response $S_t$ token by token. In the decoder, segmentation embedding is the language ID embedding (e.g., we look up the embedding for Italian to decode Italian). Thus:"
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Model Architecture ::: Causal Decoder",
        "paragraphs": [
          "As an alternative to encoder-decoders, the causal-decoders BIBREF62, BIBREF63, BIBREF64 have been used to model conversational responses BIBREF26, BIBREF27 by giving as a prefix the dialogue history. In our model, we concatenate the persona $\\mathcal {P}_s$ and the dialogue history $\\mathcal {D}_t$ as the language model prefix, and autoregressively decode the system response $S_t$ based on language embedding (i.e. $l_{id}$):",
          "Figure FIGREF9 shows the conceptual differences between the encoder-decoder and casual decoder. Note that in both multilingual models, the dialogue history encoding process is language-agnostic, while decoding language is controlled by the language embedding. Such design allows the model to understand mixed-language dialogue contexts and to responds in the desired language (details in Section SECREF44)."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Training Strategy",
        "paragraphs": [
          "We consider two training strategies to learn a multilingual conversational model: multilingual training and cross-lingual training."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Training Strategy ::: Multilingual Training",
        "paragraphs": [
          "jointly learns to perform personalized conversations in multiple languages. We follow a transfer learning approach BIBREF26, BIBREF65 by initializing our models with the weights of the large multilingual pretrained model M-Bert BIBREF37. For the causal decoder, we add the causal mask into self-attention layer to convert M-Bert encoder to decoder. For encoder-decoder model, we randomly initialize the cross encoder-decoder attention BIBREF66. Then, we train the both models on the combined training set in all 7 languages using cross-entropy loss."
        ]
      },
      {
        "section_name": "Multilingual Personalized Conversational Models ::: Training Strategy ::: Cross-lingual Training",
        "paragraphs": [
          "transfers knowledge from the source language data to the target languages. In this setting, the model is trained on English (source language) conversational samples, and evaluated on the other 6 languages. Following the methodology proposed by BIBREF4, we align the embedded representations of different languages into the same embedding space by applying cross-lingual pre-training to the encoder-decoder model. The pre-training procedure consists of two stages:",
          "pre-training the encoder and the decoder independently utilizing masked language modeling, as in BIBREF59;",
          "jointly pre-training the encoder-decoder by using two objective functions: Cross-Lingual Auto-Encoding (XAE) and Denoising Auto-Encoding (DAE) BIBREF4.",
          "For instance, DAE adds perturbations to the input sentence and tries to reconstructs the original sentence using the decoder, whereas, XAE uses parallel translation data as the supervision signal to pre-train both the encoder and decoder. As in the multilingual models, the language IDs are fed into the decoder to control the language of generated sentences. Both pre-training stages require both parallel and non-parallel data in the target language.",
          "After the two stages of pre-training, the model is fine-tuned using just the source language samples (i.e., English) with the same cross-entropy loss as for the multilingual training. However, as suggested in BIBREF4, only the encoder parameters are updated with back-propagation and both the decoder and the word embedding layer remain frozen. This retains the decoders' ability to generate multilingual output while still being able to learn new tasks using only the target language."
        ]
      },
      {
        "section_name": "Experiments ::: Evaluation Metrics",
        "paragraphs": [
          "Evaluating open-domain chit-chat models is challenging, especially in multiple languages and at the dialogue-level. Hence, we evaluate our models using both automatic and human evaluation. In both cases, human-annotated dialogues are used, which show the importance of the provided dataset."
        ]
      },
      {
        "section_name": "Experiments ::: Evaluation Metrics ::: Automatic",
        "paragraphs": [
          "For each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses. Although these automatic measures are not perfect BIBREF68, they help to roughly estimate the performance of different models under the same test set. More recently, BIBREF69 has shown the correlation between perplexity and human judgment in open-domain chit-chat models."
        ]
      },
      {
        "section_name": "Experiments ::: Evaluation Metrics ::: Human",
        "paragraphs": [
          "Asking humans to evaluate the quality of a dialogue model is challenging, especially when multiple models have to be compared. The likert score (a.k.a. 1 to 5 scoring) has been widely used to evaluate the interactive experience with conversational models BIBREF70, BIBREF65, BIBREF0, BIBREF1. In such evaluation, a human interacts with the systems for several turns, and then they assign a score from 1 to 5 based on three questions BIBREF0 about fluency, engagingness, and consistency. This evaluation is both expensive to conduct and requires many samples to achieve statistically significant results BIBREF6. To cope with these issues, BIBREF6 proposed ACUTE-EVAL, an A/B test evaluation for dialogue systems. The authors proposed two modes: human-model chats and self-chat BIBREF71, BIBREF72. In this work, we opt for the latter since it is cheaper to conduct and achieves similar results BIBREF6 to the former. Another advantage of using this method is the ability to evaluate multi-turn conversations instead of single-turn responses.",
          "Following ACUTE-EVAL, the annotator is provided with two full dialogues made by self-chat or human-dialogue. The annotator is asked to choose which of the two dialogues is better in terms of engagingness, interestingness, and humanness. For each comparison, we sample 60\u2013100 conversations from both models. In Appendix C, we report the exact questions and instructions given to the annotators, and the user interface used in the evaluation. We hired native speakers annotators for all six considered languages. The annotators were different from the dataset collection annotators to avoid any possible bias."
        ]
      },
      {
        "section_name": "Experiments ::: Implementation Details ::: Multilingual Models",
        "paragraphs": [
          "We use the \"BERT-Base, Multilingual Cased\" checkpoint, and we denote the multilingual encoder-decoder model as M-Bert2Bert ($\\sim $220M parameters) and causal decoder model as M-CausalBert ($\\sim $110M parameters). We fine-tune both models in the combined training set (English in Persona-chat BIBREF0, six languages in Xpersona) for five epochs with AdamW optimizer and a learning rate of $6.25e$-5."
        ]
      },
      {
        "section_name": "Experiments ::: Implementation Details ::: Monolingual Models",
        "paragraphs": [
          "To verify whether the multilingual agent will under-perform the monolingual agent in the monolingual conversational task, we build a monolingual encoder-decoder model and causal decoder model for each language. For a fair comparison, we initialize the monolingual models with a pre-trained monolingual BERT BIBREF5, BIBREF73, BIBREF74. We denote the monolingual encoder-decoder model as Bert2Bert ($\\sim $220M parameters) and causal decoder model as CausalBert ($\\sim $110M parameters). Then we fine-tune each model in each language independently for the same number of epoch and optimizer as the multilingual model."
        ]
      },
      {
        "section_name": "Experiments ::: Implementation Details ::: Translation-based Models",
        "paragraphs": [
          "Another strong baseline we compare with is Poly-encoder BIBREF75, a large-scale pre-trained retrieval model that has shown state-of-the-art performance in the English Persona-chat dataset BIBREF6. We adapt this model to the other languages by using the Google Translate API to translate target languages (e.g., Chinese) query to English as the input to the model, then translate the English response back to the target language. Thus, the response generation flow is: target query $\\rightarrow $ English query $\\rightarrow $ English response $\\rightarrow $ target response. We denote this model as Poly."
        ]
      },
      {
        "section_name": "Experiments ::: Implementation Details ::: Cross-lingual Models.",
        "paragraphs": [
          "In the first pre-training stage, we use the pre-trained weights from XLMR-base BIBREF60. Then, we follow the second pre-training stage of XNLG BIBREF4 for pre-training Italian, Japanese, Korean, Indonesia cross-lingual transferable models. For Chinese and French, we directly apply the pre-trained XNLG BIBREF4 weights. Then, the pre-trained models are fine-tune on English PersonaChat training set and early stop based on the perplexity on target language validation set."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Discussion ::: Quantitative Analysis",
        "paragraphs": [
          "Table TABREF20 compares monolingual, multilingual, and cross-lingual models in terms of BLEU and perplexity in the human-translated test set. On both evaluation matrices, the causal decoder models outperform the encoder-decoder models. We observe that the encoder-decoder model tends to overlook dialogue context and generate digressive responses. (Generated samples are available in Appendix D) We hypothesize that this is because the one-to-many problem BIBREF76 in open-domain conversation weakens the relation between encoder and decoder; thus the well pre-trained decoder (Bert) easily converges to a locally-optimal, and learns to ignore the dialogue context from the encoder and generate the response in an unconditional language model way. We leave the investigation of this problem to future work. On the other hand, M-CausalBert achieves a comparable or slightly better performance compared to CausalBert, which suggests that M-CausalBert leverages the data from other languages. As expected, we observe a significant gap between the cross-lingual model and other models, which indicates that cross-lingual zero-shot conversation modeling is very challenging.",
          "Table TABREF28 shows the human evaluation result of comparing M-CausalBert (Multi) against the human, translation-based Poly-encoder (Poly), and monolingual CausalBert (Mono). The results illustrate that Multi outperforms Mono in English and Chinese, and is on par with Mono in other languages. On the other hand, Poly shows a strong performance in English as it was pre-trained with a large-scale English conversation corpus. In contrast, the performance of Poly drops in other languages, which indicates that the imperfect translation affects translation-based systems."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Discussion ::: Qualitative Analysis and Discussion",
        "paragraphs": [
          "We randomly sample 7 self-chat dialogues for each baseline model in the seven languages and report them in Appendix D., And we summarize the generation of each model as follows:"
        ]
      },
      {
        "section_name": "Experiments ::: Results and Discussion ::: Qualitative Analysis and Discussion ::: Poly",
        "paragraphs": [
          "Poly-encoder, pretrained on 174 million Reddit data, can accurately retrieve coherent and diverse responses in English. However, in the other six languages, some of the retrieved responses are digressive due to translation error."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Discussion ::: Qualitative Analysis and Discussion ::: Monolingual & Multilingual",
        "paragraphs": [
          "We observe that both the monolingual and multilingual models can generate fluent responses. Compared to Bert2Bert and M-Bert2Bert, CausalBert and M-CausalBert can generate more on-topic responses but sometimes repeat through turns. CausalBert and M-CausalBert are on par with each other in monolingual conversational tasks, while M-CausalBert shows the advantage of handling a mixed-language context. For multilingual speakers, the conversation may involve multiple languages. Therefore, we experiment on M-CausalBert with two settings: 1) many-to-one, in which users converse with the model in 6 languages, and the model generate responses in English, 2) one-to-many, in which users converse with the model using English, and the model generates responses in 6 languages using language embedding and corresponding persona sentences. Table TABREF42 and table TABREF43 illustrate the generation examples under these settings (more examples reported in Appendix C.1). Most of the time, M-CausalBert can understand the mixed-language context, and decode coherent response in different languages. Understanding the mixed-language dialogue context is a desirable skill for end-to-end chit-chat systems, and a systematic study of this research question is needed in future."
        ]
      },
      {
        "section_name": "Experiments ::: Results and Discussion ::: Qualitative Analysis and Discussion ::: Cross-lingual.",
        "paragraphs": [
          "The current state-of-the-art cross-lingual generation approach XNLG BIBREF4 shows inferior performance on multi-turn dialogue tasks, and generates repetitive responses. Although cross-lingual dialogue generation is challenging, it reduces the human effort for data annotation in different languages. Therefore, the cross-language transfer is an important direction to investigate."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we studied both cross-lingual and multilingual approaches in end-to-end personalized dialogue modeling. We presented the XPersona dataset, a multilingual extension of Persona-Chat, for evaluating the multilingual personalized chatbots. We further provided both cross-lingual and multilingual baselines and compared them with the monolingual approach and two-stage translation approach. Extensive automatic evaluation and human evaluation were conducted to examine the models' performance. The experimental results showed that multilingual trained models, with a single model across multiple languages, can outperform the two-stage translation approach and is on par with monolingual models. On the other hand, the current state-of-the-art cross-lingual approach XNLG achieved lower performance than other baselines. In future work, we plan to research a more advanced cross-lingual generation approach and construct a mixed-language conversational benchmark for evaluating multilingual systems."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Annotation Instructions",
        "paragraphs": [
          "In this section, we show the instructions for French annotation:",
          "There are two existing columns of conversations: the first column (en) is the original conversations in English, the second column (fr) is the conversations translated by an automatic system (e.g., Google Translate).",
          "You should copy the conversation from the second column (the translated conversations) into the third column (named fr_annotation). In that column, you should then revise the incorrect or inappropriate translations.",
          "The goal of the revision is to make the conversations more coherent and fluent in the target language (French). Hence you can customize dialogues and persona sentences to make them fluent and coherent in the target language, including by deviating from the original translation. However, you should retain persona and conversation consistency."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Training Set Statistics",
        "paragraphs": [
          "We report our iterative revised training set statistics in Table TABREF53."
        ]
      },
      {
        "section_name": "Model Detail",
        "paragraphs": [
          "Figure FIGREF55 and FIGREF56 illustrates the details of the multilingual causal decoder and the multilingual encoder-decoder models."
        ]
      },
      {
        "section_name": "Human Evaluation",
        "paragraphs": [
          "As illustrated in Figure FIGREF54, the annotator is provided with two full dialogues made by a self-chat model or human-dialogues. Then the annotators are asked the following questions:",
          "Who would you talk to for a long conversation?",
          "If you had to say one of these speakers is interesting and one is boring, who would you say is more interesting?",
          "Which speaker sounds more human?"
        ]
      },
      {
        "section_name": "Generated Samples ::: Mixed-language Samples",
        "paragraphs": [
          "We report more the mixed-language samples generated by M-CausalBert in Table TABREF61 and TABREF62."
        ]
      },
      {
        "section_name": "Generated Samples ::: Model Comparison Samples",
        "paragraphs": [
          "We randomly sample one self-chat dialogue examples for each model in each language and report them in figure 5-32.",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert",
          "in CausalBert,M-CausalBert,PolyEncoder,M-Bert2Bert"
        ]
      }
    ],
    "qas": [
      {
        "question": "What kind of evaluations do use to evaluate dialogue?",
        "question_id": "108f99fcaf620fab53077812e8901870896acf36",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "They use automatic evaluation using perplexity and BLEU scores with reference to the human-annotated responses and human evaluation on interestingness, engagingness, and humanness.",
              "evidence": [
                "Evaluating open-domain chit-chat models is challenging, especially in multiple languages and at the dialogue-level. Hence, we evaluate our models using both automatic and human evaluation. In both cases, human-annotated dialogues are used, which show the importance of the provided dataset.",
                "Experiments ::: Evaluation Metrics ::: Automatic",
                "For each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses. Although these automatic measures are not perfect BIBREF68, they help to roughly estimate the performance of different models under the same test set. More recently, BIBREF69 has shown the correlation between perplexity and human judgment in open-domain chit-chat models.",
                "Following ACUTE-EVAL, the annotator is provided with two full dialogues made by self-chat or human-dialogue. The annotator is asked to choose which of the two dialogues is better in terms of engagingness, interestingness, and humanness. For each comparison, we sample 60\u2013100 conversations from both models. In Appendix C, we report the exact questions and instructions given to the annotators, and the user interface used in the evaluation. We hired native speakers annotators for all six considered languages. The annotators were different from the dataset collection annotators to avoid any possible bias."
              ],
              "highlighted_evidence": [
                "Hence, we evaluate our models using both automatic and human evaluation. ",
                "Experiments ::: Evaluation Metrics ::: Automatic\nFor each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses. ",
                "The annotator is asked to choose which of the two dialogues is better in terms of engagingness, interestingness, and humanness. "
              ]
            },
            "annotation_id": "115aa2aee94362702d3df290770ebbf60e76e597",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "2e27f9264e6643f5de8811d96d68747511995af1",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "perplexity (ppl.) and BLEU",
                "which of the two dialogues is better in terms of engagingness, interestingness, and humanness"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Experiments ::: Evaluation Metrics",
                "Evaluating open-domain chit-chat models is challenging, especially in multiple languages and at the dialogue-level. Hence, we evaluate our models using both automatic and human evaluation. In both cases, human-annotated dialogues are used, which show the importance of the provided dataset.",
                "Experiments ::: Evaluation Metrics ::: Automatic",
                "For each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses. Although these automatic measures are not perfect BIBREF68, they help to roughly estimate the performance of different models under the same test set. More recently, BIBREF69 has shown the correlation between perplexity and human judgment in open-domain chit-chat models.",
                "Following ACUTE-EVAL, the annotator is provided with two full dialogues made by self-chat or human-dialogue. The annotator is asked to choose which of the two dialogues is better in terms of engagingness, interestingness, and humanness. For each comparison, we sample 60\u2013100 conversations from both models. In Appendix C, we report the exact questions and instructions given to the annotators, and the user interface used in the evaluation. We hired native speakers annotators for all six considered languages. The annotators were different from the dataset collection annotators to avoid any possible bias."
              ],
              "highlighted_evidence": [
                "Evaluation Metrics\nEvaluating open-domain chit-chat models is challenging, especially in multiple languages and at the dialogue-level. Hence, we evaluate our models using both automatic and human evaluation. In both cases, human-annotated dialogues are used, which show the importance of the provided dataset.",
                "Automatic\nFor each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses.",
                "Following ACUTE-EVAL, the annotator is provided with two full dialogues made by self-chat or human-dialogue. The annotator is asked to choose which of the two dialogues is better in terms of engagingness, interestingness, and humanness."
              ]
            },
            "annotation_id": "6b9fd7c1675812a721581732a77280f6ae72adc1",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "perplexity",
                "BLEU",
                "ACUTE-EVA"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses. Although these automatic measures are not perfect BIBREF68, they help to roughly estimate the performance of different models under the same test set. More recently, BIBREF69 has shown the correlation between perplexity and human judgment in open-domain chit-chat models.",
                "Asking humans to evaluate the quality of a dialogue model is challenging, especially when multiple models have to be compared. The likert score (a.k.a. 1 to 5 scoring) has been widely used to evaluate the interactive experience with conversational models BIBREF70, BIBREF65, BIBREF0, BIBREF1. In such evaluation, a human interacts with the systems for several turns, and then they assign a score from 1 to 5 based on three questions BIBREF0 about fluency, engagingness, and consistency. This evaluation is both expensive to conduct and requires many samples to achieve statistically significant results BIBREF6. To cope with these issues, BIBREF6 proposed ACUTE-EVAL, an A/B test evaluation for dialogue systems. The authors proposed two modes: human-model chats and self-chat BIBREF71, BIBREF72. In this work, we opt for the latter since it is cheaper to conduct and achieves similar results BIBREF6 to the former. Another advantage of using this method is the ability to evaluate multi-turn conversations instead of single-turn responses."
              ],
              "highlighted_evidence": [
                "For each language, we evaluate responses generated by the models using perplexity (ppl.) and BLEU BIBREF67 with reference to the human-annotated responses.",
                "To cope with these issues, BIBREF6 proposed ACUTE-EVAL, an A/B test evaluation for dialogue systems. The authors proposed two modes: human-model chats and self-chat BIBREF71, BIBREF72. In this work, we opt for the latter since it is cheaper to conduct and achieves similar results BIBREF6 to the former. Another"
              ]
            },
            "annotation_id": "7ddfc1b4231c441a5f959928fd3af11237c84e9a",
            "worker_id": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Multi-turn annotated dialogue samples from test set in seven languages. For simplicity, we only show three turns for each dialogue and the persona in English."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: The statistics of the collected dataset. We report the number of dialogues (#Dial.) and utterances (#Utt.) of the validation and test set in six languages. Edit distance per dialogue (Edit) and BLEU score are computed to show the difference between the human-annotated dataset and auto-translated dataset. (Training set is reported in Appendix A)"
      },
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: (a) Multilingual Encoder-Decoder model. (b) Multilingual Causal Decoder model. (Detailed illustration is reported in Appendix B)"
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Results of automatic evaluation score on test set in seven languages. We compute the BLEU score and perplexity (ppl.) for monolingual, multilingual, and cross-lingual models."
      },
      {
        "file": "7-Table4-1.png",
        "caption": "Table 4: Results of ACUTE-EVAL human evaluation. Tests are conducted pairwise between M-CausalBert (Multi.) and other models (Human, Poly-encoder (Poly), Monolingual CausalBert (Mono)). Numbers indicate the winning rate of Multi. Numbers in bold are statistically significant (p < 0.05)."
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5: Many-to-one: understand mixed-language dialogue context in multiple languages and generate response in one language"
      },
      {
        "file": "9-Table6-1.png",
        "caption": "Table 6: One-to-many: response one dialogue context with 7 different languages"
      },
      {
        "file": "14-Figure2-1.png",
        "caption": "Figure 2: Human evaluation interface modified from ACUTE-EVAL(Li et al., 2019)"
      },
      {
        "file": "14-Table7-1.png",
        "caption": "Table 7: The number of dialogues (#Dial.) and utterances (#Utt.) of the training set in six languages. Edit distance per dialogue and BLEU score are computed to show the difference between the iterative revised dataset and auto-translated dataset."
      },
      {
        "file": "15-Figure4-1.png",
        "caption": "Figure 4: Multilingual Encoder-Decoder model."
      },
      {
        "file": "16-Table8-1.png",
        "caption": "Table 8: One-to-many by M-CausalBert"
      },
      {
        "file": "16-Table9-1.png",
        "caption": "Table 9: Many-to-one by M-CausalBert"
      },
      {
        "file": "17-Figure5-1.png",
        "caption": "Figure 5: English CausalBert"
      },
      {
        "file": "18-Figure12-1.png",
        "caption": "Figure 12: Chinese M-Bert2Bert"
      },
      {
        "file": "19-Figure13-1.png",
        "caption": "Figure 13: Chinese CrossLingual"
      },
      {
        "file": "20-Figure19-1.png",
        "caption": "Figure 19: France CausalBert"
      },
      {
        "file": "21-Figure23-1.png",
        "caption": "Figure 23: France CrossLingual"
      },
      {
        "file": "22-Figure27-1.png",
        "caption": "Figure 27: Japanese M-Bert2Bert"
      },
      {
        "file": "23-Figure31-1.png",
        "caption": "Figure 31: Korean PolyEncoder"
      },
      {
        "file": "23-Figure29-1.png",
        "caption": "Figure 29: Korean CausalBert"
      },
      {
        "file": "24-Figure35-1.png",
        "caption": "Figure 35: Indonesian PolyEncoder"
      },
      {
        "file": "25-Figure37-1.png",
        "caption": "Figure 37: Indonesian CrossLingual"
      }
    ]
  },
  "1810.02268": {
    "title": "A Large-Scale Test Set for the Evaluation of Context-Aware Pronoun Translation in Neural Machine Translation",
    "abstract": "The translation of pronouns presents a special challenge to machine translation to this day, since it often requires context outside the current sentence. Recent work on models that have access to information across sentence boundaries has seen only moderate improvements in terms of automatic evaluation metrics such as BLEU. However, metrics that quantify the overall translation quality are ill-equipped to measure gains from additional context. We argue that a different kind of evaluation is needed to assess how well models translate inter-sentential phenomena such as pronouns. This paper therefore presents a test suite of contrastive translations focused specifically on the translation of pronouns. Furthermore, we perform experiments with several context-aware models. We show that, while gains in BLEU are moderate for those systems, they outperform baselines by a large margin in terms of accuracy on our contrastive test set. Our experiments also show the effectiveness of parameter tying for multi-encoder architectures.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Even though machine translation has improved considerably with the advent of neural machine translation (NMT) BIBREF0 , BIBREF1 , the translation of pronouns remains a major issue. They are notoriously hard to translate since they often require context outside the current sentence.",
          "As an example, consider the sentences in Figure FIGREF1 . In both languages, there is a pronoun in the second sentence that refers to the European Central Bank. When the second sentence is translated from English to German, the translation of the pronoun it is ambiguous. This ambiguity can only be resolved with context awareness: if a translation system has access to the previous English sentence, the previous German translation, or both, it can determine the antecedent the pronoun refers to. In this German sentence, the antecedent Europ\u00e4ische Zentralbank dictates the feminine gender of the pronoun sie.",
          "It is unfortunate, then, that current NMT systems generally operate on the sentence level BIBREF2 , BIBREF3 , BIBREF4 . Documents are translated sentence-by-sentence for practical reasons, such as line-based processing in a pipeline and reduced computational complexity. Furthermore, improvements of larger-context models over baselines in terms of document-level metrics such as BLEU or RIBES have been moderate, so that their computational overhead does not seem justified, and so that it is hard to develop more effective context-aware architectures and empirically validate them.",
          "To address this issue, we present an alternative way of evaluating larger-context models on a test set that allows to specifically measure a model's capability to correctly translate pronouns. The test suite consists of pairs of source and target sentences, in combination with contrastive translation variants (for evaluation by model scoring) and additional linguistic and contextual information (for further analysis). The resource is freely available. Additionally, we evaluate several context-aware models that have recently been proposed in the literature on this test set, and extend existing models with parameter tying.",
          "The main contributions of our paper are:",
          "Section SECREF2 explains how our paper relates to existing work on context-aware models and the evaluation of pronoun translation. Section SECREF3 describes our test suite. The context-aware models we use in our experiments are detailed in Section SECREF4 . We discuss our experiments in Section SECREF5 and the results in Section SECREF6 ."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Two lines of work are related to our paper: research on context-aware translation (described in Section SECREF8 ) and research on focused evaluation of pronoun translation (described in Section SECREF11 )."
        ]
      },
      {
        "section_name": "Context-Aware NMT Models",
        "paragraphs": [
          "If the translation of a pronoun requires context beyond the current sentence (see the example in Figure FIGREF1 ), a natural extension of sentence-level NMT models is to condition the model prediction on this necessary context. In the following, we describe a number of existing approaches to making models \u201caware\u201d of additional context.",
          "The simplest possible extension is to translate units larger than sentences. BIBREF5 concatenate each sentence with the sentence that precedes it, for the source side of the corpus or both sides. All of their models are standard sequence-to-sequence models built with recurrent neural networks (RNNs), since the method does not require any architectural change. BIBREF11 use the same concatenation technique with a Transformer architecture BIBREF2 , and experiment with wider context.",
          "A number of works do propose changes to the NMT architecture. A common technique is to extend a standard encoder-decoder model by additional encoders for the context sentence(s), with a modified attention mechanism BIBREF6 , BIBREF9 , BIBREF8 . One aspect that differs between these works is the architecture of the encoder and attention. While BIBREF6 , BIBREF9 extend an RNN encoder-decoder with a second encoder that the decoder attends to, BIBREF8 extend the Transformer architecture with an encoder that is attended to by the main encoder. BIBREF8 also introduce parameter sharing between the main encoder and the context encoder, but do not empirically demonstrate its importance.",
          "While the number of encoded sentences in the previous work is fixed, BIBREF7 , BIBREF10 explore the integration of variable-size context through a hierarchical architecture, where a first-level RNN reads in words to produce sentence vectors, which are then fed into a second-level RNN to produce a document summary.",
          "Apart from differences in the architectures, related work varies in whether it considers source context, target context, or both (see Table TABREF9 for an overview of language arcs and context types). Some work considers only source context, but for pronoun translation, target-side context is intuitively important for disambiguation, especially if the antecedent itself is ambiguous. In our evaluation, we therefore emphasize models that take into account both source and target context.",
          "Our experiments are based on models from BIBREF9 , who have released their source code. We extend their models with parameter sharing, which was shown to be beneficial by BIBREF8 . Additionally, we consider a concatenative baseline, similar to BIBREF5 , and Transformer-based models BIBREF8 .",
          "This section describes several context-aware NMT models that we use in our experiments. They fall into two major categories: models based on RNNs and models based on the Transformer architecture BIBREF2 . We experiment with additional context on the source side and target side."
        ]
      },
      {
        "section_name": "Evaluation of Pronoun Translation",
        "paragraphs": [
          "Pronouns can serve a variety of functions with complex cross-lingual variation BIBREF12 , and hand-picked, manually annotated test suites have been presented for the evaluation of pronoun translation BIBREF13 , BIBREF14 , BIBREF9 . While suitable for analysis, the small size of the test suites makes it hard to make statistically confident comparisons between systems, and the hand-picked nature of the test suites introduces biases. To overcome these problems, we opted for a fully automatic approach to constructing a large-scale test suite.",
          "Conceptually, our test set is most similar to the \u201ccross-lingual pronoun prediction\u201d task held at DiscoMT and WMT in recent years BIBREF15 , BIBREF16 , BIBREF17 : participants are asked to fill a gap in a target sentence, where gaps correspond to pronouns.",
          "The first edition of the task focused on English INLINEFORM0 French, and it was found that local context (such as the verb group) was a strong signal for pronoun prediction. Hence, future editions only provided target-side lemmas instead of fully inflected forms, which makes the task less suitable to evaluate end-to-end neural machine translation systems, although such systems have been trained on the task BIBREF18 .",
          " BIBREF17 do not report on the proportion of intra-sentential and inter-sentential anaphora in their test set, but the two top-performing systems only made use of intra-sentential information. Our test suite focuses on allowing the comparison of end-to-end context-aware NMT systems, and we thus extract a large number of inter-sentential anaphora, with meta-data allowing for a focus on inter-sentential anaphora with a long distance between the pronoun and its antecedent. Our focus on evaluating end-to-end NMT systems also relieves us from having to provide annotated training sets, and reduces pressure to achieve balance and full coverage of phenomena.",
          "An alternative approach to automatically evaluate pronoun translation are reference-based methods that produce a score based on word alignment between source, translation output, and reference translation, and identification of pronouns in them, such as AutoPRF BIBREF19 and APT BIBREF20 . BIBREF21 perform a human meta-evaluation and show substantial disagreement between reference-based metrics and human judges, especially because there often exist valid alternative translations that use different pronouns than the reference. Our test set, and our protocol of generating contrastive examples, is focused on selected pronouns to minimize the risk of producing contrastive examples that are actually valid translations."
        ]
      },
      {
        "section_name": "Test set with contrastive examples",
        "paragraphs": [
          "Contrastive evaluation requires a large set of suitable examples that involve the translation of pronouns. As additional goals, our test set is designed to 1) focus on hard cases, so that it can be used as a benchmark to track progress in context-aware translation and 2) allow for fine-grained analysis.",
          "Section SECREF14 describes how we extract our data set. Section SECREF26 explains how, given a set of contrastive examples, contrastive evaluation works."
        ]
      },
      {
        "section_name": "Automatic extraction of contrastive examples from corpora",
        "paragraphs": [
          "We automatically create a test set from the OpenSubtitles corpus BIBREF22 . The goal is to provide a large number of difficult test cases where an English pronoun has to be translated to a German pronoun.",
          "The most challenging cases are translating it to either er, sie or es, depending on the grammatical gender of the antecedent. Not only is the translation of it ambiguous, there is also class imbalance in the training data (see Table TABREF18 ). There is roughly a 30% probability that it is aligned to es, which makes it difficult to learn to translate er and sie. We use parsing and automatic co-reference resolution to find translation pairs that satisfy our constraints.",
          "To provide a basis for filtering with constraints, we tokenize the whole data set with the Moses tokenizer, generate symmetric word alignments with fast_align BIBREF23 , parse the English text with CoreNLP BIBREF24 , parse the German text with ParZu BIBREF25 and perform coreference resolution on both sides. The coreference chains are obtained with the neural model of CoreNLP for English, and with CorZu for German BIBREF26 , respectively.",
          "Then we opt for high-precision, aggressive filtering, according to the following protocol: for each pair of sentences INLINEFORM0 in English and German, extract iff",
          " INLINEFORM0 contains the English pronoun it, and INLINEFORM1 contains a German pronoun that is third person singular (er, sie or es), as indicated by their part-of-speech tags;",
          "those pronouns are aligned to each other;",
          "both pronouns are in a coreference chain;",
          "their nominal antecedents in the coreference chain are aligned on word level.",
          "This removes most candidate pairs, but is necessary to overcome the noise introduced by our preprocessing pipeline, most notably coreference resolution. From the filtered set, we create a balanced test set by randomly sampling 4000 instances of each of the three translations of it under consideration (er, sie, es). We do not balance antecedent distance. See Table TABREF25 for the distribution of pronoun pairs and antecedent distance in the test set.",
          "For each sentence pair in the resulting test set, we introduce contrastive translations. A contrastive translation is a translation variant where the correct pronoun is swapped with an incorrect one. For an example, see Table TABREF19 , where the pronoun it in the original translation corresponds to sie because the antecedent bat is a feminine noun in German (Fledermaus). We produce wrong translations by replacing sie with one of the other pronouns (er, es).",
          "Note that, by themselves, these contrastive translations are grammatically correct if the antecedent is outside the current sentence. The test set also contains pronouns with an antecedent in the same sentence (antecedent distance 0). Those examples do not require any additional context for disambiguation and we therefore expect the sentence-level baseline to perform well on them.",
          "We take extra care to ensure that the resulting contrastive translations are grammatically correct, because ungrammatical sentences are easily dismissed by an NMT system. For instance, if there are any possessive pronouns (such as seine) in the sentence, we also change their gender to match the personal pronoun replacement.",
          "The German coreference resolution system does not resolve es because most instances of es in German are either non-referential forms, or they refer to a clause instead of a nominal antecedent. We limit the test set to nominal antecedents, as these are the only ambiguous cases with respect to translation. For this reason, we have to rely entirely on the English coreference links for the extraction of sentence pairs with it INLINEFORM0 es, as opposed to pairs with it INLINEFORM1 er and it INLINEFORM2 sie where we have coreference chains in both languages.",
          "Our extraction process respects document boundaries, to ensure we always search for the right context. We extract additional information from the annotated documents, such as the distance (in sentences) between pronouns and their antecedents, the document of origin, lemma, morphology and dependency information if available."
        ]
      },
      {
        "section_name": "Evaluation by scoring",
        "paragraphs": [
          "Contrastive evaluation is different from conventional evaluation of machine translation in that it does not require any translation. Rather than testing a model's ability to translate, it is a method to test a model's ability to discriminate between given good and bad translations.",
          "We exploit the fact that NMT systems are in fact language models of the target language, conditioned on source text. Like language models, NMT systems can be used to compute a model score (the negative log probability) for an existing translation. Contrastive evaluation, then, means to compare the model score of two pairs of inputs: INLINEFORM0 and INLINEFORM1 . If the model score of the actual reference translation is higher, we assume that this model can detect wrong pronoun translations.",
          "However, this does not mean that systems actually produce the reference translation when given the source sentence for translation. An entirely different target sequence might rank higher in the system's beam during decoding. The only conclusion permitted by contrastive evaluation is whether or not the reference translation is more probable than a contrastive variant.",
          "If the model score of the reference is indeed higher, we refer to this outcome as a \u201ccorrect decision\u201d by the model. The model's decision is only correct if the reference translation has a higher score than any contrastive translation. In our evaluation, we aggregate model decisions on the whole test set and report the overall percentage of correct decisions as accuracy.",
          "During scoring, the model is provided with reference translations as target context, while during translation, the model needs to predict the full sequence. It is an open question to what extent performance deteriorates when context is itself predicted, and thus noisy. We highlight that the same problem arises for sentence-level NMT, and has been addressed with alternative training strategies BIBREF27 ."
        ]
      },
      {
        "section_name": "Recurrent Models",
        "paragraphs": [
          "We consider the following recurrent baselines:",
          "baseline Our baseline model is a standard bidirectional RNN model with attention, trained with Nematus. It operates on the sentence level and does not see any additional context. The input and output embeddings of the decoder are tied, encoder embeddings are not.",
          "concat22 We concatenate each sentence with one preceding sentence, for both the source and target side of the corpus. Then we train on this new data set without any changes to the model architecture. This very simple method is inspired by BIBREF5 .",
          "The following models are taken, or slightly adapted, from BIBREF9 . For this reason, we give only a very short description of them here and the reader is referred to their work for details.",
          "s-hier A multi-encoder architecture with hierarchical attention. This model has access to one additional context: the previous source sentence. It is read by a separate encoder, and attended to by an additional attention network. The output of the resulting two attention vectors is combined with yet another attention network.",
          "s-t-hier Identical to s-hier, except that it considers two additional contexts: the previous source sentence and previous target sentence. Both are read by separate encoders, and sequences from all encoders are combined with hierarchical attention.",
          "s-hier-to-2 The model has an additional encoder for source context, whereas the target side of the corpus is concatenated, in the same way as for concat22. This model achieved the best results in BIBREF9 .",
          "For each variant, we also introduce and test weight tying: we share the parameters of embedding matrices between encoders that read the same kind of text (source or target side)."
        ]
      },
      {
        "section_name": "Transformer Models",
        "paragraphs": [
          "All remaining models are based on the Transformer architecture BIBREF2 . A Transformer avoids recurrence completely: it follows an encoder-decoder architecture using stacked self-attention and fully connected layers for both the encoder and decoder.",
          "baseline A standard context-agnostic Transformer. All model parameters are identical to a Transformer-base in BIBREF2 .",
          "concat22 A simple concatentation model where only the training data is modified, in the same way as for the recurrent concat22 model.",
          "concat21 Trained on data where the preceding sentence is concatenated to the current one only on the source side. This model is also taken from BIBREF5 .",
          " BIBREF8 A more sophisticated context-aware Transformer that uses source context only. It has a separate encoder for source context, but all layers except the last one are shared between encoders. A source and context sentence are first encoded independently, and then a single attention layer and a gating function are used to produce a context-aware representation of the source sentence. Such restricted interaction with context is shown to be beneficial for analysis of contextual phenomena captured by the model. For details the reader is referred to their work."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We train all models on the data from the WMT 2017 English INLINEFORM0 German news translation shared task ( INLINEFORM1 5.8 million sentence pairs). These corpora do not have document boundaries, therefore a small fraction of sentences will be paired with wrong context, but we expect the model to be robust against occasional random context (see also BIBREF8 ). Experimental setups for the RNN and Transformer models are different, and we describe them separately.",
          "All RNN-based models are trained with Nematus BIBREF28 . We learn a joint BPE model with 89.5k merge operations BIBREF29 . We train shallow models with an embedding size of 512, a hidden layer size of 1024 and layer normalization. Models are trained with Adam BIBREF30 , with an initial learning rate of 0.0001. We apply early stopping based on validation perplexity. The batch size for training is 80, and the maximum length of training sequences is 100 (if input sentences are concatenated) or 50 (if input lines are single sentences).",
          "For our Transformer-based experiments, we use a custom implementation and follow the hyperparameters from BIBREF2 , BIBREF8 . Systems are trained on lowercased text that was encoded using BPE (32k merge operations). Models consist of 6 encoder and decoder layers with 8 attention heads. The hidden state size is 512, the size of feedforward layers is 2048.",
          "Model performance is evaluated in terms of BLEU, on newstest2017, newstest2018 and all sentence pairs from our pronoun test set. We compute scores with SacreBLEU BIBREF31 . Evaluation with BLEU is done mainly to control for overall translation quality.",
          "To evaluate pronoun translation, we perform contrastive evaluation and report the accuracy of models on our contrastive test set."
        ]
      },
      {
        "section_name": "Evaluation",
        "paragraphs": [
          "The BLEU scores in Table TABREF30 show a moderate improvement for most context-aware systems. This suggests that the architectural changes for the context-aware models do not degrade overall translation quality. The contrastive evaluation on our test set on the other hand shows a clear increase in the accuracy of pronoun translation: The best model s-hier-to-2.tied achieves a total of +16 percentage points accuracy on the test set over the baseline, see Table TABREF31 .",
          "Table TABREF32 shows that context-aware models perform better than the baseline when the antecedent is outside the current sentence. In our experiments, all context-aware models consider one preceding sentence as context. The evaluation according to the distance of the antecedent in Table TABREF35 confirms that the subset of sentences with antecedent distance 1 benefits most from the tested context-aware models (up to +20 percentage points accuracy). However, we note two surprising patterns:",
          "The first observation can be explained by the distribution of German pronouns in the test set. The further away the antecedent, the higher the percentage of it INLINEFORM0 es cases, which are the majority class, and thus the class that will be predicted most often if evidence for other classes is lacking. We speculate that this is due to our more permissive extraction heuristics for it INLINEFORM1 es.",
          "We attribute the second observation to the existence of coreference chains where the preceding sentence contains a pronoun that refers to the same nominal antecedent as the pronoun in the current sentence. Consider the example in Table TABREF36 : The nominal antecedent of it in the current sentence is door, T\u00fcr in German with feminine gender. The nominal antecedent occurs two sentences before the current sentence, but the German sentence in between contains the pronoun sie, which is a useful signal for the context-aware models, even though they cannot know the nominal antecedent.",
          "Note that only models aware of target-side context can benefit from such circumstances: The s-hier models as well as the Transformer model by BIBREF8 only see source side context, which results in lower accuracy if the distance to the antecedent is INLINEFORM0 1, see Table TABREF35 .",
          "While such coreference chains complicate the interpretation of the results, we note that improvements on inter-sentential anaphora with antecedent distance INLINEFORM0 are relatively small (compared to distance 1), and that performance is still relatively poor (especially for the minority classes er and sie). We encourage evaluation of wider-context models on this subset, which is still large thanks to the size of the full test set.",
          "Regarding the comparison of different context-aware architectures, our results demonstrate the effectiveness of parameter sharing between the main encoder (or decoder) and the contextual encoder. We observe an improvement of 5 percentage points from s-hier-to-2 to s-hier-to-2.tied, and 4 percentage points from s-t-hier to s-t-hier.tied. Context encoders introduce a large number of extra parameters, while inter-sentential context is only relevant for a relatively small number of predictions. We hypothesize that the training signal is thus too weak to train a strong contextual encoder in an end-to-end fashion without parameter sharing. Our results also confirm the finding by BIBREF9 that multi-encoder architectures, specifically s-hier-to-2(.tied), can outperform a simple concatenation system in the translation of coreferential pronouns.",
          "The Transformer-based models perform strongest on pronouns with intra-segmental antecedent, outperforming the recurrent baseline by 9\u201318 percentage points. This is likely an effect of increased model depth and the self-attentional architecture in this set of experiments. The model by BIBREF8 only uses source context, and outperforms the most comparable RNN system, s-hier.tied. However, the Transformer-based concat22 slightly underperforms the RNN-based concat22, and we consider it future research how to better exploit target context with Transformer-based models."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "We present a large-scale test suite to specifically test the capacity of NMT models to translate pronouns correctly. The test set contains 12,000 difficult cases of pronoun translations from English it to its German counterparts er, sie and es, extracted automatically from OpenSubtitles BIBREF22 .",
          "We evaluate recently proposed context-aware models on our test set. Even though the increase in BLEU score is moderate for all context-aware models, the improvement in the translation of pronouns is considerable: The best model (s-hier-to-2.tied) achieves a +16 percentage points gain in accuracy over the baseline.",
          "Our experiments confirm the importance of careful architecture design, with multi-encoder architectures outperforming a model that simply concatenates context sentences. We also demonstrate the effectiveness of parameter sharing between encoders of a context-aware model.",
          "We hope the test set will prove useful for empirically validating novel architectures for context-aware NMT. So far, we have only evaluated models that consider one sentence of context, but the nominal antecedent is more distant for a sizable proportion of the test set, and the evaluation of variable-size context models BIBREF7 , BIBREF10 is interesting future work."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We are grateful to the Swiss National Science Foundation (SNF) for supporting the project CoNTra (grant number 105212_169888)."
        ]
      }
    ],
    "qas": [
      {
        "question": "did they collect their own contrastive test set?",
        "question_id": "ae2142ee9e093ce485025168f4bcb3da4602739d",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Automatic extraction of contrastive examples from corpora",
                "We automatically create a test set from the OpenSubtitles corpus BIBREF22 . The goal is to provide a large number of difficult test cases where an English pronoun has to be translated to a German pronoun."
              ],
              "highlighted_evidence": [
                "Automatic extraction of contrastive examples from corpora\nWe automatically create a test set from the OpenSubtitles corpus BIBREF22 ."
              ]
            },
            "annotation_id": "10afb95ba5499c6dee08f72d91f08a23b877ec5c",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Contrastive evaluation requires a large set of suitable examples that involve the translation of pronouns. As additional goals, our test set is designed to 1) focus on hard cases, so that it can be used as a benchmark to track progress in context-aware translation and 2) allow for fine-grained analysis.",
                "We automatically create a test set from the OpenSubtitles corpus BIBREF22 . The goal is to provide a large number of difficult test cases where an English pronoun has to be translated to a German pronoun."
              ],
              "highlighted_evidence": [
                "Contrastive evaluation requires a large set of suitable examples that involve the translation of pronouns. As additional goals, our test set is designed to 1) focus on hard cases, so that it can be used as a benchmark to track progress in context-aware translation and 2) allow for fine-grained analysis.",
                "We automatically create a test set from the OpenSubtitles corpus BIBREF22 . The goal is to provide a large number of difficult test cases where an English pronoun has to be translated to a German pronoun."
              ]
            },
            "annotation_id": "3c9d47b4a9cb80dfb5c629cfe5698b477f0931f8",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "It is automatically created from the OpenSubtitles corpus.",
              "evidence": [
                "We automatically create a test set from the OpenSubtitles corpus BIBREF22 . The goal is to provide a large number of difficult test cases where an English pronoun has to be translated to a German pronoun."
              ],
              "highlighted_evidence": [
                "We automatically create a test set from the OpenSubtitles corpus BIBREF22 ."
              ]
            },
            "annotation_id": "55912f5118690277f9d138b9dbbf454c3ab3d044",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "To address this issue, we present an alternative way of evaluating larger-context models on a test set that allows to specifically measure a model's capability to correctly translate pronouns. The test suite consists of pairs of source and target sentences, in combination with contrastive translation variants (for evaluation by model scoring) and additional linguistic and contextual information (for further analysis). The resource is freely available. Additionally, we evaluate several context-aware models that have recently been proposed in the literature on this test set, and extend existing models with parameter tying."
              ],
              "highlighted_evidence": [
                "To address this issue, we present an alternative way of evaluating larger-context models on a test set that allows to specifically measure a model's capability to correctly translate pronouns. The test suite consists of pairs of source and target sentences, in combination with contrastive translation variants (for evaluation by model scoring) and additional linguistic and contextual information (for further analysis). The resource is freely available."
              ]
            },
            "annotation_id": "ce4d3688f77e3fb19658291b7c382a04d1f81b72",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Overview of context-aware translation models in related work."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Frequency and probability of alignments of it in the training data of our systems (all data from the WMT 2017 news translation task). Alignments are produced by a fast_align model."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Example sentence pair with contrastive translations. An antecedent distance of 1 means that the antecedent is in the immediately preceding sentence."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Test set frequencies of pronoun pairs and antecedent distance (measured in sentences)."
      },
      {
        "file": "9-Table5-1.png",
        "caption": "Table 5: English\u2192German BLEU scores on newstest2017, newstest2018 and all sentence pairs from our pronoun test set. Case-sensitive and case-insensitive (uncased) scores are reported. Higher is better, and the best scores are marked in bold."
      },
      {
        "file": "9-Table6-1.png",
        "caption": "Table 6: Accuracy on contrastive test set (N=4000 per pronoun) with regard to reference pronoun."
      },
      {
        "file": "9-Table7-1.png",
        "caption": "Table 7: Accuracy on contrastive test set with regard to antecedent location (within segment vs. outside segment)."
      },
      {
        "file": "10-Table8-1.png",
        "caption": "Table 8: Accuracy on contrastive test set with regard to antecedent distance of antecedent (in sentences)."
      },
      {
        "file": "10-Table9-1.png",
        "caption": "Table 9: Example where 1) antecedent distance is >1 and 2) the context given contains another pronoun as an additional hint."
      }
    ]
  },
  "1909.12079": {
    "title": "Improving Fine-grained Entity Typing with Entity Linking",
    "abstract": "Fine-grained entity typing is a challenging problem since it usually involves a relatively large tag set and may require to understand the context of the entity mention. In this paper, we use entity linking to help with the fine-grained entity type classification process. We propose a deep neural model that makes predictions based on both the context and the information obtained from entity linking results. Experimental results on two commonly used datasets demonstrates the effectiveness of our approach. On both datasets, it achieves more than 5\\% absolute strict accuracy improvement over the state of the art.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Given a piece of text and the span of an entity mention in this text, fine-grained entity typing (FET) is the task of assigning fine-grained type labels to the mention BIBREF0. The assigned labels should be context dependent BIBREF1. For example, in the sentence \u201cTrump threatens to pull US out of World Trade Organization,\u201d the mention \u201cTrump\u201d should be labeled as /person and /person/politician, although Donald Trump also had other occupations such as businessman, TV personality, etc.",
          "This task is challenging because it usually uses a relatively large tag set, and some mentions may require the understanding of the context to be correctly labeled. Moreover, since manual annotation is very labor-intensive, existing approaches have to rely on distant supervision to train models BIBREF0, BIBREF2.",
          "Thus, the use of extra information to help with the classification process becomes very important. In this paper, we improve FET with entity linking (EL). EL is helpful for a model to make typing decisions because if a mention is correctly linked to its target entity, we can directly obtain the type information about this entity in the knowledge base (KB). For example, in the sentence \u201cThere were some great discussions on a variety of issues facing Federal Way,\u201d the mention \u201cFederal Way\u201d may be incorrectly labeled as a company by some FET models. Such a mistake can be avoided after linking it to the city Federal Way, Washington. For cases that require the understanding of the context, using entity linking results is also beneficial. In the aforementioned example where \u201cTrump\u201d is the mention, obtaining all the types of Donald Trump in the knowledge base (e.g., politician, businessman, TV personality, etc.) is still informative for inferring the correct type (i.e., politician) that fits the context, since they narrows the possible labels down.",
          "However, the information obtained through EL should not be fully trusted since it is not always accurate. Even when a mention is correctly linked to an entity, the type information of this entity in the KB may be incomplete or outdated. Thus, in this paper, we propose a deep neural fine-grained entity typing model that flexibly predicts labels based on the context, the mention string, and the type information from KB obtained with EL.",
          "Using EL also introduces a new problem for the training process. Currently, a widely used approach to create FET training samples is to use the anchor links in Wikipedia BIBREF0, BIBREF3. Each anchor link is regarded as a mention, and is weakly labeled with all the types of its referred entity (the Wikipedia page the anchor link points to) in KB. Our approach, when links the mention correctly, also uses all the types of the referred entity in KB as extra information. This may cause the trained model to overfit the weakly labeled data. We design a variant of the hinge loss and introduce noise during training to address this problem.",
          "We conduct experiments on two commonly used FET datasets. Experimental results show that introducing information obtained through entity linking and having a deep neural model both helps to improve FET performance. Our model achieves more than 5% absolute strict accuracy improvement over the state of the art on both datasets.",
          "Our contributions are summarized as follows:",
          "We propose a deep neural fine-grained entity typing model that utilizes type information from KB obtained through entity linking.",
          "We address the problem that our model may overfit the weakly labeled data by using a variant of the hinge-loss and introducing noise during training.",
          "We demonstrate the effectiveness of our approach with experimental results on commonly used FET datasets.",
          "Our code is available at https://github.com/HKUST-KnowComp/IFETEL."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "An early effort of classifying named entities into fine-grained types can be found in BIBREF4, which only focuses on person names. Latter, datasets with larger type sets are constructed BIBREF5, BIBREF0, BIBREF6. These datasets are more preferred by recent studies BIBREF3, BIBREF7.",
          "Most of the existing approaches proposed for FET are learning based. The features used by these approaches can either be hand-crafted BIBREF0, BIBREF1 or learned from neural network models BIBREF8, BIBREF9, BIBREF10. Since FET systems usually use distant supervision for training, the labels of the training samples can be noisy, erroneous or overly specific. Several studies BIBREF11, BIBREF12, BIBREF9 address these problems by separating clean mentions and noisy mentions, modeling type correction BIBREF3, using a hierarchy-aware loss BIBREF9, etc.",
          "BIBREF13 and BIBREF14 are two studies that are most related to this paper. BIBREF13 propose an unsupervised FET system where EL is an importat component. But they use EL to help with clustering and type name selection, which is very different from how we use it to improve the performance of a supervised FET model. BIBREF14 finds related entities based on the context instead of directly applying EL. The types of these entities are then used for inferring the type of the mention."
        ]
      },
      {
        "section_name": "Method",
        "paragraphs": [
          "Let $T$ be a predefined tag set, which includes all the types we want to assign to mentions. Given a mention $m$ and its context, the task is to predict a set of types $\\mathbf {\\tau }\\subset T$ suitable for this mention. Thus, this is a multi-class, multi-label classification problem BIBREF0. Next, we will introduce our approach for this problem in detail, including the neural model, the training of the model, and the entity linking algorithm we use."
        ]
      },
      {
        "section_name": "Method ::: Fine-grained Entity Typing Model ::: Input",
        "paragraphs": [
          "Each input sample to our FET system contains one mention and the sentence it belongs to. We denote $w_1,w_2,...,w_n$ as the words in the current sentence, $w_{p_1},w_{p_2},...,w_{p_l}$ as the words in the mention string, where $n$ is the number of words in the sentence, $p_1,...,p_l$ are the indices of the words in the mention string, $l$ is the number of words in the mention string. We also use a set of pretrained word embeddings.",
          "Our FET approach is illustrated in Figure FIGREF4. It first constructs three representations: context representation, mention string representation, and KB type representation. Note that the KB type representation is obtained from a knowledge base through entity linking and is independent of the context of the mention."
        ]
      },
      {
        "section_name": "Method ::: Fine-grained Entity Typing Model ::: Context Representation",
        "paragraphs": [
          "To obtain the context representation, we first use a special token $w_m$ to represent the mention (the token \u201c[Mention]\u201d in Figure FIGREF4). Then, the word sequence of the sentence becomes $w_1,...,w_{p_l-1},w_m,w_{p_l+1},...,w_n$. Their corresponding word embeddings are fed into two layers of BiLSTMs. Let $\\mathbf {h}_m^1$ and $\\mathbf {h}_m^2$ be the output of the first and the second layer of BiLSTMs for $w_m$, respectively. We use $\\mathbf {f}_c=\\mathbf {h}_m^1+\\mathbf {h}_m^2$ as the context representation vector."
        ]
      },
      {
        "section_name": "Method ::: Fine-grained Entity Typing Model ::: Mention String Representation",
        "paragraphs": [
          "Let $\\mathbf {x}_1,...,\\mathbf {x}_l$ be the word embeddings of the mention string words $w_{p_1},...,w_{p_l}$. Then the mention string representation $\\mathbf {f}_s=(\\sum _{i=1}^l \\mathbf {x}_i)/l$."
        ]
      },
      {
        "section_name": "Method ::: Fine-grained Entity Typing Model ::: KB Type Representation",
        "paragraphs": [
          "To obtain the KB type representation, we run an EL algorithm for the current mention. If the EL algorithm returns an entity, we retrieve the types of of this entity from the KB. We use Freebase as our KB. Since the types in Freebase is different from $T$, the target type set, they are mapped to the types in $T$ with rules similar to those used in BIBREF14. Afterwards, we perform one hot encoding on these types to get the KB Type Representation $\\mathbf {f}_e$. If the EL algorithm returns NIL (i.e., the mention cannot be linked to an entity), we simply one hot encode the empty type set."
        ]
      },
      {
        "section_name": "Method ::: Fine-grained Entity Typing Model ::: Prediction",
        "paragraphs": [
          "Apart from the three representations, we also obtain the score returned by our entity linking algorithm, which indicates its confidence on the linking result. We denote it as a one dimensional vector $\\mathbf {g}$. Then, we get $\\mathbf {f}=\\mathbf {f}_c\\oplus \\mathbf {f}_s\\oplus \\mathbf {f}_e\\oplus \\mathbf {g}$, where $\\oplus $ means concatenation. $\\mathbf {f}$ is then fed into an MLP that contains three dense layers to obtain $\\mathbf {u}_m$, out final representation for the current mention sample $m$. Let $t_1,t_2,...,t_k$ be all the types in $T$, where $k=|T|$. We embed them into the same space as $\\mathbf {u}_m$ by assigning each of them a dense vector BIBREF15. These vectors are denoted as $\\mathbf {t}_1,...,\\mathbf {t}_k$. Then the score of the mention $m$ having the type $t_i\\in T$ is calculated as the dot product of $\\mathbf {u}_m$ and $\\mathbf {t}_i$:",
          "We predict $t_i$ as a type of $m$ if $s(m,t_i)>0$."
        ]
      },
      {
        "section_name": "Method ::: Model Training",
        "paragraphs": [
          "Following existing studies, we also generate training data by using the anchor links in Wikipedia. Each anchor link can be used as a mention. These mentions are labeled by mapping the Freebase types of the target entries to the tag set $T$ BIBREF0.",
          "Since the KB type representations we use in our FET model are also obtained through mapping Freebase types, they will perfectly match the automatically generated labels for the mentions that are correctly linked (i.e., when the entity returned by the EL algorithm and the target entry of the anchor link are the same). For example, in Figure FIGREF4, suppose the example sentence is a training sample obtained from Wikipedia, where \u201cDonald Trump\u201d is an anchor link points to the Wikipedia page of Donald Trump. After mapping the Freebase types of Donald Trump to the target tag set, this sample will be weakly annotated as /person/politician, /person/tv_personality, and /person/business, which is exactly the same as the type information (the \u201cTypes From KB\u201d in Figure FIGREF4) obtained through EL. Thus, during training, when the EL system links the mention to the correct entity, the model only needs to output the types in the KB type representation. This may cause the trained model to overfit the weakly labeled training data. For most types of entities such as locations and organizations, it is fine since they usually have the same types in different contexts. But it is problematic for person mentions, as their types can be context dependent.",
          "To address this problem, during training, if a mention is linked to a person entity by our entity linking algorithm, we add a random fine-grained person type label that does not belong to this entity while generating the KB type representation. For example, if the mention is linked to a person with types /person/actor and /person/author, a random label /person/politician may be added. This will force the model to still infer the type labels from the context even when the mention is correctly linked, since the KB type representation no longer perfectly match the weak labels.",
          "To make it more flexible, we also propose to use a variant of the hinge loss used by BIBREF16 to train our model:",
          "where $\\tau _m$ is the correct type set for mention $m$, $\\bar{\\tau }_m$ is the incorrect type set. $\\lambda (t)\\in [1,+\\infty )$ is a predefined parameter to impose a larger penalty if the type $t$ is incorrectly predicted as positive. Since the problem of overfitting the weakly annotated labels is more severe for person mentions, we set $\\lambda (t)=\\lambda _P$ if $t$ is a fine-grained person type, and $\\lambda (t)=1$ for all other types.",
          "During training, we also randomly set the EL results of half of the training samples to be NIL. So that the model can perform well for mentions that cannot be linked to the KB at test time."
        ]
      },
      {
        "section_name": "Method ::: Entity Linking Algorithm",
        "paragraphs": [
          "In this paper, we use a simple EL algorithm that directly links the mention to the entity with the greatest commonness score. Commonness BIBREF17, BIBREF18 is calculated base on the anchor links in Wikipedia. It estimates the probability of an entity given only the mention string. In our FET approach, the commonness score is also used as the confidence on the linking result (i.e., the $\\mathbf {g}$ used in the prediction part of Subsection SECREF5). Within a same document, we also use the same heuristic used in BIBREF19 to find coreferences of generic mentions of persons (e.g., \u201cMatt\u201d) to more specific mentions (e.g., \u201cMatt Damon\u201d).",
          "We also tried other more advanced EL methods in our experiments. However, they do not improve the final performance of our model. Experimental results of using the EL system proposed in BIBREF19 is provided in Section SECREF4."
        ]
      },
      {
        "section_name": "Experiments ::: Setup",
        "paragraphs": [
          "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. The sizes of their tag sets are 113 and 47, respectively. FIGER (GOLD) allows mentions to have multiple type paths, but BBN does not. Another commonly used dataset, OntoNotes BIBREF1, is not used since it contains many pronoun and common noun phrase mentions such as \u201cit,\u201d \u201che,\u201d \u201ca thrift institution,\u201d which are not suitable to directly apply entity linking on.",
          "Following BIBREF0, we generate weakly labeled datasets for training with Wikipedia anchor links. Since the tag sets used by FIGER (GOLD) and BBN are different, we create a training set for each of them. For each dataset, $2,000$ weakly labeled samples are randomly picked to form a development set. We also manually annotated 50 person mentions collected from news articles for tuning the parameter $\\lambda _P$.",
          "We use the 300 dimensional pretrained GloVe word vectors provided by BIBREF20. The hidden layer sizes of the two layers of BiLSTMs are both set to 250. For the three-layer MLP, the size of the two hidden layers are both set to 500. The size of the type embeddings is 500. $\\lambda _P$ is set to 2.0. We also apply batch normalization and dropout to the input of each dense layer in our three-layer MLP during training.",
          "We use strict accuracy, Macro F1, and Micro F1 to evaluate fine-grained typing performance BIBREF0."
        ]
      },
      {
        "section_name": "Experiments ::: Compared Methods",
        "paragraphs": [
          "We compare with the following existing approaches: AFET BIBREF3, AAA BIBREF16, NFETC BIBREF9, and CLSC BIBREF21.",
          "We use Ours (Full) to represent our full model, and also compare with five variants of our own approach: Ours (DirectTrain) is trained without adding random person types while obtaining the KB type representation, and $\\lambda _P$ is set to 1; Ours (NoEL) does not use entity linking, i.e., the KB type representation and the entity linking confidence score are removed, and the model is trained in DirectTrain style; Ours (NonDeep) uses one BiLSTM layer and replaces the MLP with a dense layer; Ours (NonDeep NoEL) is the NoEL version of Ours (NonDeep); Ours (LocAttEL) uses the entity linking approach proposed in BIBREF19 instead of our own commonness based approach. Ours (Full), Ours (DirectTrain), and Ours (NonDeep) all use our own commonness based entity linking approach."
        ]
      },
      {
        "section_name": "Experiments ::: Results",
        "paragraphs": [
          "The experimental results are listed in Table TABREF16. As we can see, our approach performs much better than existing approaches on both datasets.",
          "The benefit of using entity linking in our approach can be verified by comparing Ours (Full) and Ours (NoEL). The performance on both datasets decreases if the entity linking part is removed. Especially on FIGER (GOLD), the strict accuracy drops from 75.5 to 69.8. Using entity linking improves less on BBN. We think this is because of three reasons: 1) BBN has a much smaller tag set than FIGER (GOLD); 2) BBN does not allow a mention to be annotated with multiple type paths (e.g., labeling a mention with both /building and /location is not allowed), thus the task is easier; 3) By making the model deep, the performance on BBN is already improved a lot, which makes further improvement harder.",
          "The improvement of our full approach over Ours (DirectTrain) on FIGER (GOLD) indicates that the techniques we use to avoid overfitting the weakly labeled data are also effective.",
          "Ours (LocAttEL), which uses a more advanced EL system, does not achieve better performance than Ours (Full), which uses our own EL approach. After manually checking the results of the two EL approaches and the predictions of our model on FIGER (GOLD), we think this is mainly because: 1) Our model also uses the context while making predictions. Sometimes, if it \u201cthinks\u201d that the type information provided by EL is incorrect, it may not use it. 2) The performances of different EL approaches also depends on the dataset and the types of entities used for evaluation. We find that on FIGER (GOLD), the approach in BIBREF19 is better at distinguishing locations and sports teams, but it may also make some mistakes that our simple EL method does not. For example, it may incorrectly link \u201cMarch,\u201d the month, to an entity whose Wikipedia description fits the context better. 3) For some mentions, although the EL system links it to an incorrect entity, the type of this entity is the same with the correct entity."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "We propose a deep neural model to improve fine-grained entity typing with entity linking. The problem of overfitting the weakly labeled training data is addressed by using a variant of the hinge loss and introducing noise during training. We conduct experiments on two commonly used dataset. The experimental results demonstrates the effectiveness of our approach."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This paper was supported by the Early Career Scheme (ECS, No. 26206717) from Research Grants Council in Hong Kong and WeChat-HKUST WHAT Lab on Artificial Intelligence Technology."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which datasets do they evaluate on?",
        "question_id": "3f717e6eceab0a066af65ddf782c1ebc502c28c0",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "FIGER (GOLD) BIBREF0",
                "BBN BIBREF5"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. The sizes of their tag sets are 113 and 47, respectively. FIGER (GOLD) allows mentions to have multiple type paths, but BBN does not. Another commonly used dataset, OntoNotes BIBREF1, is not used since it contains many pronoun and common noun phrase mentions such as \u201cit,\u201d \u201che,\u201d \u201ca thrift institution,\u201d which are not suitable to directly apply entity linking on."
              ],
              "highlighted_evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. The sizes of their tag sets are 113 and 47, respectively. FIGER (GOLD) allows mentions to have multiple type paths, but BBN does not. Another commonly used dataset, OntoNotes BIBREF1, is not used since it contains many pronoun and common noun phrase mentions such as \u201cit,\u201d \u201che,\u201d \u201ca thrift institution,\u201d which are not suitable to directly apply entity linking on."
              ]
            },
            "annotation_id": "9c6bf458f86dcc3ef2ba3704775dedb45e538ff5",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "FIGER (GOLD) ",
                "BBN"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. The sizes of their tag sets are 113 and 47, respectively. FIGER (GOLD) allows mentions to have multiple type paths, but BBN does not. Another commonly used dataset, OntoNotes BIBREF1, is not used since it contains many pronoun and common noun phrase mentions such as \u201cit,\u201d \u201che,\u201d \u201ca thrift institution,\u201d which are not suitable to directly apply entity linking on."
              ],
              "highlighted_evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. "
              ]
            },
            "annotation_id": "a44611e5f3862f6c4f88aea96c43e42d8b84eb6f",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "FIGER (GOLD)",
                "BBN"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. The sizes of their tag sets are 113 and 47, respectively. FIGER (GOLD) allows mentions to have multiple type paths, but BBN does not. Another commonly used dataset, OntoNotes BIBREF1, is not used since it contains many pronoun and common noun phrase mentions such as \u201cit,\u201d \u201che,\u201d \u201ca thrift institution,\u201d which are not suitable to directly apply entity linking on."
              ],
              "highlighted_evidence": [
                "We use two datasets: FIGER (GOLD) BIBREF0 and BBN BIBREF5. "
              ]
            },
            "annotation_id": "a82db6645ee3820fc45089c45ba396d64daace0a",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Our approach. The example sentence is \u201cEarlier on Tuesday, Donald Trump pledged to help hard-hit U.S. farmers caught in the middle of the escalating trade war.\u201d Here, the correct label for the mention Donald Trump should be /person, /person/politician. \u201c[Mention]\u201d is a special token that we use to represent the mention."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Fine-grained entity typing performance. The performance of \u201cOurs (DirectTrain)\u201d on BBN is omitted since this dataset does not have fine-grained types for person."
      }
    ]
  },
  "2003.11687": {
    "title": "Common-Knowledge Concept Recognition for SEVA",
    "abstract": "We build a common-knowledge concept recognition system for a Systems Engineer's Virtual Assistant (SEVA) which can be used for downstream tasks such as relation extraction, knowledge graph construction, and question-answering. The problem is formulated as a token classification task similar to named entity extraction. With the help of a domain expert and text processing methods, we construct a dataset annotated at the word-level by carefully defining a labelling scheme to train a sequence model to recognize systems engineering concepts. We use a pre-trained language model and fine-tune it with the labeled dataset of concepts. In addition, we also create some essential datasets for information such as abbreviations and definitions from the systems engineering domain. Finally, we construct a simple knowledge graph using these extracted concepts along with some hyponym relations.",
    "full_text": [
      {
        "section_name": "INTRODUCTION",
        "paragraphs": [
          "The Systems Engineer's Virtual Assistant (SEVA) BIBREF0 was introduced with the goal to assist systems engineers (SE) in their problem-solving abilities by keeping track of large amounts of information of a NASA-specific project and using the information to answer queries from the user. In this work, we address a system element by constructing a common-knowledge concept recognition system for improving the performance of SEVA, using the static knowledge collected from the Systems Engineering Handbook BIBREF1 that is widely used in projects across the organization as domain-specific commonsense knowledge. At NASA, although there exists knowledge engines and ontologies for the SE domain such as MBSE BIBREF2, IMCE BIBREF3, and OpenCaesar BIBREF4, generic commonsense acquisition is rarely discussed; we aim to address this challenge. SE commonsense comes from years of experience and learning which involves background knowledge that goes beyond any handbook. Although constructing an assistant like SEVA system is the overarching objective, a key problem to first address is to extract elementary common-knowledge concepts using the SE handbook and domain experts. We use the term `common-knowledge' as the `commonsense' knowledge of a specific domain. This knowledge can be seen as a pivot that can be used later to collect `commonsense' knowledge for the SE domain. We propose a preliminary research study that can pave a path towards a comprehensive commonsense knowledge acquisition for an effective Artificial Intelligence (AI) application for the SE domain. Overall structure of this work is summarized in Figure 1. Implementation with demo and dataset is available at: https://github.com/jitinkrishnan/NASA-SE ."
        ]
      },
      {
        "section_name": "BACKGROUND AND MOTIVATION",
        "paragraphs": [
          "Creating commonsense AI still remains an important and challenging task in AI research today. Some of the inspiring works are the CYC project BIBREF5 that tries to serve as a foundational knowledge to all systems with millions of everyday life commonsense assertions, Mosaic Commonsense Knowledge Graphs and Reasoning BIBREF6 that addresses aspects like social situations, mental states, and causal relationships, and Aristo System BIBREF7 that focuses on basic science knowledge. In NASA's context, systems engineering combines several engineering disciplines requiring extreme coordination and is prone to human errors. This, in combination with the lack of efficient knowledge transfer of generic lessons-learned makes most technology-based missions risk-averse. Thus, a comprehensive commonsense engine can significantly enhance the productivity of any mission by letting the experts focus on what they do best.",
          "Concept Recognition (CR) is a task identical to the traditional Named Entity Recognition (NER) problem. A typical NER task seeks to identify entities like name of a person such as `Shakespeare', a geographical location such as `London', or name of an organisation such as `NASA' from unstructured text. A supervised NER dataset consists of the above mentioned entities annotated at the word-token level using labelling schemes such as BIO which provides beginning (B), continuation or inside (I), and outside (O) representation for each word of an entity. BIBREF8 is the current top-performing NER model for CoNLL-2003 shared task BIBREF9. Off-the-shelf named entity extractors do not suffice in the SE common-knowledge scenario because the entities we want to extract are domain-specific concepts such as `system architecture' or `functional requirements' rather than physical entities such as `Shakespeare' or `London'. This requires defining new labels and fine-tuning.",
          "Relation extraction tasks extract semantic relationships from text. These extractors aim to connect named entities such as `Shakespeare' and `England' using relations such as `born-in'. Relations can be as simple as using hand-built patterns or as challenging as using unsupervised methods like Open IE BIBREF10; with bootstrapping, supervised, and semi-supervised methods in between. BIBREF11 and BIBREF12 are some of the high performing models that extract relations from New York Times Corpus BIBREF13 and TACRED challenges BIBREF14 respectively. Hyponyms represent hierarchical connection between entities of a domain and represent important relationships. For instance, a well-known work by BIBREF15 uses syntactic patterns such as [Y such as A, B, C], [Y including X], or [Y, including X] to extract hyponyms. Our goal is to extract preliminary hyponym relations from the concepts extracted by the CR and to connect the entities through verb phrases."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION",
        "paragraphs": [
          "SE concepts are less ambiguous as compared to generic natural language text. A word usually means one concept. For example, the word `system' usually means the same when referring to a `complex system', `system structure', or `management system' in the SE domain. In generic text, the meaning of terms like `evaluation', `requirement', or `analysis' may contextually differ. We would like domain specific phrases such as `system evaluation', `performance requirement', or `system analysis' to be single entities. Based on the operational and system concepts described in BIBREF0, we carefully construct a set of concept-labels for the SE handbook which is shown in the next section."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION ::: BIO Labelling Scheme",
        "paragraphs": [
          "abb: represents abbreviations such as TRL representing Technology Readiness Level.",
          "grp: represents a group of people or an individual such as Electrical Engineers, Systems Engineers or a Project Manager.",
          "syscon: represents any system concepts such as engineering unit, product, hardware, software, etc. They mostly represent physical concepts.",
          "opcon: represents operational concepts such as decision analysis process, technology maturity assessment, system requirements review, etc.",
          "seterm: represents generic terms that are frequently used in SE text and those that do not fall under syscon or opcon such as project, mission, key performance parameter, audit etc.",
          "event: represents event-like information in SE text such as Pre-Phase A, Phase A, Phase B, etc.",
          "org: represents an organization such as `NASA', `aerospace industry', etc.",
          "art: represents names of artifacts or instruments such as `AS1300'",
          "cardinal: represents numerical values such as `1', `100', 'one' etc.",
          "loc: represents location-like entities such as component facilities or centralized facility.",
          "mea: represents measures, features, or behaviors such as cost, risk, or feasibility."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION ::: Abbreviations",
        "paragraphs": [
          "Abbreviations are used frequently in SE text. We automatically extract abbreviations using simple pattern-matching around parentheses. Given below is a sample regex that matches most abbreviations in the SE handbook.",
          "r\"\\([ ]*[A-Z][A-Za-z]*[ ]*\\)\"",
          "An iterative regex matching procedure using this pattern over the preceding words will produce the full phrase of the abbreviation. `A process to determine a system\u2019s technological maturity based on Technology Readiness Levels (TRLs)' produces the abbreviation TRL which stands for Technology Readiness Levels. `Define one or more initial Concept of Operations (ConOps) scenarios' produces the abbreviation ConOps which stands for Concept of Operations. We pre-label these abbreviations as concept entities. Many of these abbreviations are also provided in the Appendix section of the handbook which is also extracted and used as concepts."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION ::: Common-Knowledge Definitions",
        "paragraphs": [
          "Various locations of the handbook and the glossary provide definitions of several SE concepts. We collect these and compile a comprehensive definitions document which is also used for the concept recognition task. An example definition and its description is shown below:",
          "Definition: Acceptable Risk",
          "Description: The risk that is understood and agreed to by the program/project, governing authority, mission directorate, and other customer(s) such that no further specific mitigating action is required."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION ::: CR Dataset Construction and Pre-processing",
        "paragraphs": [
          "Using python tools such as PyPDF2, NLTK, and RegEx we build a pipeline to convert PDF to raw text along with extensive pre-processing which includes joining sentences that are split, removing URLs, shortening duplicate non-alpha characters, and replacing full forms of abbreviations with their shortened forms. We assume that the SE text is free of spelling errors. For the CR dataset, we select coherent paragraphs and full sentences by avoiding headers and short blurbs. Using domain keywords and a domain expert, we annotate roughly 3700 sentences at the word-token level. An example is shown in Figure 2 and the unique tag count is shown in Table 1."
        ]
      },
      {
        "section_name": "CONCEPT RECOGNITION ::: Fine tuning with BERT",
        "paragraphs": [
          "Any language model can be used for the purpose of customizing an NER problem to CR. We choose to go with BERT BIBREF16 because of its general-purpose nature and usage of contextualized word embeddings.",
          "In the hand-labelled dataset, each word gets a label. The idea is to perform multi-class classification using BERT's pre-trained cased language model. We use pytorch transformers and hugging face as per the tutorial by BIBREF17 which uses $BertForTokenClassification$. The text is embedded as tokens and masks with a maximum token length. This embedded tokens are provided as the input to the pre-trained BERT model for a full fine-tuning. The model gives an F1-score of $0.89$ for the concept recognition task. An 80-20 data split is used for training and evaluation. Detailed performance of the CR is shown in Table 2 and 3. Additionally, we also implemented CR using spaCy BIBREF18 which also produced similar results."
        ]
      },
      {
        "section_name": "RELATION EXTRACTION",
        "paragraphs": [
          "In this work, for relation extraction, we focus on hyponyms and verb phrase chunking. Hyponyms are more specific concepts such as earth to planet or rose to flower. Verb phrase chunking connects the named entities recognized by the CR model through verbs."
        ]
      },
      {
        "section_name": "RELATION EXTRACTION ::: Hyponyms from Definitions",
        "paragraphs": [
          "The definition document consists of 241 SE definitions and their descriptions. We iteratively construct entities in increasing order of number of words in the definitions with the help of their parts-of-speech tags. This helps in creating subset-of relation between a lower-word entity and a higher-word entity. Each root entity is lemmatized such that entities like processes and process appear only once.",
          ""
        ]
      },
      {
        "section_name": "RELATION EXTRACTION ::: Hyponyms from POS tags",
        "paragraphs": [
          "Using the words (especially nouns) that surround an already identified named entity, more specific entities can be identified. This is performed on a few selected entity tags such as opcon and syscon. For example, consider the sentence `SE functions should be performed'. `SE' has tag NNP and `functions' has tag NNS. We create a relation called subset-of between `SE functions' and `SE'.",
          ""
        ]
      },
      {
        "section_name": "RELATION EXTRACTION ::: Relations from Abbreviations",
        "paragraphs": [
          "",
          "Relations from abbreviations are simple direct connections between the abbreviation and its full form described in the abbreviations dataset. Figure FIGREF25 shows a snippet of knowledge graph constructed using stands-for and subset-of relationships. Larger graphs are shown in the demo."
        ]
      },
      {
        "section_name": "RELATION EXTRACTION ::: Relation Extraction using Verb Phrase Chunking",
        "paragraphs": [
          "Finally, we explore creating contextual triples from sentences using all the entities extracted using the CR model and entities from definitions. Only those phrases that connect two entities are selected for verb phrase extraction. Using NLTK's regex parser and chunker, a grammar such as",
          "VP: {(<MD>|<R.*>|<I.*>|<VB.*>|<JJ.*>|",
          "<TO>)*<VB.*>+(<MD>|<R.*>|<I.*>|<VB.*>|",
          "<JJ.*>|<TO>)*}",
          "with at least one verb, can extract relation-like phrases from the phrase that links two concepts. An example is shown in Figure FIGREF27. Further investigation of relation extraction from SE handbook is left as future work."
        ]
      },
      {
        "section_name": "CONCLUSION AND FUTURE WORK",
        "paragraphs": [
          "We presented a common-knowledge concept extractor for the Systems Engineer's Virtual Assistant (SEVA) system and showed how it can be beneficial for downstream tasks such as relation extraction and knowledge graph construction. We construct a word-level annotated dataset with the help of a domain expert by carefully defining a labelling scheme to train a sequence labelling task to recognize SE concepts. Further, we also construct some essential datasets from the SE domain which can be used for future research. Future directions include constructing a comprehensive common-knowledge relation extractor from SE handbook and incorporating such human knowledge into a more comprehensive machine-processable commonsense knowledge base for the SE domain."
        ]
      }
    ],
    "qas": [
      {
        "question": "How many domain experts were involved into creation of dataset?",
        "question_id": "f5603271a04452cbdbb07697859bef2a2030d75c",
        "nlp_background": "zero",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "258ee4069f740c400c0049a2580945a1cc7f044c",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "2a0fb8db6ed7d5917ad97a0925223bb750282ef3",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "1",
              "evidence": [
                "Using python tools such as PyPDF2, NLTK, and RegEx we build a pipeline to convert PDF to raw text along with extensive pre-processing which includes joining sentences that are split, removing URLs, shortening duplicate non-alpha characters, and replacing full forms of abbreviations with their shortened forms. We assume that the SE text is free of spelling errors. For the CR dataset, we select coherent paragraphs and full sentences by avoiding headers and short blurbs. Using domain keywords and a domain expert, we annotate roughly 3700 sentences at the word-token level. An example is shown in Figure 2 and the unique tag count is shown in Table 1."
              ],
              "highlighted_evidence": [
                "Using domain keywords and a domain expert, we annotate roughly 3700 sentences at the word-token level."
              ]
            },
            "annotation_id": "607ddc5824ef5a51a8136c2bb1e37ba5dc616eeb",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "One domain expert.",
              "evidence": [
                "Using python tools such as PyPDF2, NLTK, and RegEx we build a pipeline to convert PDF to raw text along with extensive pre-processing which includes joining sentences that are split, removing URLs, shortening duplicate non-alpha characters, and replacing full forms of abbreviations with their shortened forms. We assume that the SE text is free of spelling errors. For the CR dataset, we select coherent paragraphs and full sentences by avoiding headers and short blurbs. Using domain keywords and a domain expert, we annotate roughly 3700 sentences at the word-token level. An example is shown in Figure 2 and the unique tag count is shown in Table 1."
              ],
              "highlighted_evidence": [
                "Using domain keywords and a domain expert, we annotate roughly 3700 sentences at the word-token level."
              ]
            },
            "annotation_id": "f515b392318535b7ab1fc338005a331f2a2f2508",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Common-knowledge concept recognition and simple relation extraction"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Performance of different labels"
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Unique Tag Count from the CR dataset"
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: A Snippet of the concept-labelled dataset"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Overall Performance of CR; For fairness, we also provide the accuracy when the most common \u2018O\u2019-tag is excluded from the analysis."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: A snippet of the knowledge graph generated"
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Figure 4: Relation Extraction using Verb Phrase"
      }
    ]
  },
  "1703.10152": {
    "title": "Automatic Argumentative-Zoning Using Word2vec",
    "abstract": "In comparison with document summarization on the articles from social media and newswire, argumentative zoning (AZ) is an important task in scientific paper analysis. Traditional methodology to carry on this task relies on feature engineering from different levels. In this paper, three models of generating sentence vectors for the task of sentence classification were explored and compared. The proposed approach builds sentence representations using learned embeddings based on neural network. The learned word embeddings formed a feature space, to which the examined sentence is mapped to. Those features are input into the classifiers for supervised classification. Using 10-cross-validation scheme, evaluation was conducted on the Argumentative-Zoning (AZ) annotated articles. The results showed that simply averaging the word vectors in a sentence works better than the paragraph to vector algorithm and by integrating specific cuewords into the loss function of the neural network can improve the classification performance. In comparison with the hand-crafted features, the word2vec method won for most of the categories. However, the hand-crafted features showed their strength on classifying some of the categories.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "One of the crucial tasks for researchers to carry out scientific investigations is to detect existing ideas that are related to their research topics. Research ideas are usually documented in scientific publications. Normally, there is one main idea stated in the abstract, explicitly presenting the aim of the paper. There are also other sub-ideas distributed across the entire paper. As the growth rate of scientific publication has been rising dramatically, researchers are overwhelmed by the explosive information. It is almost impossible to digest the ideas contained in the documents emerged everyday. Therefore, computer assisted technologies such as document summarization are expected to play a role in condensing information and providing readers with more relevant short texts. Unlike document summarization from news circles, where the task is to identify centroid sentences BIBREF0 or to extract the first few sentences of the paragraphs BIBREF1 , summarization of scientific articles involves extra text processing stage BIBREF2 . After highest ranked texts are extracted, rhetorical status analysis will be conducted on the selected sentences. Rhetorical sentence classification, also known as argumentative zoning (AZ) BIBREF3 , is a process of assigning rhetorical status to the extracted sentences. The results of AZ provide readers with general discourse context from which the scientific ideas could be better linked, compared and analyzed. For example, given a specific task, which sentences should be shown to the reader is related to the features of the sentences. For the task of identifying a paper's unique contribution, sentences expressing research purpose should be retrieved with higher priority. For comparing ideas, statements of comparison with other works would be more useful. Teufel et. al. BIBREF2 introduced their rhetorical annotation scheme which takes into account of the aspects of argumentation, metadiscourse and relatedness to other works. Their scheme resulted seven categories of rhetorical status and the categories are assigned to full sentences. Examples of human annotated sentences with their rhetorical status are shown in Table. TABREF2 . The seven categories are aim, contrast, own, background, other, basis and textual.",
          "Analyzing the rhetorical status of sentences manually requires huge amount of efforts, especially for structuring information from multiple documents. Fortunately, computer algorithms have been introduced to solve this problem. With the development of artificial intelligence, machine learning and computational linguistics, Natural Language Processing (NLP) has become a popular research area BIBREF4 , BIBREF5 . NLP covers the applications from document retrieval, text categorization BIBREF6 , document summarization BIBREF7 to sentiment analysis BIBREF8 , BIBREF9 . Those applications are targeting different types of text resources, such as articles from social media BIBREF10 and scientific publications BIBREF2 . There are several approaches to tackle these tasks. From machine learning prospective, text can be analysed via supervised BIBREF2 , semi-supervised BIBREF11 and unsupervised BIBREF12 algorithms.",
          "Document summarization from social media and news circles has received much attention for the past decades. Those problems have been addressed from many angles, one of which is feature extraction and representation. At the early stage of document summarization, features are usually engineered manually. Although the hand-crafted features have shown the ability for document summarization and sentiment analysis BIBREF13 , BIBREF9 , there are not enough efficient features to capture the semantic relations between words, phrases and sentences. Moreover, building a sufficient pool of features manually is difficult, because it requires expert knowledge and it is time-consuming. Teufel et. al. BIBREF2 have built feature pool of sixteen types of features to classify sentences, such as the position of sentence, sentence length and tense. Widyantoro et. al. used content features, qualifying adjectives and meta-discourse features BIBREF14 to explore AZ task. It took efforts to engineer these features and it is also time consuming to optimize the combination of the entire features. With the advent of neural networks BIBREF15 , it is possible for computers to learn feature representations automatically. Recently, word embedding technique BIBREF16 has been widely used in the NLP community. There are plenty of cases where word embedding and sentence representations have been applied to short text classification BIBREF17 and paraphrase detection BIBREF18 . However, the effectiveness of this technique on AZ needs further study. The research question is, is it possible to extract word embeddings as features to classify sentences into the seven categories mentioned above using supervised machine learning approach?"
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "The tool of word2vec proposed by Mikolov et al. BIBREF16 has gained a lot attention recently. With word2vec tool, word embeddings can be learnt from big amount of text corpus and the semantic relationships between words can be measured by the cosine distances between the vectors. The idea behind word embeddings is to use distributed representation BIBREF19 to map each word into k-dimension vector. How these vectors are generated using word2vec tool? The common method to derive the vectors is using neural probabilistic language model BIBREF20 . The underlying word representations for each word are obtained while training the language model. Similar to the mechanism in language model, Mikolov et al. BIBREF16 introduced two architectures: Skip-gram model and continuous bag of words (CBOW) model. Each of the model has two different training strategies, such as hierarchical softmax and negative sampling. Both these two models have three layers: input, projection and output layer. The word vectors are obtained once the models are optimized. Usually, this optimizing process is done using stochastic gradient descent method. It doesn't need labels when training the models, which makes word2vec algorithm more valuable compared with traditional supervised machine learning methods that require a big amount of annotated data. Given enough text corpus, the word2vec can generate meaningful representations.",
          "Word2vec has been applied to sentiment analysis BIBREF21 , BIBREF22 , BIBREF23 and text classification BIBREF24 . Sadeghian and Sharafat BIBREF25 explored averaging of the word vectors in a sentiment review statement. Their results indicated that word2vec models significantly outperform the vanilla bag-of-words model. Amongst the word2vec based models, softmax provides the best form of classification. Tang et al. BIBREF21 used the concatenation of vectors derived from different convolutional layers to analyze the sentiment statements. They also trained sentiment-specific word embeddings to improve the twitter sentiment classification results. This work is aiming at learning word embeddings for the task of AZ. The results were compared from three aspects: the impact of the training corpus, the effectiveness of specific word embeddings and different ways of constructing sentence representations based on the learned word vectors.",
          "Le and Mikolov BIBREF26 introduced the concept of word vector representation in a formal way:",
          "Given a sequence of training words INLINEFORM0 , the objective of the word2vec model is to maximize the average log probability:",
          " INLINEFORM0 INLINEFORM1 INLINEFORM2 p INLINEFORM3 (1)",
          "Using softmax technique, the prediction can be formalized as:",
          "p INLINEFORM0 = INLINEFORM1 (2)",
          "Each of INLINEFORM0 is un-normalized log probability for each output word INLINEFORM1 :",
          " INLINEFORM0 (3)"
        ]
      },
      {
        "section_name": "Models",
        "paragraphs": [
          "In this study, sentence embeddings were learned from large text corpus as features to classify sentences into seven categories in the task of AZ. Three models were explored to obtain the sentence vectors: averaging the vectors of the words in one sentence, paragraph vectors and specific word vectors.",
          "The first model, averaging word vectors ( INLINEFORM0 ), is to average the vectors in word sequence INLINEFORM1 . The main process in this model is to learn the word embedding matrix INLINEFORM2 :",
          " INLINEFORM0 INLINEFORM1 INLINEFORM2 INLINEFORM3 (4)",
          "where INLINEFORM0 is the word embedding for word INLINEFORM1 , which is learned by the classical word2vec algorithm BIBREF16 .",
          "The second model, INLINEFORM0 , is aiming at training paragraph vectors. It is also called distributed memory model of paragraph vectors (PV-DM) BIBREF26 , which is an extension of word2vec. In comparison with the word2vec framework, the only change in PV-DM is in the equation (3), where INLINEFORM1 is constructed from INLINEFORM2 and INLINEFORM3 , where matrix INLINEFORM4 is the word vector and INLINEFORM5 holds the paragraph vectors in such a way that every paragraph is mapped to a unique vector represented by a column in matrix INLINEFORM6 .",
          "The third model is constructed for the purpose of improving classification results for a certain category. In this study specifically, the optimization task was focused on identifying the category INLINEFORM0 . In this study, INLINEFORM1 specific word embeddings were trained ( INLINEFORM2 ) inspired by Tang et al. BIBREF21 's model: Sentiment-Specific Word Embedding (unified model: INLINEFORM3 ). After obtaining the word vectors via INLINEFORM4 , the same scheme was used to average the vectors in one sentence as in the model INLINEFORM5 ."
        ]
      },
      {
        "section_name": "Classification and evaluation",
        "paragraphs": [
          "The learned word embeddings are input into a classifier as features under a supervised machine learning framework. Similar to sentiment classification using word embeddings BIBREF21 , where they try to predict each tweet to be either positive or negative, in the task of AZ, the embeddings are used to classify each sentence into one of the seven categories.",
          "To evaluate the classification performance, precision, recall and F-measure were computed."
        ]
      },
      {
        "section_name": "Training Dataset",
        "paragraphs": [
          " INLINEFORM0 collection. ACL Anthology Reference Corpus contains the canonical 10,921 computational linguistics papers, from which 622,144 sentences were generated after filtering out sentences with lower quality.",
          " INLINEFORM0 collection contains 6,778 sentences, extracted from the titles and abstracts of publications provided by WEB OF SCIENCE ."
        ]
      },
      {
        "section_name": "Test Dataset",
        "paragraphs": [
          "Argumentative Zoning Corpus ( INLINEFORM0 corpus) consists of 80 AZ INLINEFORM1 annotated conference articles in computational linguistics, originally drawn from the Cmplg arXiv. . After Concatenating sub-sentences, 7,347 labeled sentences were obtained."
        ]
      },
      {
        "section_name": "Training strategy",
        "paragraphs": [
          "To compare the three models effectiveness on the AZ task, the three models on a same ACL dataset (introduced int he dataset section) were trained. The word2vec were also trained using different parameters, such as different dimension of features. To evaluate the impact from different domains, the first model was trained on different corpus.",
          "The characteristics of word embeddings based on different model and dataset are listed in Table. TABREF12 ."
        ]
      },
      {
        "section_name": "Parameters",
        "paragraphs": [
          "Inspired by the work from Sadeghian and Sharafat BIBREF25 , the word to vector features were set up as follows: the Minimum word count is 40; The number of threads to run in parallel is 4 and the context window is 10."
        ]
      },
      {
        "section_name": "Strategy of dealing with unbalanced data",
        "paragraphs": [
          "In imbalanced data sets, some classes are significantly outnumbered by other classes BIBREF27 , which affects the classification results. In this experiment, the test dataset is an imbalanced data set. Table. TABREF16 shows the distribution of rhetorical categories from the INLINEFORM0 test dataset. The categories OWN and OTH are significantly outnumbering other categories.",
          "To deal with the problem of classification on unbalanced data, synthetic Minority Over-sampling TEchnique (SMOTE) BIBREF28 were performed on the original dataset. 10-cross validation scheme was adopted and the results were averaged from 10 iterations."
        ]
      },
      {
        "section_name": "Results of classification for per category",
        "paragraphs": [
          "Table. TABREF19 and TABREF20 show the classification performance of different methods. ",
          "The results were examined from the following aspects:",
          "When the feature dimension is set to 100 and the training corpus is ACL, the results generated by different models were compared (AVGWVEC,",
          "PARAVEC and AVGWVEC+BSWE for BAS category only). Looking at the F-measure, AVGWVEC performs better than PARAVEC, but PARAVEC gave a better precision results on several categories, such as AIM, CTR, TXT and OWN. The results showed that PARAVEC model is not robust, for example, it performs badly for the category of BAS. For specific category classification, take the BAS category for example, the BSWE model outperforms others in terms of F-measure.",
          "When the model is fixed to AVGWVEC and the training corpus is ACL, the feature size impact (300 and 100 dimensions) was investigated. From the F-measure, it can be seen that for some categories, 300-dimension features perform better than the 100-dimension ones, for example, CTR and BKG, but they are not as good as 100-dimension features for some categories, such as BAS.",
          "When the model is set to AVGWVEC and the feature dimension is 100, the results computed from different training corpus were compared (ACL+AZ, MixedAbs and Brown corpus). ACL+AZ outperforms others and brown corpus is better than MixedAbs for most of the categories, but brown corpus is not as good as MixedAbs for the category of OWN.",
          "Finally, the results were compared between word embeddings and the methods of cuewords, Teufel 2002 and baseline. To evaluate word embeddings on AZ, the model AVGWVEC trained on ACL+AZ was used for the comparison. It can be seen from the table. TABREF19 , the model of word embeddings is better than the method using cuewords matching. It also outperforms Teufel 2002 for most of the cases, except AIM, BAS and OWN. It won baseline for most of the categories, except OWN."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "The classification results showed that the type of word embeddings and the training corpus affect the AZ performance. As the simple model, INLINEFORM0 performs better than others, which indicate averaging the word vectors in a sentence can capture the semantic property of statements. By training specific argumentation word embeddings, the performance can be improved, which can be seen from the case of detecting BAS status using INLINEFORM1 model.",
          "Feature dimension doesn't dominate the results. There is no significant difference between the resutls generated by 300-dimension of features and 100 dimensions.",
          "Training corpus affects the results. ACL+AZ outperforming others indicates that the topics of the training corpus are important factors in argumentative zoning. Although Brown corpus has more vocabularies, it doesn't win ACL+AZ.",
          "In general, the classification performance of word embeddings is competitive in terms of F-measure for most of the categories. But for classifying the categories AIM, BAS and OWN, the manually crafted features proposed by Teufel et al. BIBREF2 gave better results."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, different word embedding models on the task of argumentative zoning were compared . The results showed that word embeddings are effective on sentence classification from scientific papers. Word embeddings trained on a relevant corpus can capture the semantic features of statements and they are easier to be obtained than hand engineered features.",
          "To improve the sentence classification for a specific category, integrating word specific embedding strategy helps. The size of the feature pool doesn't matter too much on the results, nor does the vocabulary size. In comparison, the domain of the training corpus affects the classification performance."
        ]
      }
    ],
    "qas": [
      {
        "question": "What hand-crafted features are used?",
        "question_id": "d0b967bfca2039c7fb05b931c8b9955f99a468dc",
        "nlp_background": "five",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "word2vec",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "position of sentence",
                "sentence length",
                "tense",
                "qualifying adjectives",
                "meta-discourse features"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Document summarization from social media and news circles has received much attention for the past decades. Those problems have been addressed from many angles, one of which is feature extraction and representation. At the early stage of document summarization, features are usually engineered manually. Although the hand-crafted features have shown the ability for document summarization and sentiment analysis BIBREF13 , BIBREF9 , there are not enough efficient features to capture the semantic relations between words, phrases and sentences. Moreover, building a sufficient pool of features manually is difficult, because it requires expert knowledge and it is time-consuming. Teufel et. al. BIBREF2 have built feature pool of sixteen types of features to classify sentences, such as the position of sentence, sentence length and tense. Widyantoro et. al. used content features, qualifying adjectives and meta-discourse features BIBREF14 to explore AZ task. It took efforts to engineer these features and it is also time consuming to optimize the combination of the entire features. With the advent of neural networks BIBREF15 , it is possible for computers to learn feature representations automatically. Recently, word embedding technique BIBREF16 has been widely used in the NLP community. There are plenty of cases where word embedding and sentence representations have been applied to short text classification BIBREF17 and paraphrase detection BIBREF18 . However, the effectiveness of this technique on AZ needs further study. The research question is, is it possible to extract word embeddings as features to classify sentences into the seven categories mentioned above using supervised machine learning approach?"
              ],
              "highlighted_evidence": [
                "Teufel et. al. BIBREF2 have built feature pool of sixteen types of features to classify sentences, such as the position of sentence, sentence length and tense. Widyantoro et. al. used content features, qualifying adjectives and meta-discourse features BIBREF14 to explore AZ task. "
              ]
            },
            "annotation_id": "010fd112c1b0d1cfb6591f20e73c752a33d97465",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " sentences with their rhetorical status "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "One of the crucial tasks for researchers to carry out scientific investigations is to detect existing ideas that are related to their research topics. Research ideas are usually documented in scientific publications. Normally, there is one main idea stated in the abstract, explicitly presenting the aim of the paper. There are also other sub-ideas distributed across the entire paper. As the growth rate of scientific publication has been rising dramatically, researchers are overwhelmed by the explosive information. It is almost impossible to digest the ideas contained in the documents emerged everyday. Therefore, computer assisted technologies such as document summarization are expected to play a role in condensing information and providing readers with more relevant short texts. Unlike document summarization from news circles, where the task is to identify centroid sentences BIBREF0 or to extract the first few sentences of the paragraphs BIBREF1 , summarization of scientific articles involves extra text processing stage BIBREF2 . After highest ranked texts are extracted, rhetorical status analysis will be conducted on the selected sentences. Rhetorical sentence classification, also known as argumentative zoning (AZ) BIBREF3 , is a process of assigning rhetorical status to the extracted sentences. The results of AZ provide readers with general discourse context from which the scientific ideas could be better linked, compared and analyzed. For example, given a specific task, which sentences should be shown to the reader is related to the features of the sentences. For the task of identifying a paper's unique contribution, sentences expressing research purpose should be retrieved with higher priority. For comparing ideas, statements of comparison with other works would be more useful. Teufel et. al. BIBREF2 introduced their rhetorical annotation scheme which takes into account of the aspects of argumentation, metadiscourse and relatedness to other works. Their scheme resulted seven categories of rhetorical status and the categories are assigned to full sentences. Examples of human annotated sentences with their rhetorical status are shown in Table. TABREF2 . The seven categories are aim, contrast, own, background, other, basis and textual."
              ],
              "highlighted_evidence": [
                " Examples of human annotated sentences with their rhetorical status are shown in Table. TABREF2 . The seven categories are aim, contrast, own, background, other, basis and textual."
              ]
            },
            "annotation_id": "98950854b3e2c4f1cdf1a54d8e472d2bb8455a60",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "d4c5403306d7ae1e0394c9f1222dd326884851a5",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1. Examples of annotated sentences with their rhetorical status"
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2. Characteristics of word embeddings based on different model and dataset"
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3. Distribution of rhetorical categories"
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4. Performance of sentence classification per category I (precision/recall/Fmeasure)"
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5. Performance of sentence classification per category II (precision/recall/Fmeasure)"
      }
    ]
  },
  "1907.04072": {
    "title": "Multitask Learning for Blackmarket Tweet Detection",
    "abstract": "Online social media platforms have made the world more connected than ever before, thereby making it easier for everyone to spread their content across a wide variety of audiences. Twitter is one such popular platform where people publish tweets to spread their messages to everyone. Twitter allows users to Retweet other users' tweets in order to broadcast it to their network. The more retweets a particular tweet gets, the faster it spreads. This creates incentives for people to obtain artificial growth in the reach of their tweets by using certain blackmarket services to gain inorganic appraisals for their content. In this paper, we attempt to detect such tweets that have been posted on these blackmarket services in order to gain artificially boosted retweets. We use a multitask learning framework to leverage soft parameter sharing between a classification and a regression based task on separate inputs. This allows us to effectively detect tweets that have been posted to these blackmarket services, achieving an F1-score of 0.89 when classifying tweets as blackmarket or genuine.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Twitter is an important medium for people and companies to promote their products, ideologies, or to reach out and connect with other people in the form of micro-conversations. Twitter provides users with multiple ways of showing their support towards a tweet in the form of Likes, Retweets and Quotes. These content-level appraisals help in spreading the content further and act as a measure of users' agreement on the value of the content. The count of these content-level appraisals therefore determines the influence of a particular tweet and its author. This has led to the creation of certain blackmarket services such as FreeFollowers (https://www.freefollowers.io/), Like4Like (https://like4like.org/), YouLikeHits (https://www.youlikehits.com/), JustRetweet (http://justretweet.com), which allow users to post their tweets in order to gain inorganic appraisals in the form of Likes, Retweets and Quotes BIBREF0 , BIBREF1 .",
          "There has been a lot of research on the detection of fraudulent activities on Twitter such as detection of bots BIBREF2 , fake followers BIBREF3 , collusive retweeters BIBREF0 , BIBREF1 , and social spam BIBREF4 . However, the problem of detecting tweets that are posted to these blackmarket services has not been tackled before. The tweets submitted to blackmarket services are not necessarily spam or promotional tweets. As we observe in our data, there is some intersection between spammers and blackmarket users since spammers may also try to gain more appraisals by using these services. However, existing spam tweet detection approaches do not work that well in identifying individual tweets as blackmarket tweets (as shown in Table TABREF29 ).",
          "Table TABREF1 shows a sample tweet that was posted on a blackmarket service and another sample tweet that was not. In this paper, we make the first attempt to detect tweets that are posted on blackmarket services. Our aim is to build a system that can flag tweets soon after they are posted, which is why we do not consider temporal features such as the number of retweets or likes that a tweet keeps gaining over time. Instead, we only rely on the features and representations extracted from the content of the tweets.",
          "We curate a novel dataset of tweets that have been posted to blackmarket services, and a corresponding set of tweets that haven't. We propose a multitask learning approach to combine properties from the characterization of blackmarket tweets via traditional feature extraction, with a deep learning based feature representation of the tweets. We train a neural network which takes as input both the traditional feature representation as well as the deep learning based representation generated using the Tweet2Vec model BIBREF5 , and utilizes cross-stitch units BIBREF6 to learn an optimal combination of shared and task-specific knowledge via soft parameter sharing.",
          "We show that our multitask learning approach outperforms Twitter spam detection approaches, as well as state-of-the-art classifiers by 14.1% (in terms of F1-score), achieving an F1-score of 0.89 on our dataset. In short, the contributions of the paper are threefold: a new dataset, characterization of blackmarket tweets, and a novel multitask learning framework to detect tweets posted on blackmarket services."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Several studies have focused on detecting malicious activities such as spam, fake content and blackmarket services. Here, we mention some of these studies which we deem as pertinent to our work. We also mention the prior usage of multitask learning in a similar context.",
          "Spam/Fake Tweet Detection: The problem of fake and spam tweets is not new. Many solutions have been proposed to tackle this problem. Yardi et al. BIBREF7 showed that the network structure of spammers and non-spammers is different, and also tracked the life cycle of endogenous Twitter content. Chen et al. BIBREF8 conducted a comprehensive evaluation of several machine learning algorithms for timely detection of spam. Fake tweets, on the other hand, are the tweets which spread misinformation. Serrano et al. BIBREF9 provided an extensive survey on fake tweet detection. Unlike spam tweets, fake tweets are mostly associated with major events, and the accounts that produce these fake contents are mostly created during these events BIBREF10 , BIBREF11 .",
          "Blackmarket Services: Blackmarket services have recently received considerable attention due to the increase in the number of users using them. Analysis of such underground services was first documented in BIBREF12 where the authors examined the properties of social networks formed for blackmarket services. Liu et al. BIBREF13 proposed DetectVC which incorporates graph structure and the prior knowledge from the collusive followers to solve a voluntary following problem. Motoyama et al. BIBREF12 provided a detailed analysis of six underground forms, examining the properties of those social network structures that are formed and services that are being exchanged. Dutta et al. BIBREF0 investigated the customers involved in gaining fake retweets. Chetan et al. BIBREF1 proposed CoReRank, an unsupervised model and CoReRank+, a semi-supervised model which extends CoReRank to detect collusive users involved in retweeting activities.",
          "Multitask Learning: Multitask learning is used whenever we have two or more similar tasks to optimise together. Most of the related studies on multitask learning are based on how the tasks can be better learned together. Zhang et al. BIBREF14 classified multitask learning models into five types and reported the characteristics of each approach. Cross-Stitch units were introduced by Misra et al. BIBREF6 , which can learn an optimal combination of shared and task-specific representations. Gupta et al. BIBREF15 proposed GIRNet, a unified position-sensitive multitask recurrent neural network architecture."
        ]
      },
      {
        "section_name": "Blackmarket Services",
        "paragraphs": [
          "blackAs studied in BIBREF0 , there are two prevalent models of blackmarket services, namely premium and freemium. Premium services are only available upon payment from customers, whereas freemium services offer both paid and unpaid options. The unpaid services are available to the users when they contribute to the blackmarket by providing appraisals for other users' content. Here, we mainly concentrate on freemium services. The freemium services can be further divided into three categories: (i) social-share services (request customers to spread the content on social media), (ii) credit-based services (customers earn credits by providing appraisals, and can then use the credits earned to gain appraisals for their content), and (iii) auto-time retweet services (customers need to provide their Twitter access tokens, upon which their content is retweeted 10-20 times for each 15-minute window)."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "We collected data from Credit-based Freemium services because their service model is easy to understand. We crawled two blackmarket sites \u2013 YouLikeHits and Like4Like, between the period of February and April 2019. We created dummy accounts (after careful IRB approval) on these sites to participate in the platform and recorded Tweet IDs of the tweets that were posted for gaining retweets. We used Twitter's REST API to collect the tweet objects of these tweets. The timelines of the authors of these tweets were also collected, allowing us to find genuine tweets by the same users that have not been posted to these blackmarket sites."
        ]
      },
      {
        "section_name": "Dataset Description",
        "paragraphs": [
          "In total, we collected INLINEFORM0 tweets posted on blackmarket sites. Out of these, we removed non-English tweets and tweets with a length of less than two characters. Finally, we were left with INLINEFORM1 blackmarket tweets. Then, from the timelines of the authors of these tweets, we randomly sampled INLINEFORM2 genuine tweets that were not posted on these blackmarket sites during the same period. Both the blackmarket and genuine tweets were also inspected manually."
        ]
      },
      {
        "section_name": "Analysis of Blackmarket Tweets",
        "paragraphs": [
          "To further understand the purpose of the collusive users behind the usage of blackmarket services, we annotated blackmarket tweets in our test set into a few discrete categories. The statistics of the categories are as follows: Promotional - 43.75%, Entertainment - 15.89%, Spam - 13.57%, News - 7.86%, Politics - 4.82%, and Others - 14.11%. We considered a tweet as Promotional only if the tweet attempts to promote a website/product. Most of the tweets in the Others category include personal tweets without any call to action or promotion, but this also can be considered as self-promotion. We further noticed that there were about 5% of normal tweets on concerning issues such as \u201cpray for ...\", indicating that blackmarket services are also being used for non-business purposes. 99% of tweets other than the tweets from Others class included at least one URL, and 100% of the URLs in the blackmarket tweets were shortened."
        ]
      },
      {
        "section_name": "Proposed Approach",
        "paragraphs": [
          "This section describes the features and tweet representation methodology, and the proposed model to solve the problem."
        ]
      },
      {
        "section_name": "Tweet Content Features",
        "paragraphs": [
          "We use the following features based on the tweet content:",
          " INLINEFORM0 : Number of user mentions in the tweet",
          " INLINEFORM0 : Number of hashtags in the tweet",
          " INLINEFORM0 : Number of URLs in the tweet",
          " INLINEFORM0 : Count of media content in the tweet",
          " INLINEFORM0 : Is the tweet a reply to another tweet?",
          " INLINEFORM0 : Number of special characters (non alpha-numeric) in the tweet",
          " INLINEFORM0 : Length of the content (number of characters) in the tweet",
          " INLINEFORM0 : Sentiment score of the tweet obtained using SentiWordNet, ranging from -1 (negative) to +1 (positive)",
          " INLINEFORM0 : Number of noun words in the tweet",
          " INLINEFORM0 : Number of adjective words in the tweet",
          " INLINEFORM0 : Number of pronoun words in the tweet",
          " INLINEFORM0 : Number of verbs in the tweet"
        ]
      },
      {
        "section_name": "Tweet Content Representation",
        "paragraphs": [
          "We use the Tweet2Vec model BIBREF5 to generate a vector-space representation of each of the tweets. Tweet2Vec is a character-level deep learning based encoder for social media posts trained on the task of predicting the associated hashtags. It considers the assumption that posts with the same hashtags should have similar representation. It uses a bi-directional Gated Recurrent Unit (Bi-GRU) for learning the tweet representation. To get the representation for a particular tweet, the model combines the final GRU states by going through a forward and backward pass over the entire sequence.",
          "We use the pre-trained model provided by Dhingra et al. BIBREF5 , which is trained on a dataset of 2 million tweets, to get the tweet representation. This gives us a 500-dimensional representation of each tweet, based on its content."
        ]
      },
      {
        "section_name": "Proposed Model",
        "paragraphs": [
          "The architecture of our model is shown in Figure FIGREF21 . We adopt multitask learning to develop our model. The primary task is set as a binary classification problem, wherein the tweets are classified as blackmarket or genuine. The secondary task is set as a regression problem, wherein the number of likes and retweets that a tweet will gain after five days of being posted is predicted.",
          "The model takes a different input feature vector for each of the tasks.",
          "Primary Input: The primary task takes as input the tweet content representation generated by the Tweet2Vec model, which is a 500-dimensional vector for each of the tweets, as described above.",
          "Secondary Input: The secondary task takes as input the vector of tweet content features, which is a 12-dimensional vector, as described above.",
          "As shown in Figure FIGREF21 , the inputs are fed into separate fully connected (FC) layers with cross-stitch units stacked between successive layers. The cross-stitch units find the best shared representations using linear combinations, and learn the optimal linear combinations for a given set of tasks. The cross-stitch units essentially allow us to unify two separate networks for two separate tasks into a single network wherein each layer of the network shares the parameters from the other network using linear combinations. The network also employs batch-normalization and dropout to avoid overfitting.",
          "The output layer of the first task classifies tweets as blackmarket or genuine using a cross entropy loss function. The output layer of the second task predicts the numerical values for the number of retweets and likes that a tweet will gain after five days of being posted by using a Mean Squared Error (MSE) loss. Note that the performance of the secondary task is not of importance to us, however, the secondary task helps the primary task. Therefore, we focus on the performance of the model in the primary task during training and evaluation."
        ]
      },
      {
        "section_name": "Baseline Methods",
        "paragraphs": [
          "Since there is no prior work on blackmarket tweet detection, we chose state-of-the-art Twitter spam detection methods as baselines, along with training some state-of-the-art classifiers on the features we generated for our dataset.",
          "Spam Detection 1: We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.",
          "Spam Detection 2: For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset.",
          "We generate a combined feature vector by concatenating the tweet content features and the encoding generated by Tweet2Vec. This feature vector is then fed to state-of-the-art machine learning classifiers - Random Forest (RF), Multi-layer Perceptron (MLP), and Support Vector Machine (SVM)."
        ]
      },
      {
        "section_name": "Evaluation Setup",
        "paragraphs": [
          "We consider the problem as a binary classification problem, where the tweets are classified into two classes - blackmarket and genuine. The performance of each competing method is measured using the following metrics: Precision, Recall, and F1-score. The primary output of the multitask learning model gives us the classification result, which is what we use to evaluate our model. All hyperparameters of the models are appropriately tuned. The average results are reported after 5-fold cross-validation."
        ]
      },
      {
        "section_name": "Experimental Results",
        "paragraphs": [
          "As shown in Table TABREF29 , we observe that the multitask learning based model which uses the Tweet2Vec encoding and the content features as inputs to two separate tasks outperforms all the baselines, achieving an F1-score of 0.89 for classification of tweets as Blackmarket or Genuine. The best baseline is Spam Detector 2 which achieves an F1-score of 0.77.",
          "blackWe analyse the false negatives generated by our model to find which type of tweets the model finds difficult to classify. The percentage of each class in the false negatives is as follows: Promotional - 23.29%, Politics - 10.96%, Entertainment - 21.92%, News - 9.59%, Spam - 5.48%, and Others - 28.77%. We observe that the tweets belonging to the category Others are difficult to classify since they are similar to genuine tweets in terms of content. The results also indicate that our model is robust while classifying blackmarket tweets belonging to the following categories \u2013 News, Spam and Politics."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we presented a novel multitask learning approach to solve the problem of identification of tweets that are submitted to blackmarket services, without the use of any temporal features. To sum up, our contributions are three-fold: (i) Characterization: We proposed 12 tweet content based features that are useful in the task of identifying blackmarket tweets, (ii) Classification: We developed a novel Multitask Learning based model to classify tweets as blackmarket tweets or genuine tweets, (iii) Dataset: We collected a dataset consisting of tweets that have been submitted to blackmarket services in order to gain inorganic appraisals."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "The work was partially funded by DST (ECR/2017/00l691, DST/INT/UK/P158/2017), Ramanujan Fellowship, and the Infosys Centre of AI, IIIT-Delhi, India."
        ]
      }
    ],
    "qas": [
      {
        "question": "What baseline do they compare to?",
        "question_id": "4d5b74499804ea5bc5520beb88d0f9816f67205a",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": " spam detection method proposed by Wu et al. BIBREF4 ,  spam detection method  proposed by Rajdev et. al. BIBREF11,   feature vector by concatenating the tweet content features with Random Forest,  feature vector by concatenating the tweet content features with Multi-layer Perception and  feature vector by concatenating the tweet content features with Support Vector Machine.",
              "evidence": [
                "Since there is no prior work on blackmarket tweet detection, we chose state-of-the-art Twitter spam detection methods as baselines, along with training some state-of-the-art classifiers on the features we generated for our dataset.",
                "Spam Detection 1: We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.",
                "Spam Detection 2: For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset.",
                "We generate a combined feature vector by concatenating the tweet content features and the encoding generated by Tweet2Vec. This feature vector is then fed to state-of-the-art machine learning classifiers - Random Forest (RF), Multi-layer Perceptron (MLP), and Support Vector Machine (SVM)."
              ],
              "highlighted_evidence": [
                "Since there is no prior work on blackmarket tweet detection, we chose state-of-the-art Twitter spam detection methods as baselines, along with training some state-of-the-art classifiers on the features we generated for our dataset.\n\nSpam Detection 1: We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.\n\nSpam Detection 2: For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset.\n\nWe generate a combined feature vector by concatenating the tweet content features and the encoding generated by Tweet2Vec. This feature vector is then fed to state-of-the-art machine learning classifiers - Random Forest (RF), Multi-layer Perceptron (MLP), and Support Vector Machine (SVM)."
              ]
            },
            "annotation_id": "471bc581f837bc36e8337013a4181094a54536ff",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Wu et al. BIBREF4",
                "Rajdev et. al. BIBREF11"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Spam Detection 1: We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.",
                "Spam Detection 2: For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset."
              ],
              "highlighted_evidence": [
                "We use the Twitter spam detection method proposed by Wu et al. BIBREF4 .",
                "For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 ."
              ]
            },
            "annotation_id": "5d28537e058a6b4f31348ad57dc0d9876531507c",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Word2Vec and Doc2Vec to encode the tweets, then MLP classifier; Random Forest classifier on a standard set of features",
              "evidence": [
                "Spam Detection 1: We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.",
                "Spam Detection 2: For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset."
              ],
              "highlighted_evidence": [
                " We use the Twitter spam detection method proposed by Wu et al. BIBREF4 . It uses the Word2Vec and Doc2Vec models to encode the tweets into a vector representation, which is fed to a MLP classifier in order to classify the tweets as spam or not-spam. We use the same methodology to classify tweets in our dataset as blackmarket or genuine.",
                " For baseline 2, we consider the approach proposed by Rajdev et. al. BIBREF11 . They proposed flat and hierarchical classifications approaches with few of the standard set of features which can classify spam, fake and legitimate tweets. We use their experimental setup with Random Forest classifier on our dataset."
              ]
            },
            "annotation_id": "a93b0d524ae09c72ff5996e845e544d9c4dc5085",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Fig. 1. Architecture of our proposed multitask learning model for the detection of blackmarket tweets."
      },
      {
        "file": "4-TableII-1.png",
        "caption": "TABLE II PERFORMANCE OF THE COMPETING METHODS."
      }
    ]
  },
  "1909.10481": {
    "title": "Cross-Lingual Natural Language Generation via Pre-Training",
    "abstract": "In this work we focus on transferring supervision signals of natural language generation (NLG) tasks between multiple languages. We propose to pretrain the encoder and the decoder of a sequence-to-sequence model under both monolingual and cross-lingual settings. The pre-training objective encourages the model to represent different languages in the shared space, so that we can conduct zero-shot cross-lingual transfer. After the pre-training procedure, we use monolingual data to fine-tune the pre-trained model on downstream NLG tasks. Then the sequence-to-sequence model trained in a single language can be directly evaluated beyond that language (i.e., accepting multi-lingual input and producing multi-lingual output). Experimental results on question generation and abstractive summarization show that our model outperforms the machine-translation-based pipeline methods for zero-shot cross-lingual generation. Moreover, cross-lingual transfer improves NLG performance of low-resource languages by leveraging rich-resource language data. Our implementation and data are available at https://github.com/CZWin32768/xnlg.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Learning natural language generation (NLG) models heavily relies on annotated training data. However, most available datasets are collected in a single language (typically English), which restricts deploying the applications to other languages. In this work, we aim at transferring the supervision of a monolingual NLG dataset to unseen languages, so that we can boost performance for the low-resource settings.",
          "Various methods have been proposed over the years to learn universal cross-lingual word embeddings BIBREF0, BIBREF1, BIBREF2 or sentence encoders BIBREF3, BIBREF4, BIBREF5, which tries to encode multilingual texts into a single shared vector space. Despite achieving promising results on cross-lingual classification problems, cross-lingual pre-trained models purposed for NLG tasks remains relatively understudied.",
          "The cross-lingual generation problem is challenging due to the following reasons. First, it requires the models to understand multilingual input texts, and generate multilingual target sequences. So both encoder and decoder should be pre-trained together. Second, the many-to-many nature of cross-lingual NLG increases language pairs with the square of the number of languages. Third, the prediction space of cross-lingual NLG is much larger than classification tasks, which makes the knowledge transfer of decoders quite critical.",
          "Previous work mainly relies on machine translation (MT) systems to map texts to different languages. The first strand of research directly uses MT in a pipeline manner BIBREF6. For example, the input written in other languages is first translated to English, and fed into the NLG model that is trained by English data. Then the generated English text is translated back to the target language. Another strand of work employs MT to generate pseudo training data for other language pairs that are lack of annotations BIBREF7, BIBREF8. However, such methods have to use multiple MT systems, which renders them suffering from error propagation. Moreover, because the pipeline-based methods do not explicitly share the same parameter space across the languages, we can not directly transfer the task-specific supervision to other low-resource languages.",
          "In this paper, we propose a cross-lingual pre-trained model (named as Xnlg) in order to transfer monolingual NLG supervision to other pre-trained languages by fine-tuning. Specifically, Xnlg shares the same sequence-to-sequence model across languages, and is pre-trained with both monolingual and cross-lingual objectives. The model not only learns to understand multilingual input, but also is able to generate specific languages by conditioning on the encoded semantics. Figure FIGREF2 demonstrates how to use Xnlg to perform cross-lingual transfer for downstream tasks. The proposed model enables us to fine-tune the pre-trained model on monolingual NLG training data, and then evaluate it beyond a single language, including zero-shot cross-lingual generation. Besides, we explore several fine-tuning strategies to make a compromise between cross-lingual ability and task ability. In addition, we introduce two cross-lingual NLG datasets (i.e., question generation, and abstractive summarization) for evaluation, which includes three languages, namely English, Chinese, and French. Experimental results on the NLG tasks show that Xnlg achieves competitive performance compared with the machine-translation-based pipeline model in zero-shot cross-lingual settings."
        ]
      },
      {
        "section_name": "Related Work ::: Cross-Lingual NLG",
        "paragraphs": [
          "Several previous methods have been proposed for cross-lingual abstractive summarization. BIBREF7 xnhg and BIBREF8 xsummacl use translated documents or summaries as pseudo training data. BIBREF9 ncls incorporate monolingual summarization and machine translation in the training procedure to improve cross-lingual summarization. However, the systems only conduct experiments that generate summaries with different languages from the input language, rather than transferring supervision signals across all language pairs. BIBREF10 kumar2019cross introduce a cross-lingual model for question generation, which uses training data annotated in multiple languages to jointly train a sequence-to-sequence model. In contrast, our method can also be applied to zero-shot settings across languages."
        ]
      },
      {
        "section_name": "Related Work ::: Monolingual Pre-Training",
        "paragraphs": [
          "Various training objectives are designed to pretrain text encoders used for general-purpose language representations, such as language modeling BIBREF11, BIBREF12, BIBREF13, BIBREF14, BIBREF15, auto-encoding BIBREF16, and machine translation BIBREF17. Apart from pre-training encoders, several pre-trained models BIBREF18, BIBREF19 are proposed for generation tasks. In comparison, our goal is to investigate a pre-training method for cross-lingual NLG tasks."
        ]
      },
      {
        "section_name": "Related Work ::: Cross-Lingual Pre-Training",
        "paragraphs": [
          "Cross-lingual pre-training aims at building universal cross-lingual encoders that can encode multilingual sentences to a shared embedding space. BIBREF20 artetxe2018massively use the sequence encoder of the multilingual translation model BIBREF3 to produce cross-lingual sentence embeddings. However, as shown in the experiments (Section SECREF4), it is difficult to control the target language by directly fine-tuning the pre-trained translation model on downstream NLG tasks. BIBREF4 xnli propose an alignment loss function to encourage parallel sentences to have similar representations. By pre-training BERT BIBREF13 on corpora of multiple languages, it shows a surprising ability to produce cross-lingual representations BIBREF21. More recently, BIBREF5 xlm extend mask language modeling pre-training to cross-lingual settings, which shows significant improvements on cross-lingual text classification and unsupervised machine translation. By comparison, we pretrain both encoder and decoder for cross-lingual generation tasks, rather than only focusing on encoder."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "Xnlg is a pre-trained sequence-to-sequence model, which is based on Transformer BIBREF22. Both the encoder and the decoder are supposed to support multiple languages. Following BIBREF5, we use language tag embeddings to distinguish the source and target languages. Given a sentence and its corresponding language tag, Xnlg encodes the input into vector representations. By conditioning on the encoding vectors and a specific language tag, the decoder generates the output sequence in the target language. Figure FIGREF6 illustrates the pre-training objectives and the pre-training protocol designed for Xnlg."
        ]
      },
      {
        "section_name": "Methods ::: Pre-Training Tasks ::: Monolingual MLM",
        "paragraphs": [
          "The masked language modeling (MLM) BIBREF13 task, also known as the Cloze task BIBREF23, aims at predicting the randomly masked words according to their context. The objective pretrains the bidirectional encoder to obtain contextual representations. Following BIBREF13, we randomly mask 15% of the tokens in a monolingual sentence. For each masked token, we substitute it with a special token M, a random token, or the unchanged token with a probability of 0.8, 0.1, and 0.1, respectively. Let $x$ denote a sentence from the monolingual training corpus, and $M_{x}$ the set of randomly masked positions. The monolingual MLM loss is defined as: MLM(x) = -i Mxp( xi | xMx) where $x_{\\setminus M_{x}}$ is the masked version of input $x$. Notice that language tags are fed into the model for all pre-training tasks."
        ]
      },
      {
        "section_name": "Methods ::: Pre-Training Tasks ::: Denoising Auto-Encoding (DAE)",
        "paragraphs": [
          "We use the denoising auto-encoding (DAE) objective BIBREF24 to pretrain the encoder-decoder attention mechanism. Given sentence $x$ from the monolingual corpus, we use three types of noise to obtain the randomly perturbed text $\\hat{x}$. First, the word order is locally shuffled. Second, we randomly drop tokens of the sentence with a probability of $0.1$. Third, we substitute tokens with the special padding token P with a probability of $0.1$. The pre-training objective is to recover the original sentence $x$ by conditioning on $\\hat{x}$. The DAE loss is computed via: DAE(x) = -p(x|x) = -i = 1|x|p(xi | x, x<i) where $x_{<i}$ represents the tokens of previous time steps $x_1,\\cdots ,x_{i-1}$."
        ]
      },
      {
        "section_name": "Methods ::: Pre-Training Tasks ::: Cross-Lingual MLM (XMLM)",
        "paragraphs": [
          "Similar to monolingual MLM, the masked token prediction task can be extended to cross-lingual settings BIBREF5. To be specific, given a parallel corpus, we concatenate the pair of bilingual sentences $(x,y)$ to a whole sequence, and use it as the input of MLM. The language tags are also fed into the model to indicate the languages of tokens. During training, we adopt the same masking strategy as monolingual MLM. Apart from using monolingual context to predict the masked tokens, XMLM encourages the model to utilize the alignment of bilingual sentences, so that the model learns to map cross-lingual texts into a shared vector space. Similar to eq:mlm, the cross-lingual MLM loss is: XMLM(x,y) = -i Mxp( xi | xMx , yMy)",
          "-i Myp( yi | xMx , yMy) where $M_x, M_y$ represent the masked positions of $x$ and $y$, respectively."
        ]
      },
      {
        "section_name": "Methods ::: Pre-Training Tasks ::: Cross-Lingual Auto-Encoding (XAE)",
        "paragraphs": [
          "If only DAE is used as the pre-training task for the decoder, we found that the model ignores the target language tag while generating just the same language as the input, caused by the spurious correlation issue BIBREF25. In other words, the DAE loss captures the spurious correlation between the source language tag and the target sentences, but we expect the language of generated sentences can be controlled by the target language tag. To solve the above problem, we use machine translation as the cross-lingual auto-encoding (XAE) task, which decreases mutual information between the target sentences and the source language tag. XAE can be viewed as the multilingual-version DAE task in the sense that both of them recover the sentence by conditioning on the encoded representations. The cross-lingual auto-encoding loss is defined as: XAE(x,y) = -p(y|x) - p(x|y) where $(x,y)$ is a pair of sentences in the parallel corpus."
        ]
      },
      {
        "section_name": "Methods ::: Pre-Training Protocol",
        "paragraphs": [
          "As shown in Figure FIGREF6(b), we propose a two-stage pre-training protocol for Xnlg. The first stage pretrains the encoding components, where the model learns to encode multilingual sentences to a shared embedding space. We consider using MLM and XMLM as the pre-training tasks. The objective of the first stage is to minimize: 1= (x,y) p XMLM(x,y) + x m MLM(x) where ${_{\\textnormal {p}}}$ indicates the parallel corpus, and ${_{\\textnormal {m}}}$ is the monolingual corpus.",
          "Although the pre-trained encoder in the first stage enables the model to encode multilingual sentences. However, it cannot directly be used in cross-lingual NLG because: 1) encoder-decoder attention is not pre-trained; 2) the decoding algorithm is different between masked language modeling and autoregressive decoding, resulting in the mismatch between pre-training and fine-tuning. Therefore, we conduct decoding pre-training in the second stage by using DAE and XAE as the tasks. Besides, we only update decoder parameters and keep the encoder fixed. The objective of the second stage is to minimize: 2 = (x,y) pXAE(x,y) + x mDAE(x)"
        ]
      },
      {
        "section_name": "Methods ::: Fine-Tuning on Downstream NLG Tasks",
        "paragraphs": [
          "In the fine-tuning procedure, let us assume that we only have English training data for downstream NLG tasks. According to whether the target language is English, the directions of NLG can be categorized into two classes: any languages to non-English languages (Any-to-Others), and any languages to English (Any-to-English)."
        ]
      },
      {
        "section_name": "Methods ::: Fine-Tuning on Downstream NLG Tasks ::: Fine-Tuning for Any-to-Others NLG",
        "paragraphs": [
          "Ideally, the model can be fine-tuned towards a new task without losing its cross-lingual ability. However, we observe the catastrophic forgetting phenomenon of target language controllability, if we fine-tune all the model parameters for Any-to-Others NLG. So we keep the decoder and word embeddings frozen and only update the encoder parameters during fine-tuning. In practice, we found that the proposed fine-tuning method prevents the model from only decoding English words for the Any-to-Others setting."
        ]
      },
      {
        "section_name": "Methods ::: Fine-Tuning on Downstream NLG Tasks ::: Fine-Tuning for Any-to-English NLG",
        "paragraphs": [
          "For the Any-to-English NLG transfer, the decoder always generates English. So we can freeze the encoder parameters, and update the decoder parameters to retain the cross-lingual ability. As an alternative way, we can also fine-tune all the parameters to obtain the best results on the English dataset while having a slight drop in performance."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We conduct experiments over two cross-lingual NLG downstream tasks, i.e., cross-lingual question generation, and cross-lingual abstractive summarization. We compare Xnlg with state-of-the-art cross-lingual pre-trained models, and machine-translation-based pipelines."
        ]
      },
      {
        "section_name": "Experiments ::: Training Details ::: Pre-Training",
        "paragraphs": [
          "We use a pre-trained Xnlg with a 10-layer encoder and a 6-layer decoder. For every Transformer layer, we use 1024 hidden units, 8 attention heads, and GELU activations BIBREF26. In the first pre-training stage, we directly use the 15-language pre-trained XLM BIBREF5 to initialize the parameters of our encoder and decoder. In the second stage, we use Wikipedia as the monolingual data for the DAE objective, and MultiUN BIBREF27 as the parallel data for the XAE objective. The DAE loss is trained with a weight of $0.5$. We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively. Following BIBREF5, we use the tokenizer provided by BIBREF28 for Chinese, and Moses for other languages, respectively. Then the words in all languages are split with a shared subword vocabulary learned by BPE BIBREF29. We use Adam optimizer with a linear warm-up over the first 4,000 steps and linear decay for later steps, and the learning rate is set to $10^{-4}$. The pre-training batch size is 64, and the sequence length is set to 256. It takes about 30 hours to run 23,000 steps for the pre-training procedure by using 4 Nvidia Telsa V100-16GB GPUs."
        ]
      },
      {
        "section_name": "Experiments ::: Training Details ::: Fine-Tuning",
        "paragraphs": [
          "For fine-tuning on downstream NLG tasks, we use Adam optimizer with a learning rate of $5\\times 10^{-6}$. We set the batch size as 16 and 32 for question generation and abstractive summarization, respectively. When the target language is the same as the language of training data, we fine-tune all parameters. When the target language is different from the language of training data, we fine-tune the Transformer layers of the encoder. We truncate the input sentences to the first 256 tokens. During decoding, we use beam search with beam size of 3, and limit the length of the target sequence to 80 tokens."
        ]
      },
      {
        "section_name": "Experiments ::: Question Generation",
        "paragraphs": [
          "We evaluate our model on the zero-shot cross-lingual answer-aware question generation task. The goal of question generation (QG) is to generate a question that asks towards the answer with the given passage and the expected answer. In the following experiments, we extend the QG task to the cross-lingual setting. By only using English QG training data, our goal is to generate questions in English or Chinese with the given passage-answer pair in English or Chinese.",
          "We use SQuAD 1.1 BIBREF30 as the English QG dataset. It is a popular English question answering dataset containing over 100,000 questions and their corresponding annotated passages. Following BIBREF31, we regard the original development set as the test set, and sample 5000 examples from the training data of two datasets as the development sets. For Chinese QG, we follow the default data splits of WebQA BIBREF32. We regard the provided annotated evidence sentences as the input passages instead of entire documents. To construct the input sequence, we view the whole input passage as a single sentence, and concatenate the passage and the answer into one sequence with a special token S between them. During decoding Chinese, we utilize a subset of vocabulary, which is obtained from the passage sentences of the WebQA dataset."
        ]
      },
      {
        "section_name": "Experiments ::: Question Generation ::: English-English Question Generation",
        "paragraphs": [
          "We first conduct experiments on the supervised English-English QG setting. We compare our model to the following baselines:",
          "CorefNqg BIBREF33 A sequence-to-sequence model with attention mechanism and a feature-rich encoder.",
          "Mp-Gsn BIBREF31 A sequence-to-sequence model with gated self-attention and maxout pointer mechanism.",
          "Xlm BIBREF5 The current state-of-the-art cross-lingual pre-training model. We initialize the Transformer-based sequence-to-sequence model with pre-trained XLM.",
          "We evaluate models with BLEU-4 (BL-4), ROUGE (RG) and METEOR (MTR) metrics. As shown in Table TABREF16, our model outperforms the baselines, which demonstrates that our pre-trained model provides a good initialization for NLG."
        ]
      },
      {
        "section_name": "Experiments ::: Question Generation ::: Chinese-Chinese Question Generation",
        "paragraphs": [
          "We conduct experiments on the zero-shot Chinese-Chinese QG task to evaluate the cross-lingual transfer ability. In this task, models are trained with English QG data but evaluated with Chinese QG examples. We include the following models as our baselines:",
          "Xlm Fine-tuning XLM with the English QG data.",
          "Pipeline (Xlm) The pipeline of translating input Chinese sentences into English first, then performing En-En-QG with the XLM model, and finally translating back to the Chinese. We use the Transformer as the translator, which is also trained on the MultiUN dataset.",
          "Pipeline (Xlm) with Google Translator Same to Pipeline (Xlm) but using Google Translator to translate the texts.",
          "We evaluate models by both automatic evaluation metrics and human experts. The automatic metrics scores are computed by regarding each Chinese character as a token. For human evaluation, we consider three metrics for the generated questions: relatedness, fluency, and correctness, which are represented as integers ranged from 1 to 3. We randomly select 100 passage-answer pairs from the English QG test set, and use the models to generate questions. Then we present these examples to three experts to ask for the above scores. In Table TABREF17 and Table TABREF18, we present the results for the zero-shot Zh-Zh-QG. The results of monolingual supervised models are also reported in Table TABREF16 as reference. In the automatic evaluation, our model consistently performs better than baselines in both zero-shot and monolingual supervised setting. In the human evaluation, our model also obtains significant improvements in terms of relatedness and correctness."
        ]
      },
      {
        "section_name": "Experiments ::: Question Generation ::: English-Chinese Question Generation",
        "paragraphs": [
          "In the zero-shot English-Chinese question generation experiments, we use Xlm and Pipeline (Xlm) as our baselines. Pipeline (Xlm) is a pipeline method that uses En-En-QG with Xlm to generate questions, and then translates the results to Chinese. Because there is no annotations for En-Zh-QG, we perform human evaluation studies for this setting. Table TABREF19 shows the human evaluation results, where our model surpasses all the baselines especially in terms of relatedness and correctness."
        ]
      },
      {
        "section_name": "Experiments ::: Question Generation ::: Chinese-English Question Generation",
        "paragraphs": [
          "We also conduct experiments for zero-shot Chinese-English question generation, and adopt the same evaluation procedure to En-Zh-QG. Pipeline (Xlm) first translates Chinese input to English, and then conduct En-En-QG with Xlm. As shown in Table TABREF20, human evaluation results indicate that Xnlg achieves significant improvements on the three metrics."
        ]
      },
      {
        "section_name": "Experiments ::: Abstractive Summarization",
        "paragraphs": [
          "We conduct experiments on cross-lingual abstractive summarization (AS). AS is the task of converting the input sentences into summaries while preserving the key meanings. For evaluation, we use English/French/Chinese Gigaword to extract the first sentence and the headline of each article, and regard them as input document and predicted summaries, respectively. For each language, we sample 500k/5k/5k examples for training/validation/test."
        ]
      },
      {
        "section_name": "Experiments ::: Abstractive Summarization ::: Zero-Shot Summarization",
        "paragraphs": [
          "In the zero-shot setting, we only use English data for training, and directly evaluate the model on other languages. In Table TABREF22 and Table TABREF23, we present the results for French/Chinese AS, which are evaluated by the ROUGE-1, ROUGE-2 and ROUGE-L metrics. We also report the results of supervised AS in Table TABREF21 for reference. We find that Xnlg outperforms all the baseline models on both French and Chinese AS. Comparing with French, there is a larger gap between baselines and our model on zero-shot Chinese AS, which indicates that the error propagation issue is more serious on distant language pairs."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Studies ::: Effects of Pre-Training",
        "paragraphs": [
          "We conduct ablation studies for pre-training objectives, and the results can be seen in Table TABREF40. We observe that our model greatly benefits from the DAE objective for the zero-shot Chinese question generation task. The results also demonstrate that combining DAE and XAE can alleviate the spurious correlation issue and improves cross-lingual NLG."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Studies ::: Effects of Fine-Tuning Strategies",
        "paragraphs": [
          "As shown in Table TABREF41, we use the En-En-QG and Zh-Zh-QG tasks to analyze the effects of using different fine-tuning strategies. It can be observed that fine-tuning encoder parameters, our model obtain an impressive performance for both English and Chinese QG, which shows the strong cross-lingual transfer ability of our model. When fine-tuning all the parameters, the model achieves the best score for English QG, but it suffers a performance drop when evaluating on Chinese QG. We find that fine-tuning decoder hurts cross-lingual decoding, and the model learns to only decodes English words. For only fine-tuning decoder, the performance degrades by a large margin for both languages because of the underfitting issue, which indicates the necessity of fine-tuning encoder."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Studies ::: Effects of Cross-Lingual Transfer",
        "paragraphs": [
          "We examine whether low-resource NLG can benefit from cross-lingual transfer. We consider English as the rich-resource language, and conduct experiments for few-shot French/Chinese AS. Specifically, we first fine-tune Xnlg on the English AS data, and then fine-tune it on the French or Chinese AS data. We compare with the monolingual supervised model that Xnlg is only fine-tuned on the dataset of the target language. As shown in Figure FIGREF49, we can observe that the cross-lingual supervision improves performance for few-shot abstractive summarization. As the training data size becomes larger, the performance of two models is getting closer."
        ]
      },
      {
        "section_name": "Experiments ::: Case Studies",
        "paragraphs": [
          "As shown in Figure FIGREF42, we present some examples generated by Xnlg and the baselines in four directions (En-En, En-Zh, Zh-En, and Zh-Zh). When decoding on an unseen language, Xlm tends to generate random output, because it is not designed for cross-lingual NLG. In terms of the pipeline model, we can observe that it suffers from the error propagation issue, especially when the source and target languages are all different from the training data. For example, when the pipeline model performs Zh-Zh-QG, keywords are translated twice, increasing the risk of mistranslation. In the second example, \u201catomic bomb\u201d is mistranslated to \u201cnuclear bomb\u201d, resulting in its low correctness. On the contrary, by directly transferring English supervision signals to the other generation directions, the generated questions of Xnlg match the references better than baselines."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we propose a pre-training method for cross-lingual natural language generation (NLG) that can transfer monolingual NLG supervision signals to all pre-trained languages. With the pre-trained model, we achieve zero-shot cross-lingual NLG on several languages by only fine-tuning once. Experimental results show that our model outperforms the machine-translation-based pipeline model on several cross-lingual NLG tasks. For future work, we would like to improve our pre-training method towards the fully unsupervised setting."
        ]
      }
    ],
    "qas": [
      {
        "question": "What languages do they use during pretraining?",
        "question_id": "dae2f135e50d77867c3f57fc3cb0427b2443e126",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English",
                "French",
                "Chinese"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use a pre-trained Xnlg with a 10-layer encoder and a 6-layer decoder. For every Transformer layer, we use 1024 hidden units, 8 attention heads, and GELU activations BIBREF26. In the first pre-training stage, we directly use the 15-language pre-trained XLM BIBREF5 to initialize the parameters of our encoder and decoder. In the second stage, we use Wikipedia as the monolingual data for the DAE objective, and MultiUN BIBREF27 as the parallel data for the XAE objective. The DAE loss is trained with a weight of $0.5$. We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively. Following BIBREF5, we use the tokenizer provided by BIBREF28 for Chinese, and Moses for other languages, respectively. Then the words in all languages are split with a shared subword vocabulary learned by BPE BIBREF29. We use Adam optimizer with a linear warm-up over the first 4,000 steps and linear decay for later steps, and the learning rate is set to $10^{-4}$. The pre-training batch size is 64, and the sequence length is set to 256. It takes about 30 hours to run 23,000 steps for the pre-training procedure by using 4 Nvidia Telsa V100-16GB GPUs."
              ],
              "highlighted_evidence": [
                " We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively. "
              ]
            },
            "annotation_id": "2bb60ad5c14731590234adfc159ec26bfab571a4",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English",
                "Chinese",
                "French"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use a pre-trained Xnlg with a 10-layer encoder and a 6-layer decoder. For every Transformer layer, we use 1024 hidden units, 8 attention heads, and GELU activations BIBREF26. In the first pre-training stage, we directly use the 15-language pre-trained XLM BIBREF5 to initialize the parameters of our encoder and decoder. In the second stage, we use Wikipedia as the monolingual data for the DAE objective, and MultiUN BIBREF27 as the parallel data for the XAE objective. The DAE loss is trained with a weight of $0.5$. We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively. Following BIBREF5, we use the tokenizer provided by BIBREF28 for Chinese, and Moses for other languages, respectively. Then the words in all languages are split with a shared subword vocabulary learned by BPE BIBREF29. We use Adam optimizer with a linear warm-up over the first 4,000 steps and linear decay for later steps, and the learning rate is set to $10^{-4}$. The pre-training batch size is 64, and the sequence length is set to 256. It takes about 30 hours to run 23,000 steps for the pre-training procedure by using 4 Nvidia Telsa V100-16GB GPUs."
              ],
              "highlighted_evidence": [
                "We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively."
              ]
            },
            "annotation_id": "82e6e7cd1217db9fc590c3de14e1f1c77488ed57",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "English/French/Chinese"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Related Work ::: Monolingual Pre-Training",
                "We use a pre-trained Xnlg with a 10-layer encoder and a 6-layer decoder. For every Transformer layer, we use 1024 hidden units, 8 attention heads, and GELU activations BIBREF26. In the first pre-training stage, we directly use the 15-language pre-trained XLM BIBREF5 to initialize the parameters of our encoder and decoder. In the second stage, we use Wikipedia as the monolingual data for the DAE objective, and MultiUN BIBREF27 as the parallel data for the XAE objective. The DAE loss is trained with a weight of $0.5$. We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively. Following BIBREF5, we use the tokenizer provided by BIBREF28 for Chinese, and Moses for other languages, respectively. Then the words in all languages are split with a shared subword vocabulary learned by BPE BIBREF29. We use Adam optimizer with a linear warm-up over the first 4,000 steps and linear decay for later steps, and the learning rate is set to $10^{-4}$. The pre-training batch size is 64, and the sequence length is set to 256. It takes about 30 hours to run 23,000 steps for the pre-training procedure by using 4 Nvidia Telsa V100-16GB GPUs."
              ],
              "highlighted_evidence": [
                "Pre-Training\nWe use a pre-trained Xnlg with a 10-layer encoder and a 6-layer decoder. For every Transformer layer, we use 1024 hidden units, 8 attention heads, and GELU activations BIBREF26. In the first pre-training stage, we directly use the 15-language pre-trained XLM BIBREF5 to initialize the parameters of our encoder and decoder. In the second stage, we use Wikipedia as the monolingual data for the DAE objective, and MultiUN BIBREF27 as the parallel data for the XAE objective. The DAE loss is trained with a weight of $0.5$. We train a two-language (English/Chinese) and a three-language (English/French/Chinese) Xnlg for two downstream NLG tasks, respectively."
              ]
            },
            "annotation_id": "f62ac103d33c9b09217721a8f66043aab681325f",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: We use a monolingual (such as English) NLG dataset to fine-tune the pre-trained model XNLG, and then evaluate it beyond the language for both source and target sides (e.g., Chinese, and French)."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Overview of the pre-training tasks and the pre-training protocol designed for XNLG."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Human evaluation results of zero-shot Chinese-Chinese question generation. Rel is short for relatedness, Flu for fluency, and Corr for correctness. \u201c*\u201d indicates the improvements are significant at p < 0.05."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Evaluation results of monolingual supervised question generation for English and Chinese. BL is short for BLEU, MTR for METEOR, and RG for ROUGE. The results with \u201c\u2020\u201d are reported on different data splits."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Evaluation results of zero-shot ChineseChinese question generation. Same shorthands apply as in Table 1."
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Human evaluation results of zero-shot English-Chinese question generation. \u201c*\u201d indicates the improvements are significant at p < 0.05. Same shorthands apply as in Table 3."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: Human evaluation results of zero-shot Chinese-English question generation. \u201c*\u201d indicates the improvements are significant at p < 0.05. Same shorthands apply as in Table 3."
      },
      {
        "file": "6-Table7-1.png",
        "caption": "Table 7: Evaluation results of zero-shot French abstractive summarization. Same shorthands apply as in Table 1."
      },
      {
        "file": "6-Table6-1.png",
        "caption": "Table 6: Evaluation results of monolingual supervised abstractive summarization. Same shorthands apply as in Table 1."
      },
      {
        "file": "6-Table8-1.png",
        "caption": "Table 8: Evaluation results of zero-shot Chinese abstractive summarization. Same shorthands apply as in Table 1."
      },
      {
        "file": "7-Table9-1.png",
        "caption": "Table 9: Ablations for pre-training objectives, where models are evaluated on zero-shot Chinese-Chinese question generation. Same shorthands apply as in Table 1."
      },
      {
        "file": "7-Table10-1.png",
        "caption": "Table 10: Effects of different fine-tuning strategies. Dec, Enc and ET represent fine-tuning the parameters of the decoder, encoder, and Transformer layers of encoder, respectively. Same shorthands apply as in Table 1."
      },
      {
        "file": "8-Figure3-1.png",
        "caption": "Figure 3: Examples of generated questions by XNLG and the baselines in four directions (En-En,En-Zh,Zh-En and Zh-Zh). \u201c*\u201d: Because XLM is not designed for cross-lingual NLG, it is hard to produce meaningful sentences for En-Zh-QG and Zh-Zh-QG."
      },
      {
        "file": "9-Figure4-1.png",
        "caption": "Figure 4: ROUGE-2 scores for few-shot French/Chinese abstractive summarization with different training data sizes."
      }
    ]
  },
  "1805.04833": {
    "title": "Hierarchical Neural Story Generation",
    "abstract": "We explore story generation: creative systems that can build coherent and fluent passages of text about a topic. We collect a large dataset of 300K human-written stories paired with writing prompts from an online forum. Our dataset enables hierarchical story generation, where the model first generates a premise, and then transforms it into a passage of text. We gain further improvements with a novel form of model fusion that improves the relevance of the story to the prompt, and adding a new gated multi-scale self-attention mechanism to model long-range context. Experiments show large improvements over strong baselines on both automated and human evaluations. Human judges prefer stories generated by our approach to those from a strong non-hierarchical model by a factor of two to one.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Story-telling is on the frontier of current text generation technology: stories must remain thematically consistent across the complete document, requiring modeling very long range dependencies; stories require creativity; and stories need a high level plot, necessitating planning ahead rather than word-by-word generation BIBREF0 .",
          "We tackle the challenges of story-telling with a hierarchical model, which first generates a sentence called the prompt describing the topic for the story, and then conditions on this prompt when generating the story. Conditioning on the prompt or premise makes it easier to generate consistent stories because they provide grounding for the overall plot. It also reduces the tendency of standard sequence models to drift off topic.",
          "We find that standard sequence-to-sequence (seq2seq) models BIBREF1 applied to hierarchical story generation are prone to degenerating into language models that pay little attention to the writing prompt (a problem that has been noted in other domains, such as dialogue response generation BIBREF2 ). This failure is due to the complex and underspecified dependencies between the prompt and the story, which are much harder to model than the closer dependencies required for language modeling (for example, consider the subtle relationship between the first sentence and prompt in Figure FIGREF1 ).",
          "To improve the relevance of the generated story to its prompt, we introduce a fusion mechanism BIBREF3 where our model is trained on top of an pre-trained seq2seq model. To improve over the pre-trained model, the second model must focus on the link between the prompt and the story. For the first time, we show that fusion mechanisms can help seq2seq models build dependencies between their input and output.",
          "Another major challenge in story generation is the inefficiency of modeling long documents with standard recurrent architectures\u2014stories contain 734 words on average in our dataset. We improve efficiency using a convolutional architecture, allowing whole stories to be encoded in parallel. Existing convolutional architectures only encode a bounded amount of context BIBREF4 , so we introduce a novel gated self-attention mechanism that allows the model to condition on its previous outputs at different time-scales.",
          "To train our models, we gathered a large dataset of 303,358 human generated stories paired with writing prompts from an online forum. Evaluating free form text is challenging, so we also introduce new evaluation metrics which isolate different aspects of story generation.",
          "Experiments show that our fusion and self-attention mechanisms improve over existing techniques on both automated and human evaluation measures. Our new dataset and neural architectures allow for models which can creatively generate longer, more consistent and more fluent passages of text. Human judges prefer our hierarchical model's stories twice as often as those of a non-hierarchical baseline."
        ]
      },
      {
        "section_name": "Writing Prompts Dataset",
        "paragraphs": [
          "We collect a hierarchical story generation dataset from Reddit's WritingPrompts forum. WritingPrompts is a community where online users inspire each other to write by submitting story premises, or prompts, and other users freely respond. Each prompt can have multiple story responses. The prompts have a large diversity of topic, length, and detail. The stories must be at least 30 words, avoid general profanity and inappropriate content, and should be inspired by the prompt (but do not necessarily have to fulfill every requirement). Figure FIGREF1 shows an example.",
          "We scraped three years of prompts and their associated stories using the official Reddit API. We clean the dataset by removing automated bot posts, deleted posts, special announcements, comments from moderators, and stories shorter than 30 words. We use NLTK for tokenization. The dataset models full text to generate immediately human-readable stories. We reserve 5% of the prompts for a validation set and 5% for a test set, and present additional statistics about the dataset in Table TABREF4 .",
          "For our experiments, we limit the length of the stories to 1000 words maximum and limit the vocabulary size for the prompts and the stories to words appearing more than 10 times each. We model an unknown word token and an end of document token. This leads to a vocabulary size of 19,025 for the prompts and 104,960 for the stories. As the dataset is scraped from an online forum, the number of rare words and misspellings is quite large, so modeling the full vocabulary is challenging and computationally intensive."
        ]
      },
      {
        "section_name": "Approach",
        "paragraphs": [
          "The challenges of WritingPrompts are primarily in modeling long-range dependencies and conditioning on an abstract, high-level prompt. Recurrent and convolutional networks have successfully modeled sentences BIBREF5 , BIBREF4 , but accurately modeling several paragraphs is an open problem. While seq2seq networks have strong performance on a variety of problems, we find that they are unable to build stories that accurately reflect the prompts. We will evaluate strategies to address these challenges in the following sections."
        ]
      },
      {
        "section_name": "Hierarchical Story Generation",
        "paragraphs": [
          "High-level structure is integral to good stories, but language models generate on a strictly-word-by-word basis and so cannot explicitly make high-level plans. We introduce the ability to plan by decomposing the generation process into two levels. First, we generate the premise or prompt of the story using the convolutional language model from BIBREF4 . The prompt gives a sketch of the structure of the story. Second, we use a seq2seq model to generate a story that follows the premise. Conditioning on the prompt makes it easier for the story to remain consistent and also have structure at a level beyond single phrases."
        ]
      },
      {
        "section_name": "Efficient Learning with Convolutional Sequence-to-Sequence Model",
        "paragraphs": [
          "The length of stories in our dataset is a challenge for RNNs, which process tokens sequentially. To transform prompts into stories, we instead build on the convolutional seq2seq model of BIBREF6 , which uses deep convolutional networks as the encoder and decoder. Convolutional models are ideally suited to modeling long sequences, because they allow parallelism of computation within the sequence. In the Conv seq2seq model, the encoder and decoder are connected with attention modules BIBREF7 that perform a weighted sum of encoder outputs, using attention at each layer of the decoder."
        ]
      },
      {
        "section_name": "Modeling Unbounded Context with Gated Multi-Scale Self-attention",
        "paragraphs": [
          "CNNs can only model a bounded context window, preventing the modeling of long-range dependencies within the output story. To enable modeling of unbounded context, we supplement the decoder with a self-attention mechanism BIBREF8 , BIBREF9 , which allows the model to refer to any previously generated words. The self-attention mechanism improves the model's ability to extract long-range context with limited computational impact due to parallelism.",
          "Gated Attention: Similar to BIBREF9 , we use multi-head attention to allow each head to attend to information at different positions. However, the queries, keys and values are not given by linear projections but by more expressive gated deep neural nets with Gated Linear Unit BIBREF4 activations. We show that gating lends the self-attention mechanism crucial capacity to make fine-grained selections.",
          "Multi-Scale Attention: Further, we propose to have each head operating at a different time scale, depicted in Figure FIGREF7 . Thus the input to each head is downsampled a different amount\u2014the first head sees the full input, the second every other input timestep, the third every third input timestep, etc. The different scales encourage the heads to attend to different information. The downsampling operation limits the number of tokens in the attention maps, making them sharper.",
          "The output of a single attention head is given by DISPLAYFORM0 ",
          " where INLINEFORM0 contains the hidden states up to time INLINEFORM1 at layer INLINEFORM2 , and INLINEFORM3 are gated downsampling networks as shown in Figure FIGREF7 . Unlike BIBREF9 , we allow the model to optionally attend to a 0 vector at each timestep, if it chooses to ignore the information of past timesteps (see Figure FIGREF8 ). This mechanism allows the model to recover the non-self-attention architecture and avoid attending to the past if it provides only noise. Additionally, we do not allow the self-attention mechanism to attend to the current timestep, only the past."
        ]
      },
      {
        "section_name": "Improving Relevance to Input Prompt with Model Fusion",
        "paragraphs": [
          "Unlike tasks such as translation, where the semantics of the target are fully specified by the source, the generation of stories from prompts is far more open-ended. We find that seq2seq models ignore the prompt and focus solely on modeling the stories, because the local dependencies required for language modeling are easier to model than the subtle dependencies between prompt and story.",
          "We propose a fusion-based approach to encourage conditioning on the prompt. We train a seq2seq model that has access to the hidden states of a pretrained seq2seq model. Doing so can be seen as a type of boosting or residual learning that allows the second model to focus on what the first model failed to learn\u2014such as conditioning on the prompt. To our knowledge, this paper is the first to show that fusion reduces the problem of seq2seq models degenerating into language models that capture primarily syntactic and grammatical information.",
          "The cold fusion mechanism of BIBREF3 pretrains a language model and subsequently trains a seq2seq model with a gating mechanism that learns to leverage the final hidden layer of the language model during seq2seq training. We modify this approach by combining two seq2seq models as follows (see Figure FIGREF13 ): DISPLAYFORM0 ",
          " where the hidden state of the pretrained seq2seq model and training seq2seq model (represented by INLINEFORM0 ) are concatenated to learn gates INLINEFORM1 . The gates are computed using a linear projection with the weight matrix INLINEFORM2 . The gated hidden layers are combined by concatenation and followed by more fully connected layers with GLU activations (see Appendix). We use layer normalization BIBREF10 after each fully connected layer."
        ]
      },
      {
        "section_name": "Story Generation",
        "paragraphs": [
          "Sequence-to-sequence neural networks BIBREF1 have achieved state of the art performance on a variety of text generation tasks, such as machine translation BIBREF1 and summarization BIBREF11 . Recent work has applied these models to more open-ended generation tasks, including writing Wikipedia articles BIBREF12 and poetry BIBREF13 .",
          "Previous work on story generation has explored seq2seq RNN architectures BIBREF14 , but has focused largely on using various content to inspire the stories. For instance, BIBREF15 uses photos to inspire short paragraphs trained on romance novels, and BIBREF16 chain a series of independent descriptions together into a short story. BIBREF17 decompose story generation into two steps, first converting text into event representations, then modeling stories as sequences of events before translating back to natural language. Similarly, BIBREF18 generate summaries of movies as sequences of events using an RNN, then sample event representations using MCMC. They find this technique can generate text of the desired genre, but the movie plots are not interpretable (as the model outputs events, not raw text). However, we are not aware of previous work that has used hierarchical generation from a textual premise to improve the coherence and structure of stories."
        ]
      },
      {
        "section_name": "Hierarchical Text Generation",
        "paragraphs": [
          "Previous work has proposed decomposing the challenge of generating long sequences of text into a hierarchical generation task. For instance, BIBREF19 use an LSTM to hierarchically learn word, then sentence, then paragraph embeddings, then transform the paragraph embeddings into text. BIBREF20 generate a discrete latent variable based on the context, then generates text conditioned upon it."
        ]
      },
      {
        "section_name": "Fusion Models",
        "paragraphs": [
          "Previous work has investigated the integration of language models with seq2seq models. The two models can be leveraged together without architectural modifications: BIBREF21 use language models to initialize the encoder and decoder side of the seq2seq model independently, and BIBREF22 combine the predictions of the language model and seq2seq model solely at inference time. Recent work has also proposed deeper integration. BIBREF23 combined a trained language model with a trained seq2seq model to learn a gating function that joins them. BIBREF3 propose training the seq2seq model given the fixed language model then learning a gate to filter the information from the language model."
        ]
      },
      {
        "section_name": "Baselines",
        "paragraphs": [
          "We evaluate a number of baselines:",
          "(1) Language Models: Non-hierarchical models for story generation, which do not condition on the prompt. We use both the gated convolutional language (GCNN) model of BIBREF4 and our additional self-attention mechanism.",
          "(2) seq2seq: using LSTMs and convolutional seq2seq architectures, and Conv seq2seq with decoder self-attention.",
          "(3) Ensemble: an ensemble of two Conv seq2seq with self-attention models.",
          "(4) KNN: we also compare with a KNN model to find the closest prompt in the training set for each prompt in the test set. A TF-IDF vector for each prompt was created using fasttext BIBREF24 and faiss BIBREF25 was used for KNN search. The retrieved story from the training set is limited to 150 words to match the length of generated stories."
        ]
      },
      {
        "section_name": "Fusion Training",
        "paragraphs": [
          "To train the fusion model, we first pretrain a Conv seq2seq with self-attention model on the WritingPrompts dataset. This pretrained model is fixed and provided to the second Conv seq2seq with self-attention model during training time. The two models are integrated with the fusion mechanism described in Section SECREF11 ."
        ]
      },
      {
        "section_name": "Training",
        "paragraphs": [
          "We implement models with the fairseq-py library in PyTorch. Similar to BIBREF6 , we train using the Nesterov accelerated gradient method BIBREF26 using gradient clipping BIBREF27 . We perform hyperparameter optimization on each of our models by cross-validating with random search on a validation set. We provide model architectures in the appendix."
        ]
      },
      {
        "section_name": "Generation",
        "paragraphs": [
          "We generate stories from our models using a top-k random sampling scheme. At each timestep, the model generates the probability of each word in the vocabulary being the likely next word. We randomly sample from the INLINEFORM0 most likely candidates from this distribution. Then, subsequent timesteps generate words based on the previously selected words. We find this sampling strategy substantially more effective than beam search, which tends to produce common phrases and repetitive text from the training set BIBREF28 , BIBREF29 . Sentences produced by beam search tend to be short and generic. Completely random sampling can introduce very unlikely words, which can damage generation as the model has not seen such mistakes at training time. The restriction of sampling from the 10 most likely candidates reduces the risk of these low-probability samples.",
          "For each model, we tune a temperature parameter for the softmax at generation time. To ease human evaluation, we generate stories of 150 words and do not generate unknown word tokens.",
          "For prompt generation, we use a self-attentive GCNN language model trained with the same prompt-side vocabulary as the sequence-to-sequence story generation models. The language model to generate prompts has a validation perplexity of 63.06. Prompt generation is conducted using the top-k random sampling from the 10 most likely candidates, and the prompt is completed when the language model generates the end of prompt token."
        ]
      },
      {
        "section_name": "Evaluation",
        "paragraphs": [
          "We propose a number of evaluation metrics to quantify the performance of our models. Many commonly used metrics, such as BLEU for machine translation or ROUGE for summarization, compute an n-gram overlap between the generated text and the human text\u2014however, in our open-ended generation setting, these are not useful. We do not aim to generate a specific story; we want to generate viable and novel stories. We focus on measuring both the fluency of our models and their ability to adhere to the prompt.",
          "For automatic evaluation, we measure model perplexity on the test set and prompt ranking accuracy. Perplexity is commonly used to evaluate the quality of language models, and it reflects how fluently the model can produce the correct next word given the preceding words. We use prompt ranking to assess how strongly a model's output depends on its input. Stories are decoded under 10 different prompts\u20149 randomly sampled prompts and 1 true corresponding prompt\u2014and the likelihood of the story given the various prompts is recorded. We measure the percentage of cases where the true prompt is the most likely to generate the story. In our evaluation, we examined 1000 stories from the test set for each model.",
          "For human evaluation, we use Amazon Mechanical Turk to conduct a triple pairing task. We use each model to generate stories based on held-out prompts from the test set. Then, groups of three stories are presented to the human judges. The stories and their corresponding prompts are shuffled, and human evaluators are asked to select the correct pairing for all three prompts. 105 stories per model are grouped into questions, and each question is evaluated by 15 judges.",
          "Lastly, we conduct human evaluation to evaluate the importance of hierarchical generation for story writing. We use Amazon Mechanical Turk to compare the stories from hierarchical generation from a prompt with generation without a prompt. 400 pairs of stories were evaluated by 5 judges each in a blind test."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "We analyze the effect of our modeling improvements on the WritingPrompts dataset."
        ]
      },
      {
        "section_name": "Generation Quality",
        "paragraphs": [
          "Our proposed fusion model is capable of generating unique text without copying directly from the training set. When analyzing 500 150-word generated stories from test-set prompts, the average longest common subsequence is 8.9. In contrast, the baseline Conv seq2seq model copies 10.2 words on average and the KNN baseline copies all 150 words from a story in the training set.",
          "Figure FIGREF27 shows the values of the fusion gates for an example story, averaged at each timestep. The pretrained seq2seq model acts similarly to a language model producing common words and punctuation. The second seq2seq model learns to focus on rare words, such as horned and robe.",
          "However, the fusion model has limitations. Using random sampling to generate can produce errors. For example, can't is tokenized to ca n't, and the model occasionally produces the first token but misses the second. A similar error is after one line of dialogue, the model may move to another line of dialogue without generating a newline token. A further obstacle is repetition. The model focuses frequently on what it has recently produced, which leads to the generation of similar text multiple times.",
          "In the generation of prompts using the GCNN language model, we find that prompts are fairly generic compared to human prompts. Language models often struggle to model rare words accurately, as the probability distribution over the next word is dominated by more common words. This tends to produce similar prompts, particularly at the start \u2014 we see many prompts that start with the man. In contrast, many of the human prompts are very unique (e.g. prompting stories in fantasy worlds such as Harry Potter and Game of Thrones) and the language model rarely produces the specific vocabulary required by these settings."
        ]
      },
      {
        "section_name": "Use of Attention",
        "paragraphs": [
          "We analyze the encoder-decoder attention in the fusion model and find that unlike attention maps in machine translation, where each decoder timestep tends to attend to a different word on the encoder-side, the attention map for each decoder timestep looks similar and focuses mainly on salient words in the prompt. We further look at the usage of the self-attention layers within the decoder. While they could be leveraged to look at words generated very far in the past, at many timesteps the self-attention focuses on the recent past."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We have collected the first dataset for creative text generation based on short writing prompts. This new dataset pushes the boundaries of text generation by requiring longer range dependencies and conditioning on an abstract premise. Building on this dataset, we show through automatic and human evaluation that novel hierarchical models, self-attention mechanisms and model fusion significantly improves the fluency, topicality, and overall quality of the generated stories."
        ]
      },
      {
        "section_name": "GCNN Language Model + Self-Attention",
        "paragraphs": [
          "9 layers with hidden unit sizes INLINEFORM0 and convolutional kernel widths INLINEFORM1 . Learning rate 1, momentum 0.99, dropout 0.1, embedding size 300, l2 normalization INLINEFORM2 , 4 decoder self-attention heads."
        ]
      },
      {
        "section_name": "Conv seq2seq + self-attention",
        "paragraphs": [
          "3 layers in encoder with hidden unit sizes INLINEFORM0 and convolutional kernel widths INLINEFORM1 . 8 layers in the decoder with hidden unit sizes INLINEFORM2 with convolutional kernel widths INLINEFORM3 . Learning rate 0.25, momentum 0.99, dropout 0.3, embedding size 256, output embedding size 256, l2 nomalization INLINEFORM4 , 4 decoder self-attention heads."
        ]
      },
      {
        "section_name": "Ensemble: Conv seq2seq + self-attention",
        "paragraphs": [
          "Two different Conv seq2seq models were trained and ensembled together by averaging with equal weights."
        ]
      },
      {
        "section_name": "Fusion: Conv seq2seq + self-attention",
        "paragraphs": [
          "The pretrained seq2seq model is the model in Section SECREF37 . The additional fused model has the following architecture:",
          "5 layers in the encoder with hidden unit sizes INLINEFORM0 and convolutional kernel widths INLINEFORM1 . 5 layers in the decoder with hidden unit sizes INLINEFORM2 and convolutional kernel widths INLINEFORM3 . Learning rate 0.25, momentum 0.99, dropout 0.3, embedding size 256, output embedding size 256, l2 normalization INLINEFORM4 , 4 decoder self-attention heads."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they use pre-trained embeddings like BERT?",
        "question_id": "29ba93bcd99c2323d04d4692d3672967cca4915e",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "209d68f5cc3623049ac0871cbe7668cae8bd2a96",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "8ef8f9fa89b05d59c695585cfae3f43ce46e58f7",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "b55f7914cb77916231e47d6a5b5645fe18935df2",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Example prompt and beginning of a story from our dataset. We train a hierarchical model that first generates a prompt, and then conditions on the prompt when generating a story."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Statistics of WRITINGPROMPTS dataset"
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Self-Attention Mechanism of a single head, with GLU gating and downsampling. Multiple heads are concatenated, with each head using a separate downsampling function."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Multihead self-attention mechanism. The decoder layer depicted attends with itself to gate the input of the subsequent decoder layer."
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Figure 4: Diagram of our fusion model, which learns a second seq2seq model to improve a pretrained model. The separate hidden states are combined after gating through concatenation."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Effect of new attention mechanism. Gated multi-scale attention significantly improves the perplexity on the WRITINGPROMPTS dataset."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Perplexity on WRITINGPROMPTS. We dramatically improve over standard seq2seq models."
      },
      {
        "file": "6-Figure5-1.png",
        "caption": "Figure 5: Human accuracy at pairing stories with the prompts used to generate them. People find that our fusion model significantly improves the link between the prompt and generated stories."
      },
      {
        "file": "6-Figure6-1.png",
        "caption": "Figure 6: Accuracy of prompt ranking. The fusion model most accurately pairs prompt and stories."
      },
      {
        "file": "6-Figure7-1.png",
        "caption": "Figure 7: Accuracy on the prompt/story pairing task vs. number of generated stories. Our generative fusion model can produce many stories without degraded performance, while the KNN can only produce a limited number relevant stories."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Effect of Hierarchical Generation. Human judges prefer stories that were generated hierarchically by first creating a premise and creating a full story based on it with a seq2seq model."
      },
      {
        "file": "7-Figure8-1.png",
        "caption": "Figure 8: Average weighting of each model in our Fusion model for the beginning of the generated story for the prompt Gates of Hell. The fused model (orange) is primarily used for words which are closely related to the prompt, whereas generic words are generated by the pre-trained model (green)."
      },
      {
        "file": "9-Table5-1.png",
        "caption": "Table 5: Example stories generated by the proposed hierarchical fusion approach compared to stories generated by a language model. Stories generated by the fusion model relate to the desired prompt and show increased coherence between sentences and ability to stay on one topic compared to the language modeling baseline."
      }
    ]
  },
  "1805.07882": {
    "title": "Sentence Modeling via Multiple Word Embeddings and Multi-level Comparison for Semantic Textual Similarity",
    "abstract": "Different word embedding models capture different aspects of linguistic properties. This inspired us to propose a model (M-MaxLSTM-CNN) for employing multiple sets of word embeddings for evaluating sentence similarity/relation. Representing each word by multiple word embeddings, the MaxLSTM-CNN encoder generates a novel sentence embedding. We then learn the similarity/relation between our sentence embeddings via Multi-level comparison. Our method M-MaxLSTM-CNN consistently shows strong performances in several tasks (i.e., measure textual similarity, identify paraphrase, recognize textual entailment). According to the experimental results on STS Benchmark dataset and SICK dataset from SemEval, M-MaxLSTM-CNN outperforms the state-of-the-art methods for textual similarity tasks. Our model does not use hand-crafted features (e.g., alignment features, Ngram overlaps, dependency features) as well as does not require pre-trained word embeddings to have the same dimension.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Measuring the semantic similarity/relation of two pieces of short text plays a fundamental role in a variety of language processing tasks (i.e., plagiarism detection, question answering, and machine translation). Semantic textual similarity (STS) task is challenging because of the diversity of linguistic expression. For example, two sentences with different lexicons could have a similar meaning. Moreover, the task requires to measure similarity at several levels (e.g., word level, phrase level, sentence level). These challenges give difficulties to conventional approaches using hand-crafted features.",
          "Recently, the emergence of word embedding techniques, which encode the semantic properties of a word into a low dimension vector, leads to the successes of many learning models in natural language processing (NLP). For example, BIBREF0 randomly initialize word vectors, then tunes them during the training phase of a sentence classification task. By contrast, BIBREF1 initialize word vectors via the pre-train word2vec model trained on Google News BIBREF2 . BIBREF3 train a word embedding model on the paraphrase dataset PPDB, then apply the word representation for word and bi-gram similarity tasks.",
          "Several pre-trained word embeddings are available, which are trained on various corpora under different models. BIBREF4 observed that different word embedding models capture different aspects of linguistic properties: a Bag-of-Words contexts based model tends to reflect the domain aspect (e.g., scientist and research) while a paraphrase-relationship based model captures semantic similarities of words (e.g., boy and kid). From experiments, we also observed that the performance of a word embedding model is usually inconsistent over different datasets. This inspired us to develop a model taking advantages of various pre-trained word embeddings for measuring textual similarity/relation.",
          "In this paper, we propose a convolutional neural network (CNN) to learn a multi-aspect word embedding from various pre-trained word embeddings. We then apply the max-pooling scheme and Long Short Term Memory (LSTM) on this embedding to form a sentence representation. In STS tasks, BIBREF5 shows the efficiency of the max-pooling scheme in modeling sentences from word embedding representations refined via CNN. However, the max-pooling scheme lacks the property of word order (e.g., sentence(\u201cBob likes Marry\u201d) = sentence(\u201cMarry likes Bob\u201d)). To address this weakness, we use LSTM as an additional scheme for modeling sentences with word order characteristics. For measuring the similarity/relation between two sentence representations, we propose Multi-level comparison which consists of word-word level, sentence-sentence level, and word-sentence level. Through these levels, our model comprehensively evaluates the similarity/relation between two sentences.",
          "We evaluate our M-MaxLSTM-CNN model on three tasks: STS, textual entailment recognition, paraphrase identification. The advantages of M-MaxLSTM-CNN are: i) simple but efficient for combining various pre-trained word embeddings with different dimensions; ii) using Multi-level comparison shows better performances compared to using only sentence-sentence comparison; iii) does not require hand-crafted features (e.g., alignment features, Ngram overlaps, syntactic features, dependency features) compared to the state-of-the-art ECNU BIBREF6 on STS Benchmark dataset.",
          "Our main contributions are as follows:",
          "The remainder of this paper is organized as follows: Section 2 reviews the previous research, Section 3 introduces the architecture of our model, Section 4 describes the three tasks and datasets, Section 5 describes the experiment setting, Section 6 reports and discusses the results of the experiments, and Section 7 concludes our work."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Most prior research on modeling textual similarity relied on feature engineering. BIBREF7 extract INLINEFORM0 -gram overlap features and dependency-based features, while BIBREF8 employ features based on machine translation metrics. BIBREF9 propose a method using corpus-based and knowledge-based measures of similarity. BIBREF10 design a model which incorporates both syntax and lexical semantics using dependency grammars. BIBREF11 combine the fine-grained n-gram overlap features with the latent representation from matrix factorization. BIBREF12 develop a latent variable model which jointly learns paraphrase relations between word and sentence pairs. Using Dependency trees, BIBREF13 propose a robust monolingual aligner and successfully applied it for STS tasks.",
          "The recent emergence of deep learning models has provided an efficient way to learn continuous vectors representing words/sentences. By using a neural network in the context of a word prediction task, BIBREF14 and BIBREF15 generate word embedding vectors carrying semantic meanings. The embedding vectors of words which share similar meanings are close to each other. To capture the morphology of words, BIBREF16 enrich the word embedding with character n-grams information. Closest to this approach, BIBREF17 also propose to represent a word or sentence using a character n-gram count vector. However, the objective function for learning these embeddings is based on paraphrase pairs.",
          "For modeling sentences, composition approach attracted many studies. BIBREF18 model each word as a matrix and used iterated matrix multiplication to present a phrase. BIBREF19 design a Dependency Tree-Structured LSTM for modeling sentences. This model outperforms the linear chain LSTM in STS tasks. Convolutional neural network (CNN) has recently been applied efficiently for semantic composition BIBREF0 , BIBREF20 , BIBREF5 . This technique uses convolutional filters to capture local dependencies in term of context windows and applies a pooling layer to extract global features. BIBREF21 use CNN to extract features at multiple level of granularity. The authors then compare their sentence representations via multiple similarity metrics at several granularities. BIBREF22 propose a hierarchical CNN-LSTM architecture for modeling sentences. In this approach, CNN is used as an encoder to encode an sentence into a continuous representation, and LSTM is used as a decoder. BIBREF23 train a sentence encoder on a textual entailment recognition database using a BiLSTM-Maxpooling network. This encoder achieves competitive results on a wide range of transfer tasks.",
          "At SemEval-2017 STS task, hybrid approaches obtain strong performances. BIBREF24 train a linear regression model with WordNet, alignment features and the word embedding word2vec. BIBREF6 develop an ensemble model with multiple boosting techniques (i.e., Random Forest, Gradient Boosting, and XGBoost). This model incorporates traditional features (i.e., n-gram overlaps, syntactic features, alignment features, bag-of-words) and sentence modeling methods (i.e., Averaging Word Vectors, Projecting Averaging Word Vectors, LSTM).",
          "MVCNN model BIBREF25 and MGNC-CNN model BIBREF26 are close to our approach. In MVCNN, the authors use variable-size convolution filters on various pre-trained word embeddings for extracting features. However, MVCNN requires word embeddings to have the same size. In MGNC-CNN, the authors apply independently CNN on each pre-trained word embedding for extracting features and then concatenate these features for sentence classification. By contrast, our M-MaxLSTM-CNN model jointly applies CNN on all pre-trained word embeddings to learn a multi-aspect word embedding. From this word representation, we encode sentences via the max-pooling and LSTM. To learn the similarity/relation between two sentences, we employ Multi-level comparison."
        ]
      },
      {
        "section_name": "Model description",
        "paragraphs": [
          "Our model (shown in Figure FIGREF4 ) consists of three main components: i) learning a multi-aspect word embedding (Section 3.1); ii) modeling sentences from this embedding (Section 3.2); iii) measuring the similarity/relation between two sentences via Multi-level comparison (section 3.3)."
        ]
      },
      {
        "section_name": "Multi-aspect word embedding",
        "paragraphs": [
          "Given a word INLINEFORM0 , we transfer it into a word vector INLINEFORM1 via INLINEFORM2 pre-trained word embeddings as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is concatenation operator, INLINEFORM1 is the word embedding vector of INLINEFORM2 in the INLINEFORM3 th pre-trained embedding.",
          "To learn a multi-aspect word embedding INLINEFORM0 from the representation INLINEFORM1 , we design INLINEFORM2 convolutional filters. Each filter INLINEFORM3 is denoted as a weight vector with the same dimension as INLINEFORM4 and a bias value INLINEFORM5 . The INLINEFORM6 is obtained by applying these filters on the INLINEFORM7 as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 denotes a logistic sigmoid function.",
          "The next section explains how to model a sentence from its multiple-aspect word embeddings."
        ]
      },
      {
        "section_name": "Sentence modeling",
        "paragraphs": [
          "Given an input sentence INLINEFORM0 , we obtain a sequence of multiple-aspect word embeddings INLINEFORM1 using Eq. (1-3). For modeling the sentence from the representation INLINEFORM2 , we use two schemes: max-pooling and LSTM.",
          "Max-pooling scheme: To construct a max-pooling sentence embedding INLINEFORM0 , the most potential features are extracted from the representation INLINEFORM1 as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is the INLINEFORM1 th element of INLINEFORM2 .",
          "LSTM scheme: From Eq. (4), we find that the max-pooling scheme ignores the property of word order. Therefore, we construct a LSTM sentence embedding INLINEFORM0 to support the sentence embedding INLINEFORM1 . The representation INLINEFORM2 is transformed to a fix-length vector by recursively applying a LSTM unit to each input INLINEFORM3 and the previous step INLINEFORM4 . At each time step INLINEFORM5 , the LSTM unit with INLINEFORM6 -memory dimension defines six vectors in INLINEFORM7 : input gate INLINEFORM8 , forget gate INLINEFORM9 , output gate INLINEFORM10 , tanh layer INLINEFORM11 , memory cell INLINEFORM12 and hidden state INLINEFORM13 as follows (from BIBREF19 ): DISPLAYFORM0 DISPLAYFORM1 ",
          " where INLINEFORM0 respectively denote a logistic sigmoid function and element-wise multiplication; INLINEFORM1 are respectively two weights matrices and a bias vector for input gate INLINEFORM2 . The denotation is similar to forget gate INLINEFORM3 , output gate INLINEFORM4 , tanh layer INLINEFORM5 , memory cell INLINEFORM6 and hidden state INLINEFORM7 .",
          "Finally, the sentence embedding INLINEFORM0 is obtained by concatenating the two sentence embeddings INLINEFORM1 and INLINEFORM2 : DISPLAYFORM0 "
        ]
      },
      {
        "section_name": "Multi-level comparison",
        "paragraphs": [
          "In this section, we describe the process for evaluating the similarity/relation between two sentences. We compare two sentences via three levels: word-word, sentence-sentence and word-sentence.",
          "Given two input sentences INLINEFORM0 and INLINEFORM1 , we encode them into two sequences of multi-aspect word embeddings INLINEFORM2 and INLINEFORM3 (Section 3.2). We then compute a word-word similarity vector INLINEFORM4 as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 is the INLINEFORM1 th multi-aspect word embedding of sentence INLINEFORM2 ; INLINEFORM3 is a function to flatten a matrix into a vector; and INLINEFORM4 and INLINEFORM5 are respectively a weight matrix and a bias parameter.",
          "Given two input sentences INLINEFORM0 and INLINEFORM1 , we encode them into two sentence embeddings INLINEFORM2 and INLINEFORM3 (Section 3.1 and 3.2). To compute the similarity/relation between the two embeddings, we introduce four comparison metrics:",
          "Cosine similarity: DISPLAYFORM0 ",
          "Multiplication vector & Absolute difference: DISPLAYFORM0 ",
          " where INLINEFORM0 is element-wise multiplication.",
          "Neural difference: DISPLAYFORM0 ",
          " where INLINEFORM0 and INLINEFORM1 are respectively a weight matrix and a bias parameter.",
          "As a result, we have a sentence-sentence similarity vector INLINEFORM0 as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 and INLINEFORM1 are respectively a weight matrix and a bias parameter.",
          "Given a sentence embedding INLINEFORM0 and a sequence of multi-aspect word embeddings INLINEFORM1 , we compute a word-sentence similarity matrix INLINEFORM2 as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 is the multi-aspect word embedding of the INLINEFORM1 th word in sentence INLINEFORM2 ; INLINEFORM3 and INLINEFORM4 are respectively a weight matrix and a bias parameter.",
          "As a result, we have a word-sentence similarity vector INLINEFORM0 for the two sentences as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is a function to flatten a matrix into a vector; INLINEFORM1 and INLINEFORM2 are respectively a weight matrix and a bias parameter.",
          "Finally, we compute a target score/label of a sentence pair as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 , INLINEFORM1 , INLINEFORM2 and INLINEFORM3 are model parameters; INLINEFORM4 is a predicted target score/label."
        ]
      },
      {
        "section_name": "Tasks & Datasets",
        "paragraphs": [
          "We evaluate our model on three tasks:",
          "Table TABREF30 shows the statistic of the three datasets. Because of not dealing with name entities and multi-word idioms, the vocabulary size of SICK is quite small compared to the others."
        ]
      },
      {
        "section_name": "Pre-trained word embeddings",
        "paragraphs": [
          "We study five pre-trained word embeddings for our model:",
          "word2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.",
          "fastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.",
          "GloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).",
          "Baroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.",
          "SL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
        ]
      },
      {
        "section_name": "Model configuration",
        "paragraphs": [
          "In all of the tasks, we used the same model configuration as follows:",
          "Convolutional filters: we used 1600 filters. It is also the dimension of the word embedding concatenated from the five pre-trained word embeddings.",
          "LSTM dimension: we also selected 1600 for LSTM dimension.",
          "Neural similarity layers: the dimension of INLINEFORM0 , INLINEFORM1 , INLINEFORM2 and INLINEFORM3 are respectively 50, 5, 5 and 100.",
          "Penultimate fully-connected layer: has the dimension of 250 and is followed by a drop-out layer ( INLINEFORM0 ).",
          "We conducted a grid search on 30% of STSB dataset to select these optimal hyper-parameters."
        ]
      },
      {
        "section_name": "Training Setting",
        "paragraphs": [
          "In these tasks, we use the cross-entropy objective function and employ AdaDelta as the stochastic gradient descent (SGD) update rule with mini-batch size as 30. Details of Adadelta method can be found in BIBREF28 . During the training phase, the pre-trained word embeddings are fixed.",
          "To compute a similarity score of a sentence pair in the range INLINEFORM0 , where INLINEFORM1 is an integer, we replace Eq. (27) with the equations in BIBREF19 as follows: DISPLAYFORM0 ",
          " where INLINEFORM0 , INLINEFORM1 , INLINEFORM2 and INLINEFORM3 are parameters; INLINEFORM4 ; INLINEFORM5 is a predicted similarity score.",
          "A sparse target distribution INLINEFORM0 which satisfies INLINEFORM1 is computed as: DISPLAYFORM0 ",
          "for INLINEFORM0 , and INLINEFORM1 is the similarity score.",
          "To train the model, we minimize the regularized KL-divergence between INLINEFORM0 and INLINEFORM1 : DISPLAYFORM0 ",
          "where INLINEFORM0 is the number of training pairs and INLINEFORM1 denotes the model parameters. The gradient descent optimization Adadelta is used to learn the model parameters. We also use mini-batch size as 30 and keep the pre-trained word embeddings fixed during the training phase. We evaluate our models through Pearson correlation INLINEFORM2 ."
        ]
      },
      {
        "section_name": "Experiments and Discussion",
        "paragraphs": [
          "This section describes two experiments: i) compare our model against recent systems; ii) evaluate the efficiency of using multiple pre-trained word embeddings."
        ]
      },
      {
        "section_name": "Overall evaluation",
        "paragraphs": [
          "Besides existing methods, we also compare our model with several sentence modeling approaches using multiple pre-trained word embeddings:",
          "Word Average: DISPLAYFORM0 ",
          "where INLINEFORM0 is the sentence embedding of a INLINEFORM1 -words sentence, and INLINEFORM2 is from Eq. (1)",
          "Project Average: DISPLAYFORM0 ",
          "where INLINEFORM0 is a INLINEFORM1 weight matrix, and INLINEFORM2 is a 1600 bias vector.",
          "LSTM: apply Eq. (5-11) on INLINEFORM0 to construct the 1600-dimension INLINEFORM1 sentence embedding.",
          "Max-CNN: apply Eq. (2-4) on INLINEFORM0 to construct the 1600-dimension INLINEFORM1 sentence embedding.",
          "We report the results of these methods in Table TABREF49 . Overall, our M-MaxLSTM-CNN shows competitive performances in these tasks. Especially in the STS task, M-MaxLSTM-CNN outperforms the state-of-the-art methods on the two datasets. Because STSB includes complicated samples compared to SICK, the performances of methods on STSB are quite lower. In STSB, the prior top performance methods use ensemble approaches mixing hand-crafted features (word alignment, syntactic features, N-gram overlaps) and neural sentence representations, while our approach is only based on a neural sentence modeling architecture. In addition, we observed that InferSent shows the strong performance on SICK-R but quite low on STSB while our model consistently obtains the strong performances on both of the datasets. InferSent uses transfer knowledge on textual entailment data, consequently it obtains the strong performance on this entailment task.",
          "According to BIBREF31 , using Word Average as the compositional architecture outperforms the other architectures (e.g., Project Average, LSTM) for STS tasks. In a multiple word embeddings setting, however, Word Average does not show its efficiency. Each word embedding model has its own architecture as well as objective function. These factors makes the vector spaces of word embeddings are different. Therefore, we intuitively need a step to learn or refine a representation from a set of pre-trained word embeddings rather than only averaging them. Because Project Average model, LSTM model and Max-CNN model have their parameters for learning sentence embeddings, they significantly outperform Word Average model.",
          "We observed that MaxLSTM-CNN outperforms Max-CNN in both of the settings (i.e., sentence-sentence comparison, Multi-level comparison). As mentioned in Section 1, Max-CNN ignores the property of word order. Therefore, our model achieves improvement compared to Max-CNN by additionally employing LSTM for capturing this property.",
          "We only applied Multi-level comparison on Max-CNN and MaxLSTM-CNN because these encoders generate multi-aspect word embeddings. The experimental results prove the efficiency of using Multi-level comparison. In the textual entailment dataset SICK-E, the task mainly focuses on interpreting the meaning of a whole sentence pair rather than comparing word by word. Therefore, the performance of Multi-level comparison is quite similar to sentence-sentence comparison in the SICK-E task. This is also the reason why LSTM, which captures global relationships in sentences, has the strong performance in this task."
        ]
      },
      {
        "section_name": "Evaluation of exploiting multiple pre-trained word embeddings",
        "paragraphs": [
          "In this section, we evaluate the efficiency of using multiple pre-trained word embeddings. We compare our multiple pre-trained word embeddings model against models using only one pre-trained word embedding. The same objective function and Multi-level comparison are applied for these models. In case of using one pre-trained word embedding, the dimension of LSTM and the number of convolutional filters are set to the length of the corresponding word embedding. Table TABREF57 shows the experimental results of this comparison. Because the approach using five word embeddings outperforms the approaches using two, three, or four word embeddings, we only report the performance of using five word embeddings. We also report INLINEFORM0 which is the proportion of vocabulary available in a pre-trained word embedding. SICK dataset ignores idiomatic multi-word expressions, and named entities, consequently the INLINEFORM1 of SICK is quite high.",
          "We observed that no word embedding has strong results on all the tasks. Although trained on the paraphrase database and having the highest INLINEFORM0 , the SL999 embedding could not outperform the Glove embedding in SICK-R. HCTI BIBREF5 , which is the current state-of-the-art in the group of neural representation models on STSB, also used the Glove embedding. However, the performance of HTCI in STSB ( INLINEFORM1 ) is lower than our model using the Glove embedding. In SICK-R, InferSent BIBREF23 achieves a strong performance ( INLINEFORM2 ) using the Glove embedding with transfer knowledge, while our model with only the Glove embedding achieves a performance close to the performance of InferSent. These results confirm the efficiency of Multi-level comparison.",
          "In STSB and MRPC, as employing the five pre-trained embeddings, the INLINEFORM0 is increased. This factor limits the number of random values when initializing word embedding representations because a word out of a pre-trained word embedding is assigned a random word embedding representation. In other words, a word out of a pre-trained word embedding is assigned a random semantic meaning. Therefore, the increase of the INLINEFORM1 improves the performance of measuring textual similarity. In STSB and MRPC, our multiple pre-trained word embedding achieves a significant improvement in performance compared against using one word embedding. In SICK-R and SICK-E, although the INLINEFORM2 is not increased when employing five pre-trained embeddings, the performance of our model is improved. This fact shows that our model learned an efficient word embedding via these pre-trained word embeddings."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this work, we study an approach employing multiple pre-trained word embeddings and Multi-level comparison for measuring semantic textual relation. The proposed M-MaxLSTM-CNN architecture consistently obtains strong performances on several tasks. Compared to the state-of-the art methods in STS tasks, our model does not require handcrafted features (e.g., word alignment, syntactic features) as well as transfer learning knowledge. In addition, it allows using several pre-trained word embeddings with different dimensions.",
          "Future work could apply our multiple word embeddings approach for transfer learning tasks. This strategy allows making use of pre-trained word embeddings as well as available resources."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This work was done while Nguyen Tien Huy was an intern at Toshiba Research Center."
        ]
      }
    ],
    "qas": [
      {
        "question": "which pretrained embeddings were experimented with?",
        "question_id": "3eb107f35f4f5f5f527a93ffb487aa2e3fe51efd",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "word2vec ",
                "fastText ",
                "GloVe ",
                "Baroni ",
                "SL999 "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We study five pre-trained word embeddings for our model:",
                "word2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.",
                "fastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.",
                "GloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).",
                "Baroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.",
                "SL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ],
              "highlighted_evidence": [
                "We study five pre-trained word embeddings for our model:\n\nword2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.\n\nfastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.\n\nGloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).\n\nBaroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.\n\nSL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ]
            },
            "annotation_id": "517a767308accfd20fea719876112e44444c3d25",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "word2vec",
                "fastText",
                "GloVe",
                "Baroni",
                "SL999"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We study five pre-trained word embeddings for our model:",
                "word2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.",
                "GloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).",
                "Baroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.",
                "fastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.",
                "SL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ],
              "highlighted_evidence": [
                "We study five pre-trained word embeddings for our model:\n\nword2vec is trained on Google News dataset (100 billion tokens). ",
                "GloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).",
                "Baroni uses a context-predict approach to learn a 400-dimensional semantic embedding model.",
                "fastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.",
                "SL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ]
            },
            "annotation_id": "8c9bb4e0f2193dee2e1b9a7c819b54935eca7328",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "word2vec",
                "fastText",
                "GloVe",
                "Baroni",
                "SL999"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We study five pre-trained word embeddings for our model:",
                "word2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.",
                "fastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.",
                "GloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).",
                "Baroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.",
                "SL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ],
              "highlighted_evidence": [
                "We study five pre-trained word embeddings for our model:\n\nword2vec is trained on Google News dataset (100 billion tokens). The model contains 300-dimensional vectors for 3 million words and phrases.\n\nfastText is learned via skip-gram with subword information on Wikipedia text. The embedding representations in fastText are 300-dimensional vectors.\n\nGloVe is a 300-dimensional word embedding model learned on aggregated global word-word co-occurrence statistics from Common Crawl (840 billion tokens).\n\nBaroni uses a context-predict approach to learn a 400-dimensional semantic embedding model. It is trained on 2.8 billion tokens constructed from ukWaC, the English Wikipedia and the British National Corpus.\n\nSL999 is trained under the skip-gram objective with negative sampling on word pairs from the paraphrase database PPDB. This 300-dimensional embedding model is tuned on SimLex-999 dataset BIBREF27 ."
              ]
            },
            "annotation_id": "d3e44a72f50eb967a67c0864a90237cac33aa41b",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: The proposed M-MaxLSTM-CNN model: (a) MaxLSTM-CNN encoder; (b) Multi-level comparison."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Statistic of datasets. |V |, l denote the vocabulary size, and the average length of sentences respectively."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Test set results with Pearson\u2019s r score\u00d7100 for STS tasks, and accuracy for other tasks. Boldface values show the highest scores in each dataset. SICK-R and SICK-E denote the STS task and the entailment task in SICK dataset respectively."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: Evaluation of exploiting multiple pre-trained word embeddings. |V |avai is the proportion of vocabulary available in a word embedding. In case of using all word embeddings, |V |avai denotes the proportion of vocabulary where each word is available in at least one word embedding."
      }
    ]
  },
  "2004.01820": {
    "title": "Aggressive, Repetitive, Intentional, Visible, and Imbalanced: Refining Representations for Cyberbullying Classification",
    "abstract": "Cyberbullying is a pervasive problem in online communities. To identify cyberbullying cases in large-scale social networks, content moderators depend on machine learning classifiers for automatic cyberbullying detection. However, existing models remain unfit for real-world applications, largely due to a shortage of publicly available training data and a lack of standard criteria for assigning ground truth labels. In this study, we address the need for reliable data using an original annotation framework. Inspired by social sciences research into bullying behavior, we characterize the nuanced problem of cyberbullying using five explicit factors to represent its social and linguistic aspects. We model this behavior using social network and language-based features, which improve classifier performance. These results demonstrate the importance of representing and modeling cyberbullying as a social phenomenon.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Cyberbullying poses a serious threat to the safety of online communities. The Centers for Disease Control and Prevention (CDC) identify cyberbullying as a \u201cgrowing public health problem in need of additional research and prevention efforts\u201d BIBREF0. Cyberbullying has been linked to negative mental health outcomes, including depression, anxiety, and other forms of self-harm, suicidal ideation, suicide attempts, and difficulties with social and emotional processing BIBREF1, BIBREF2, BIBREF3. Where traditional bullying was once limited to a specific time and place, cyberbullying can occur at any hour and from any location on earth BIBREF4. Once the first message has been sent, the attack can escalate rapidly as harmful content is spread across shared media, compounding these negative effects BIBREF5, BIBREF6.",
          "Internet users depend on content moderators to flag abusive text and ban cyberbullies from participating in online communities. However, due to the overwhelming volume of social media data produced every day, manual human moderation is often unfeasible. For this reason, social media platforms are beginning to rely instead on machine learning classifiers for automatic cyberbullying detection BIBREF7.",
          "The research community has developed increasingly competitive classifiers to detect harmful or aggressive content in text. Despite significant progress in recent years, however, existing models remain unfit for real-world applications. This is due, in part, to shortcomings in the training and testing data BIBREF8, BIBREF9, BIBREF10. Most annotation schemes have ignored the importance of social context, and researchers have neglected to provide annotators with objective criteria for distinguishing cyberbullying from other crude messages.",
          "To address the urgent need for reliable data, we provide an original annotation framework and an annotated Twitter dataset. The key advantages to our labeling approach are:",
          "[leftmargin=.2in]",
          "Contextually-informed ground truth. We provide annotators with the social context surrounding each message, including the contents of the reply thread and the account information of each user involved.",
          "Clear labeling criteria. We ask annotators to provide labels for five clear cyberbullying criteria. These criteria can be combined and adapted for revised definitions of cyberbullying.",
          "Using our new dataset, we experiment with existing NLP features and compare results with a newly-proposed set of features. We designed these features to encode the dynamic relationship between a potential bully and victim, using comparative measures from their relative linguistic and social network profiles. Additionally, our features have low computational complexity, so they can scale to internet-scale datasets, unlike expensive network centrality and clustering measurements.",
          "Results from our experiments suggest that, although existing NLP models can reliably detect aggressive language in text, these lexically-trained classifiers will fall short of the more subtle goal of cyberbullying detection. With $n$-grams and dictionary-based features, classifiers prove unable to detect harmful intent, visibility among peers, power imbalance, or the repetitive nature of aggression with sufficiently high precision and recall. However, our proposed feature set improves $F_1$ scores on all four of these social measures. Real-world detection systems can benefit from our proposed approach, incorporating the social aspects of cyberbullying into existing models and training these models on socially-informed ground truth labels."
        ]
      },
      {
        "section_name": "Background",
        "paragraphs": [
          "Existing approaches to cyberbullying detection generally follow a common workflow. Data is collected from social networks or other online sources, and ground truth is established through manual human annotation. Machine learning algorithms are trained on the labeled data using the message text or hand-selected features. Then results are typically reported using precision, recall, and $F_1$ scores. Comparison across studies is difficult, however, because the definition of cyberbullying has not been standardized. Therefore, an important first step for the field is to establish an objective definition of cyberbullying."
        ]
      },
      {
        "section_name": "Background ::: Defining Cyberbullying",
        "paragraphs": [
          "Some researchers view cyberbullying as an extension of more \u201ctraditional\u201d bullying behaviors BIBREF16, BIBREF17, BIBREF18. In one widely-cited book, the psychologist Dan Olweus defines schoolyard bullying in terms of three criteria: repetition, harmful intent, and an imbalance of power BIBREF19. He then identifies bullies by their intention to \u201cinflict injury or discomfort\u201d upon a weaker victim through repeated acts of aggression.",
          "Social scientists have extensively studied this form of bullying as it occurs among adolescents in school BIBREF20, BIBREF21. However, experts disagree whether cyberbullying should be studied as a form of traditional bullying or a fundamentally different phenomenon BIBREF20, BIBREF17. Some argue that, although cyberbullying might involve repeated acts of aggression, this condition might not necessarily hold in all cases, since a single message can be otherwise forwarded and publicly viewed without repeated actions from the author BIBREF22, BIBREF5. Similarly, the role of power imbalance is uncertain in online scenarios. Power imbalances of physical strength or numbers may be less relevant, whereas bully anonymity and the permanence of online messages may be sufficient to render the victim defenseless BIBREF23.",
          "The machine learning community has not reached a unanimous definition of cyberbullying either. They have instead echoed the uncertainty of the social scientists. Moreover, some authors have neglected to publish any objective cyberbullying criteria or even a working definition for their annotators, and among those who do, the formulation varies. This disagreement has slowed progress in the field, since classifiers and datasets cannot be as easily compared. Upon review, however, we found that all available definitions contained a strict subset of the following criteria: aggression (aggr), repetition (rep), harmful intent (harm), visibility among peers (peer), and power imbalance (power). The datasets built from these definitions are outlined in Table TABREF1."
        ]
      },
      {
        "section_name": "Background ::: Existing Sources of Cyberbullying Data",
        "paragraphs": [
          "According to BIBREF7, data collection is the most restrictive \u201cbottleneck\u201d in cyberbullying research. Because there are very few publicly available datasets, some researchers have turned to crowdsourcing using Amazon Mechanical Turk or similar platforms.",
          "In most studies to date, annotators labeled individual messages instead of message threads, ignoring social context altogether BIBREF11, BIBREF13, BIBREF24, BIBREF14, BIBREF25, BIBREF15. Only three of the papers that we reviewed incorporated social context in the annotation process. BIBREF4 considered batches of time-sorted tweets called sessions, which were grouped by user accounts, but they did not include message threads or any other form of context. BIBREF7 presented \u201coriginal conversation[s] when possible,\u201d but they did not explain when this information was available. BIBREF8 was the only study to label full message reply threads as they appeared in the original online source."
        ]
      },
      {
        "section_name": "Background ::: Modeling Cyberbullying Behavior",
        "paragraphs": [
          "A large body of work has been published on cyberbullying detection and prediction, primarily through the use of natural language processing techniques. Most common approaches have relied on lexical features such as $n$-grams BIBREF8, BIBREF7, BIBREF26, TF-IDF vectors BIBREF27, BIBREF28, BIBREF15, word embeddings BIBREF29, or phonetic representations of messages BIBREF30, as well as dictionary-based counts on curse words, hateful or derogatory terms, pronouns, emoticons, and punctuation BIBREF11, BIBREF31, BIBREF14, BIBREF25. Some studies have also used message sentiment BIBREF25, BIBREF15, BIBREF7 or the age, gender, personality, and psychological state of the message author according to text from their timelines BIBREF11, BIBREF31. These methods have been reported with appreciable success as shown in Table TABREF8.",
          "Some researchers argue, however, that lexical features alone may not adequately represent the nuances of cyberbullying. BIBREF12 found that among Instagram media sessions containing profane or vulgar content, only 30% were acts of cyberbullying. They also found that while cyberbullying posts contained a moderate proportion of negative terms, the most negative posts were not considered cases of cyberbullying by the annotators. Instead, these negative posts referred to politics, sports, and other domestic matters between friends BIBREF12.",
          "The problem of cyberbullying cuts deeper than merely the exchange of aggressive language. The meaning and intent of an aggressive post is revealed through conversation and interaction between peers. Therefore, to properly distinguish cyberbullying from other uses of aggressive or profane language, future studies should incorporate key indicators from the social context of each message. Specifically, researchers can measure the author's status or social advantage, the author's harmful intent, the presence of repeated aggression in the thread, and the visibility of the thread among peers BIBREF12, BIBREF10, BIBREF9.",
          "Since cyberbullying is an inherently social phenomenon, some studies have naturally considered social network measures for classification tasks. Several features have been derived from the network representations of the message interactions. The degree and eigenvector centralities of nodes, the $k$-core scores, and clustering of communities, as well as the tie strength and betweenness centralities of mention edges have all been shown to improve text-based models BIBREF13, BIBREF25. Additionally, bullies and victims can be more accurately identified by their relative network positions. For example, the Jaccard coefficient between neighborhood sets in bully and victim networks has been found to be statistically significant BIBREF32. The ratio of all messages sent and received by each user was also significant.",
          "These findings show promising directions for future work. Social network features may provide the information necessary to reliably classify cyberbullying. However, it may be prohibitively expensive to build out social networks for each user due to time constraints and the limitations of API calls BIBREF33. For this reason, alternative measurements of online social relationships should be considered.",
          "In the present study, we leverage prior work by incorporating linguistic signals into our classifiers. We extend prior work by developing a dataset that better reflects the definitions of cyberbullying presented by social scientists, and by proposing and evaluating a feature set that represents information pertaining to the social processes that underlie cyberbullying behavior."
        ]
      },
      {
        "section_name": "Curating a Comprehensive Cyberbullying Dataset",
        "paragraphs": [
          "Here, we provide an original annotation framework and a new dataset for cyberbullying research, built to unify existing methods of ground truth annotation. In this dataset, we decompose the complex issue of cyberbullying into five key criteria, which were drawn from the social science and machine learning communities. These criteria can be combined and adapted for revised definitions of cyberbullying."
        ]
      },
      {
        "section_name": "Curating a Comprehensive Cyberbullying Dataset ::: Data Collection",
        "paragraphs": [
          "We collected a sample of 1.3 million unlabeled tweets from the Twitter Filter API. Since cyberbullying is a social phenomenon, we chose to filter for tweets containing at least one \u201c@\u201d mention. To restrict our investigation to original English content, we removed all non-English posts and retweets (RTs), narrowing the size of our sample to 280,301 tweets.",
          "Since aggressive language is a key component of cyberbullying BIBREF12, we ran the pre-trained classifier of BIBREF35 over our dataset to identify hate speech and aggressive language and increase the prevalence of cyberbullying examples . This gave us a filtered set of 9,803 aggressive tweets.",
          "We scraped both the user and timeline data for each author in the aggressive set, as well as any users who were mentioned in one of the aggressive tweets. In total, we collected data from 21,329 accounts. For each account, we saved the full user object, including profile name, description, location, verified status, and creation date. We also saved a complete list of the user's friends and followers, and a 6-month timeline of all their posts and mentions from January $1^\\text{st}$ through June $10^\\text{th}$, 2019. For author accounts, we extended our crawl to include up to four years of timeline content. Lastly, we collected metadata for all tweets belonging to the corresponding message thread for each aggressive message."
        ]
      },
      {
        "section_name": "Curating a Comprehensive Cyberbullying Dataset ::: Annotation Task",
        "paragraphs": [
          "We presented each tweet in the dataset to three separate annotators as a Human Intelligence Task (HIT) on Amazon's Mechanical Turk (MTurk) platform. By the time of recruitment, 6,897 of the 9,803 aggressive tweets were accessible from the Twitter web page. The remainder of the tweets had been removed, or the Twitter account had been locked or suspended.",
          "We asked our annotators to consider the full message thread for each tweet as displayed on Twitter's web interface. We also gave them a list of up to 15 recent mentions by the author of the tweet, directed towards any of the other accounts mentioned in the original thread. Then we asked annotators to interpret each tweet in light of this social context, and had them provide us with labels for five key cyberbullying criteria. We defined these criteria in terms of the author account (\u201cwho posted the given tweet?\u201d) and the target (\u201cwho was the tweet about?\u201d \u2013 not necessarily the first mention). We also stated that \u201cif the target is not on Twitter or their handle cannot be identified\u201d the annotator should \u201cplease write OTHER.\u201d With this framework established, we gave the definitions for our five cyberbullying criteria as follows.",
          "Aggressive language: (aggr) Regardless of the author's intent, the language of the tweet could be seen as aggressive. The user either addresses a group or individual, and the message contains at least one phrase that could be described as confrontational, derogatory, insulting, threatening, hostile, violent, hateful, or sexually abusive.",
          "Repetition: (rep) The target user has received at least two aggressive messages in total (either from the author or from another user in the visible thread).",
          "Harmful intent: (harm) The tweet was designed to tear down or disadvantage the target user by causing them distress or by harming their public image. The target does not respond agreeably as to a joke or an otherwise lighthearted comment.",
          "Visibility among peers: (peer) At least one other user besides the target has liked, retweeted, or responded to at least one of the author's messages.",
          "Power imbalance: (power) Power is derived from authority and perceived social advantage. Celebrities and public figures are more powerful than common users. Minorities and disadvantaged groups have less power. Bullies can also derive power from peer support.",
          "Each of these criteria was represented as a binary label, except for power imbalance, which was ternary. We asked \u201cIs there strong evidence that the author is more powerful than the target? Is the target more powerful? Or if there is not any good evidence, just mark equal.\u201d We recognized that an imbalance of power might arise in a number of different circumstances. Therefore, we did not restrict our definition to just one form of power, such as follower count or popularity.",
          "For instructional purposes, we provided five sample threads to demonstrate both positive and negative examples for each of the five criteria. Two of these threads are shown here. The thread in Figure FIGREF18 displays bullying behavior that is targeted against the green user, with all five cyberbullying criteria displayed. The thread includes repeated use of aggressive language such as \u201cshe really fucking tried\u201d and \u201cshe knows she lost.\u201d The bully's harmful intent is evident in the victim's defensive responses. And lastly, the thread is visible among four peers as three gang up against one, creating a power imbalance.",
          "The final tweet in Figure FIGREF18 shows the importance of context in the annotation process. If we read only this individual message, we might decide that the post is cyberbullying, but given the social context here, we can confidently assert that this post is not cyberbullying. Although it contains the aggressive phrase \u201cFUCK YOU TOO BITCH\u201d, the author does not intend harm. The message is part of a joking exchange between two friends or equals, and no other peers have joined in the conversation or interacted with the thread.",
          "After asking workers to review these examples, we gave them a short 7-question quiz to test their knowledge. Workers were given only one quiz attempt, and they were expected to score at least 6 out of 7 questions correctly before they could proceed to the paid HIT. Workers were then paid $\\$0.12$ for each thread that they annotated.",
          "We successfully recruited 170 workers to label all 6,897 available threads in our dataset. They labeled an average of 121.7 threads and a median of 7 threads each. They spent an average time of 3 minutes 50 seconds, and a median time of 61 seconds per thread. For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17.",
          "We determined ground truth for our data using a 2 out of 3 majority vote as in BIBREF12. If the message thread was missing or a target user could not be identified, we removed the entry from the dataset, since later we would need to draw our features from both the thread and the target profile. After filtering in this way, we were left with 5,537 labeled tweets."
        ]
      },
      {
        "section_name": "Curating a Comprehensive Cyberbullying Dataset ::: Cyberbullying Transcends Cyberaggression",
        "paragraphs": [
          "As discussed earlier, some experts have argued that cyberbullying is different from online aggression BIBREF12, BIBREF10, BIBREF9. We asked our annotators to weigh in on this issue by asking them the subjective question for each thread: \u201cBased on your own intuition, is this tweet an example of cyberbullying?\u201d We did not use the cyberbullying label as ground truth for training models; we used this label to better understand worker perceptions of cyberbullying. We found that our workers believed cyberbullying will depend on a weighted combination of the five criteria presented in this paper, with the strongest correlate being harmful intent as shown in Table TABREF17.",
          "Furthermore, the annotators decided our dataset contained 74.8% aggressive messages as shown in the Positive Balance column of Table TABREF17. We found that a large majority of these aggressive tweets were not labeled as \u201ccyberbullying.\u201d Rather, only 10.5% were labeled by majority vote as cyberbullying, and only 21.5% were considered harmful. From this data, we propose that cyberbullying and cyberaggression are not equivalent classes. Instead, cyberbullying transcends cyberaggression."
        ]
      },
      {
        "section_name": "Feature Engineering",
        "paragraphs": [
          "We have established that cyberbullying is a complex social phenomenon, different from the simpler notion of cyberaggression. Standard Bag of Words (BoW) features based on single sentences, such as $n$-grams and word embeddings, may thus lead machine learning algorithms to incorrectly classify friendly or joking behavior as cyberbullying BIBREF12, BIBREF10, BIBREF9. To more reliably capture the nuances of repetition, harmful intent, visibility among peers, and power imbalance, we designed a new set of features from the social and linguistic traces of Twitter users. These measures allow our classifiers to encode the dynamic relationship between the message author and target, using network and timeline similarities, expectations from language models, and other signals taken from the message thread.",
          "For each feature and each cyberbullying criterion, we compare the cumulative distributions of the positive and negative class using the two-sample Kolmogorov-Smirnov test. We report the Kolmogorov-Smirnov statistic $D$ (a normalized distance between the CDF of the positive and negative class) as well as the $p$-value with $\\alpha = 0.05$ as our level for statistical significance."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Text-based Features",
        "paragraphs": [
          "To construct realistic and competitive baseline models, we consider a set of standard text-based features that have been used widely throughout the literature. Specifically, we use the NLTK library BIBREF36 to construct unigrams, bigrams, and trigrams for each labeled message. This parallels the work of BIBREF8, BIBREF7, and BIBREF26. Following BIBREF30, we incorporate counts from the Linguistic Inquiry and Word Count (LIWC) dictionary to measure the linguistic and psychological processes that are represented in the text BIBREF37. We also use a modified version of the Flesch-Kincaid Grade Level and Flesch Reading Ease scores as computed in BIBREF35. Lastly, we encode the sentiment scores for each message using the Valence Aware Dictionary and sEntiment Reasoner (VADER) of BIBREF38."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Social Network Features",
        "paragraphs": [
          "Network features have been shown to improve text-based models BIBREF6, BIBREF25, and they can help classifiers distinguish between bullies and victims BIBREF32. These features may also capture some of the more social aspects of cyberbullying, such as power imbalance and visibility among peers. However, many centrality measures and clustering algorithms require detailed network representations. These features may not be scalable for real-world applications. We propose a set of low-complexity measurements that can be used to encode important higher-order relations at scale. Specifically, we measure the relative positions of the author and target accounts in the directed following network by computing modified versions of Jaccard's similarity index as we now explain."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Social Network Features ::: Neighborhood Overlap",
        "paragraphs": [
          "Let $N^{+}(u)$ be the set of all accounts followed by user $u$ and let $N^{-}(u)$ be the set of all accounts that follow user $u$. Then $N(u) = N^{+}(u) \\cup N^{-}(u)$ is the neighborhood set of $u$. We consider five related measurements of neighborhood overlap for a given author $a$ and target $t$, listed here.",
          "Downward overlap measures the number of two-hop paths from the author to the target along following relationships; upward overlap measures two-hop paths in the opposite direction. Inward overlap measures the similarity between the two users' follower sets, and outward overlap measures the similarity between their sets of friends. Bidirectional overlap then is a more generalized measure of social network similarity. We provide a graphical depiction for each of these features on the right side of Figure FIGREF18.",
          "High downward overlap likely indicates that the target is socially relevant to the author, as high upward overlap indicates the author is relevant to the target. Therefore, when the author is more powerful, downward overlap is expected to be lower and upward overlap is expected be higher. This trend is slight but visible in the cumulative distribution functions of Figure FIGREF26 (a): downward overlap is indeed lower when the author is more powerful than when the users are equals ($D=0.143$). However, there is not a significant difference for upward overlap ($p=0.85$). We also observe that, when the target is more powerful, downward and upward overlap are both significantly lower ($D=0.516$ and $D=0.540$ respectively). It is reasonable to assume that messages can be sent to celebrities and other powerful figures without the need for common social connections.",
          "Next, we consider inward and outward overlap. When the inward overlap is high, the author and target could have more common visibility. Similarly, if the outward overlap is high, then the author and target both follow similar accounts, so they might have similar interests or belong to the same social circles. Both inward and outward overlaps are expected to be higher when a post is visible among peers. This is true of both distributions in Figure FIGREF26. The difference in outward overlap is significant ($D=0.04$, $p=0.03$), and the difference for inward overlap is short of significant ($D=0.04$, $p=0.08$)."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Social Network Features ::: User-based features",
        "paragraphs": [
          "We also use basic user account metrics drawn from the author and target profiles. Specifically, we count the friends and followers of each user, their verified status, and the number of tweets posted within six-month snapshots of their timelines, as in BIBREF11, BIBREF4, and BIBREF8."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Timeline Features",
        "paragraphs": [
          "Here, we consider linguistic features, drawn from both the author and target timelines. These are intended to capture the social relationship between each user, their common interests, and the surprise of a given message relative to the author's timeline history."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Timeline Features ::: Message Behavior",
        "paragraphs": [
          "To more clearly represent the social relationship between the author and target users, we consider the messages sent between them as follows:",
          "Downward mention count: How many messages has the author sent to the target?",
          "Upward mention count: How many messages has the target sent to the author?",
          "Mention overlap: Let $M_a$ be the set of all accounts mentioned by author $a$, and let $M_t$ be the set of all accounts mentioned by target $t$. We compute the ratio $\\frac{|M_a \\cap M_t|}{|M_a \\cup M_t|}$.",
          "Multiset mention overlap: Let $\\hat{M}_a$ be the multiset of all accounts mentioned by author $a$ (with repeats for each mention), and let $\\hat{M}_t$ be the multiset of all accounts mentioned by target $t$. We measure $\\frac{|\\hat{M}_a \\cap ^{*} \\hat{M}_t|}{|\\hat{M}_a \\cup \\hat{M}_t|}$ where $\\cap ^{*}$ takes the multiplicity of each element to be the sum of the multiplicity from $\\hat{M}_a $ and the multiplicity from $\\hat{M}_b$",
          "The direct mention count measures the history of repeated communication between the author and the target. For harmful messages, downward overlap is higher ($D=0.178$) and upward overlap is lower ($D=0.374$) than for harmless messages, as shown in Figure FIGREF38. This means malicious authors tend to address the target repeatedly while the target responds with relatively few messages.",
          "Mention overlap is a measure of social similarity that is based on shared conversations between the author and the target. Multiset mention overlap measures the frequency of communication within this shared space. These features may help predict visibility among peers, or repeated aggression due to pile-on bullying situations. We see in Figure FIGREF38 that repeated aggression is linked to slightly greater mention overlap ($D=0.07$, $p=0.07$), but the trend is significant only for multiset mention overlap ($D=0.08$, $p=0.03$)."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Timeline Features ::: Timeline Similarity",
        "paragraphs": [
          "Timeline similarity is used to indicate common interests and shared topics of conversation between the author and target timelines. High similarity scores might reflect users' familiarity with one another, or suggest that they occupy similar social positions. This can be used to distinguish cyberbullying from harmless banter between friends and associates. To compute this metric, we represent the author and target timelines as TF-IDF vectors $\\vec{A}$ and $\\vec{T}$. We then take the cosine similarity between the vectors as",
          "A cosine similarity of 1 means that users' timelines had identical counts across all weighted terms; a cosine similarity of 0 means that their timelines did not contain any words in common. We expect higher similarity scores between friends and associates.",
          "In Figure FIGREF44 (a), we see that the timelines were significantly less similar when the target was in a position of greater power ($D=0.294$). This is not surprising, since power can be derived from such differences between social groups. We do not observe the same dissimilarity when the author was more powerful ($p=0.58$). What we do observe is likely caused by noise from extreme class imbalance and low inter-annotator agreement on labels for author power.",
          "Turning to Figure FIGREF44 (b), we see that aggressive messages were less likely to harbor harmful intent if they were sent between users with similar timelines ($D=0.285$). Aggressive banter between friends is generally harmless, so again, this confirms our intuitions."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Timeline Features ::: Language Models",
        "paragraphs": [
          "Harmful intent is difficult to measure in isolated messages because social context determines pragmatic meaning. We attempt to approximate the author's harmful intent by measuring the linguistic \u201csurprise\u201d of a given message relative to the author's timeline history. We do this in two ways: through a simple ratio of new words, and through the use of language models.",
          "To estimate historical language behavior, we count unigram and bigram frequencies from a 4-year snapshot of the author's timeline. Then, after removing all URLs, punctuation, stop words, mentions, and hashtags from the original post, we take the cardinality of the set unigrams in the post having zero occurrences in the timeline. Lastly, we divide this count by the length of the processed message to arrive at our new words ratio. We can also build a language model from the bigram frequencies, using Kneser-Ney smoothing as implemented in NLTK BIBREF36. From the language model, we compute the surprise of the original message $m$ according to its cross-entropy, given by",
          "where $m$ is composed of bigrams $b_1, b_2, \\dots , b_N$, and $P(b_i)$ is the probability of the $i$th bigram from the language model.",
          "We see in Figure FIGREF47 that harmfully intended messages have a greater density of new words ($D=0.06$). This is intuitive, since attacks may be staged around new topics of conversation. However, the cross entropy of these harmful messages is slightly lower than for harmless messages ($D=0.06$). This may be due to harmless jokes, since joking messages might depart more from the standard syntax of the author's timeline."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Thread Features",
        "paragraphs": [
          "Finally, we turn to the messages of the thread itself to compute measures of visibility and repeated aggression."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Thread Features ::: Visibility",
        "paragraphs": [
          "To determine the public visibility of the author's post, we collect basic measurements from the interactions of other users in the thread. They are as follows.",
          "Message count: Count the messages posted in the thread",
          "Reply message count: Count the replies posted in the thread after the author's first comment.",
          "Reply user count: Count the users who posted a reply in the thread after the author's first comment.",
          "Maximum author favorites: The largest number of favorites the author received on a message in the thread.",
          "Maximum author retweets: The largest number of retweets the author received on a message in the thread."
        ]
      },
      {
        "section_name": "Feature Engineering ::: Thread Features ::: Aggression",
        "paragraphs": [
          "To detect repeated aggression, we again employ the hate speech and offensive language classifier of BIBREF35. Each message is given a binary label according to the classifier-assigned class: aggressive (classified as hate speech or offensive language) or non-aggressive (classified as neither hate speech nor offensive language). From these labels, we derive the following features.",
          "Aggressive message count: Count the messages in the thread classified as aggressive",
          "Aggressive author message count: Count the author's messages that were classified as aggressive",
          "Aggressive user count: Of the users who posted a reply in the thread after the author first commented, count how many had a message classified as aggressive"
        ]
      },
      {
        "section_name": "Experimental Evaluation",
        "paragraphs": [
          "Using our proposed features from the previous section and ground truth labels from our annotation task, we trained a separate Logistic Regression classifier for each of the five cyberbullying criteria, and we report precision, recall, and $F_1$ measures over each binary label independently. We averaged results using five-fold cross-validation, with 80% of the data allocated for training and 20% of the data allocated for testing at each iteration. To account for the class imbalance in the training data, we used the synthetic minority over-sampling technique (SMOTE) BIBREF39. We did not over-sample testing sets, however, to ensure that our tests better match the class distributions obtained as we did by pre-filtering for aggressive directed Twitter messages.",
          "We compare our results across the five different feature combinations given in Table TABREF58. Note that because we do not include thread features in the User set, it can be used for cyberbullying prediction and early intervention. The Proposed set can be used for detection, sinct it is a collection of all newly proposed features, including thread features. The Combined adds these to the baseline text features.",
          "The performance of the different classifiers is summarized in Tables TABREF59, TABREF64, and TABREF65. Here, we see that Bag of Words and text-based methods performed well on the aggressive language classification task, with an $F_1$ score of 83.5%. This was expected and the score aligns well with the success of other published results of Table TABREF8. Cyberbullying detection is more complex than simply identifying aggressive text, however. We find that these same baseline methods fail to reliably detect repetition, harmful intent, visibility among peers, and power imbalance, as shown by the low recall scores in Table TABREF64. We conclude that our investigation of socially informed features was justified.",
          "Our proposed set of features beats recall scores for lexically trained baselines in all but the aggression criterion. We also improve precision scores for repetition, visibility among peers, and power imbalance. When we combine all features, we see our $F_1$ scores beat baselines for each criterion. This demonstrates the effectiveness of our approach, using linguistic similarity and community measurements to encode social characteristics for cyberbullying classification.",
          "Similar results were obtained by replacing our logistic regression model with any of a random forest model, support vector machine (SVM), AdaBoost, or Multilayer Perceptron (MLP). We report all precision, recall, and $F_1$ scores in Appendix 2, Tables TABREF69-TABREF77. We chose to highlight logistic regression because it can be more easily interpreted. As a result, we can identify the relative importance of our proposed features. The feature weights are also given in Appendix 2, Tables TABREF78-TABREF78. There we observe a trend. The aggressive language and repetition criteria are dominated by lexical features; the harmful intent is split between lexical and historical communication features; and the visibility among peers and target power criteria are dominated by our proposed social features.",
          "Although we achieve moderately competitive scores in most categories, our classifiers are still over-classifying cyberbullying cases. Precision scores are generally much lower than recall scores across all models. To reduce our misclassification of false positives and better distinguish between joking or friendly banter and cyberbullying, it may be necessary to mine for additional social features. Overall, we should work to increase all $F_1$ scores to above 0.8 before we can consider our classifiers ready for real-world applications BIBREF10."
        ]
      },
      {
        "section_name": "Discussion ::: Limitations",
        "paragraphs": [
          "Our study focuses on the Twitter ecosystem and a small part of its network. The initial sampling of tweets was based on a machine learning classifier of aggressive English language. This classifier has an F1 score of 0.90 BIBREF35. Even with this filter, only 0.7% of tweets were deemed by a majority of MTurk workers as cyberbullying (Table TABREF17). This extreme class imbalance can disadvantage a wide range of machine learning models. Moreover, the MTurk workers exhibited only moderate inter-annotator agreement (Table TABREF17). We also acknowledge that notions of harmful intent and power imbalance can be subjective, since they may depend on the particular conventions or social structure of a given community. For these reasons, we recognize that cyberbullying still has not been unambiguously defined. Moreover, their underlying constructs are difficult to identify. In this study, we did not train workers to recognize subtle cues for interpersonal popularity, nor the role of anonymity in creating a power imbalance.",
          "Furthermore, because we lack the authority to define cyberbullying, we cannot assert a two-way implication between cyberbullying and the five criteria outlined here. It may be possible for cyberbullying to exist with only one criterion present, such as harmful intent. Our five criteria also might not span all of the dimensions of cyberbullying. However, they are representative of the literature in both the social science and machine learning communities, and they can be used in weighted combinations to accommodate new definitions.",
          "The main contribution of our paper is not that we solved the problem of cyberbullying detection. Instead, we have exposed the challenge of defining and measuring cyberbullying activity, which has been historically overlooked in the research community."
        ]
      },
      {
        "section_name": "Discussion ::: Future Directions",
        "paragraphs": [
          "Cyberbullying detection is an increasingly important and yet challenging problem to tackle. A lack of detailed and appropriate real-world datasets stymies progress towards more reliable detection methods. With cyberbullying being a systemic issue across social media platforms, we urge the development of a methodology for data sharing with researchers that provides adequate access to rich data to improve on the early detection of cyberbullying while also addressing the sensitive privacy issues that accompany such instances."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this study, we produced an original dataset for cyberbullying detection research and an approach that leverages this dataset to more accurately detect cyberbullying. Our labeling scheme was designed to accommodate the cyberbullying definitions that have been proposed throughout the literature. In order to more accurately represent the nature of cyberbullying, we decomposed this complex issue into five representative characteristics. Our classes distinguish cyberbullying from other related behaviors, such as isolated aggression or crude joking. To help annotators infer these distinctions, we provided them with the full context of each message's reply thread, along with a list of the author's most recent mentions. In this way, we secured a new set of labels for more reliable cyberbullying representations.",
          "From these ground truth labels, we designed a new set of features to quantify each of the five cyberbullying criteria. Unlike previous text-based or user-based features, our features measure the relationship between a message author and target. We show that these features improve the performance of standard text-based models. These results demonstrate the relevance of social-network and language-based measurements to account for the nuanced social characteristics of cyberbullying.",
          "Despite improvements over baseline methods, our classifiers have not attained the high levels of precision and recall that should be expected of real-world detection systems. For this reason, we argue that the challenging task of cyberbullying detection remains an open research problem."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "This material is based upon work supported by the Defense Advanced Research Projects Agency (DARPA) under Agreement No. HR0011890019, and by the National Science Foundation (NSF) under Grant No. 1659886 and Grant No. 1553579."
        ]
      },
      {
        "section_name": "Appendix 1: Analysis of the Real-World Class Distribution for Cyberbullying Criteria",
        "paragraphs": [
          "To understand the real-world class distribution for the cyberbullying criteria, we randomly selected 222 directed English tweets from an unbiased sample of drawn from the Twitter Decahose stream across the entire month of October 2016. Using the same methodology given in the paper, we had these tweets labeled three times each on Amazon Mechanical Turk. Again, ground truth was determined using 2 out of 3 majority vote. Upon analysis, we found that the positive class balance was prohibitively small, especially for repetition, harmful intent, visibility among peers, and author power, which were all under 5%."
        ]
      },
      {
        "section_name": "Appendix 2: Model Evaluation",
        "paragraphs": [
          "For the sake of comparison, we provide precision, recall, and $F_1$ scores for five different machine learning models: $k$-nearest neighbors (KNN), random forest, support vector machine (SVM), AdaBoost, and Multilayer Perceptron (MLP). Then we provide feature weights for our logistic regression model trained on each of the five cyberbullying criteria."
        ]
      }
    ],
    "qas": [
      {
        "question": "What agreement measure is used?",
        "question_id": "42eb7c5311fc1ac0344f0b38d3184ccd4faad3be",
        "nlp_background": "five",
        "topic_background": "research",
        "paper_read": "no",
        "search_query": "cyberbullying",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Fleiss's Kappa"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We successfully recruited 170 workers to label all 6,897 available threads in our dataset. They labeled an average of 121.7 threads and a median of 7 threads each. They spent an average time of 3 minutes 50 seconds, and a median time of 61 seconds per thread. For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ],
              "highlighted_evidence": [
                "For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ]
            },
            "annotation_id": "67cee6de2a0dda2b1b0d4cad7c9e28369fe83f3d",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Fleiss's Kappa "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We successfully recruited 170 workers to label all 6,897 available threads in our dataset. They labeled an average of 121.7 threads and a median of 7 threads each. They spent an average time of 3 minutes 50 seconds, and a median time of 61 seconds per thread. For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ],
              "highlighted_evidence": [
                " For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ]
            },
            "annotation_id": "9f71c3d94a22f92fc337668123382564dd472e77",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Fleiss's Kappa"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We successfully recruited 170 workers to label all 6,897 available threads in our dataset. They labeled an average of 121.7 threads and a median of 7 threads each. They spent an average time of 3 minutes 50 seconds, and a median time of 61 seconds per thread. For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ],
              "highlighted_evidence": [
                "For each thread, we collected annotations from three different workers, and from this data we computed our reliability metrics using Fleiss's Kappa for inter-annotator agreement as shown in Table TABREF17."
              ]
            },
            "annotation_id": "a3948f5d15af0f47fbecb771fbc5fabbb05907ef",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Datasets built from different related definitions of cyberbullying. For each dataset, we report the size, positive class balance, inter-annotator agreement, and whether the study incorporated social context in the annotation process."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: State of the Art in Cyberbullying Detection. Here, results are reported on either the Cyberbullying (CB) class exclusively or on the entire (total) dataset."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Analysis of Labeled Twitter Data"
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Cyberbullying or not. The leftmost thread demonstrates all five cyberbullying criteria. Although the thread in the middle contains repeated use of aggressive language, there is no harmful intent, visibility among peers, or power imbalance. Overlap measures. (right) Graphical representation of the neighborhood overlap measures of author a and target t."
      },
      {
        "file": "6-Figure2-1.png",
        "caption": "Figure 2: Cumulative Distribution Functions for neighborhood overlap on relevant features. These measures are shown to be predictive of power imbalance and visibility among peers."
      },
      {
        "file": "7-Figure3-1.png",
        "caption": "Figure 3: Cumulative Distribution Functions for message behavior on relevant features. These measures are shown to be indicative of harmful intent and repetition."
      },
      {
        "file": "7-Figure4-1.png",
        "caption": "Figure 4: Cumulative Distribution Functions for timeline similarity on relevant features. These measures are shown to be predictive of power imbalance and harmful intent."
      },
      {
        "file": "7-Figure5-1.png",
        "caption": "Figure 5: Cumulative Distribution Functions for language models on relevant features. These measures are shown to be predictive of harmful intent."
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: Feature Combinations"
      },
      {
        "file": "8-Table6-1.png",
        "caption": "Table 6: Recall"
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5: Precision"
      },
      {
        "file": "8-Table7-1.png",
        "caption": "Table 7: F1 Scores"
      },
      {
        "file": "11-Table8-1.png",
        "caption": "Table 8: Analysis of Unfiltered Decahose Data"
      },
      {
        "file": "11-Table9-1.png",
        "caption": "Table 9: Random Forest Precision"
      },
      {
        "file": "11-Table10-1.png",
        "caption": "Table 10: AdaBoost Precision"
      },
      {
        "file": "11-Table11-1.png",
        "caption": "Table 11: MLP Precision"
      },
      {
        "file": "12-Table19-1.png",
        "caption": "Table 19: Top Absolute Weights for Repetition Features"
      },
      {
        "file": "12-Table20-1.png",
        "caption": "Table 20: Top Absolute Weights for Harmful Intent"
      },
      {
        "file": "12-Table12-1.png",
        "caption": "Table 12: Random Forest Recall"
      },
      {
        "file": "12-Table21-1.png",
        "caption": "Table 21: Top Absolute Weights for Visibility Among Peers"
      }
    ]
  },
  "1808.04122": {
    "title": "A Capsule Network-based Embedding Model for Knowledge Graph Completion and Search Personalization",
    "abstract": "In this paper, we introduce an embedding model, named CapsE, exploring a capsule network to model relationship triples (subject, relation, object). Our CapsE represents each triple as a 3-column matrix where each column vector represents the embedding of an element in the triple. This 3-column matrix is then fed to a convolution layer where multiple filters are operated to generate different feature maps. These feature maps are reconstructed into corresponding capsules which are then routed to another capsule to produce a continuous vector. The length of this vector is used to measure the plausibility score of the triple. Our proposed CapsE obtains better performance than previous state-of-the-art embedding models for knowledge graph completion on two benchmark datasets WN18RR and FB15k-237, and outperforms strong search personalization baselines on SEARCH17.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Knowledge graphs (KGs) containing relationship triples (subject, relation, object), denoted as (s, r, o), are the useful resources for many NLP and especially information retrieval applications such as semantic search and question answering BIBREF0 . However, large knowledge graphs, even containing billions of triples, are still incomplete, i.e., missing a lot of valid triples BIBREF1 . Therefore, much research efforts have focused on the knowledge graph completion task which aims to predict missing triples in KGs, i.e., predicting whether a triple not in KGs is likely to be valid or not BIBREF2 , BIBREF3 , BIBREF4 . To this end, many embedding models have been proposed to learn vector representations for entities (i.e., subject/head entity and object/tail entity) and relations in KGs, and obtained state-of-the-art results as summarized by BIBREF5 and BIBREF6 . These embedding models score triples (s, r, o), such that valid triples have higher plausibility scores than invalid ones BIBREF2 , BIBREF3 , BIBREF4 . For example, in the context of KGs, the score for (Melbourne, cityOf, Australia) is higher than the score for (Melbourne, cityOf, United Kingdom).",
          "Triple modeling is applied not only to the KG completion, but also for other tasks which can be formulated as a triple-based prediction problem. An example is in search personalization, one would aim to tailor search results to each specific user based on the user's personal interests and preferences BIBREF7 , BIBREF8 , BIBREF9 , BIBREF10 , BIBREF11 , BIBREF12 . Here the triples can be formulated as (submitted query, user profile, returned document) and used to re-rank documents returned to a user given an input query, by employing an existing KG embedding method such as TransE BIBREF3 , as proposed by BIBREF12 . Previous studies have shown the effectiveness of modeling triple for either KG completion or search personalization. However, there has been no single study investigating the performance on both tasks.",
          "Conventional embedding models, such as TransE BIBREF3 , DISTMULT BIBREF13 and ComplEx BIBREF14 , use addition, subtraction or simple multiplication operators, thus only capture the linear relationships between entities. Recent research has raised interest in applying deep neural networks to triple-based prediction problems. For example, BIBREF15 proposed ConvKB\u2014a convolutional neural network (CNN)-based model for KG completion and achieved state-of-the-art results. Most of KG embedding models are constructed to modeling entries at the same dimension of the given triple, where presumably each dimension captures some relation-specific attribute of entities. To the best of our knowledge, however, none of the existing models has a \u201cdeep\u201d architecture for modeling the entries in a triple at the same dimension.",
          " BIBREF16 introduced capsule networks (CapsNet) that employ capsules (i.e., each capsule is a group of neurons) to capture entities in images and then uses a routing process to specify connections from capsules in a layer to those in the next layer. Hence CapsNet could encode the intrinsic spatial relationship between a part and a whole constituting viewpoint invariant knowledge that automatically generalizes to novel viewpoints. Each capsule accounts for capturing variations of an object or object part in the image, which can be efficiently visualized. Our high-level hypothesis is that embedding entries at the same dimension of the triple also have these variations, although it is not straightforward to be visually examined.",
          "To that end, we introduce CapsE to explore a novel application of CapsNet on triple-based data for two problems: KG completion and search personalization. Different from the traditional modeling design of CapsNet where capsules are constructed by splitting feature maps, we use capsules to model the entries at the same dimension in the entity and relation embeddings. In our CapsE, INLINEFORM0 , INLINEFORM1 and INLINEFORM2 are unique INLINEFORM3 -dimensional embeddings of INLINEFORM4 , INLINEFORM5 and INLINEFORM6 , respectively. The embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] of (s, r, o) is fed to the convolution layer where multiple filters of the same INLINEFORM10 shape are repeatedly operated over every row of the matrix to produce INLINEFORM11 -dimensional feature maps. Entries at the same dimension from all feature maps are then encapsulated into a capsule. Thus, each capsule can encode many characteristics in the embedding triple to represent the entries at the corresponding dimension. These capsules are then routed to another capsule which outputs a continuous vector whose length is used as a score for the triple. Finally, this score is used to predict whether the triple (s, r, o) is valid or not.",
          "In summary, our main contributions from this paper are as follows:",
          " INLINEFORM0 We propose an embedding model CapsE using the capsule network BIBREF16 for modeling relationship triples. To our best of knowledge, our work is the first consideration of exploring the capsule network to knowledge graph completion and search personalization.",
          " INLINEFORM0 We evaluate our CapsE for knowledge graph completion on two benchmark datasets WN18RR BIBREF17 and FB15k-237 BIBREF18 . CapsE obtains the best mean rank on WN18RR and the highest mean reciprocal rank and highest Hits@10 on FB15k-237.",
          " INLINEFORM0 We restate the prospective strategy of expanding the triple embedding models to improve the ranking quality of the search personalization systems. We adapt our model to search personalization and evaluate on SEARCH17 BIBREF12 \u2013 a dataset of the web search query logs. Experimental results show that our CapsE achieves the new state-of-the-art results with significant improvements over strong baselines."
        ]
      },
      {
        "section_name": "The proposed CapsE",
        "paragraphs": [
          "Let INLINEFORM0 be a collection of valid factual triples in the form of (subject, relation, object) denoted as (s, r, o). Embedding models aim to define a score function giving a score for each triple, such that valid triples receive higher scores than invalid triples.",
          "We denote INLINEFORM0 , INLINEFORM1 and INLINEFORM2 as the INLINEFORM3 -dimensional embeddings of INLINEFORM4 , INLINEFORM5 and INLINEFORM6 , respectively. In our proposed CapsE, we follow BIBREF15 to view each embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] as a matrix INLINEFORM10 , and denote INLINEFORM11 as the INLINEFORM12 -th row of INLINEFORM13 . We use a filter INLINEFORM14 operated on the convolution layer. This filter INLINEFORM15 is repeatedly operated over every row of INLINEFORM16 to generate a feature map INLINEFORM17 , in which INLINEFORM18 where INLINEFORM19 denotes a dot product, INLINEFORM20 is a bias term and INLINEFORM21 is a non-linear activation function such as ReLU. Our model uses multiple filters INLINEFORM22 to generate feature maps. We denote INLINEFORM23 as the set of filters and INLINEFORM24 as the number of filters, thus we have INLINEFORM25 INLINEFORM26 -dimensional feature maps, for which each feature map can capture one single characteristic among entries at the same dimension.",
          "We build our CapsE with two single capsule layers for a simplified architecture. In the first layer, we construct INLINEFORM0 capsules, wherein entries at the same dimension from all feature maps are encapsulated into a corresponding capsule. Therefore, each capsule can capture many characteristics among the entries at the corresponding dimension in the embedding triple. These characteristics are generalized into one capsule in the second layer which produces a vector output whose length is used as the score for the triple.",
          "The first capsule layer consists of INLINEFORM0 capsules, for which each capsule INLINEFORM1 has a vector output INLINEFORM2 . Vector outputs INLINEFORM3 are multiplied by weight matrices INLINEFORM4 to produce vectors INLINEFORM5 which are summed to produce a vector input INLINEFORM6 to the capsule in the second layer. The capsule then performs the non-linear squashing function to produce a vector output INLINEFORM7 : DISPLAYFORM0 ",
          "where INLINEFORM0 , and INLINEFORM1 are coupling coefficients determined by the routing process as presented in Algorithm SECREF2 . Because there is one capsule in the second layer, we make only one difference in the routing process proposed by BIBREF16 , for which we apply the INLINEFORM2 in a direction from all capsules in the previous layer to each of capsules in the next layer.",
          "[ht] 1.25",
          "all capsule i INLINEFORM0 the first layer INLINEFORM1 0 INLINEFORM2 = 1, 2, ..., m INLINEFORM3 INLINEFORM4 ",
          " INLINEFORM0 ",
          "all capsule i INLINEFORM0 the first layer INLINEFORM1 The routing process is extended from BIBREF16 .",
          "We illustrate our proposed model in Figure FIGREF1 where embedding size: INLINEFORM0 , the number of filters: INLINEFORM1 , the number of neurons within the capsules in the first layer is equal to INLINEFORM2 , and the number of neurons within the capsule in the second layer: INLINEFORM3 . The length of the vector output INLINEFORM4 is used as the score for the input triple.",
          "Formally, we define the score function INLINEFORM0 for the triple INLINEFORM1 as follows: DISPLAYFORM0 ",
          "where the set of filters INLINEFORM0 is shared parameters in the convolution layer; INLINEFORM1 denotes a convolution operator; and INLINEFORM2 denotes a capsule network operator. We use the Adam optimizer BIBREF19 to train CapsE by minimizing the loss function BIBREF14 , BIBREF15 as follows: DISPLAYFORM0 ",
          " INLINEFORM0 ",
          "here INLINEFORM0 and INLINEFORM1 are collections of valid and invalid triples, respectively. INLINEFORM2 is generated by corrupting valid triples in INLINEFORM3 ."
        ]
      },
      {
        "section_name": "Knowledge graph completion evaluation ",
        "paragraphs": [
          "In the knowledge graph completion task BIBREF3 , the goal is to predict a missing entity given a relation and another entity, i.e, inferring a head entity INLINEFORM0 given INLINEFORM1 or inferring a tail entity INLINEFORM2 given INLINEFORM3 . The results are calculated based on ranking the scores produced by the score function INLINEFORM4 on test triples."
        ]
      },
      {
        "section_name": "Experimental setup",
        "paragraphs": [
          "Datasets: We use two recent benchmark datasets WN18RR BIBREF17 and FB15k-237 BIBREF18 . These two datasets are created to avoid reversible relation problems, thus the prediction task becomes more realistic and hence more challenging BIBREF18 . Table TABREF7 presents the statistics of WN18RR and FB15k-237.",
          "Evaluation protocol: Following BIBREF3 , for each valid test triple INLINEFORM0 , we replace either INLINEFORM1 or INLINEFORM2 by each of all other entities to create a set of corrupted triples. We use the \u201cFiltered\u201d setting protocol BIBREF3 , i.e., not taking any corrupted triples that appear in the KG into accounts. We rank the valid test triple and corrupted triples in descending order of their scores. We employ evaluation metrics: mean rank (MR), mean reciprocal rank (MRR) and Hits@10 (i.e., the proportion of the valid test triples ranking in top 10 predictions). Lower MR, higher MRR or higher Hits@10 indicate better performance. Final scores on the test set are reported for the model obtaining the highest Hits@10 on the validation set.",
          "Training protocol: We use the common Bernoulli strategy BIBREF20 , BIBREF21 when sampling invalid triples. For WN18RR, BIBREF22 found a strong evidence to support the necessity of a WordNet-related semantic setup, in which they averaged pre-trained word embeddings for word surface forms within the WordNet to create synset embeddings, and then used these synset embeddings to initialize entity embeddings for training their TransE association model. We follow this evidence in using the pre-trained 100-dimensional Glove word embeddings BIBREF23 to train a TransE model on WN18RR.",
          "We employ the TransE and ConvKB implementations provided by BIBREF24 and BIBREF15 . For ConvKB, we use a new process of training up to 100 epochs and monitor the Hits@10 score after every 10 training epochs to choose optimal hyper-parameters with the Adam initial learning rate in INLINEFORM0 and the number of filters INLINEFORM1 in INLINEFORM2 . We obtain the highest Hits@10 scores on the validation set when using N= 400 and the initial learning rate INLINEFORM3 on WN18RR; and N= 100 and the initial learning rate INLINEFORM4 on FB15k-237.",
          "Like in ConvKB, we use the same pre-trained entity and relation embeddings produced by TransE to initialize entity and relation embeddings in our CapsE for both WN18RR and FB15k-237 ( INLINEFORM0 ). We set the batch size to 128, the number of neurons within the capsule in the second capsule layer to 10 ( INLINEFORM1 ), and the number of iterations in the routing algorithm INLINEFORM2 in INLINEFORM3 . We run CapsE up to 50 epochs and monitor the Hits@10 score after each 10 training epochs to choose optimal hyper-parameters. The highest Hits@10 scores for our CapsE on the validation set are obtained when using INLINEFORM4 , INLINEFORM5 and the initial learning rate at INLINEFORM6 on WN18RR; and INLINEFORM7 , INLINEFORM8 and the initial learning rate at INLINEFORM9 on FB15k-237.",
          "Dataset: We use the SEARCH17 dataset BIBREF12 of query logs of 106 users collected by a large-scale web search engine. A log entity consists of a user identifier, a query, top-10 ranked documents returned by the search engine and clicked documents along with the user's dwell time. BIBREF12 constructed short-term (session-based) user profiles and used the profiles to personalize the returned results. They then employed the SAT criteria BIBREF26 to identify whether a returned document is relevant from the query logs as either a clicked document with a dwell time of at least 30 seconds or the last clicked document in a search session (i.e., a SAT click). After that, they assigned a INLINEFORM0 label to a returned document if it is a SAT click and also assigned INLINEFORM1 labels to the remaining top-10 documents. The rank position of the INLINEFORM2 labeled documents is used as the ground truth to evaluate the search performance before and after re-ranking.",
          "The dataset was uniformly split into the training, validation and test sets. This split is for the purpose of using historical data in the training set to predict new data in the test set BIBREF12 . The training, validation and test sets consist of 5,658, 1,184 and 1,210 relevant (i.e., valid) triples; and 40,239, 7,882 and 8,540 irrelevant (i.e., invalid) triples, respectively.",
          "Evaluation protocol: Our CapsE is used to re-rank the original list of documents returned by a search engine as follows: (i) We train our model and employ the trained model to calculate the score for each INLINEFORM0 triple. (ii) We then sort the scores in the descending order to obtain a new ranked list. To evaluate the performance of our proposed model, we use two standard evaluation metrics: mean reciprocal rank (MRR) and Hits@1. For each metric, the higher value indicates better ranking performance.",
          "We compare CapsE with the following baselines using the same experimental setup: (1) SE: The original rank is returned by the search engine. (2) CI BIBREF27 : This baseline uses a personalized navigation method based on previously clicking returned documents. (3) SP BIBREF9 , BIBREF11 : A search personalization method makes use of the session-based user profiles. (4) Following BIBREF12 , we use TransE as a strong baseline model for the search personalization task. Previous work shows that the well-known embedding model TransE, despite its simplicity, obtains very competitive results for the knowledge graph completion BIBREF28 , BIBREF29 , BIBREF14 , BIBREF30 , BIBREF15 . (5) The CNN-based model ConvKB is the most closely related model to our CapsE.",
          "Embedding initialization: We follow BIBREF12 to initialize user profile, query and document embeddings for the baselines TransE and ConvKB, and our CapsE.",
          "We train a LDA topic model BIBREF31 with 200 topics only on the relevant documents (i.e., SAT clicks) extracted from the query logs. We then use the trained LDA model to infer the probability distribution over topics for every returned document. We use the topic proportion vector of each document as its document embedding (i.e. INLINEFORM0 ). In particular, the INLINEFORM1 element ( INLINEFORM2 ) of the vector embedding for document INLINEFORM3 is: INLINEFORM4 where INLINEFORM5 is the probability of the topic INLINEFORM6 given the document INLINEFORM7 .",
          "We also represent each query by a probability distribution vector over topics. Let INLINEFORM0 be the set of top INLINEFORM1 ranked documents returned for a query INLINEFORM2 (here, INLINEFORM3 ). The INLINEFORM4 element of the vector embedding for query INLINEFORM5 is defined as in BIBREF12 : INLINEFORM6 , where INLINEFORM7 is the exponential decay function of INLINEFORM8 which is the rank of INLINEFORM9 in INLINEFORM10 . And INLINEFORM11 is the decay hyper-parameter ( INLINEFORM12 ). Following BIBREF12 , we use INLINEFORM13 . Note that if we learn query and document embeddings during training, the models will overfit to the data and will not work for new queries and documents. Thus, after the initialization process, we fix (i.e., not updating) query and document embeddings during training for TransE, ConvKB and CapsE.",
          "In addition, as mentioned by BIBREF9 , the more recently clicked document expresses more about the user current search interest. Hence, we make use of the user clicked documents in the training set with the temporal weighting scheme proposed by BIBREF11 to initialize user profile embeddings for the three embedding models.",
          "Hyper-parameter tuning: For our CapsE model, we set batch size to 128, and also the number of neurons within the capsule in the second capsule layer to 10 ( INLINEFORM0 ). The number of iterations in the routing algorithm is set to 1 ( INLINEFORM1 ). For the training model, we use the Adam optimizer with the initial learning rate INLINEFORM2 INLINEFORM3 INLINEFORM4 INLINEFORM5 INLINEFORM6 INLINEFORM7 . We also use ReLU as the activation function INLINEFORM8 . We select the number of filters INLINEFORM9 . We run the model up to 200 epochs and perform a grid search to choose optimal hyper-parameters on the validation set. We monitor the MRR score after each training epoch and obtain the highest MRR score on the validation set when using INLINEFORM10 and the initial learning rate at INLINEFORM11 .",
          "We employ the TransE and ConvKB implementations provided by BIBREF24 and BIBREF15 and then follow their training protocols to tune hyper-parameters for TransE and ConvKB, respectively. We also monitor the MRR score after each training epoch and attain the highest MRR score on the validation set when using margin = 5, INLINEFORM0 -norm and SGD learning rate at INLINEFORM1 for TransE; and INLINEFORM2 and the Adam initial learning rate at INLINEFORM3 for ConvKB."
        ]
      },
      {
        "section_name": "Main experimental results",
        "paragraphs": [
          "Table TABREF10 compares the experimental results of our CapsE with previous state-of-the-art published results, using the same evaluation protocol. Our CapsE performs better than its closely related CNN-based model ConvKB on both experimental datasets (except Hits@10 on WN18RR and MR on FB15k-237), especially on FB15k-237 where our CapsE gains significant improvements of INLINEFORM0 in MRR (which is about 25.1% relative improvement), and INLINEFORM1 % absolute improvement in Hits@10. Table TABREF10 also shows that our CapsE obtains the best MR score on WN18RR and the highest MRR and Hits@10 scores on FB15k-237.",
          "Following BIBREF3 , for each relation INLINEFORM0 in FB15k-237, we calculate the averaged number INLINEFORM1 of head entities per tail entity and the averaged number INLINEFORM2 of tail entities per head entity. If INLINEFORM3 1.5 and INLINEFORM4 1.5, INLINEFORM5 is categorized one-to-one (1-1). If INLINEFORM6 1.5 and INLINEFORM7 1.5, INLINEFORM8 is categorized one-to-many (1-M). If INLINEFORM9 1.5 and INLINEFORM10 1.5, INLINEFORM11 is categorized many-to-one (M-1). If INLINEFORM12 1.5 and INLINEFORM13 1.5, INLINEFORM14 is categorized many-to-many (M-M). As a result, 17, 26, 81 and 113 relations are labelled 1-1, 1-M, M-1 and M-M, respectively. And 0.9%, 6.3%, 20.5% and 72.3% of the test triples in FB15k-237 contain 1-1, 1-M, M-1 and M-M relations, respectively.",
          "Figure FIGREF11 shows the Hits@10 and MRR results for predicting head and tail entities w.r.t each relation category on FB15k-237. CapsE works better than ConvKB in predicting entities on the \u201cside M\u201d of triples (e.g., predicting head entities in M-1 and M-M; and predicting tail entities in 1-M and M-M), while ConvKB performs better than CapsE in predicting entities on the \u201cside 1\u201d of triples (i.e., predicting head entities in 1-1 and 1-M; and predicting tail entities in 1-1 and M-1).",
          "Figure FIGREF12 shows the Hits@10 and MRR scores w.r.t each relation on WN18RR. INLINEFORM0 , INLINEFORM1 , INLINEFORM2 and INLINEFORM3 are symmetric relations which can be considered as M-M relations. Our CapsE also performs better than ConvKB on these 4 M-M relations. Thus, results shown in Figures FIGREF11 and FIGREF12 are consistent. These also imply that our CapsE would be a potential candidate for applications which contain many M-M relations such as search personalization.",
          "We see that the length and orientation of each capsule in the first layer can also help to model the important entries in the corresponding dimension, thus CapsE can work well on the \u201cside M\u201d of triples where entities often appear less frequently than others appearing in the \u201cside 1\u201d of triples. Additionally, existing models such as DISTMULT, ComplEx and ConvE can perform well for entities with high frequency, but may not for rare entities with low frequency. These are reasons why our CapsE can be considered as the best one on FB15k-237 and it outperforms most existing models on WN18RR.",
          "Effects of routing iterations: We study how the number of routing iterations affect the performance. Table TABREF13 shows the Hits@10 scores on the WN18RR validation set for a comparison w.r.t each number value of the routing iterations and epochs with the number of filters INLINEFORM0 and the Adam initial learning rate at INLINEFORM1 . We see that the best performance for each setup over each 10 epochs is obtained by setting the number INLINEFORM2 of routing iterations to 1. This indicates the opposite side for knowledge graphs compared to images. In the image classification task, setting the number INLINEFORM3 of iterations in the routing process higher than 1 helps to capture the relative positions of entities in an image (e.g., eyes, nose and mouth) properly. In contrast, this property from images may be only right for the 1-1 relations, but not for the 1-M, M-1 and M-M relations in the KGs because of the high variant of each relation type (e.g., symmetric relations) among different entities."
        ]
      },
      {
        "section_name": "Search personalization application",
        "paragraphs": [
          "Given a user, a submitted query and the documents returned by a search system for that query, our approach is to re-rank the returned documents so that the more relevant documents should be ranked higher. Following BIBREF12 , we represent the relationship between the submitted query, the user and the returned document as a (s, r, o)-like triple (query, user, document). The triple captures how much interest a user puts on a document given a query. Thus, we can evaluate the effectiveness of our CapsE for the search personalization task."
        ]
      },
      {
        "section_name": "Main results",
        "paragraphs": [
          "Table TABREF17 presents the experimental results of the baselines and our model. Embedding models TranE, ConvKB and CapsE produce better ranking performances than traditional learning-to-rank search personalization models CI and SP. This indicates a prospective strategy of expanding the triple embedding models to improve the ranking quality of the search personalization systems. In particular, our MRR and Hits@1 scores are higher than those of TransE (with relative improvements of 14.5% and 22% over TransE, respectively). Specifically, our CapsE achieves the highest performances in both MRR and Hits@1 (our improvements over all five baselines are statistically significant with INLINEFORM0 using the paired t-test).",
          "To illustrate our training progress, we plot performances of CapsE on the validation set over epochs in Figure FIGREF18 . We observe that the performance is improved with the increase in the number of filters since capsules can encode more useful properties for a large embedding size."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Other transition-based models extend TransE to additionally use projection vectors or matrices to translate embeddings of INLINEFORM0 and INLINEFORM1 into the vector space of INLINEFORM2 , such as: TransH BIBREF20 , TransR BIBREF21 , TransD BIBREF32 and STransE BIBREF24 . Furthermore, DISTMULT BIBREF13 and ComplEx BIBREF14 use a tri-linear dot product to compute the score for each triple. Moreover, ConvKB BIBREF15 applies convolutional neural network, in which feature maps are concatenated into a single feature vector which is then computed with a weight vector via a dot product to produce the score for the input triple. ConvKB is the most closely related model to our CapsE. See an overview of embedding models for KG completion in BIBREF6 .",
          "For search tasks, unlike classical methods, personalized search systems utilize the historical interactions between the user and the search system, such as submitted queries and clicked documents to tailor returned results to the need of that user BIBREF7 , BIBREF8 . That historical information can be used to build the user profile, which is crucial to an effective search personalization system. Widely used approaches consist of two separated steps: (1) building the user profile from the interactions between the user and the search system; and then (2) learning a ranking function to re-rank the search results using the user profile BIBREF9 , BIBREF33 , BIBREF10 , BIBREF11 . The general goal is to re-rank the documents returned by the search system in such a way that the more relevant documents are ranked higher. In this case, apart from the user profile, dozens of other features have been proposed as the input of a learning-to-rank algorithm BIBREF9 , BIBREF33 . Alternatively, BIBREF12 modeled the potential user-oriented relationship between the submitted query and the returned document by applying TransE to reward higher scores for more relevant documents (e.g., clicked documents). They achieved better performances than the standard ranker as well as competitive search personalization baselines BIBREF27 , BIBREF9 , BIBREF11 ."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We propose CapsE\u2014a novel embedding model using the capsule network to model relationship triples for knowledge graph completion and search personalization. Experimental results show that our CapsE outperforms other state-of-the-art models on two benchmark datasets WN18RR and FB15k-237 for the knowledge graph completion. We then show the effectiveness of our CapsE for the search personalization, in which CapsE outperforms the competitive baselines on the dataset SEARCH17 of the web search query logs. In addition, our CapsE is capable to effectively model many-to-many relationships. Our code is available at: https://github.com/daiquocnguyen/CapsE."
        ]
      },
      {
        "section_name": "Acknowledgement",
        "paragraphs": [
          "This research was partially supported by the ARC Discovery Projects DP150100031 and DP160103934. The authors thank Yuval Pinter for assisting us in running his code."
        ]
      }
    ],
    "qas": [
      {
        "question": "What size filters do they use in the convolution layer?",
        "question_id": "1acfbdc34669cf19a778aceca941543f11b9a861",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "1x3 filter size is used in convolutional layers.",
              "evidence": [
                "To that end, we introduce CapsE to explore a novel application of CapsNet on triple-based data for two problems: KG completion and search personalization. Different from the traditional modeling design of CapsNet where capsules are constructed by splitting feature maps, we use capsules to model the entries at the same dimension in the entity and relation embeddings. In our CapsE, INLINEFORM0 , INLINEFORM1 and INLINEFORM2 are unique INLINEFORM3 -dimensional embeddings of INLINEFORM4 , INLINEFORM5 and INLINEFORM6 , respectively. The embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] of (s, r, o) is fed to the convolution layer where multiple filters of the same INLINEFORM10 shape are repeatedly operated over every row of the matrix to produce INLINEFORM11 -dimensional feature maps. Entries at the same dimension from all feature maps are then encapsulated into a capsule. Thus, each capsule can encode many characteristics in the embedding triple to represent the entries at the corresponding dimension. These capsules are then routed to another capsule which outputs a continuous vector whose length is used as a score for the triple. Finally, this score is used to predict whether the triple (s, r, o) is valid or not."
              ],
              "highlighted_evidence": [
                "The embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] of (s, r, o) is fed to the convolution layer where multiple filters of the same INLINEFORM10 shape are repeatedly operated over every row of the matrix to produce INLINEFORM11 -dimensional feature maps."
              ]
            },
            "annotation_id": "9d7c2ee8e0dd25eea19c5e8e52459d827e7f39ba",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "c80a15ae611a393b6f1d8cad7e028da04f6f960c",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "1x3",
              "evidence": [
                "To that end, we introduce CapsE to explore a novel application of CapsNet on triple-based data for two problems: KG completion and search personalization. Different from the traditional modeling design of CapsNet where capsules are constructed by splitting feature maps, we use capsules to model the entries at the same dimension in the entity and relation embeddings. In our CapsE, INLINEFORM0 , INLINEFORM1 and INLINEFORM2 are unique INLINEFORM3 -dimensional embeddings of INLINEFORM4 , INLINEFORM5 and INLINEFORM6 , respectively. The embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] of (s, r, o) is fed to the convolution layer where multiple filters of the same INLINEFORM10 shape are repeatedly operated over every row of the matrix to produce INLINEFORM11 -dimensional feature maps. Entries at the same dimension from all feature maps are then encapsulated into a capsule. Thus, each capsule can encode many characteristics in the embedding triple to represent the entries at the corresponding dimension. These capsules are then routed to another capsule which outputs a continuous vector whose length is used as a score for the triple. Finally, this score is used to predict whether the triple (s, r, o) is valid or not."
              ],
              "highlighted_evidence": [
                "The embedding triple [ INLINEFORM7 , INLINEFORM8 , INLINEFORM9 ] of (s, r, o) is fed to the convolution layer where multiple filters of the same INLINEFORM10 shape are repeatedly operated over every row of the matrix to produce INLINEFORM11 -dimensional feature maps. "
              ]
            },
            "annotation_id": "cf7c1ec458b3344a9ede0c5fd7aee4c38f8caabc",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: An example illustration of our CapsE with k = 4, N = 5, and d = 2."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Statistics of the experimental datasets. #E is the number of entities. #R is the number of relations."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Experimental results on the WN18RR and FB15k-237 test sets. Hits@10 (H@10) is reported in %. Results of DISTMULT, ComplEx and ConvE are taken from Dettmers et al. (2018). Results of TransE on FB15k237 are taken from Nguyen et al. (2018). Our CapsE Hits@1 scores are 33.7% on WN18RR and 48.9% on FB15k-237. Formulas of MRR and Hits@1 show a strong correlation, so using Hits@1 does not really reveal any additional information for this task. The best score is in bold, while the second best score is in underline. ? denotes our new results for TransE and ConvKB, which are better than those published by Nguyen et al. (2018)."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Hits@10 (in %) and MRR on the FB15k-237 test set w.r.t each relation category."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Hits@10 and MRR on the WN18RR test set w.r.t each relation. The right y-axis is the percentage of triples corresponding to relations."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Hits@10 on the WN18RR validation set with N = 50 and the initial learning rate at 1e\u22125 w.r.t each number of iterations in the routing algorithm m and each 10 training epochs."
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: Experimental results on the test set. [?] denotes the results reported in (Vu et al., 2017). Hits@1 (H@1) is reported in %. In information retrieval, Hits@1 is also referred to as P@1. The subscripts denote the relative improvement over our TransE results."
      },
      {
        "file": "8-Figure4-1.png",
        "caption": "Figure 4: Learning curves on the validation set with the initial learning rate at 5e\u22125."
      }
    ]
  },
  "1907.05338": {
    "title": "To Tune or Not To Tune? How About the Best of Both Worlds?",
    "abstract": "The introduction of pre-trained language models has revolutionized natural language research communities. However, researchers still know relatively little regarding their theoretical and empirical properties. In this regard, Peters et al. perform several experiments which demonstrate that it is better to adapt BERT with a light-weight task-specific head, rather than building a complex one on top of the pre-trained language model, and freeze the parameters in the said language model. However, there is another option to adopt. In this paper, we propose a new adaptation method which we first train the task model with the BERT parameters frozen and then fine-tune the entire model together. Our experimental results show that our model adaptation method can achieve 4.7% accuracy improvement in semantic similarity task, 0.99% accuracy improvement in sequence labeling task and 0.72% accuracy improvement in the text classification task.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The introduction of pre-trained language models, such as BERT BIBREF1 and Open-GPT BIBREF2 , among many others, has brought tremendous progress to the NLP research and industrial communities. The contribution of these models can be categorized into two aspects. First, pre-trained language models allow modelers to achieve reasonable accuracy without the need an excessive amount of manually labeled data. This strategy is in contrast with the classical deep learning methods, which requires a multitude more data to reach comparable results. Second, for many NLP tasks, including but not limited to, SQuAD BIBREF3 , CoQA BIBREF4 , named entity recognition BIBREF5 , Glue BIBREF6 , machine translation BIBREF7 , pre-trained model allows the creation of new state-of-art, given a reasonable amount of labelled data.",
          "In the post pre-trained language model era, to pursue new state-of-art, two directions can be followed. The first method, is to improve the pre-training process, such as in the work of ERNIE BIBREF8 , GPT2.0 BIBREF2 and MT-DNN BIBREF9 . The second method is to stand on the shoulder of the pre-trained language models. Among the many possibilities, one of them is to build new neural network structures on top of pre-trained language models.",
          "In principles, there are three ways to train the networks with stacked neural networks on top of pre-trained language models, as shown in Table TABREF1 . In Peters et al . BIBREF0 , the authors compare the possibility of option stack-only and finetune-only, and conclude that option finetune-only is better than option stack-only. More specifically, Peter et al. BIBREF0 argue that it is better to add a task-specific head on top of BERT than to freeze the weights of BERT and add more complex network structures. However, Peters et al. BIBREF0 did not compare option stack-and-finetune and finetune-only. On the other hand, before pre-trained deep language models became popular, researchers often use a strategy analog to option stack-and-finetune. That is, modelers first train the model until convergence, and then fine-tune the word embeddings with a few epochs. If pre-trained language models can be understood as at least partially resemblance of word embeddings, then it will be imprudent not to consider the possibility of option stack-and-finetune.",
          "In this study, we aim to compare the strategy stack-and-finetune and strategy finetune-only. More specifically, we perform three NLP tasks, sequence labeling, text classification, and question similarity. In the first tasks, we demonstrate that even without modifying the network structures, building networks on top of pre-trained language models might improve accuracy. In the second tasks, we show that by ensembling different neural networks, one can even improve the accuracy of fine-tuning only methods even further. Finally, in the last task, we demonstrate that if one can tailor-made a neural network that specifically fit the characteristics of the pre-trained language models, one can improve the accuracy even further. All the results indicate the strategy stack-and-finetune is superior to strategy finetune-only. This leads us to conclude that, at least, by overlooking the possibility strategy stack-and-finetune is imprudent.",
          "The contribution of this paper is two-fold. First, we propose a new strategy to improve the fine-tune-only strategy proposed by Peter et al. BIBREF0 , this allows us to achieve better results, at least on the selected tasks. More importantly, the results of this study demonstrate the importance of neural networks design, even in the presence of all-powerful pre-trained language models. Second, during the experiment, we have found that although simply using the proposed training strategy can result in higher accuracies compared to that of Peter et al. BIBREF0 , it is still a challenging task to find the appropriate methods to design and to utilize pre-trained networks. In this regard, we find that pre-trained models differ significantly from word embeddings in terms of their training strategies. Especially, since word embeddings can be viewed as shallow transfer learning, while pre-trained model should be viewed as deep transfer learning, one must try to combat over-fitting problems with more care due to the enormous number of parameters presented in the pre-trained models. Besides, we also find that in order to achieve the maximal performance in the post-pre-trained language model era, one must design, either manually or via Auto ML, networks that best fit the structure, especially the depth of the pre-trained language models.",
          "The rest of the paper is organized as follows. First, we review the relevant literature on pre-trained deep neural networks, the argument in Peter et al. BIBREF0 as well as fine-tuning strategies with word embeddings. Second, we present three experiments and showed the superiority of strategy stack-and-finetune compared to strategy finetune-only. Finally, we conclude with some remarks and future research possibilities."
        ]
      },
      {
        "section_name": "Related Studies",
        "paragraphs": [
          "Before the introduction of deep neural networks, researchers in the field of NLP have been using pre-trained models. Among all of them, one of the most famous is the word embeddings, which maps each word into a continuous vector, instead of one-hot encodings BIBREF10 . By doing so, not only are we able to reduce the dimensionality of the input features, which helps to avoid over-fitting, but also capture, at least partially, the internal meaning of each word.",
          "However, since each word is only endowed with a fixed numerical vector in the methodology of word embeddings, word embeddings are unable to capture the contextual meaning in the text. For example, consider the word \u201dbank\u201d sentences \u201cI am walking on the bank of the river.\u201d with \u201cI am going to rob the bank\u201d. It is obvious that the word \u201cbank\u201d represents completely different meaning, which the word embeddings techniques fail to capture.",
          "The aforementioned deficiencies prompt researchers to propose deep neural networks that are able to be trained in an unsupervised fashion while being able to capture the contextual meaning of the words presented in the texts. Some early attempts include pre-trained models includes, CoVe BIBREF11 , CVT BIBREF12 , BIBREF13 , ELMo BIBREF14 and ULMFiT BIBREF15 . However, the most successful ones are BERT BIBREF1 and Open-GPT BIBREF2 . Unlike standard NLP deep learning model, BERT and Open-GPT are built on top of transformer BIBREF16 structures, instead of LSTM BIBREF17 or GRU BIBREF18 . The difference between BERT and Open-GPT is that BERT uses bi-directional self-attentions while Open-GPT uses only unidirectional ones, as shown in Figure FIGREF2 . The transformer structures differ from the LSTM's in the two important aspects. First, it allows for stacking of multiple layers with residual connections and batch normalizations, which allows for free gradient flow. Second, the core computational unit is matrix multiplications, which allows researchers to utilize the full computational potential of TPU BIBREF19 . After training on a large corpus, both BERT and Open-GPT are able to renew the SOTA of many important natural language tasks, such as such as SQuAD BIBREF3 , CoQA BIBREF4 , named entity recognition BIBREF5 , Glue BIBREF6 , machine translation BIBREF7 .",
          "In the presence of the success of pre-trained language models, especially BERT BIBREF1 , it is natural to ask how to best utilize the pre-trained language models to achieve new state-of-the-art results. In this line of work, Liu et al. BIBREF20 investigated the linguistic knowledge and transferability of contextual representations by comparing BERT BIBREF1 with ELMo BIBREF14 , and concluded that while the higher levels of LSTM's are more task-specific, this trend does not exhibit in transformer based models. Stickland and Murray BIBREF21 invented projected attention layer for multi-task learning using BERT, which results in an improvement in various state-of-the-art results compared to the original work of Devlin et al. BIBREF1 . Xu et al. BIBREF22 propose a \u201cpost-training\u201d algorithms, which does not directly fine-tune BERT, but rather first \u201cpost-train\u201d BERT on the task related corpus using the masked language prediction task next sentence prediction task, which helps to reduce the bias in the training corpus. Finally, Sun et al. BIBREF23 added additional fine-tuning tasks based on multi-task training, which further improves the prediction power of BERT in the tasks of text classification.",
          "In this aspect, however, there is a simple yet crucial question that needs to be addressed. That is, whether it is possible to top BERT with the commonly used or task specific layers, and if this is possible, how to best utilize the pre-trained language models in this situation. In this regards, Peters et al. BIBREF0 investigated how to best adapt the pre-trained model to a specific task, and focused on two different adaptation method,feature extraction and directly fine-tuning the pre-trained model, which corresponding to the strategy finetune-only and the strategy stack-only in Table TABREF1 . On this regard, Peters et al. BIBREF0 performs five experiments, including: (1) named entity recognition BIBREF5 ; (2) sentiment analysis BIBREF24 ; (3) natural language inference BIBREF25 ; (4) paraphrase detection BIBREF26 ; (5) semantic textual similarity BIBREF27 . By the results of these tasks, Peters et al. BIBREF0 concludes that adding a light task-specific head and performing fine-tuning on BERT is better than building a complex network on top without BERT fine-tuning."
        ]
      },
      {
        "section_name": "Methodology",
        "paragraphs": [
          "Under our strategy stack-and-finetune, the model training process is divided into two phases, which are described in detail below. In the first phase, the parameters of the pre-training model are fixed, and only the upper-level models added for a specific task is learned. In the second phase, we fine-tune the upper-level models together with the pre-trained language models. We choose this strategy for the following reasons. Pre-training models have been used to obtain more effective word representations through the study of a large number of corpora. In the paradigm proposed in the original work by Devlin et al. BIBREF1 , the author directly trained BERT along with with a light-weighted task-specific head. In our case though, we top BERT with a more complex network structure, using Kaiming initialization BIBREF28 . If one would fine-tune directly the top models along with the weights in BERT, one is faced with the following dilemma: on the one hand, if the learning rate is too large, it is likely to disturb the structure innate to the pre-trained language models; on the other hand, if the learning rate is too small, since we top BERT with relatively complex models, the convergence of the top models might be impeded. Therefore, in the first phase we fix the weights in the pre-training language models, and only train the model on top of it.",
          "Another aspect that is worth commenting in the first phase is that it is most beneficial that one does not train the top model until it reaches the highest accuracy on the training or validation data sets, but rather only up to a point where the prediction accuracy of the training and validation data sets do not differ much. This is intuitively reasonable for the following reasons. Unlike word embeddings, the pre-trained language models possess a large number of parameters compared to the task-specific models we build on top them. Therefore, if one were to train the top models until they reach the highest prediction accuracy in the training or validation data sets, it would likely cause the models to over-fit. Therefore, in our experiment, we found that this leads to the highest performance increase in the fine-tuning stage."
        ]
      },
      {
        "section_name": "Overview",
        "paragraphs": [
          "We perform three different experiments to test our hypotheses. First, we perform a named entity recognition tasks, by adding a bi-LSTM on top of the BERT model. In this experiment, we hope to test whether, without any modification to the commonly used network structure, our proposed training strategy will improve the overall accuracy. Second, we perform a text classification experiments, in this experiments, we trained three models, and perform a model ensemble. We hope to show that even the added network has not contributed to significantly in improving the accuracy, it does provide opportunities for model ensembles. Finally, we perform the textual similarity tests, in which we show that if one can tailor make a network that specifically fit the characteristics of the pre-trained languages, more significant improvement can be expected.",
          "Under the strategy finetune-only, we use only single BERT.In order to adapt to different tasks, we will add a fully connected layer upon BERT. In the sequence labeling task, the BERT word embedding of each word passes through two fully connected layers, and the prediction probability of named entity can be obtained. In the next two verification tasks, we use \u201c[CLS]\u201d for prediction and add two fully connected layers subsequently. Under our strategy stack-and-finetune, we set different learning rates for the two phases. We tried to set the learning rate of the first stage to INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 and INLINEFORM4 , and set it to a smaller number in the latter stage, such as INLINEFORM5 , INLINEFORM6 , INLINEFORM7 and INLINEFORM8 . After our experiments, we found that it gets better results while the learning rate is set to 0.001 in the stage of training only the upper model and set to INLINEFORM9 in the later stage. Since BERT-Adam BIBREF1 has excellent performance, in our experiments, we use it as an optimizer with INLINEFORM10 , INLINEFORM11 -weight decay of INLINEFORM12 .We apply a dropout trick on all layers and set the dropout probability as 0.1."
        ]
      },
      {
        "section_name": "Experiment A: Sequence Labeling",
        "paragraphs": [
          "In the sequence labeling task,we explore sub-task named entity recognition using CoNLL03 dataset BIBREF5 , which is a public available used in many studies to test the accuracy of their proposed methods BIBREF29 , BIBREF30 , BIBREF31 , BIBREF32 , BIBREF1 . For strategy finetune-only and strategy stack-and-finetune, we implemented two models: one with BERT and the other with BERT adding a Bi-LSTM on top. Eval measure is accuracy and F1 score.",
          "As is shown in Table 2, even without modifying the networks to specifically adapt to the pre-trained model, our training strategy still brought improvement towards overall accuracy of 0.99% for the accuracy and 0.068 on the F1 score, proving the success of our proposed methods."
        ]
      },
      {
        "section_name": "Experiment B: Text Classification",
        "paragraphs": [
          "In the task of text categorization, we used Yahoo Answer Classification Dataset. The Dataset is consists of 10 classes, but due to the huge amount of the dataset, we just select two class of them. As for the upper model,we choose DenseNet BIBREF33 and HighwayLSTM BIBREF34 .",
          "The DenseNet structure contains four independent blocks and each block has four CNNs connected by residual. We initialize word embedding in the word representation layer with BERT. We initialize each character as a 768-dimension vector. In the experiment of training DenseNet,we concat the output vector of DenseNet with [CLS] for prediction.",
          "We find the ensembled model enjoys a 0.72% improvements compared to the fine-tune only model and 0.005 improvement for the F1 score."
        ]
      },
      {
        "section_name": "Experiment C: Semantic Similarity Tasks",
        "paragraphs": [
          "We use \u201cQuora-Question-Pair\u201d dataset 1. This is a commonly used dataset containing 400k question pairs, annotated manually to be semantically equivalent or not. Due to its high quality, it is a standard dataset to test the success of various semantic similarity tasks. Various models which are tested on this data set are proposed, including but not limited to BIBREF35 , BIBREF36 , BIBREF37 , BIBREF38 .",
          "Apart from the BERT fine-tuning only model and BERT+ BIMPM model, we also devise two new network structures by modifying the BIMPM model. In the first model is to remove the first bi-LSTM of BIMPM, which is the input layer for the matching layer in BIMPM. In the second model, we combine the matching layer of BIMPM and with a transformer BIBREF16 , a model we call Sim-Transformer by replacing the output layer of the matching layer, originally a bi-LSTM model, with a transformer model. From the experimental results shown in Table 4, we can see that due to the strong expressive ability of the BERT, there is almost no difference in the experimental results of removing the first bi-LSTM and BIMPM. In addition, we also find that Sim-Transformer's performance without fine-tuning is nearly four percentage points lower than BIMPM, but it out-performs BIMPM after fine-tuning. In general, the results show that BERT + Sim-Transformer out-performs BERT-only model by 4.7%, thus confirming our hypotheses again."
        ]
      },
      {
        "section_name": "Discussions and Conclusions",
        "paragraphs": [
          "In summary, we find that in all the three tasks, our proposed method out-performs the methods of simply tuning pre-trained language models, as is proposed in BIBREF0 . However, we would like to caution the readers in two aspects when reading the conclusion of this study. First, this study does not argue that our proposed methods are always superior to fine-tuning only methods. For example, all the experiments in our study are based on data sets of relatively large size. In the other spectrum, if one is only given a limited data set, then building complex networks upon pre-trained language models might lead to disastrous over-fitting. If this is the case, then it is possible that deep domain adaptation BIBREF39 might be a better choice if one desires to stack neural networks on top of pre-trained language models. However, most domain adaptation applications belong to the field of computer vision, therefore, a call for domain adaptations research in the NLP fields.",
          "During the experimentation, we also discover some tricks to obtain higher quality networks. The first is that due to the enormous number of parameters presented in the pre-trained language models, to achieve generalizable results on the test data sets, it is vital to combat over-fitting. In classical embedding + training networks, the general training method is to fix the word-embeddings, then train the top model until it converges, and finally fine-tuning the word-embeddings for a few epochs. This training strategy does not work when we replace pre-trained language models with word-embeddings. In our experiment, we first fix the pre-trained language models, and then we train the top neural networks only for a few epochs, until it reaches a reasonable accuracy, while closely monitoring the discrepancy between training accuracy and testing accuracy. After that, we fine-tune the pre-trained language model as well as our models on top together. This allows us to achieve better results on the experimentation. However, it is not yet clear to us when to stop the training of top neural networks. This poses an even more essential question for Auto ML researchers in the following sense. In the classical computer vision based Auto ML approaches, since one seldom build networks on already trained models, there is no particular need to auxiliary measure for over-fittings. While if Auto ML is to be performed on NLP tasks successfully, it might be essential that the gap between training accuracy and test accuracy to be incorporated when one evaluates the model.",
          "Finally, it is not yet clear what is the most proper way to build networks that tops the pre-trained language models. However, there are several principles that we can follow when designing such networks. First, such networks must be able to ensure the gradient flow from the top of the model to the bottom. This is essential due to the depth of the pre-trained language model. Second, this also means, one does not need explicitly to build extremely complex networks on top of pre-trained language models unless it complements the mechanisms of self-attention. Finally, a challenge remains as to how to use the depth of pre-trained language models. The process of our experiment shows that utilizing deeper layers might be a fruitful way to achieve better accuracy."
        ]
      }
    ],
    "qas": [
      {
        "question": "did they test with other pretrained models besides bert?",
        "question_id": "79e61134a6e29141cd19252571ffc92a0b4bc97f",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "We perform three different experiments to test our hypotheses. First, we perform a named entity recognition tasks, by adding a bi-LSTM on top of the BERT model. In this experiment, we hope to test whether, without any modification to the commonly used network structure, our proposed training strategy will improve the overall accuracy. Second, we perform a text classification experiments, in this experiments, we trained three models, and perform a model ensemble. We hope to show that even the added network has not contributed to significantly in improving the accuracy, it does provide opportunities for model ensembles. Finally, we perform the textual similarity tests, in which we show that if one can tailor make a network that specifically fit the characteristics of the pre-trained languages, more significant improvement can be expected.",
                "Under the strategy finetune-only, we use only single BERT.In order to adapt to different tasks, we will add a fully connected layer upon BERT. In the sequence labeling task, the BERT word embedding of each word passes through two fully connected layers, and the prediction probability of named entity can be obtained. In the next two verification tasks, we use \u201c[CLS]\u201d for prediction and add two fully connected layers subsequently. Under our strategy stack-and-finetune, we set different learning rates for the two phases. We tried to set the learning rate of the first stage to INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 and INLINEFORM4 , and set it to a smaller number in the latter stage, such as INLINEFORM5 , INLINEFORM6 , INLINEFORM7 and INLINEFORM8 . After our experiments, we found that it gets better results while the learning rate is set to 0.001 in the stage of training only the upper model and set to INLINEFORM9 in the later stage. Since BERT-Adam BIBREF1 has excellent performance, in our experiments, we use it as an optimizer with INLINEFORM10 , INLINEFORM11 -weight decay of INLINEFORM12 .We apply a dropout trick on all layers and set the dropout probability as 0.1."
              ],
              "highlighted_evidence": [
                "First, we perform a named entity recognition tasks, by adding a bi-LSTM on top of the BERT model. ",
                "Under the strategy finetune-only, we use only single BERT."
              ]
            },
            "annotation_id": "043a190c8e474d7ca7ede7bbdc340409e0482d49",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "We perform three different experiments to test our hypotheses. First, we perform a named entity recognition tasks, by adding a bi-LSTM on top of the BERT model. In this experiment, we hope to test whether, without any modification to the commonly used network structure, our proposed training strategy will improve the overall accuracy. Second, we perform a text classification experiments, in this experiments, we trained three models, and perform a model ensemble. We hope to show that even the added network has not contributed to significantly in improving the accuracy, it does provide opportunities for model ensembles. Finally, we perform the textual similarity tests, in which we show that if one can tailor make a network that specifically fit the characteristics of the pre-trained languages, more significant improvement can be expected.",
                "Under the strategy finetune-only, we use only single BERT.In order to adapt to different tasks, we will add a fully connected layer upon BERT. In the sequence labeling task, the BERT word embedding of each word passes through two fully connected layers, and the prediction probability of named entity can be obtained. In the next two verification tasks, we use \u201c[CLS]\u201d for prediction and add two fully connected layers subsequently. Under our strategy stack-and-finetune, we set different learning rates for the two phases. We tried to set the learning rate of the first stage to INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 and INLINEFORM4 , and set it to a smaller number in the latter stage, such as INLINEFORM5 , INLINEFORM6 , INLINEFORM7 and INLINEFORM8 . After our experiments, we found that it gets better results while the learning rate is set to 0.001 in the stage of training only the upper model and set to INLINEFORM9 in the later stage. Since BERT-Adam BIBREF1 has excellent performance, in our experiments, we use it as an optimizer with INLINEFORM10 , INLINEFORM11 -weight decay of INLINEFORM12 .We apply a dropout trick on all layers and set the dropout probability as 0.1."
              ],
              "highlighted_evidence": [
                "First, we perform a named entity recognition tasks, by adding a bi-LSTM on top of the BERT model.",
                "Under the strategy finetune-only, we use only single BERT.In order to adapt to different tasks, we will add a fully connected layer upon BERT. In the sequence labeling task, the BERT word embedding of each word passes through two fully connected layers, and the prediction probability of named entity can be obtained."
              ]
            },
            "annotation_id": "63c58de6fb55db8552a052faf2da734a92cb18f8",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Under the strategy finetune-only, we use only single BERT.In order to adapt to different tasks, we will add a fully connected layer upon BERT. In the sequence labeling task, the BERT word embedding of each word passes through two fully connected layers, and the prediction probability of named entity can be obtained. In the next two verification tasks, we use \u201c[CLS]\u201d for prediction and add two fully connected layers subsequently. Under our strategy stack-and-finetune, we set different learning rates for the two phases. We tried to set the learning rate of the first stage to INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 and INLINEFORM4 , and set it to a smaller number in the latter stage, such as INLINEFORM5 , INLINEFORM6 , INLINEFORM7 and INLINEFORM8 . After our experiments, we found that it gets better results while the learning rate is set to 0.001 in the stage of training only the upper model and set to INLINEFORM9 in the later stage. Since BERT-Adam BIBREF1 has excellent performance, in our experiments, we use it as an optimizer with INLINEFORM10 , INLINEFORM11 -weight decay of INLINEFORM12 .We apply a dropout trick on all layers and set the dropout probability as 0.1."
              ],
              "highlighted_evidence": [
                "Under the strategy finetune-only, we use only single BERT."
              ]
            },
            "annotation_id": "8903d5b7ac7c5ad82db6d3f3b15d33a5aa35837c",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Methods to Stack Neural Networks on Top of Pre-trained Language Models"
      },
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: The Difference Between BERT and Open-GPT, extracted from Devlin et al. [2], Figure 1"
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Results for named entity recognition"
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Results for text classification"
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Results for semantic similarity task"
      }
    ]
  },
  "2003.08437": {
    "title": "A Corpus of Adpositional Supersenses for Mandarin Chinese",
    "abstract": "Adpositions are frequent markers of semantic relations, but they are highly ambiguous and vary significantly from language to language. Moreover, there is a dearth of annotated corpora for investigating the cross-linguistic variation of adposition semantics, or for building multilingual disambiguation systems. This paper presents a corpus in which all adpositions have been semantically annotated in Mandarin Chinese; to the best of our knowledge, this is the first Chinese corpus to be broadly annotated with adposition semantics. Our approach adapts a framework that defined a general set of supersenses according to ostensibly language-independent semantic criteria, though its development focused primarily on English prepositions (Schneider et al., 2018). We find that the supersense categories are well-suited to Chinese adpositions despite syntactic differences from English. On a Mandarin translation of The Little Prince, we achieve high inter-annotator agreement and analyze semantic correspondences of adposition tokens in bitext.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Adpositions (i.e. prepositions and postpositions) include some of the most frequent words in languages like Chinese and English, and help convey a myriad of semantic relations of space, time, causality, possession, and other domains of meaning. They are also a persistent thorn in the side of second language learners owing to their extreme idiosyncrasy BIBREF1, BIBREF2. For instance, the English word in has no exact parallel in another language; rather, for purposes of translation, its many different usages cluster differently depending on the second language. Semantically annotated corpora of adpositions in multiple languages, including parallel data, would facilitate broader empirical study of adposition variation than is possible today, and could also contribute to NLP applications such as machine translation BIBREF3, BIBREF4, BIBREF5, BIBREF6, BIBREF7, BIBREF8, BIBREF9 and grammatical error correction BIBREF1, BIBREF10, BIBREF11, BIBREF12, BIBREF13, BIBREF14.",
          "This paper describes the first corpus with broad-coverage annotation of adpositions in Chinese. For this corpus we have adapted schneider-etal-2018-comprehensive Semantic Network of Adposition and Case Supersenses annotation scheme (SNACS; see sec:snacs) to Chinese. Though other languages were taken into consideration in designing SNACS, no serious annotation effort has been undertaken to confirm empirically that it generalizes to other languages. After developing new guidelines for syntactic phenomena in Chinese (subsec:adpositioncriteria), we apply the SNACS supersenses to a translation of The Little Prince (3 2 3), finding the supersenses to be robust and achieving high inter-annotator agreement (sec:corpus-annotation). We analyze the distribution of adpositions and supersenses in the corpus, and compare to adposition behavior in a separate English corpus (see sec:corpus-analysis). We also examine the predictions of a part-of-speech tagger in relation to our criteria for annotation targets (sec:adpositionidentification). The annotated corpus and the Chinese guidelines for SNACS will be made freely available online."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "To date, most wide-coverage semantic annotation of prepositions has been dictionary-based, taking a word sense disambiguation perspective BIBREF16, BIBREF17, BIBREF18. BIBREF19 proposed a supersense-based (unlexicalized) semantic annotation scheme which would be applied to all tokens of prepositions in English text. We adopt a revised version of the approach, known as SNACS (see sec:snacs). Previous SNACS annotation efforts have been mostly focused on English\u2014particularly STREUSLE BIBREF20, BIBREF0, the semantically annotated corpus of reviews from the English Web Treebank BIBREF21. We present the first adaptation of SNACS for Chinese by annotating an entire Chinese translation of The Little Prince."
        ]
      },
      {
        "section_name": "Related Work ::: Chinese Adpositions and Roles",
        "paragraphs": [
          "In the computational literature for Chinese, apart from some focused studies (e.g., BIBREF22 on logical-semantic representation of temporal adpositions), there has been little work addressing adpositions specifically. Most previous semantic projects for Mandarin Chinese focused on content words and did not directly annotate the semantic relations signaled by functions words such as prepositions BIBREF23, BIBREF24, BIBREF25, BIBREF26. For example, in Chinese PropBank, BIBREF27 argued that the head word and its part of speech are clearly informative for labeling the semantic role of a phrase, but the preposition is not always the most informative element. BIBREF28 annotated the Tsinghua Corpus BIBREF29 from People\u2019s Daily where the content words were selected as the headwords, i.e., the object is the headword of the prepositional phrase. In these prepositional phrases, the nominal headwords were labeled with one of the 59 semantic relations (e.g. Location, LocationIni, Kernel word) whereas the prepositions and postpositions were respectively labeled with syntactic relations Preposition and LocationPreposition. Similarly, in Semantic Dependency Relations (SDR, BIBREF30, BIBREF31), prepositions and localizers were labeled as semantic markers mPrep and mRange, whereas semantic roles, e.g., Location, Patient, are assigned to the governed nominal phrases.",
          "BIBREF32 compared PropBank parsing performance on Chinese and English, and showed that four Chinese prepositions (4, 2, 3, and 4) are among the top 20 lexicalized syntactic head words in Chinese PropBank, bridging the connections between verbs and their arguments. The high frequency of prepositions as head words in PropBank reflects their importance in context. However, very few annotation scheme attempted to directly label the semantics of these adposition words.",
          "BIBREF33 is the most relevant adposition annotation effort, categorizing Chinese prepositions into 66 types of senses grouped by lexical items. However, these lexicalized semantic categories are constrained to a given language and a closed set of adpositions. For semantic labeling of Chinese adpositions in a multilingual context, we turn to the SNACS framework, described below."
        ]
      },
      {
        "section_name": "Related Work ::: SNACS: Adposition Supersenses",
        "paragraphs": [
          "BIBREF0 proposed the Semantic Network of Adposition and Case Supersenses (SNACS), a hierarchical inventory of 50 semantic labels, i.e., supersenses, that characterize the use of adpositions, as shown in fig:supersenses. Since the meaning of adpositions is highly affected by the context, SNACS can help distinguish different usages of adpositions. For instance, single-label presents an example of the supersense Topic for the adposition about which emphasizes the subject matter of urbanization that the speaker discussed. In single-label-amb, however, the same preposition about takes a measurement in the context, expressing an approximation.",
          ". I gave a presentation about:Topic urbanization.",
          ". We have about:Approximator 3 eggs left.",
          "Though assigning a single label to each adposition can help capture its lexical contribution to the sentence meaning as well as disambiguate its uses in different scenarios, the canonical lexical semantics of adpositions are often stretched to fit the needs of the scene in actual language use.",
          ". I care about:StimulusTopic you.",
          "For instance, eg:stimulustopic blends the domains of emotion (principally reflected in care, which licenses a Stimulus), and cognition (principally reflected in about, which often marks non-emotional Topics). Thus, SNACS incorporates the construal analysis BIBREF34 wherein the lexical semantic contribution of an adposition (its function) is distinguished and may diverge from the underlying relation in the surrounding context (its scene role). Construal is notated by SceneRoleFunction, as StimulusTopic in eg:stimulustopic.",
          "Another motivation for incorporating the construal analysis, as pointed out by BIBREF34, is its capability to adapt the English-centric supersense labels to other languages, which is the main contribution of this paper. The construal analysis can give us insights into the similarities and differences of function and scene roles of adpositions across languages."
        ]
      },
      {
        "section_name": "Adposition Criteria in Mandarin Chinese",
        "paragraphs": [
          "Our first challenge is to determine which tokens qualify as adpositions in Mandarin Chinese and merit supersense annotations. The English SNACS guidelines (we use version 2.3) broadly define the set of SNACS annotation targets to include canonical prepositions (taking an noun phrase (NP) complement) and their subordinating (clausal complement) uses. Possessives, intransitive particles, and certain uses of the infinitive marker to are also included BIBREF35.",
          "In Chinese, the difficulty lies in two areas, which we discuss below. Firstly, prepositional words are widely attested. However, since no overt derivational morphology occurs on these prepositional tokens (previously referred to as coverbs), we need to filter non-prepositional uses of these words. Secondly, post-nominal particles, i.e., localizers, though not always considered adpositions in Chinese, deliver rich semantic information."
        ]
      },
      {
        "section_name": "Adposition Criteria in Mandarin Chinese ::: Coverbs",
        "paragraphs": [
          "Tokens that are considered generic prepositions can co-occur with the main predicate of the clause and introduce an NP argument to the clause BIBREF36 as in zho:shangtopic. These tokens are referred to as coverbs. In some cases, coverbs can also occur as the main predicate. For example, the coverb 4 heads the predicate phrase in zho:pred.",
          ". 1 4:Locus 24 4:TopicLocus 3342.",
          "3sg p:at academia lc:on-top-of successful",
          "`He succeeded in academia.\u2019",
          ". 3 4 de 2 4 4 34.",
          "2sg want de sheep res at inside",
          "`The sheep you wanted is in the box.' (zh_lpp_1943.92)",
          "In this project, we only annotate coverbs when they do not function as the main predicate in the sentence, echoing the view that coverbs modify events introduced by the predicates, rather than establishing multiple events in a clause BIBREF37. Therefore, lexical items such as 4 are annotated when functioning as a modifier as in zho:shangtopic, but not when as the main predicate as in zho:pred."
        ]
      },
      {
        "section_name": "Adposition Criteria in Mandarin Chinese ::: Localizers",
        "paragraphs": [
          "Localizers are words that follow a noun phrase to refine its semantic relation. For example, 4 in zho:shangtopic denotes a contextual meaning, `in a particular area,' whereas the co-occurring coverb 4 only conveys a generic location. It is unclear whether localizers are syntactically postpositions, but we annotate all localizers because of their semantic significance. Though coverbs frequently co-occur with localizers and the combination of coverbs and localizers is very productive, there is no strong evidence to suggest that they are circumpositions. As a result, we treat them as separate targets for SNACS annotation: for example, 4 and 4 receive Locus and TopicLocus respectively in zho:shangtopic.",
          "Setting aside the syntactic controversies of coverbs and localizers in Mandarin Chinese, we regard both of them as adpositions that merit supersense annotations. As in zho:shangtopic, both the coverb 4 and the localizer 4 surround an NP argument 24 (`academia') and they as a whole modify the main predicate 3342 (`successful'). In this paper, we take the stance that coverbs co-occur with the main predicate and precede an NP, whereas localizers follow a noun phrase and add semantic information to the clause."
        ]
      },
      {
        "section_name": "Corpus Annotation",
        "paragraphs": [
          "We chose to annotate the novella The Little Prince because it has been translated into hundreds of languages and dialects, which enables comparisons of linguistic phenomena across languages on bitexts. This is the first Chinese corpus to undergo SNACS annotation. Ongoing adpositional supersense projects on The Little Prince include English, German, French, and Korean. In addition, The Little Prince has received large attention from other semantic frameworks and corpora, including the English BIBREF38 and Chinese BIBREF26 AMR corpora."
        ]
      },
      {
        "section_name": "Corpus Annotation ::: Preprocessing",
        "paragraphs": [
          "We use the same Chinese translation of The Little Prince as the Chinese AMR corpus BIBREF26, which is also sentence-aligned with the English AMR corpus BIBREF38. These bitext annotations in multiple languages and annotation semantic frameworks can facilitate cross-framework comparisons.",
          "Prior to supersense annotation, we conducted the following preprocessing steps in order to identify the adposition targets that merit supersense annotation."
        ]
      },
      {
        "section_name": "Corpus Annotation ::: Preprocessing ::: Tokenization",
        "paragraphs": [
          "After automatic tokenization using Jieba, we conducted manual corrections to ensure that all potential adpositions occur as separate tokens, closely following the Chinese Penn Treebank segmentation guidelines BIBREF39. The final corpus includes all 27 chapters of The Little Prince, with a total of 20k tokens."
        ]
      },
      {
        "section_name": "Corpus Annotation ::: Preprocessing ::: Adposition Targets",
        "paragraphs": [
          "All annotators jointly identified adposition targets according to the criteria discussed in subsec:adpositioncriteria. Manual identification of adpositions was necessary as an automatic POS tagger was found unsuitable for our criteria (sec:adpositionidentification)."
        ]
      },
      {
        "section_name": "Corpus Annotation ::: Preprocessing ::: Data Format",
        "paragraphs": [
          "Though parsing is not essential to this annotation project, we ran the StanfordNLP BIBREF40 dependency parser to obtain POS tags and dependency trees. These are stored alongside supersense annotations in the CoNLL-U-Lex format BIBREF41, BIBREF0. CoNLL-U-Lex extends the CoNLL-U format used by the Universal Dependencies BIBREF42 project to add additional columns for lexical semantic annotations."
        ]
      },
      {
        "section_name": "Corpus Annotation ::: Reliability of Annotation",
        "paragraphs": [
          "The corpus is jointly annotated by three native Mandarin Chinese speakers, all of whom have received advanced training in theoretical and computational linguistics. Supersense labeling was performed cooperatively by 3 annotators for 25% (235/933) of the adposition targets, and for the remainder, independently by the 3 annotators, followed by cooperative adjudication. Annotation was conducted in two phases, and therefore we present two inter-annotator agreement studies to demonstrate the reproducibility of SNACS and the reliability of the adapted scheme for Chinese.",
          "",
          "tab:iaa-results shows raw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons. Agreement levels on scene role, function, and full construal are high for both phases, attesting to the validity of the annotation framework in Chinese. However, there is a slight decrease from Phase 1 to Phase 2, possibly due to the seven newly attested adpositions in Phase 2 and the 1-year interval between the two annotation phases."
        ]
      },
      {
        "section_name": "Corpus Analysis",
        "paragraphs": [
          "Our corpus contains 933 manually identified adpositions. Of these, 70 distinct adpositions, 28 distinct scene roles, 26 distinct functions, and 41 distinct full construals are attested in annotation. Full statistics of token and type frequencies are shown in tab:stats. This section presents the most frequent adpositions in Mandarin Chinese, as well as quantitative and qualitative comparisons of scene roles, functions, and construals between Chinese and English annotations."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Adpositions in Chinese",
        "paragraphs": [
          "We analyze semantic and distributional properties of adpositions in Mandarin Chinese. The top 5 most frequent prepositions and postpositions are shown in tab:statstoptoks. Prepositions include canonical adpositions such as 14 and coverbs such as 4. Postpositions are localizers such as 4 and 1. We observe that prepositions 4 and 4 are dominant in the corpus (greater than 10%). Other top adpositions are distributed quite evenly between prepositions and postpositions. On the low end, 27 out of the 70 attested adposition types occur only once in the corpus."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English",
        "paragraphs": [
          "The distribution of scene role and function types in Chinese and English reflects the differences and similarities of adposition semantics in both languages. In tab:statssupersensezhen we compare this corpus with the largest English adposition supersense corpus, STREUSLE version 4.1 BIBREF0, which consists of web reviews. We note that the Chinese corpus is proportionally smaller than the English one in terms of token and adposition counts. Moreover, there are fewer scene role, function and construal types attested in Chinese. The proportion of construals in which the scene role differs from the function (scene$\\ne $fxn) is also halved in Chinese. In this section, we delve into comparisons regarding scene roles, functions, and full construals between the two corpora both quantitatively and qualitatively."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: Overall Distribution of Supersenses",
        "paragraphs": [
          "fig:barscenezhen,fig:barfunctionzhen present the top 10 scene roles and functions in Mandarin Chinese and their distributions in English. It is worth noting that since more scene role and function types are attested in the larger STREUSLE dataset, the percentages of these supersenses in English are in general lower than the ones in Chinese.",
          "",
          "There are a few observations in these distributions that are of particular interest. For some of the examples, we use an annotated subset of the English Little Prince corpus for qualitative comparisons, whereas all quantitative results in English refer to the larger STREUSLE corpus of English Web Treebank reviews BIBREF0."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: Fewer Adpositions in Chinese",
        "paragraphs": [
          "As shown in tab:statssupersensezhen, the percentage of adposition targets over tokens in Chinese is only half of that in English. This is due to the fact that Chinese has a stronger preference to convey semantic information via verbal or nominal forms. Examples eg:enmoreadpositions,eg:zhlessadpositions show that the prepositions used in English, of and in, are translated as copula verbs (4) and progressives (44) in Chinese. Corresponding to fig:barscenezhen,fig:barfunctionzhen, the proportion of the supersense label Topic in English is higher than that in Chinese; and similarly, the supersense label Identity is not attested in Chinese for either scene role or function.",
          ". It was a picture of:Topic a boa constrictor in:Manner the act of:Identity swallowing an animal . (en_lpp_1943.3)",
          ". [4 de] 4 [[4 2 32] 44 12 [4 1 4 34]]",
          "draw de cop one cl boa prog swallow one cl big animal",
          "`The drawing is a boa swallowing a big animal'. (en_lpp_1943.3)"
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: Larger Proportion of Locus in Chinese",
        "paragraphs": [
          "In both fig:barscenezhen and fig:barfunctionzhen, the percentages of Locus as scene role and function are twice that of the English corpus respectively. This corresponds to the fact that fewer supersense types occur in Mandarin Chinese than in English. As a result, generic locative and temporal adpositions, as well as adpositions tied to thematic roles, have larger proportions in Chinese than in English."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: Experiencer as Function in Chinese",
        "paragraphs": [
          "Despite the fact that there are fewer supersense types attested in Chinese, Experiencer as a function is specific to Chinese as it does not have any prototypical adpositions in English BIBREF35. In eg:enexperiencergoal, the scene role Experiencer is expressed through the preposition to and construed as Goal, which highlights the abstract destination of the `air of truth'. This reflects the basic meaning of to, which denotes a path towards a goal BIBREF43. In contrast, the lexicalized combination of the preposition 4 and the localizer 21 in eg:zhexperiencershenghuo are a characteristic way to introduce the mental state of the experiencer, denoting the meaning `to someone's regard'. The high frequency of 21 and the semantic role of Experiencer (6.3%) underscore its status as a prototypical adposition usage in Chinese.",
          ". To:ExperiencerGoal those who understand life, that would have given a much greater air of truth to my story. (en_lpp_1943.185)",
          ". [4:Experiencer [32 12 de 2] 21:Experiencer], 44 1 4 32 12",
          "p:to know-about life de people lc:one's-regard this-way tell res seems real",
          "`It looks real to those who know about life.' (zh_lpp_1943.185)"
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: Divergence of Functions across Languages",
        "paragraphs": [
          "Among all possible types of construals between scene role and function, here we are only concerned with construals where the scene role differs from the function (scene$\\ne $fxn). The basis of hwang-etal-2017-double construal analysis is that a scene role is construed as a function to express the contexual meaning of the adposition that is different from its lexical one. fig:barconstrualzhen presents the top 10 divergent (scene$\\ne $fxn) construals in Chinese and their corresponding proportions in English. Strikingly fewer types of construals are formed in Chinese. Nevertheless, Chinese is replete with RecipientDirection adpositions, which constitute nearly half of the construals.",
          "",
          "The 2 adpositions annotated with RecipientDirection are 4 and 4, both meaning `towards' in Chinese. In eg:enrecipient,eg:zhrecipientdirection, both English to and Chinese 4 have Recipient as the scene role. In eg:enrecipient, Goal is labelled as the function of to because it indicates the completion of the \u201csaying\u201d event. In Chinese, 4 has the function label Direction provided that 4 highlights the orientation of the message uttered by the speaker as in eg:zhrecipientdirection. Even though they express the same scene role in the parallel corpus, their lexical semantics still requires them to have different functions in English versus Chinese.",
          ". You would have to say to:RecipientGoal them: \u201cI saw a house that costs $$20,000$.\u201d (en_lpp_1943.172).",
          ". (3) 41 [4:RecipientDirection 1men] 1: \u201c3 44 le 2 4 24 32 de 2zi.\u201d",
          "2sg must P:to 3pl say 1sg see asp one CL $10,000$ franc de house",
          "`You must tell them: \u201cI see a house that costs 10,000 francs.\u201d ' (zh_lpp_1943.172)."
        ]
      },
      {
        "section_name": "Corpus Analysis ::: Supersense & Construal Distributions in Chinese versus English ::: New Construals in Chinese",
        "paragraphs": [
          "Similar to the distinction between RecipientGoal and RecipientDirection in English versus Chinese, language-specific lexical semantics contribute to unique construals in Chinese, i.e. semantic uses of adpositions that are unattested in the STREUSLE corpus. Six construals are newly attested in the Chinese corpus:",
          "[noitemsep,topsep=0pt]",
          "BeneficiaryExperiencer",
          "CircumstanceTime",
          "PartPortionLocus",
          "TopicLocus",
          "CircumstanceAccompanier",
          "DurationInstrument",
          "Of these new construals, BeneficiaryExperiencer has the highest frequency in the corpus. The novelty of this construal lies in the possibility of Experiencer as function in Chinese, shown by the parallel examples in eg:enbenibeni,eg:zhbeniexpe, where 4 receives the construal annotation BeneficiaryExperiencer.",
          ". One must not hold it against:Beneficiary them . (en_lpp_1943.180)",
          ". 33zimen 4:BeneficiaryExperiencer 42men 41 14 xie",
          "children P:to adults should lenient comp",
          "`Children should not hold it against adults.' (zh_lpp_1943.180)",
          "Similarly, other new construals in Chinese resulted from the lexical meaning of the adpositions that are not equivalent to those in English. For instance, the combination of 1 ... 2 (during the time of) denotes the circumstance of an event that is grounded by the time (2) of the event. Different lexical semantics of adpositions necessarily creates new construals when adapting the same supersense scheme into a new language, inducing newly found associations between scene and function roles of these adpositions. Fortunately, though combinations of scene and function require innovation when adapting SNACS into Chinese, the 50 supersense labels are sufficient to account for the semantic diversity of adpositions in the corpus."
        ]
      },
      {
        "section_name": "POS Tagging of Adposition Targets",
        "paragraphs": [
          "We conduct a post-annotation comparison between manually identified adposition targets and automatically POS-tagged adpositions in the Chinese SNACS corpus. Among the 933 manually identified adposition targets that merit supersense annotation, only 385 (41.3%) are tagged as adp (adposition) by StanfordNLP BIBREF40. fig:piegoldpos shows that gold targets are more frequently tagged as verb than adp in automatic parses, as well as a small portion that are tagged as noun. The inclusion of targets with pos=verb reflects our discussion in subsec:adpositioncriteria that coverbs co-occurring with a main predicate are included in our annotation. The automatic POS tagger also wrongly predicts some non-coverb adpositions, such as 12, to be verbs.",
          "The StanfordNLP POS tagger also suffers from low precision (72.6%). Most false positives resulted from the discrepancies in adposition criteria between theoretical studies on Chinese adpositions and the tagset used in Universal Dependencies (UD) corpora such as the Chinese-GSD corpus. For instance, the Chinese-GSD corpus considers subordinating conjunctions (such as 23, 24, 42, 34) adpositions; however, theoretical research on Chinese adpositions such as BIBREF44 differentiates them from adpositions, since they can never syntactically precede a noun phrase.",
          "Hence, further SNACS annotation and disambiguation efforts on Chinese adpositions cannot rely on the StanfordNLP adp category to identify annotation targets. Since adpositions mostly belong to a closed set of tokens, we apply a simple rule to identify all attested adpositions which are not functioning as the main predicate of a sentence, i.e., not the root of the dependency tree. As shown in Table TABREF43, our heuristic results in an $F_1$ of 82.4%, outperforming the strategy of using the StanfordNLP POS tagger."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we presented the first corpus annotated with adposition supersenses in Mandarin Chinese. The corpus is a valuable resource for examining similarities and differences between adpositions in different languages with parallel corpora and can further support automatic disambiguation of adpositions in Chinese. We intend to annotate additional genres\u2014including native (non-translated) Chinese and learner corpora\u2014in order to more fully capture the semantic behavior of adpositions in Chinese as compared to other languages."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We thank anonymous reviewers for their feedback. This research was supported in part by NSF award IIS-1812778 and grant 2016375 from the United States\u2013Israel Binational Science Foundation (BSF), Jerusalem, Israel."
        ]
      }
    ],
    "qas": [
      {
        "question": "What inter-annotator agreement did they obtain?",
        "question_id": "7d539258b948cd5b5ad1230a15e4b739f29ed947",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " two inter-annotator agreement ",
                "aw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The corpus is jointly annotated by three native Mandarin Chinese speakers, all of whom have received advanced training in theoretical and computational linguistics. Supersense labeling was performed cooperatively by 3 annotators for 25% (235/933) of the adposition targets, and for the remainder, independently by the 3 annotators, followed by cooperative adjudication. Annotation was conducted in two phases, and therefore we present two inter-annotator agreement studies to demonstrate the reproducibility of SNACS and the reliability of the adapted scheme for Chinese.",
                "tab:iaa-results shows raw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons. Agreement levels on scene role, function, and full construal are high for both phases, attesting to the validity of the annotation framework in Chinese. However, there is a slight decrease from Phase 1 to Phase 2, possibly due to the seven newly attested adpositions in Phase 2 and the 1-year interval between the two annotation phases."
              ],
              "highlighted_evidence": [
                "The corpus is jointly annotated by three native Mandarin Chinese speakers, all of whom have received advanced training in theoretical and computational linguistics. Supersense labeling was performed cooperatively by 3 annotators for 25% (235/933) of the adposition targets, and for the remainder, independently by the 3 annotators, followed by cooperative adjudication. Annotation was conducted in two phases, and therefore we present two inter-annotator agreement studies to demonstrate the reproducibility of SNACS and the reliability of the adapted scheme for Chinese.",
                "tab:iaa-results shows raw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons. Agreement levels on scene role, function, and full construal are high for both phases, attesting to the validity of the annotation framework in Chinese. However, there is a slight decrease from Phase 1 to Phase 2, possibly due to the seven newly attested adpositions in Phase 2 and the 1-year interval between the two annotation phases."
              ]
            },
            "annotation_id": "047f5f828136b659282cd2645e66129be3870f12",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Raw agreement is around .90 for this dataset.",
              "evidence": [
                "tab:iaa-results shows raw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons. Agreement levels on scene role, function, and full construal are high for both phases, attesting to the validity of the annotation framework in Chinese. However, there is a slight decrease from Phase 1 to Phase 2, possibly due to the seven newly attested adpositions in Phase 2 and the 1-year interval between the two annotation phases.",
                "FLOAT SELECTED: Table 1: Inter-annotator agreement (IAA) results on two samples from different phases of the project."
              ],
              "highlighted_evidence": [
                "tab:iaa-results shows raw agreement and Cohen's kappa across three annotators computed by averaging three pairwise comparisons.",
                "FLOAT SELECTED: Table 1: Inter-annotator agreement (IAA) results on two samples from different phases of the project."
              ]
            },
            "annotation_id": "2247105159bf171338b7e7f4c572631aaa3b9726",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "The average agreement on scene, function and construal is 0.915",
              "evidence": [
                "FLOAT SELECTED: Table 1: Inter-annotator agreement (IAA) results on two samples from different phases of the project."
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Table 1: Inter-annotator agreement (IAA) results on two samples from different phases of the project."
              ]
            },
            "annotation_id": "a467cf3e49187252146873ead4393ebf78fce1e4",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: SNACS hierarchy of 50 supersenses."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Inter-annotator agreement (IAA) results on two samples from different phases of the project."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Percentages and counts of the top 5 prepositions and postpositions in Chinese Little Prince. The percentages are out of all adpositions."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Statistics of the final Mandarin The Little Prince Corpus (the Chinese SNACS Corpus). Tokenization, identification of adposition targets, and supersense labeling were performed manually."
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Statistics of Adpositional Supersenses in Chinese versus English. % adps presents the proportion of adposition targets over all token counts; uniq adps/scene/fxn/cons demonstrates the type frequency of adposition tokens, scene role and function supersense and construals; scene\u2260fxn and % scene\u2260fxn shows the type frequency and proportion of divergent construals."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Top 10 most frequent scene roles in Chinese versus English."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Top 10 most frequent functions in Chinese versus English."
      },
      {
        "file": "6-Figure4-1.png",
        "caption": "Figure 4: Top 10 Construals where scene\u2260function in Chinese versus English."
      },
      {
        "file": "6-Figure5-1.png",
        "caption": "Figure 5: POS Distribution of Gold Adposition Tokens."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: Adposition identification performance on Chinese SNACS corpus."
      }
    ]
  },
  "2003.04978": {
    "title": "Fake News Detection with Different Models",
    "abstract": "This is a paper for exploring various different models aiming at developing fake news detection models and we had used certain machine learning algorithms and we had used pretrained algorithms such as TFIDF and CV and W2V as features for processing textual data.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "For this report, we are exploring the field of natural language processing, which is the broad study of how computers and machines can understand human to human communication and how texts are analyzed based on contextual information by machines.",
          "In particular, we are using natural language processing to classify news articles as real news or \u201cfake news\u201d. Fake news is misinformation masked under the guise of a real news article, and is used to deceptively influence people\u2019s beliefs.",
          "For this report, we are classifying news articles as \u201creal\u201d or \u201cfake\u201d, which will be a binary classification problem - classifying the samples as a positive (with fake news) or negative (not fake news) sample. Many studies have used machine learning algorithms and build classifiers based on features like content, the author\u2019s name and job-title, using lots of models like the convolutional neural network (CNN), recurrent neural network (RNN), feed-forward neural network (FFNN), long-short term memory (LSTM) and logistic regression to find the most optimal model and return its results. In [1], the author built a classifier using natural language processing and used models like CNN, RNN, FFNN, and Logistic Regression and concluded that the CNN classifiers could not be as competitive as the RNN classifiers. The authors in [2] think that their study can be improved by having more features like knowing the history of lies spoken by the news reporter or the speaker.",
          "Moreover, apart from the traditional machine learning methods, new models have also been developed. One of the newer models, TraceMiner, creates an LSTM-RNN model inferring from the embedding of social media users in the social network structure to propagate through the path of messages and has provided high classification accuracy$^{5}$. FAKEDETECTOR is another inference model developed to detect the credibility of the fake news which is considered to be quite reliable and accurate$^{7}$.",
          "There also have been studies that have a different approach. A paper surveys the current state-of-the-art technologies that are imperative when adopting and developing fake news detection and provides a classification of several accurate assessment methods that analyze the text and detect anomalies$^{3}$.",
          "These previous approaches lack a clear contextual analysis used in NLP. We considered the semantic meaning of each word and we feel that the presence of particular words influence the meaning. We reckoned this important since we felt the contextual meaning of the text needs to be preserved and analyzed for better classification. Other studies emphasize the user and features related to them. In [4], \u201c45 features\u2026[were used] for predicting accuracy...across four types: structural, user, content, and temporal,\u201d so features included characteristics beyond the text. Article [6] \"learn[s] the representations of news articles, creators and subjects simultaneously.\" In our project, we emphasize the content by working with articles whose labels only relate to the text, nothing outside that scope, and have used SVM, Logistic Regression, ANN, LSTM, and Random Forest.",
          "We had devised this problem into 3 different phases: pre-processing, text-to-numeric representation conversion using pre-trained algorithms, and then evaluate the models using state-of-the-art machine learning algorithms. We had analysed the data set and in particular the text part of the data explaining how it is distributed and then we converted each text into numeric representation using pre-training models such as TFIDF, CV and W2V for vector representation. Finally, we evaluated our numeric conversion data using significant machine learning algorithms such as neural networks, classification algorithms etc to perform the classification."
        ]
      },
      {
        "section_name": "Methods ::: The Dataset",
        "paragraphs": [
          "The training data set has five features: ID, title, author, text, and label. The ID uniquely identifies the news article. The title and author are the title and author of the news article respectively. The text is the content of the article, and may be incomplete. The label indicates whether the article is reliable (real) or not (fake):",
          "label = ${\\left\\lbrace \\begin{array}{ll} 0 & \\textrm {if reliable news} \\\\ 1 & \\textrm {if fake news} \\end{array}\\right.}$",
          "The training data set contains 20800 odd number of samples.",
          "The test data set does not have labels, so we do not use it. The test data set will be selected from the training data set randomly when we are evaluating our models.",
          "In our project, since we hypothesized that the text and the words used within the text are key to distinguish between real and fake news samples, we decided to investigate only the text column."
        ]
      },
      {
        "section_name": "Methods ::: Data Pre-processing ::: Removed numbers",
        "paragraphs": [
          "Within the context of a news article title or text, numbers simply quantify claims and do not change the meaning of the text. Therefore it is best to remove all numbers to minimize noise in our data. We use the string.digits string constant in Python as well as the translate and maketrans methods from Python\u2019s string module to convert all numerical digits to an empty string, effectively removing all digits."
        ]
      },
      {
        "section_name": "Methods ::: Data Pre-processing ::: Removed punctuation and special characters",
        "paragraphs": [
          "In addition of pre-processing the textual data, we removed all characters that are not textual (not alphabets such as punctuation, extra delimiters etc.). We used the string.punctuation module in Python to find all punctuation characters. We remove all those punctuation characters from every word in the texts, with the exception of the symbols \u2018#\u2019 and \u2018@\u2019. Because these are characters used for Twitter hashtags and mentions, we handle these later. Next, we removed an assortment of special characters that don\u2019t appear on traditional American keyboards and don\u2019t contribute to the meaning of the tweets. The long dash (\u201c\u2013\u201d), single and double Asian quotations, ellipse characters (\u2026), and bullet points (\u2022) all were removed for this reason.",
          "After removing all special characters, there are still a couple of pre-processing cases we account for. For these cases, we used regular expressions to detect certain patterns we wish to remove. One of the patterns is Twitter hashtags and mentions. In a news setting, Twitter hashtags and mentions are often added to try to obtain more search results and relevance, but often distract from the overall meaning of the news content itself. In our problem, we are primarily concerned with words and mostly their contextual meanings used in the text and we assumed that these unnecessary characters. To detect the hashtags and mentions, we simply use regular expressions to remove all text after a hashtag (#) or @ symbol, and stop removing text when we reach the next space. We also use regular expressions to handle em dashes (\u2014) and more than two consecutive spaces. Em dashes are used in various linguistic contexts like joining independent clauses. They do not add to the meaning of the text, however they are surrounded by two words of different clauses, so we replaced all em dashes with a single space to maintain the integrity of each phrase. Lastly, we replace any set of two or more consecutive spaces with just one space.",
          "Proceeding further, we make all of our texts lowercase and then remove all rows that have foreign language characters in their text, since we are only interested in identifying fake news in English. To do this we used the package langid in Python to identify the language of all texts, and removed all rows with foreign characters. This finally ensures the text we preserve is only with English words with no non-alpha character."
        ]
      },
      {
        "section_name": "Methods ::: Data Pre-processing ::: Removed stop words",
        "paragraphs": [
          "Stop words are a list of the most common words in a language, such as \u201ca\u201d, \u201cbe\u201d, \u201cquite\u201d, \u201cshould\u201d...etc. They are often void of meaning, and does not add anything to the content. They are also most frequently present in every text. Hence, we presumed removal of stop words can have multiple advantages. For once, it decreases memory overhead, since we cut down a huge amount of text (and hence narrows down the number of features to train our models on). Second, it reduces noise, since by eliminating stop words, we are able to focus on more meaningful contents (the more distinct features between these two classes). Although it is not often the case that removing stop words are the most optimal, sometimes the information that we are looking for may be included in the stop words that we removed. For example, in most cases of language modeling, or translation, where it is important that we keep all the stop words. However, in our circumstances, we are using the semantics of the text to make a decision. In this case, we can safely remove stop words to observe the more meaningful context words."
        ]
      },
      {
        "section_name": "Methods ::: Data Distribution",
        "paragraphs": [
          "We performed some data analysis on the text and wanted to understand how the text is distributed. We had analyzed and represented our data (text) distribution in a few different perspectives. We first analyzed the data through graphing its sentiment polarity, most popular unigram and bigram, as well as looking at the distribution of the word types. We will be comparing the graphs before and after preprocessing, which includes, stop word removal, removing punctuation and special characters, and numbers."
        ]
      },
      {
        "section_name": "Methods ::: Data Distribution ::: Sentiment Polarity",
        "paragraphs": [
          "Polarity Graphs before pre-processing",
          "",
          "Polarity Graphs after pre-processing",
          "",
          "For both before and after pre-processing, the distribution of the polarity of fake news sentiment and real news sentiment are mostly the same. For both fake news and real news, there are slightly more positive news than the negatives. However, there is a noticeable difference between the polarity. We can see that although not by much, fake news are a little bit more polar than real news. There are more outliers, and the data are a little bit more spread out."
        ]
      },
      {
        "section_name": "Methods ::: Data Distribution ::: Part of Speech Distribution",
        "paragraphs": [
          "Part of Speech Graphs before pre-processing",
          "",
          "Part of Speech Graphs after pre-processing",
          "",
          "Although the differences are slight, there is a difference in part of speech distribution between real and fake news. In fake news, there are a higher percentage of adverbs and adjectives compared to all the other parts of speech, while there is a lower percentage of proper pronoun; however, in real news, there are a higher percentage of pronoun. We can interpret this as there are more adverbs and adjectives in fakes new, and there are more pronoun in real news. Perhaps, this is indicating that fake news are more likely to use adverbs and adjectives to embellish their sentences, while real news use more pronouns to establish as reference to their legitimacy."
        ]
      },
      {
        "section_name": "Methods ::: Data Distribution ::: Unigram and Bigram",
        "paragraphs": [
          "Unigrams",
          "",
          "",
          "Bigrams",
          "",
          "",
          "The comparison between the result of the top unigram and bigram before and after preprocessing demonstrates that our decision to remove stop words is the correct choice. The top unigram and bigram are all consisted of words, in other words, filler words that does supply us with any explanation.",
          "After removing the stop words, we can see that the top unigrams and bigrams become much more specific."
        ]
      },
      {
        "section_name": "Methods ::: Unsupervised Pre-training to encode our texts into numeric representations",
        "paragraphs": [
          ""
        ]
      },
      {
        "section_name": "Methods ::: Unsupervised Pre-training to encode our texts into numeric representations ::: Natural Language Processing Models",
        "paragraphs": [
          "After text have been cleaned, they are mapped into numeric representations in form of vectors of the textual data using three pre-training algorithms (i.e. CountVectorizer, TF-IDFVectorizer, and Word2Vec). Each sample, originally consisting of all text, is converted into a vector of features. Since only the text is passed into these pre-training algorithm, this stage is unsupervised. In the cases of CountVectorizer and TfidfVectorizer, the number of features is clipped at 10000 to avoid memory overrun and overfitting (because of the large number of features (the vocabulary))."
        ]
      },
      {
        "section_name": "Methods ::: Unsupervised Pre-training to encode our texts into numeric representations ::: CountVectorizer",
        "paragraphs": [
          "The CountVectorizer provides a simple way to both tokenize a collection of text documents and build a vocabulary of known distinct words, but also to encode new documents using that vocabulary$^{13}$.",
          "Given a collection of text documents, $S$ , CountVectorizer will generate a sparse matrix $A$ of size $m$ by $n$, where $m =$ total number of documents, $n =$ total number of distinct words used in $S$.",
          "$A = \\begin{pmatrix} a_{11} & a_{12} & \\cdots & a_{1n}\\\\ \\vdots & \\vdots & \\vdots & \\vdots \\\\ a_{m1} & a_{m2} & \\cdots & a_{mn} \\end{pmatrix}$",
          "This matrix is the one hot encoded representation of the different words present in the corpus. Entry $a_{ij} =$ total number of times $j$th word appears in the $i$th document.",
          "We had converted the sparse matrix into a dense one since we found that there are plenty of distinct words in the corpus which may not even be present in some of the samples and hence they may be populated with zeros. Hence, we felt that since zeros may be entirely populated, we decided to convert it to a dense matrix using the todense() method call which a dense representation of the sparse matrix."
        ]
      },
      {
        "section_name": "Methods ::: Unsupervised Pre-training to encode our texts into numeric representations ::: TF-IDFVectorizer",
        "paragraphs": [
          "Although TF-IDF is an old algorithm, it is simple and effective to be used in the phase of pre-training$^{11}$. The computation of TfidfVectorizer involves computing the product of term frequency and inverse document frequency. As the term implies, TF-IDF calculates values for each word in a document through an inverse proportion of the frequency of the word in a particular document to the percentage of documents the word appears in$^{12}$.",
          "The term frequency $tf(t, d)$ calculates the proportion of times that the term $t\\in V(d)$ appears in the document $d$. The vocabulary $V(d) = \\sum _t n(t,d)$ is constructed by the document $d$. Thus, if a word $w^{\\prime }$ does not appear in a document $d^{\\prime }$, the term frequency $tf(t^{\\prime }, d^{\\prime })$ in this case would be zero. The idea of the term frequency is essentially the same as CountVectorizer.",
          "Given a document collection $D$, the inverse document frequency $idf(t, D)$ is the log of the number of documents $N$ divided by $df(t,D)$, the number of documents $d \\in D$ containing the term $t$. As a result, common words in $D$ will have a low term frequency score, while infrequent words will have a high term frequency. Thus, the term frequency will be very likely to separate fake news that often have less common words (even ungrammatical) from real news that usually consist of common words.",
          "As a summary, TF-IDF score $w(t,d)$ for a word increases with its count, but will be counteracted if the word appears in too many documents.",
          "Similar to CountVectorizer, we found that most of the entries within the matrix were 0. Hence, we used the dense (todense() call) to return the dense representation of the sparse TFIDF matrix representation."
        ]
      },
      {
        "section_name": "Methods ::: Unsupervised Pre-training to encode our texts into numeric representations ::: Word2Vec",
        "paragraphs": [
          "Word2Vec is another state of the art model used to represent words into vectors. Word2Vec is a simple neural network which basically tries to predict the next word within a context given a set of words provided. Word2Vec basically represents a vector for each word within the context and the vector representation is the weights of the particular connection from the input layer node into one of the hidden layer neurons. This information is mainly encoding the contextual information of the particular word within the corpus (collection of texts) on which we train our word2vec model.",
          "In this project, all we did was we trained the word2vec model on our current corpus. We did this because we felt that the corpus contained very specific words which had a contextual meaning completely different from what is used in general. Hence, we chose to train the corpus on the existing texts in our corpus texts over the pre-trained word2vec models such as google models. For training our word2vec models, we chose the minimum count as the average number of words in each of the texts in general, since we believed that texts which are shorter than the mean length have less context and hence we rejected those sentences to train on. We then used the number of features as the default number of features as 100 since we wanted to analyze on a short number of features.",
          "For this project, we decided on a very simple and plain approach. We obtained the vector for each sentence by summing all the vector representations for each word in the sentence only if the word belongs to the word2vec model. The summed up vector is finally divided with the number of words in the sentence since we wanted to make sure that the size of the text doesn\u2019t affect the vector embeddings and hence we normalized our word2vec embedding."
        ]
      },
      {
        "section_name": "Methods ::: Outlier Removal",
        "paragraphs": [
          "During outlier removal, the Isolation Forest algorithm isolates observations by randomly selecting a feature and then randomly selecting a split value between the maximum and minimum values of selected features. In Isolation Forest, an anomaly score can be calculated as the number of conditions required to separate given observation.",
          "",
          "In our outlier detections and removals, Isolation Forest has been applied to three different features. Generated from TFIDF, CV, WV. Percentages of outlier in each feature set is calculated, bar graph of percentage of training outliers are included."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning",
        "paragraphs": [
          "Once the representations of text are pre-trained from previous unsupervised learning, the representations are then fed into 5 different models to perform supervised learning on the downstream task. In this case, the downstream task is a binary classification of the fake news as either real or fake. A k-fold prediction error is obtained from each of the 5 models, and since we have 3 different pre-training models, we have a total of 15 models to compare."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning ::: Artificial Neural Network (ANN)",
        "paragraphs": [
          "We trained simple Artificial Neural Networks which contains an input layer, particular number of output layers (specified by a hyperparameter) in which each hidden layer contains the same number of neurons and the same activation function, and an output layer with just one node for the classification (real or fake) which uses sigmoid as an activation function. We chose sigmoid as the output layer activation and the binary_crossentropy as the loss since it is a binary classification problem and the use of softmax normalizes the results which is not needed for this problem and since we use only one output node to return the activation, we applied sigmoid for the output layer activation. We performed Grid Search strategy to find the best hyper-parameters such as activations, optimizers, number of hidden layers and number of hidden neurons. We had used Keras Sequential model and we used Dense Layers which contains connections to every hidden node in the next layer.",
          "Due to the limitation of computing resource, the grid search for Neural Networks is divided into three sequential steps. Instead of performing grid search on all the hyperparameters all at once, we chose to do grid search for the activations for the hidden layers, optimizers and the number of hidden layers and hidden neurons (done together). We coupled the number of hidden layers and the number of neurons since we believed that each of these hyperparameters interact with each other in improving the model training. We also did a K-fold Split for 3 splits at each step and picked the best hyperparameters which renders the highest accuracy."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning ::: Long Short Term Memory networks (LSTMs)",
        "paragraphs": [
          "Long Short Term Memory networks (LSTMs) is a special recurrent neural network (RNN) introduced by Hochreiter & Schmidhuber (1997)$^{8}$.",
          "",
          "(Christopher Olah. \u201cUnderstanding LSTM Networks.\u201d)",
          "The chain-like nature of an RNN allows information to be passed from the beginning all the way to the end. The prediction at time step $t$ depends on all previous predictions at time step $t\u2019 < t$. However, when a typical RNN is used in a larger context (i.e. a relatively large time steps), the RNN suffers from the issue of vanishing gradient descent $^{9}$. LSTMs, a special kind of RNN, can solve this long-term dependency problem.",
          "",
          "(Christopher Olah. \u201cUnderstanding LSTM Networks.\u201d)",
          "Each cell in a typical LSTMs network contains 3 gates (i.e., forget gate, input gate, and output gate) to decide whether or not information should be maintained in the cell state $C_t$.",
          "For CountVectorizer and TfidfVectorizer, each sample of text is converted into a 1-d feature vector of size 10000. As a result, the number of time steps (i.e. the maximum amount of word vectors for each sample) for these two can only be set to 1, as the pre-trained representations are done at the sample\u2019s level. By contrast, the number of time steps for Word2Vec can either be 1, if we simply take an average of the word embeddings, or the length of the sentence, where each word has an embedding and thus the pre-trained representations are done at the word\u2019s level. We choose the approach with 1 timestep in our model because it requires less computation power. Meanwhile, we also do the length of the sentence, and 200 time steps are chosen as 200 is close to the mean amount of words in each sample and it is a fairly common choice in practice. However, since we do not have enough computation power to fine-tune (grid search) our model, we leave it out for our model and include it only in the final section.",
          "In the LSTM layer, a dropout rate of 0.2, a common choice in practice$^{10}$ , is used to prevent overfitting. Grid search is performed in order to pick decent values of hyperparameters, including the number of hidden units in the LSTM layer, the number of hidden layers, the activation functions and the number of nodes in the hidden layer, and the optimizer. Relatively small numbers of hidden layers (i.e., {0, 1, 2}) and nodes (i.e., {200, 400, 600}) are selected as the basis for grid search, because this is a simple binary classification task and too many of them would cause overfitting.",
          "Due to the limitation of computing resource, the grid search for LSTMs is divided into four sequential steps. Instead of performing grid search on all the hyperparameters all at once, the grid search is first done on the number of hidden layers and all other hyperparameters are randomly selected from the subset. Then, the grid search is done on the number of nodes in the hidden layer(s), using the best number of hidden layer found in step 1. The grid search completes when all four steps are finished. In each step we used K-fold cross validation with $K = 3$."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning ::: Random Forest",
        "paragraphs": [
          "A random forest is an ensemble classifier that estimates based on the combination of different decision trees. So random forest will fit a number of decision tree classifiers on various subsamples of the dataset. A random best subsets are built by each tree in the forest. In the end, it gives the best subset of features among all the random subsets of features.",
          "In our project, 3 random forest algorithms have been applied with models count vectorizer, tfidf and word-to-vector. Random forest algorithm requires 4 hyperparameters to tune, such as the number of trees in the forest (i.e., {200, 400, 800}); the maximum depth of the tree (i.e., {1,5,9}); the minimum number of samples required to be at a lead node (i.e., {2, 4}); The minimum number of samples at each leaf node has the effect of smoothing the model, especially during regression; the minimum number of samples required to be at a leaf node (i.e., {5, 10}). All parameters are applied to grid search and in the end, the best set of parameters can be determined as we used K-fold cross validation with $K = 3$."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning ::: Logistic Regression",
        "paragraphs": [
          "Logistic regression is a statistical machine learning algorithm that classifies the data by considering outcome variables on extreme ends and this algorithm is providing a discriminatory line between classes. Compared to another simple model, linear regression, which requires hard threshold in classification, logistic regression can overcome threshold values for a large dataset. Logistic regression produces a logistic curve, which is limited to values between 0 to 1, by adding sigmoid function in the end.",
          "In regards to our project, three logistic regressions have been applied with models CountVectorizer, TF-IDF and Word2Vec. We did grid search on the solvers, including newton-cg, sag, lbfgs and liblinear. Grid search is also performed on the inverse of regularization parameter with values being {0, 4, 10}. Best parameter sets can be determined as we used K-fold cross validation with $K = 3$."
        ]
      },
      {
        "section_name": "Methods ::: Fine-tuning ::: Support Vector Machine (SVM)",
        "paragraphs": [
          "SVM is a supervised machine learning algorithm in which a hyperplane is created in order to separate and categorize features. The optimal hyperplane is usually calculated by creating support vectors on both sides of the hyperplane in which each vector must maximize the distance between each other. In other words, the larger the distance between each vector around the hyperplane, the more accurate the decision boundary will be between the categories of features.",
          "In regards to our project, we fit 3 support vector machines on CountVectorizer, TfidfVectorizer, and WordToVectorizer. An SVM requires specific parameters such as a kernel type, $C$, maximum iterations, etc. In our case, we needed to determine the optimal $C$ as well as the optimal kernel for each fit. We used K-fold cross validation with $K = 3$. A grid search of kernel types and $C$ was performed in order to give us the most accurate svm model. The parameters we used for each kernel were linear and rbf while the values we used for $C$ were 0.25 ,0.5, and 0.75. Once the grid search was completed for these hyperparameters, the model was evaluated with the most optimal hyperparameters using cross validation of 3 splits."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Grid Search Results",
          "",
          "Mean Test Scores",
          "",
          "",
          "",
          "",
          "ANN Loss and Accuracy",
          "",
          "LSTM Loss and Accuracy",
          "",
          "The model is evaluated using a 3-fold of cross validation. Out of the fifteen models, CountVectorizer with LSTMs performs the best. Word2Vec performs the worst among the three pre-training algorithms. Random forest performs the worst among the five fine-tuning algorithms."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "Among our three pre-training models, CountVectorizer achieves in general the best performance comparatively and Word2Vec performs relatively poor amongst the three models. The essential idea behind both CountVectorizer and TF-IDF is computing a score which depends on the frequency of the word belonging to the vocabulary. However, comparing to CountVectorizer, the TF-IDF includes an extra inverse document frequency that \u201cpenalizes\u201d (apparently masks) the contextual meaning within the words that appear more frequently across documents. They represent the importance of the word within a document. The results may imply that even though the penalization is smoothed by a log function, the punishment may be too high.",
          "The results also show that in general neural networks do the best consistently, as neural networks serve as a powerful universal approximator. However, the loss and accuracy plots show that we are using too many epochs and thus have the issue of overfitting. This is because our pre-training model is already very strong so it learns a good contextual representation of text. As a result, the epochs needed for downstream task are not much. In addition, one thing to note is that logistic regression also performs very well. This implies that our data are mostly linearly separable. While neural networks can fit the data very well, but they run the risk of overfitting the data. As a result, neural networks are not as good as SVM and Logistic Regression for TF-IDF.",
          "A combination of CountVectorizer and LSTMs is the best among all the models. While LSTMs with one timestep are very similar to ANN in terms of architecture, LSTMs have gates and a tanh activation function inside the module. This different design may let LSTMs perform slightly better than ANN.",
          "Word2Vec does not perform well. One reason is that we are simply taking an average of the word embedding vectors to get a generalized vector representation of each sample of paragraph. Taking an average fails to represent the dependencies between words. Another reason is that we do not use pre-trained Word2Vec embeddings available online from huge corpus but instead build our own from the dataset. While we thought that building our own Word2Vec would make the model specific to this task, the results show that Word2Vec may need to be built from larger dataset."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This report provides a fairly simple approach to encode texts and how the presence of words in general impacts the classification of texts as real and fake.",
          "We achieved high accuracy results in most of our algorithms and in particular neural networks generally do better than the others.",
          "What's worth noting is that our LSTMs only use a timestep of 1 and are essentially multi-layer perceptrons. Still, as mentioned is the LSTM's method section, the LSTMs with the real recurrence are performed by using Word2Vec for representations at the word's level. In this case, each word has its own vector, and a sample will be a collection of vectors and thus a 2-D matrix. As mentioned before, each vectorized word will become a timestep, and a total of 200 timesteps is used (If the paragraph has more than 200 words, only the first 200 words will be selected). We run our model and get the following results.",
          "",
          "The results seem solid, but this approach is not included in our model because it takes too much time to run and we do not have time to fine-tune the hyperparameters. But in future work, we believe that using LSTMs with real recurrence will give an even better results.",
          "While we achieve great performance in this dataset, the question remains as to whether X (to be replaced by the best model) can still perform well in tasks that classify news into more than two categories, such as the Fake News Challenge. In that case, a simple unidirectional LSTMs may not be so well and may need to be replaced by a bidirectional one. In addition, it would be interested to know how well our pre-trained model performs in other downstream tasks, such as Spam Detection. Lastly, in our model, the pre-training is done on the dataset given (will make the model specific to the task), instead of on the big corpus available online, such as Google's pre-trained Word2Vec model. If the task were a classification of four or eight categories, pre-trained model on large corpus may perform better as the model is pre-trained on more words.",
          "We can also try to improve the training by using different word embeddings. While we only chose only 3 different types of embeddings, we could have tried different embeddings such as GloVe and the features used are entirely dependent only on context words. We can use different forms for encoding texts which can be used to be trained using these algorithms to achieve a better model. In another",
          "State-of-the-art pre-trained models can be used if the task is no longer a binary classification. Models like Transformer and BERT will be strong candidates as they have learned a very strong representation that takes the context into account when computing an embedding for a word. Unlike LSTMs whose sequential nature prohibits parallelization, the Transformer and the BERT can achieve parallelization by replacing recurrence with the attention mechanism. Thus, they require less computation power and can be easily fine-tuned in downstream tasks."
        ]
      },
      {
        "section_name": "Github Repo",
        "paragraphs": [
          "https://github.com/Sairamvinay/Fake-News-Dataset"
        ]
      },
      {
        "section_name": "Author Contributions",
        "paragraphs": [
          "Sairamvinay Vijayaraghavan: Project Planning, Problem Formation, DataSet Search, POS Distribution graph, Code for CountVectorizer, Word2Vec, ANN, Randomforest,To parse csv files (readdata), Code integration for TextVectorizer, Grid Search model running, ROC model running, Code Base Cleanup and management (further cleanup), PowerPoint Checking, Report Analysis for W2V, ANN, Report editing",
          "Zhiyuan Guo: Project Planning, DataSet Search, Polarity Graphs, Code for LSTM, RandomForest, Adding Functionality and Readability in each of the scripts, Code Integration, Grid Search model running, ROC model running, PowerPoint Development, Report Analysis for TFIDF and LSTM, Report Analysis for the Abstract, the Discussion, Conclusion, Pipeline Diagram, Report editing",
          "Ye Wang: Project Planning, DataSet Search, Code for TFIDF, PCA, Grid Search model running, ROC model running, Report Integration into Latex, Report Analysis of the Results (table creations), Report Analysis for the Outlier Removal, Random Forest, Report editing",
          "John Voong: Word2Vec, DataCleanup (StopWord Cleanup), Grid Search model running, ROC model running, PowerPoint Development, Report Analysis for W2V, Pipeline Diagram, Report editing, Paper structure",
          "Wenda Xu: Code for PCA, ROC model running, Code Base Cleanup and management, PowerPoint Development, Report Analysis about Count Vectorizer, Report Analysis about Logistic Regression",
          "Armand Nasseri: Project Planning, Dataset search, Code for SVM, Data Cleanup (StopWord Cleanup), ROC model running, PowerPoint Development, Report Analysis about SVM",
          "Jiaru Cai: Outlier Removal, Accuracy and Loss Plots for Neural Network, PowerPoint Framework",
          "Kevin Vuong: DataCleanup (remove punctuations), Code for Logistic Regression, Grid Search model running, PowerPoint Cleanup, Report Analysis about Data Cleanup, Introduction and Abstract",
          "Linda Li: Unigram and Bigram analysis, Code for ROC plots, Report Analysis of the Data Cleanup section, Graph analysis",
          "Eshan Wadhwa: Related Work, References and Citation (Introduction and Field research), Report Editing, PowerPoint slides,"
        ]
      },
      {
        "section_name": "References",
        "paragraphs": [
          "[1] Samir Bajaj, \u201cThe Pope Has a New Baby!\u201d Fake News Detection Using Deep Learning\u201d, Winter 2017,",
          "https://pdfs.semanticscholar.org/19ed/b6aa318d70cd727b3cdb006a782556ba657a.pdf",
          "[2] Arjun Roy, Kingshuk Basak, Asif Ekbal, and Pushpak Bhattacharyya, \u201cA Deep Ensemble Framework for Fake News Detection and Classification\u201d, 12 November 2018,",
          "https://arxiv.org/pdf/1811.04670.pdf",
          "[3] Niall J. Conroy, Victoria L. Rubin, and Yimin Chen, \u201cAutomatic Deception Detection: Methods for Finding Fake News\u201d, November 2015,",
          "https://asistdl.onlinelibrary.wiley.com/doi/epdf/10.1002/pra2.2015.145052010082.",
          "[4] Liang Wu and Huan Liu, \u201cTracing Fake-News Footprints: Characterizing Social Media Messages by How They Propagate\u201d, February 2018,",
          "http://www.public.asu.edu/~liangwu1/WSDM18_TraceMiner.pdf",
          "[5] Adrian Colyer, \u201cTracing fake news footprints: characterizing social media messages by how they propagate\u201d,the morning paper, February 2018, https://blog.acolyer.org/2018/02/19/tracing-fake-news-footprints-characterizing-social-media-messages-by-how-they-propagate/",
          "[6] Kai Shu, Amy Sliva, Suhang Wang, Jiliang Tang and Huan Liu, \u201cFake News Detection on Social Media: A Data Mining Perspective\u201d, August 2017,",
          "https://arxiv.org/abs/1708.01967",
          "[7] Jiawei Zhang, Bowen Dong and Philip S. Yu, \u201cFAKEDETECTOR: Effective Fake News Detection with Deep Diffusive Neural Network\u201d, August 2019,",
          "https://arxiv.org/pdf/1805.08751.pdf",
          "[8] Sepp Hochreiter and Jurgen Schmidhuber, \u201cLong short-term memory\u201d, November 1997,",
          "http://www.bioinf.jku.at/publications/older/2604.pdf",
          "[9] Yoshua Bengio, Patrice Simard, and Paolo Frasconi. \u201cLearning long-term dependencies with gradient descent is difficult\u201d, March 1994,",
          "http://www.comp.hkbu.edu.hk/~markus/teaching/comp7650/tnn-94-gradient.pdf",
          "[10] Gaofeng Cheng, Vijayaditya Peddinti, Daniel Povey, et al., \u201cAn Exploration of Dropout with LSTMs\u201d. August 2017,",
          "https://www.danielpovey.com/files/2017_interspeech_dropout.pdf",
          "[11] Juan Ramos. \u201cUsing tf-idf to determine word relevance in document queries\u201d, December 2003,",
          "https://www.cs.rutgers.edu/~mlittman/courses/ml03/iCML03/papers/ramos.pdf",
          "[12] Gerard Salton and Christopher Buckley. \u201cTerm-weighting approaches in automatic text retrieval\u201d, January 1988,",
          "https://www.sciencedirect.com/science/article/abs/pii/0306457388900210",
          "[13] Jason Brownlee. \u201cHow to Prepare Text Data for Machine Learning with scikit-learn\u201d, August 2019,",
          "https://machinelearningmastery.com/prepare-text-data-machine-learning-scikit-learn/"
        ]
      }
    ],
    "qas": [
      {
        "question": "Which datasets do they use?",
        "question_id": "65c9aee2051ff7c47112b2aee0d928d9b6a8c2fe",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "bbefbfe6e26fd38172b515459aa34296e4e86ba4",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "https://github.com/Sairamvinay/Fake-News-Dataset\n\n"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Github Repo",
                "https://github.com/Sairamvinay/Fake-News-Dataset"
              ],
              "highlighted_evidence": [
                "Github Repo\nhttps://github.com/Sairamvinay/Fake-News-Dataset"
              ]
            },
            "annotation_id": "bfcf2465a431a6595bc9227f6532dca306fff768",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "d4ef3d86ce61cb64d3547db5f604a17ab45d9073",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": []
  },
  "1910.07924": {
    "title": "LibriVoxDeEn: A Corpus for German-to-English Speech Translation and German Speech Recognition",
    "abstract": "We present a corpus of sentence-aligned triples of German audio, German text, and English translation, based on German audio books. The corpus consists of over 100 hours of audio material and over 50k parallel sentences. The audio data is read speech and thus low in disfluencies. The quality of audio and sentence alignments has been checked by a manual evaluation, showing that speech alignment quality is in general very high. The sentence alignment quality is comparable to well-used parallel translation data and can be adjusted by cutoffs on the automatic alignment score. To our knowledge, this corpus is to date the largest resource for end-to-end speech translation for German.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Direct speech translation has recently been shown to be feasible using a single sequence-to-sequence neural model, trained on parallel data consisting of source audio, source text and target text. The crucial advantage of such end-to-end approaches is the avoidance of error propagation as in a pipeline approaches of speech recognition and text translation. While cascaded approaches have an advantage in that they can straightforwardly use large independent datasets for speech recognition and text translation, clever sharing of sub-networks via multi-task learning and two-stage modeling BIBREF0, BIBREF1, BIBREF2 has closed the performance gap between end-to-end and pipeline approaches. However, end-to-end neural speech translation is very data hungry while available datatsets must be considered large if they exceed 100 hours of audio. For example, the widely used Fisher and Call-home Spanish-English corpus BIBREF3 comprises 162 hours of audio and $138,819$ parallel sentences. Larger corpora for end-to-end speech translation have only recently become available for speech translation from English sources. For example, 236 hours of audio and $131,395$ parallel sentences are available for English-French speech translation based on audio books BIBREF4, BIBREF5. For speech translation of English TED talks, 400-500 hours of audio aligned to around $250,000$ parallel sentences depending on the language pair have been provided for eight target languages by DiGangiETAL:19. Pure speech recognition data are available in amounts of $1,000$ hours of read English speech and their transcriptions in the LibriSpeech corpus provided by PanayotovETAL:15.",
          "When it comes to German sources, the situation regarding corpora for end-to-end speech translation as well as for speech recognition is dire. To our knowledge, the largest freely available corpora for German-English speech translation comprise triples for 37 hours of German audio, German transcription, and English translation BIBREF6. Pure speech recognition data are available from 36 hours BIBREF7 to around 200 hours BIBREF8.",
          "We present a corpus of sentence-aligned triples of German audio, German text, and English translation, based on German audio books. The corpus consists of over 100 hours of audio material aligned to over 50k parallel sentences. Our approach mirrors that of KocabiyikogluETAL:18 in that we start from freely available audio books. The fact that the audio data is read speech keeps the number of disfluencies low. Furthermore, we use state-of-the art tools for audio-text and text-text alignment, and show in a manual evaluation that the speech alignment quality is in general very high, while the sentence alignment quality is comparable to widely used corpora such as that of KocabiyikogluETAL:18 and can be adjusted by cutoffs on the automatic alignment score. To our knowledge, the presented corpus is to data the largest resource for end-to-end speech translation for German."
        ]
      },
      {
        "section_name": "Overview",
        "paragraphs": [
          "In the following, we will give an overview over our corpus creation methodology. More details will be given in the following sections.",
          "Creation of German corpus (see Section sourcecorpus. )",
          "Data download",
          "Download German audio books from LibriVox web platform",
          "Collect corresponding text files by crawling public domain web pages",
          "Audio preprocessing",
          "Manual filtering of audio pre- and postfixes",
          "Text preprocessing",
          "Noise removal, e.g. special symbols, advertisements, hyperlinks",
          "Sentence segmentation using spaCy",
          "Speech-to-text alignments",
          "Manual chapter segmentation of audio files",
          "Audio-to-text alignments using forced aligner aeneas",
          "Split audio according to obtained timestamps using SoX",
          "Creation of German-English Speech Translation Corpus (see Sections targetcorpus. and corpusfiltering. )",
          "Download English translations for German texts",
          "Text preprocessing (same procedure as for German texts)",
          "Bilingual text-to-text alignments",
          "Manual text-to-text alignments of chapters",
          "Dictionary creation using parallel DE-EN WikiMatrix corpus BIBREF9",
          "German-English sentence alignments using hunalign BIBREF10",
          "Data filtering based on hunalign alignment scores"
        ]
      },
      {
        "section_name": "Source Corpus Creation ::: Data Collection",
        "paragraphs": [
          "We acquired pairs of German books and their corresponding audio files starting from LibriVox, an open source platform for people to publish their audio recordings of them reading books which are available open source on the platform Project Gutenberg. Source data were gathered in a semi-automatic way: The URL links were collected manually by using queries containing metadata descriptions to find German books with LibriVox audio and possible German transcripts. These were later automatically scraped using BeautifulSoup4 and Scrapy, and saved for further processing and cleaning. Public domain web pages crawled include https://gutenberg.spiegel.de, http://www.zeno.org, and https://archive.org."
        ]
      },
      {
        "section_name": "Source Corpus Creation ::: Data Preprocessing",
        "paragraphs": [
          "We processed the audio data in a semi-automatic manner which included manual splitting and alignment of audio files into chapters, while also saving timestamps for start and end of chapters. We removed boilerplate intros and outros and as well as noise at the beginning and end of the recordings.",
          "Preprocessing the text included removal of several items, including special symbols like *, advertisements, hyperlinks in [], <>, empty lines, quotes, - preceding sentences, indentations, and noisy OCR output.",
          "German sentence segmentation was done using spaCy based on a medium sized German corpus that contains the TIGER corpus and the WikiNER dataset dataset. Furthermore we added rules to adjust the segmenting behavior for direct speech and for semicolon-separated sentences."
        ]
      },
      {
        "section_name": "Source Corpus Creation ::: Text-to-Speech Alignment",
        "paragraphs": [
          "To align sentences to onsets and endings of corresponding audio segments we made use of aeneas \u2013 a tool for an automatic synchronization of text and audio. In contrast to most forced aligners, aeneas does not use automatic speech recognition (ASR) to compare an obtained transcript with the original text. Instead, it works in the opposite direction by using dynamic time warping to align the mel-frequency cepstral coefficients extracted from the real audio to the audio representation synthesized from the text, thus aligning the text file to a time interval in the real audio.",
          "Furthermore, we used the maps pointing to the beginning and the end of each text row in the audio file produced with SoX to split the audio into sentence level chunks. The timestamps were also used to filter boilerplate information about the book, author, speaker at the beginning and end of the audio file.",
          "Statistics on the resulting corpus are given in Table TABREF36."
        ]
      },
      {
        "section_name": "Target Corpus Creation ::: Data Collection and Preprocessing",
        "paragraphs": [
          "In collecting and preprocessing the English texts we followed the same procedure as for the source language corpus, i.e., we manually created queries containing metadata descriptions of English books (e.g. author names) corresponding to German books which then were scraped. The spaCy model for sentence segmentation used a large English web corpus. See Section sourcecorpus. for more information."
        ]
      },
      {
        "section_name": "Target Corpus Creation ::: Text-to-Text Alignment",
        "paragraphs": [
          "To produce text-to-text alignments we used hunalign with a custom dictionary of parallel sentences, generated from the WikiMatrix corpus. Using this additional dictionary improved our alignment scores. Furthermore we availed ourselves of a realign option enabling to save a dictionary generated in a first pass and profiting from it in a second pass. The final dictionary we used for the alignments consisted of a combination of entries of our corpora as well as the parallel corpus WikiMatrix. For further completeness we reversed the arguments in hunalign to not only obtain German to English alignments, but also English to German. These tables were merged to build the union by dropping duplicate entries and keeping those with a higher confidence score, while also appending alignments that may only have been produced when aligning in a specific direction.",
          "Statistics on the resulting text alignments are given in Table TABREF37."
        ]
      },
      {
        "section_name": "Data Filtering and Corpus Structure ::: Corpus Filtering",
        "paragraphs": [
          "A last step in our corpus creation procedure consisted out filtering out empty and incomplete alignments, i.e., alignments that did not consist of a DE-EN sentence pair. This was achieved by dropping all entries with a hunalign score of -0.3 or below. Table TABREF38 shows the resulting corpus after this filtering step.",
          "Moreover, many-to-many alignments by hunalign were re-segmented to source-audio sentence level for German, while keeping the merged English sentence to provide a complete audio lookup. The corresponding English sentences were duplicated and tagged with <MERGE> to mark that the German sentence was involved into a many-to-many alignment.",
          "The size of our final cleaned and filtered corpus is thus comparable to the cleaned Augmented LibriSpeech corpus that has been used in speech translation experiments by BerardETAL:18.",
          "Statistics on the resulting filtered text alignments are given in Table TABREF38."
        ]
      },
      {
        "section_name": "Data Filtering and Corpus Structure ::: Corpus Structure",
        "paragraphs": [
          "Our corpus is structured in following folders:",
          "contains German text files for each book",
          "contains English text files for each book",
          "alignment maps produced by aeneas",
          "sentence level audio files",
          "text2speech, a lookup table for speech alignments",
          "text2text, a lookup table for text-to-text alignments",
          "Further information about the corpus and a download link can be found here: https://www.cl.uni-heidelberg.de/statnlpgroup/librivoxdeen/."
        ]
      },
      {
        "section_name": "Corpus Evaluation ::: Human Evaluation",
        "paragraphs": [
          "For a manual evaluation of our dataset, we split the corpus into three bins according to ranges $(-0.3,0.3]$, $(0.3,0.8]$ and $(0.8,\\infty )$ of the hunalign confidence score (see Table TABREF56).",
          "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:",
          "Wrong alignment",
          "Partial alignment with slightly compositional translational equivalence",
          "Partial alignment with compositional translation and additional or missing information",
          "Correct alignment with compositional translation and few additional or missing information",
          "Correct alignment and fully compositional translation",
          "The evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:",
          "Wrong alignment",
          "Partial alignment, some words or sentences may be missing",
          "Correct alignment, allowing non-spoken syllables at start or end.",
          "The evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
        ]
      },
      {
        "section_name": "Corpus Evaluation ::: Evaluation Results",
        "paragraphs": [
          "Table TABREF54 shows the results of our manual evaluation. The audio-text alignment was rated as in general as high quality. The text-text alignment rating increases corresponding to increasing hunalign confidence score which shows that the latter can be safely used to find a threshold for corpus filtering. Overall, the audio-text and text-text alignment scores are very similar to those reported by KocabiyikogluETAL:18.",
          "The inter-annotator agreement between two raters was measured by Krippendorff's $\\alpha $-reliability score BIBREF11 for ordinal ratings. The inter-annotator reliability for text-to-text alignment quality ratings scored 0.77, while for audio-text alignment quality ratings it scored 1.00."
        ]
      },
      {
        "section_name": "Corpus Evaluation ::: Examples",
        "paragraphs": [
          "In the following, we present selected examples for text-text alignments for each bin. A closer inspection reveals properties and shortcomings of hunalign scores which are based on a combination of dictionary-based alignments and sentence-length information.",
          "Shorter sentence pairs are in general aligned correctly, irrespective of the score (compare examples with score $0.30$. $0.78$ and $1.57$, $2.44$ below). Longer sentences can include exact matches of longer substrings, however, they are scored based on a bag-of-words overlap (see the examples with scores $0.41$ and $0.84$ below).",
          "Schigolch Yes, yes; und mir tr\u00e4umte von einem St\u00fcck Christmas Pudding.",
          "She only does that to revive old memories. LULU.",
          "Und h\u00e4tten drei\u00dfigtausend Helfer sich ersehn.",
          "And feardefying Folker shall our companion be; He shall bear our banner; better none than he.",
          "Kakambo verlor nie den Kopf.",
          "Cacambo never lost his head.",
          "Es befindet sich gar keine junge Dame an Bord, versetzte der Proviantmeister.",
          "He is a tall gentleman, quiet, and not very talkative, and has with him a young lady \u2014 There is no young lady on board, interrupted the AROUND THE WORLD IN EIGPITY DAYS. purser..",
          "Ottilie, getragen durch das Gef\u00fchl ihrer Unschuld, auf dem Wege zu dem erw\u00fcnschtesten Gl\u00fcck, lebt nur f\u00fcr Eduard.",
          "Ottilie, led by the sense of her own innocence along the road to the happiness for which she longed, only lived for Edward.",
          "Was ist geschehen? fragte er.",
          "What has happened ? he asked.",
          "Es sind nun drei Monate verflossen, da\u00df wir Charleston auf dem Chancellor verlassen, und zwanzig Tage, die wir schon auf dem Flosse, von der Gnade der Winde und Str\u00f6mungen abh\u00e4ngig, verbracht haben!",
          "JANUARY st to th.More than three months had elapsed since we left Charleston in the Chancellor, and for no less than twenty days had we now been borne along on our raft at the mercy of the wind and waves.",
          "Charlotte stieg weiter, und Ottilie trug das Kind.",
          "Charlotte went on up the cliff, and Ottilie carried the child.",
          "Fin de siecle, murmelte Lord Henry.",
          "Fin de siecle, murmured Lord Henry."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We presented a corpus of aligned triples of German audio, German text, and English translations for speech translation from German to English. The audio data in our corpus are read speech, based on German audio books, ensuring a low amount of speech disfluencies. The audio-text alignment and text-to-text sentence alignment was done with state-of-the-art alignment tools and checked to be of high quality in a manual evaluation. The audio-text alignment was generally rated very high. The text-text sentence alignment quality is comparable to widely used corpora such as that of KocabiyikogluETAL:18. A cutoff on a sentence alignment quality score allows to filter the text alignments further for speech translation, resulting in a clean corpus of $50,427$ German-English sentence pairs aligned to 110 hours of German speech. A larger version of the corpus, comprising 133 hours of German speech and high-quality alignments to German transcriptions is available for speech recognition."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "The research reported in this paper was supported in part by the German research foundation (DFG) under grant RI-2221/4-1."
        ]
      }
    ],
    "qas": [
      {
        "question": "How is the sentence alignment quality evaluated?",
        "question_id": "46aa61557c8d20b1223a30366a0704d7af68bbbe",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "German",
        "question_writer": "486a870694ba60f1a1e7e4ec13e328164cd4b43c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Through human evaluation on a 5-point scale for text alignment and 3-point scale for audio-text",
              "evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:",
                "Wrong alignment",
                "Partial alignment with slightly compositional translational equivalence",
                "Partial alignment with compositional translation and additional or missing information",
                "Correct alignment with compositional translation and few additional or missing information",
                "Correct alignment and fully compositional translation",
                "The evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:",
                "Partial alignment, some words or sentences may be missing",
                "Correct alignment, allowing non-spoken syllables at start or end.",
                "The evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
              ],
              "highlighted_evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:\n\nWrong alignment\n\nPartial alignment with slightly compositional translational equivalence\n\nPartial alignment with compositional translation and additional or missing information\n\nCorrect alignment with compositional translation and few additional or missing information\n\nCorrect alignment and fully compositional translation\n\nThe evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:\n\nWrong alignment\n\nPartial alignment, some words or sentences may be missing\n\nCorrect alignment, allowing non-spoken syllables at start or end.\n\nThe evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
              ]
            },
            "annotation_id": "7aafc607e9232c2212c0bb0b694568f3b768a81e",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:\n\nWrong alignment\n\nPartial alignment with slightly compositional translational equivalence\n\nPartial alignment with compositional translation and additional or missing information\n\nCorrect alignment with compositional translation and few additional or missing information\n\nCorrect alignment and fully compositional translation\n\nThe evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:\n\nWrong alignment\n\nPartial alignment, some words or sentences may be missing\n\nCorrect alignment, allowing non-spoken syllables at start or end.\n\nThe evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:",
                "Wrong alignment",
                "Partial alignment with slightly compositional translational equivalence",
                "Partial alignment with compositional translation and additional or missing information",
                "Correct alignment with compositional translation and few additional or missing information",
                "Correct alignment and fully compositional translation",
                "The evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:",
                "Partial alignment, some words or sentences may be missing",
                "Correct alignment, allowing non-spoken syllables at start or end.",
                "The evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
              ],
              "highlighted_evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:\n\nWrong alignment\n\nPartial alignment with slightly compositional translational equivalence\n\nPartial alignment with compositional translation and additional or missing information\n\nCorrect alignment with compositional translation and few additional or missing information\n\nCorrect alignment and fully compositional translation\n\nThe evaluation of the audio-text alignment quality was conducted according to the following 3-point scale:\n\nWrong alignment\n\nPartial alignment, some words or sentences may be missing\n\nCorrect alignment, allowing non-spoken syllables at start or end.\n\nThe evaluation experiment was performed by two annotators who each rated 30 items from each bin, where 10 items were the same for both annotators in order to calculate inter-annotator reliability."
              ]
            },
            "annotation_id": "1f92ab9b953860b775d303d243f3b07e6352d870",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "5-point scale used in KocabiyikogluETAL:18"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:",
                "Wrong alignment",
                "Partial alignment with slightly compositional translational equivalence",
                "Partial alignment with compositional translation and additional or missing information",
                "Correct alignment with compositional translation and few additional or missing information",
                "Correct alignment and fully compositional translation"
              ],
              "highlighted_evidence": [
                "The evaluation of the text alignment quality was conducted according to the 5-point scale used in KocabiyikogluETAL:18:\n\nWrong alignment\n\nPartial alignment with slightly compositional translational equivalence\n\nPartial alignment with compositional translation and additional or missing information\n\nCorrect alignment with compositional translation and few additional or missing information\n\nCorrect alignment and fully compositional translation"
              ]
            },
            "annotation_id": "722480c3c6e2fc1d13450d20fa2bcb73b22be4bd",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Source corpus description"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: DE-EN text-to-text alignment data after filtering"
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Manual evaluation of for audio-text and text-text alignments, averaged over 90 items and two raters"
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Bins of text alignment quality according to hunalign confidence score"
      }
    ]
  },
  "1603.09405": {
    "title": "Enhancing Sentence Relation Modeling with Auxiliary Character-level Embedding",
    "abstract": "Neural network based approaches for sentence relation modeling automatically generate hidden matching features from raw sentence pairs. However, the quality of matching feature representation may not be satisfied due to complex semantic relations such as entailment or contradiction. To address this challenge, we propose a new deep neural network architecture that jointly leverage pre-trained word embedding and auxiliary character embedding to learn sentence meanings. The two kinds of word sequence representations as inputs into multi-layer bidirectional LSTM to learn enhanced sentence representation. After that, we construct matching features followed by another temporal CNN to learn high-level hidden matching feature representations. Experimental results demonstrate that our approach consistently outperforms the existing methods on standard evaluation datasets.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Traditional approaches BIBREF0 , BIBREF1 , BIBREF2 for sentence relation modeling tasks such as paraphrase identification, question answering, recognized textual entailment and semantic textual similarity prediction usually build the supervised model using a variety of hand crafted features. Hundreds of features generated at different linguistic levels are exploited to boost classification. With the success of deep learning, there has been much interest in applying deep neural network based techniques to further improve the prediction performances BIBREF3 , BIBREF4 , BIBREF5 .",
          "A key component of deep neural network is word embedding which serve as an lookup table to get word representations. From low level NLP tasks such as language modeling, POS tagging, name entity recognition, and semantic role labeling BIBREF6 , BIBREF7 , to high level tasks such as machine translation, information retrieval and semantic analysis BIBREF8 , BIBREF9 , BIBREF10 . Deep word representation learning has demonstrated its importance for these tasks. All the tasks get performance improvement via further learning either word level representations or sentence level representations. On the other hand, some researchers have found character-level convolutional networks BIBREF11 , BIBREF12 are useful in extracting information from raw signals for the task such as language modeling or text classification.",
          "In this work, we focus on deep neural network based sentence relation modeling tasks. We explore treating each sentence as a kind of raw signal at character level, and applying temporal (one-dimensional) Convolution Neural Network (CNN) BIBREF6 , Highway Multilayer Perceptron (HMLP) and multi-layer bidirectional LSTM (Long Short Term Memory) BIBREF13 to learn sentence representations. We propose a new deep neural network architecture that jointly leverage pre-trained word embedding and character embedding to represent the meaning sentences. More specifically, our new approach first generates two kinds of word sequence representations. One kind of sequence representations are the composition of pre-trained word vectors. The other kind of sequence representation comprise word vectors that generating from character-level convolutional network. We then inject the two sequence representations into bidirectional LSTM, which means forward directional LSTM accept pre-trained word embedding output and backward directional LSTM accept auxiliary character CNN embedding output. The final sentence representation is the concatenation of the two direction. After that, we construct matching features followed by another temporal CNN to learn high-level hidden matching feature representations. Figure FIGREF1 shows the neural network architecture for general sentence relation modeling.",
          "Our model shows that when trained on small size datasets, combining pre-trained word embeddings with auxiliary character-level embedding can improve the sentence representation. Word embeddings can help capturing general word semantic meanings, whereas char-level embedding can help modeling task specific word meanings. Note that auxiliary character-level embedding based sentence representation do not require the knowledge of words or even syntactic structure of a language. The enhanced sentence representation generated by multi-layer bidirectional LSTM will encapsulate the character and word levels informations. Furthermore, it may enhance matching features that generated by computing similarity measures on sentence pairs. Quantitative evaluations on standard dataset demonstrate the effectiveness and advantages of our method."
        ]
      },
      {
        "section_name": "Character-level Convolutional Neural Network",
        "paragraphs": [
          "Besides pre-trained word vectors, we are also interested in generating word vectors from characters. To achieve that, we leverage deep convolutional neural network(ConvNets). The model accepts a sequence of encoded characters as input. The encoding si done by prescribing an alphabet of size INLINEFORM0 for the input language, and then quantize each character using one-hot encoding. Then, the sequence of characters is transformed to a sequence of such INLINEFORM1 sized vectors with fixed length INLINEFORM2 . Any character exceeding length INLINEFORM3 is ignored, and any characters that are not in the alphabet are quantized as all-zero vectors. The alphabet used in our model consists of 36 characters, including 26 english letters and 10 digits. Below, we will introduce character-level temporal convolution neural network."
        ]
      },
      {
        "section_name": "Temporal Convolution",
        "paragraphs": [
          "Temporal Convolution applies one-dimensional convolution over an input sequence. The one-dimensional convolution is an operation between a vector of weights INLINEFORM0 and a vector of inputs viewed as a sequence INLINEFORM1 . The vector INLINEFORM2 is the filter of the convolution. Concretely, we think of INLINEFORM3 as the input token and INLINEFORM4 as a single feature value associated with the INLINEFORM5 -th character in this token. The idea behind the one-dimensional convolution is to take the dot product of the vector INLINEFORM6 with each INLINEFORM7 -gram in the token INLINEFORM8 to obtain another sequence INLINEFORM9 : DISPLAYFORM0 ",
          "Usually, INLINEFORM0 is not a single value, but a INLINEFORM1 -dimensional vector so that INLINEFORM2 . There exist two types of 1d convolution operations. One is called Time Delay Neural Networks (TDNNs). The other one was introduced by BIBREF6 . In TDNN, weights INLINEFORM3 form a matrix. Each row of INLINEFORM4 is convolved with the corresponding row of INLINEFORM5 . In BIBREF6 architecture, a sequence of length INLINEFORM6 is represented as: DISPLAYFORM0 ",
          "where INLINEFORM0 is the concatenation operation. In general, let INLINEFORM1 refer to the concatenation of characters INLINEFORM2 . A convolution operation involves a filter INLINEFORM3 , which is applied to a window of INLINEFORM4 characters to produce the new feature. For example, a feature INLINEFORM5 is generated from a window of characters INLINEFORM6 by: DISPLAYFORM0 ",
          "Here INLINEFORM0 is a bias term and INLINEFORM1 is a non-linear function such as the thresholding function INLINEFORM2 . This filter is applied to each possible window of characters in the sequence INLINEFORM3 to produce a feature map: DISPLAYFORM0 ",
          "with INLINEFORM0 ."
        ]
      },
      {
        "section_name": "Highway MLP",
        "paragraphs": [
          "On top of convolutional neural network layers, we build another Highway Multilayer Perceptron (HMLP) layer to further enhance character-level word embeddings. Conventional MLP applies an affine transformation followed by a nonlinearity to obtain a new set of features: DISPLAYFORM0 ",
          "One layer of a highway network does the following: DISPLAYFORM0 ",
          "where INLINEFORM0 is a nonlinearity, INLINEFORM1 is called as the transform gate, and INLINEFORM2 is called as the carry gate. Similar to the memory cells in LSTM networks, highway layers allow adaptively carrying some dimensions of the input directly to the input for training deep networks."
        ]
      },
      {
        "section_name": "Multi-Layer Bidirectional LSTM",
        "paragraphs": [
          "Now that we have two kinds of word sequence representations. One kind of sequence representations are the composition of pre-trained word vectors. The other kind of sequence representation comprise word vectors that generating from character-level convolutional network. We can inject the two sequence representations into bidirectional LSTM to learn sentence representation. More specifically, forward directional LSTM accept pre-trained word embedding output and backward directional LSTM accept character CNN embedding output. The final sentence representation is the concatenation of the two direction."
        ]
      },
      {
        "section_name": "RNN vs LSTM",
        "paragraphs": [
          "Recurrent neural networks (RNNs) are capable of modeling sequences of varying lengths via the recursive application of a transition function on a hidden state. For example, at each time step INLINEFORM0 , an RNN takes the input vector INLINEFORM1 and the hidden state vector INLINEFORM2 , then applies affine transformation followed by an element-wise nonlinearity such as hyperbolic tangent function to produce the next hidden state vector INLINEFORM3 : DISPLAYFORM0 ",
          "A major issue of RNNs using these transition functions is that it is difficult to learn long-range dependencies during training step because the components of the gradient vector can grow or decay exponentially BIBREF14 .",
          "The LSTM architecture BIBREF15 addresses the problem of learning long range dependencies by introducing a memory cell that is able to preserve state over long periods of time. Concretely, at each time step INLINEFORM0 , the LSTM unit can be defined as a collection of vectors in INLINEFORM1 : an input gate INLINEFORM2 , a forget gate INLINEFORM3 , an output gate INLINEFORM4 , a memory cell INLINEFORM5 and a hidden state INLINEFORM6 . We refer to INLINEFORM7 as the memory dimensionality of the LSTM. One step of an LSTM takes as input INLINEFORM8 , INLINEFORM9 , INLINEFORM10 and produces INLINEFORM11 , INLINEFORM12 via the following transition equations: DISPLAYFORM0 ",
          "where INLINEFORM0 and INLINEFORM1 are the element-wise sigmoid and hyperbolic tangent functions, INLINEFORM2 is the element-wise multiplication operator."
        ]
      },
      {
        "section_name": "Model Description",
        "paragraphs": [
          "One shortcoming of conventional RNNs is that they are only able to make use of previous context. In text entailment, the decision is made after the whole sentence pair is digested. Therefore, exploring future context would be better for sequence meaning representation. Bidirectional RNNs architecture BIBREF13 proposed a solution of making prediction based on future words. At each time step INLINEFORM0 , the model maintains two hidden states, one for the left-to-right propagation INLINEFORM1 and the other for the right-to-left propagation INLINEFORM2 . The hidden state of the Bidirectional LSTM is the concatenation of the forward and backward hidden states. The following equations illustrate the main ideas: DISPLAYFORM0 ",
          "Deep RNNs can be created by stacking multiple RNN hidden layer on top of each other, with the output sequence of one layer forming the input sequence for the next. Assuming the same hidden layer function is used for all INLINEFORM0 layers in the stack, the hidden vectors INLINEFORM1 are iteratively computed from INLINEFORM2 to INLINEFORM3 and INLINEFORM4 to INLINEFORM5 : DISPLAYFORM0 ",
          "Multilayer bidirectional RNNs can be implemented by replacing each hidden vector INLINEFORM0 with the forward and backward vectors INLINEFORM1 and INLINEFORM2 , and ensuring that every hidden layer receives input from both the forward and backward layers at the level below. Furthermore, we can apply LSTM memory cell to hidden layers to construct multilayer bidirectional LSTM.",
          "Finally, we can concatenate sequence hidden matrix INLINEFORM0 and reversed sequence hidden matrix INLINEFORM1 to form the sentence representation. We refer to INLINEFORM2 is the number of layers, INLINEFORM3 as the memory dimensionality of the LSTM. In the next section, we will use the two matrixs to generate matching feature planes via linear algebra operations."
        ]
      },
      {
        "section_name": "Learning from Matching Features",
        "paragraphs": [
          "Inspired by BIBREF10 , we apply element-wise merge to first sentence matrix INLINEFORM0 and second sentence matrix INLINEFORM1 . Similar to previous method, we can define two simple matching feature planes (FPs) with below equations: DISPLAYFORM0 ",
          "where INLINEFORM0 is the element-wise multiplication. The INLINEFORM1 measure can be interpreted as an element-wise comparison of the signs of the input representations. The INLINEFORM2 measure can be interpreted as the distance between the input representations.",
          "In addition to the above measures, we also found the following feature plane can improve the performance: DISPLAYFORM0 ",
          "In INLINEFORM0 , the INLINEFORM1 means one-dimensional convolution. Join mean concatenate the two representation. The intuition behind INLINEFORM2 is let the one-dimensional convolution preserves the common information between sentence pairs."
        ]
      },
      {
        "section_name": "Reshape Feature Planes",
        "paragraphs": [
          "Recall that the multi-layer bidirectional LSTM generates sentence representation matrix INLINEFORM0 by concatenating sentence hidden matrix INLINEFORM1 and reversed sentence hidden matrix INLINEFORM2 . Then we conduct element-wise merge to form feature plane INLINEFORM3 . Therefore, the final input into temporal convolution layer is a 3D tensor INLINEFORM4 , where INLINEFORM5 is the number of matching feature plane, INLINEFORM6 is the number of layers, INLINEFORM7 as the memory dimensionality of the LSTM. Note that the 3D tensor convolutional layer input INLINEFORM8 can be viewed as an image where each feature plane is a channel. In computer vision and image processing communities, the spatial 2D convolution is often used over an input image composed of several input planes. In experiment section, we will compare 2D convolution with 1D convolution. In order to facilitate temporal convolution, we need reshape INLINEFORM9 to 2D tensor."
        ]
      },
      {
        "section_name": "CNN Topology",
        "paragraphs": [
          "The matching feature planes can be viewed as channels of images in image processing. In our scenario, these feature planes hold the matching information. We will use temporal convolutional neural network to learn hidden matching features. The mechanism of temporal CNN here is the same as character-level temporal CNN. However, the kernels are totally different.",
          "It's quite important to design a good topology for CNN to learn hidden features from heterogeneous feature planes. After several experiments, we found two topological graphs can be deployed in the architecture. Figure FIGREF20 and Figure FIGREF20 show the two CNN graphs. In Topology i@, we stack temporal convolution with kernel width as 1 and tanh activation on top of each feature plane. After that, we deploy another temporal convolution and tanh activation operation with kernel width as 2. In Topology ii@, however, we first stack temporal convolution and tanh activation with kernel width as 2. Then we deploy another temporal convolution and tanh activation operation with kernel width as 1. Experiment results demonstrate that the Topology i@ is slightly better than the Topology ii@. This conclusion is reasonable. The feature planes are heterogeneous. After conducting convolution and tanh activation transformation, it makes sense to compare values across different feature planes."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We selected two related sentence relation modeling tasks: semantic relatedness task, which measures the degree of semantic relatedness of a sentence pair by assigning a relatedness score ranging from 1 (completely unrelated) to 5 ( very related); and textual entailment task, which determines whether the truth of a text entails the truth of another text called hypothesis. We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. It consists of about 10,000 English sentence pairs annotated for relatedness in meaning and entailment."
        ]
      },
      {
        "section_name": "Hyperparameters and Training Details",
        "paragraphs": [
          "We first initialize our word representations using publicly available 300-dimensional Glove word vectors . LSTM memory dimension is 100, the number of layers is 2. On the other hand, for CharCNN model we use threshold activation function on top of each temporal convolution and max pooling pairs . The CharCNN input frame size equals alphabet size, output frame size is 100. The maximum sentence length is 37. The kernel width of each temporal convolution is set to 3, the step is 1, the hidden units of HighwayMLP is 50. Training is done through stochastic gradient descent over shuffled mini-batches with the AdaGrad update rule BIBREF16 . The learning rate is set to 0.05. The mini-batch size is 25. The model parameters were regularized with a per-minibatch L2 regularization strength of INLINEFORM0 . Note that word embeddings were fixed during training."
        ]
      },
      {
        "section_name": "Objective Functions",
        "paragraphs": [
          "The task of semantic relatedness prediction tries to measure the degree of semantic relatedness of a sentence pair by assigning a relatedness score ranging from 1 (completely unrelated) to 5 (very related). More formally, given a sentence pair, we wish to predict a real-valued similarity score in a range of INLINEFORM0 , where INLINEFORM1 is an integer. The sequence INLINEFORM2 is the ordinal scale of similarity, where higher scores indicate greater degrees of similarity. We can predict the similarity score INLINEFORM3 by predicting the probability that the learned hidden representation INLINEFORM4 belongs to the ordinal scale. This is done by projecting an input representation onto a set of hyperplanes, each of which corresponds to a class. The distance from the input to a hyperplane reflects the probability that the input will located in corresponding scale.",
          "Mathematically, the similarity score INLINEFORM0 can be written as: DISPLAYFORM0 ",
          "where INLINEFORM0 and the weight matrix INLINEFORM1 and INLINEFORM2 are parameters.",
          "In order to introduce the task objective function, we define a sparse target distribution INLINEFORM0 that satisfies INLINEFORM1 : DISPLAYFORM0 ",
          "where INLINEFORM0 . The objective function then can be defined as the regularized KL-divergence between INLINEFORM1 and INLINEFORM2 : DISPLAYFORM0 ",
          "where INLINEFORM0 is the number of training pairs and the superscript INLINEFORM1 indicates the INLINEFORM2 -th sentence pair BIBREF10 .",
          "Referring to textual entailment recognition task, we want to maximize the likelihood of the correct class. This is equivalent to minimizing the negative log-likelihood (NLL). More specifically, the label INLINEFORM0 given the inputs INLINEFORM1 is predicted by a softmax classifier that takes the hidden state INLINEFORM2 at the node as input: DISPLAYFORM0 ",
          "After that, the objective function is the negative log-likelihood of the true class labels INLINEFORM0 : DISPLAYFORM0 ",
          "where INLINEFORM0 is the number of training pairs and the superscript INLINEFORM1 indicates the INLINEFORM2 th sentence pair."
        ]
      },
      {
        "section_name": "Results and Discussions",
        "paragraphs": [
          "Table TABREF31 and TABREF32 show the Pearson correlation and accuracy comparison results of semantic relatedness and text entailment tasks. We can see that combining CharCNN with multi-layer bidirectional LSTM yields better performance compared with other traditional machine learning methods such as SVM and MaxEnt approach BIBREF17 , BIBREF0 that served with many handcraft features. Note that our method doesn't need extra handcrafted feature extraction procedure. Also our method doesn't leverage external linguistic resources such as wordnet or parsing which get best results in BIBREF10 . More importantly, both task prediction results close to the state-of-the-art results. It proved that our approaches successfully simultaneously predict heterogeneous tasks. Note that for semantic relatedness task, the latest research BIBREF10 proposed a tree-structure based LSTM, the Pearson correlation score of their system can reach 0.863. Compared with their approach, our method didn't use dependency parsing and can be used to predict tasks contains multiple languages.",
          "We hope to point out that we implemented the method in BIBREF10 , but the results are not as good as our method. Here we use the results reported in their paper. Based on our experiments, we believe the method in BIBREF10 is very sensitive to the initializations, thus it may not achieve the good performance in different settings. However, our method is pretty stable which may benefit from the joint tasks training."
        ]
      },
      {
        "section_name": "Tree LSTM vs Sequence LSTM",
        "paragraphs": [
          "In this experiment, we will compare tree LSTM with sequential LSTM. A limitation of the sequence LSTM architectures is that they only allow for strictly sequential information propagation. However, tree LSTMs allow richer network topologies where each LSTM unit is able to incorporate information from multiple child units. As in standard LSTM units, each Tree-LSTM unit (indexed by INLINEFORM0 ) contains input and output gates INLINEFORM1 and INLINEFORM2 , a memory cell INLINEFORM3 and hidden state INLINEFORM4 . The difference between the standard LSTM unit and tree LSTM units is that gating vectors and memory cell updates are dependent on the states of possibly many child units. Additionally, instead of a single forget gate, the tree LSTM unit contains one forget gate INLINEFORM5 for each child INLINEFORM6 . This allows the tree LSTM unit to selectively incorporate information from each child.",
          "We use dependency tree child-sum tree LSTM proposed by BIBREF10 as our baseline. Given a tree, let INLINEFORM0 denote the set of children of node INLINEFORM1 . The child-sum tree LSTM transition equations are the following: DISPLAYFORM0 ",
          "Table TABREF35 show the comparisons between tree and sequential based methods. We can see that, if we don't deploy CNN, simple Tree LSTM yields better result than traditional LSTM, but worse than Bidirectional LSTM. This is reasonable due to the fact that Bidirectional LSTM can enhance sentence representation by concatenating forward and backward representations. We found that adding CNN layer will decrease the accuracy in this scenario. Because when feeding into CNN, we have to reshape the feature planes otherwise convolution will not work. For example, we set convolution kernel width as 2, the input 2D tensor will have the shape lager than 2. To boost performance with CNN, we need more matching features. We found Multi-layer Bidirectional LSTM can incorporate more features and achieve best performance compared with single-layer Bidirectional LSTM."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Existing neural sentence models mainly fall into two groups: convolutional neural networks (CNNs) and recurrent neural networks (RNNs). In regular 1D CNNs BIBREF6 , BIBREF8 , BIBREF19 , a fixed-size window slides over time (successive words in sequence) to extract local features of a sentence; then they pool these features to a vector, usually taking the maximum value in each dimension, for supervised learning. The convolutional unit, when combined with max-pooling, can act as the compositional operator with local selection mechanism as in the recursive autoencoder BIBREF3 . However, semantically related words that are not in one filter can't be captured effectively by this shallow architecture. BIBREF20 built deep convolutional models so that local features can mix at high-level layers. However, deep convolutional models may result in worse performance BIBREF19 .",
          "On the other hand, RNN can take advantage of the parsing or dependency tree of sentence structure information BIBREF3 , BIBREF21 . BIBREF4 used dependency-tree recursive neural network to map text descriptions to quiz answers. Each node in the tree is represented as a vector; information is propagated recursively along the tree by some elaborate semantic composition. One major drawback of RNNs is the long propagation path of information near leaf nodes. As gradient may vanish when propagated through a deep path, such long dependency buries illuminating information under a complicated neural architecture, leading to the difficulty of training. To address this issue, BIBREF10 proposed a Tree-Structured Long Short-Term Memory Networks. This motivates us to investigate multi-layer bidirectional LSTM that directly models sentence meanings without parsing for RTE task."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this paper, we propose a new deep neural network architecture that jointly leverage pre-trained word embedding and character embedding to learn sentence meanings. Our new approach first generates two kinds of word sequence representations as inputs into bidirectional LSTM to learn sentence representation. After that, we construct matching features followed by another temporal CNN to learn high-level hidden matching feature representations. Our model shows that combining pre-trained word embeddings with auxiliary character-level embedding can improve the sentence representation. The enhanced sentence representation generated by multi-layer bidirectional LSTM will encapsulate the character and word levels informations. Furthermore, it may enhance matching features that generated by computing similarity measures on sentence pairs. Experimental results on benchmark datasets demonstrate that our new framework achieved the state-of-the-art performance compared with other deep neural networks based approaches."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which datasets do they evaluate on?",
        "question_id": "420862798054f736128a6f0c4393c7f9cc648b40",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SICK (Sentences Involving Compositional Knowledge) dataset "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We selected two related sentence relation modeling tasks: semantic relatedness task, which measures the degree of semantic relatedness of a sentence pair by assigning a relatedness score ranging from 1 (completely unrelated) to 5 ( very related); and textual entailment task, which determines whether the truth of a text entails the truth of another text called hypothesis. We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. It consists of about 10,000 English sentence pairs annotated for relatedness in meaning and entailment."
              ],
              "highlighted_evidence": [
                "We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. "
              ]
            },
            "annotation_id": "18ee05e63e95cf30da12e45bca7f39214b45adb0",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SICK (Sentences Involving Compositional Knowledge) dataset"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We selected two related sentence relation modeling tasks: semantic relatedness task, which measures the degree of semantic relatedness of a sentence pair by assigning a relatedness score ranging from 1 (completely unrelated) to 5 ( very related); and textual entailment task, which determines whether the truth of a text entails the truth of another text called hypothesis. We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. It consists of about 10,000 English sentence pairs annotated for relatedness in meaning and entailment."
              ],
              "highlighted_evidence": [
                "We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation."
              ]
            },
            "annotation_id": "5f2db275a581887ab9d4d380f0d44277f1cc2aa0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SICK (Sentences Involving Compositional Knowledge) dataset"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We selected two related sentence relation modeling tasks: semantic relatedness task, which measures the degree of semantic relatedness of a sentence pair by assigning a relatedness score ranging from 1 (completely unrelated) to 5 ( very related); and textual entailment task, which determines whether the truth of a text entails the truth of another text called hypothesis. We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. It consists of about 10,000 English sentence pairs annotated for relatedness in meaning and entailment."
              ],
              "highlighted_evidence": [
                "We use standard SICK (Sentences Involving Compositional Knowledge) dataset for evaluation. "
              ]
            },
            "annotation_id": "cefa35262312398148a7a571ab29b05dc6a0a070",
            "worker_id": "d9135203a92ded14d260a7d551b7a447c8b7c910"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Neural Network Architecture for Deep Matching Feature Learning. M-BLSTM is Multilayer Bidirectional LSTM. Orange color represents sequence representations that concatenating pre-trained word vectors. Purple color represents sequence representation concatenating word vectors that generating from character-level convolutional network and HMLP."
      },
      {
        "file": "6-Figure2-1.png",
        "caption": "Figure 2: CNN Topology I Figure 3: CNN Topology II"
      },
      {
        "file": "7-Table1-1.png",
        "caption": "Table 1: Semantic Relatedness Task Comparison."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Textual Entailment Task Comparison."
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3: Results of Tree LSTM vs Sequence LSTM on auxiliary char embedding."
      }
    ]
  },
  "1912.11585": {
    "title": "THUEE system description for NIST 2019 SRE CTS Challenge",
    "abstract": "This paper describes the systems submitted by the department of electronic engineering, institute of microelectronics of Tsinghua university and TsingMicro Co. Ltd. (THUEE) to the NIST 2019 speaker recognition evaluation CTS challenge. Six subsystems, including etdnn/ams, ftdnn/as, eftdnn/ams, resnet, multitask and c-vector are developed in this evaluation.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "This paper describes the systems developed by the department of electronic engineering, institute of microelectronics of Tsinghua university and TsingMicro Co. Ltd. (THUEE) for the NIST 2019 speaker recognition evaluation (SRE) CTS challenge BIBREF0. Six subsystems, including etdnn/ams, ftdnn/as, eftdnn/ams, resnet, multitask and c-vector are developed in this evaluation. All the subsystems consists of a deep neural network followed by dimension deduction, score normalization and calibration. For each system, we begin with a summary of the data usage, followed by a description of the system setup along with their hyperparameters. Finally, we report experimental results obtained by each subsystem and fusion system on the SRE18 development and SRE18 evaluation datasets."
        ]
      },
      {
        "section_name": "Data Usage",
        "paragraphs": [
          "For the sake of clarity, the datasets notations are defined as in table 1 and the training data for the six subsystems are list in table 2, 3, and 4."
        ]
      },
      {
        "section_name": "Systems ::: Etdnn/ams",
        "paragraphs": [
          "Etdnn/ams system is an extended version of tdnn with the additive margin softmax loss BIBREF1. Etdnn is used in speaker verification in BIBREF2. Compared with the traditional tdnn in BIBREF3, it has wider context and interleaving dense layers between each two tdnn layers. The architecture of our etdnn network is shown in table TABREF6. It is the same as the etdnn architecture in BIBREF2, except that the context of layer 5 of our system is t-3:t+3 instead of t-3, t, t+3. The x-vector is extracted from layer 12 prior to the ReLU non-linearity. For the loss, we use additive margin softmax with $m=0.15$ instead of traditional softmax loss or angular softmax loss. Additive margin softmax is proposed in BIBREF4 and then used in speaker verification in our paper BIBREF1. It is easier to train and generally performs better than angular softmax."
        ]
      },
      {
        "section_name": "Systems ::: ftdnn/as",
        "paragraphs": [
          "Factorized TDNN (ftdnn) architecture is listed in table TABREF8. It is the same to BIBREF2 except that we use 1024 nodes instead of 512 nodes in layer 12 and 13. The x-vector is extracted from layer 12 prior to the ReLU non-linearity. So our x-vector is 1024 dimensional. More details about the architecture can be found in BIBREF2."
        ]
      },
      {
        "section_name": "Systems ::: eftdnn/ams",
        "paragraphs": [
          "Extended ftdnn (eftdnn) is a combination of etdnn and ftdnn. Its architecture is listed in table TABREF10. The x-vector is extracted from layer 22 prior to the ReLU non-linearity."
        ]
      },
      {
        "section_name": "Systems ::: resnet",
        "paragraphs": [
          "ResNet architecture is also based on tdnn x-vector BIBREF3. The five frame level tdnn layers in BIBREF3 are replaced by ResNet34 (512 nodes) + DNN(512 nodes) + DNN(1000 nodes). Further details about ResNet34 can be found in BIBREF5. In our realization, acoustic features are regarded as a single channel picture and feed into the ResNet34. If the dimensions in the residual network don't match, zeros are added. The statistic pooling and segment level network stay the same. For the loss function, we use angular softmax with $m=4$. The x-vector is extracted from first DNN layer in segment level prior to the ReLU non-linearity. It has 512 dimensions."
        ]
      },
      {
        "section_name": "Systems ::: multitask",
        "paragraphs": [
          "Multitask architecture is proposed in BIBREF6. It is a hybrid multi-task learning based on x-vector network and ASR network. It aims to introduce phonetic information by another neural acoustic model in ASR to help speaker recognition task. The architecture is shown in Fig. FIGREF13.",
          "The frame-level part of the x-vector network is a 10-layer TDNN. The input of each layer is the sliced output of the previous layer. The slicing parameter is: {t - 2; t - 1; t; t + 1; t + 2}, { t }, { t - 2; t; t + 2 }, {t}, { t - 3; t; t + 3 }, {t }, {t - 4; t; t + 4 }, { t }, { t } , { t }. It has 512 nodes in layer 1 to 9, and the 10-th layer has 1500 nodes. The segment-level part of x-vector network is a 2-layer fully-connected network with 512 nodes per layer. The output is predicted by softmax and the size is the same as the number of speakers.",
          "The ASR network has no statistics pooling component. The frame-level part of the x-vector network is a 7-layer TDNN. The input of each layer is the sliced output of the previous layer. The slicing parameter is: {t - 2; t - 1; t; t + 1; t + 2}, {t - 2; t; t + 2}, {t - 3; t; t + 3}, {t}, {t}, {t}, {t}. It has 512 nodes in layer 1 to 7.",
          "Only the first TDNN layer of the x-vector network is shared with the ASR network. The phonetic classification is done at the frame level, while the speaker labels are classified at the segment level.",
          "To train the multitask network, we need training data with speaker and ASR transcribed. But only Phonetic dataset fits this condition and the data amount is too small to train a neural network. So, we need to train a GMM-HMM speech recognition system to do phonetic alignment for other datasets. The GMM-HMM is trained using Phonetic dataset with features of 20-dimensional MFCCs with delta and delta-delta, totally 60-dimensional. The total number of senones is 3800. After training, forced alignment is applied to the SRE, Switchboard, and Voxceleb datasets using a fMLLR-SAT system."
        ]
      },
      {
        "section_name": "Systems ::: c-vector",
        "paragraphs": [
          "C-vector architecture is also one of our proposed systems in paper BIBREF7. As shown in Fig. FIGREF15, it is an extension of multitask architecture. It combines multitask architecture with an extra ASR Acoustic Model. The output of ASR Acoustic Model is concatenated with x-vector's frame-level output as the input of statistics pooling. Refer to BIBREF7 for more details.",
          "The multitask part of c-vector has the same architecture as in the above section SECREF12 ASR Acoustic Model of c-vector is a 5-layer TDNN network. The slicing parameter is { t - 2; t - 1; t; t + 1; t + 2 }, { t - 1; t; t + 1 }, { t - 1; t; t + 1 }, { t - 3; t; t + 3}, { t - 6; t - 3; t}. The 5-th layer is the BN layer containing 128 nodes and other layers have 650 nodes.",
          "A GMM-HMM is also trained as like in section SECREF12 to do phonetic alignment for training datasets."
        ]
      },
      {
        "section_name": "feature and back-end",
        "paragraphs": [
          "23-dimensional MFCC (20-3700Hz) is extracted as feature for etdnn/ams, ftdnn/as, eftdnn/ams, multitask and c-vector subsystems. 23-dimensional Fbank is used as feature for ResNet 16kHz subsystems. A simple energy-based VAD is used based on the C0 component of the MFCC feature BIBREF8.",
          "For each neural network, its training data are augmented using the public accessible MUSAN and RIRS_NOISES as the noise source. Two-fold data augmentation is applied for etdnn/ams, ftdnn/as, resnet, multitask and cvector subsystems. For eftdnn/ams subsystem, five-fold data augmentation is applied.",
          "After the embeddings are extracted, they are then transformed to 150 dimension using LDA. Then, embeddings are projected into unit sphere. At last, adapted PLDA with no dimension reduction is applied.",
          "The execution time is test on Intel Xeon E5-2680 v4. Extracting x-vector cost about 0.087RT. Single trial cost around 0.09RT. The memory cost about 1G for a x-vector extraction and a single trial. In the inference, only CPU is used.",
          "The speed test was performed on Intel Xeon E5-2680 v4 for etdnn_ams, multitask, c-vector and ResNet system. Test on Intel Xeon Platinum 8168 for ftdnn and eftdnn system. Extracting embedding cost about 0.103RT for etdnn_ams, 0.089RT for multitask, 0.092RT for c-vector, 0.132RT for eftdnn, 0.0639RT for ftdnn, and 0.112RT for ResNet. Single trial cost around 1.2ms for etdnn_ams, 0.9ms for multitask, 0.9ms for c-vector, 0.059s for eftdnn, 0.0288s for ftdnn, 1.0ms for ResNet. The memory cost about 1G for an embedding extraction and a single trial. In the inference, we just use CPU."
        ]
      },
      {
        "section_name": "Fusion",
        "paragraphs": [
          "Our primary system is the linear fusion of all the above six subsystems by BOSARIS Toolkit on SRE19 dev and eval BIBREF9. Before the fusion, each score is calibrated by PAV method (pav_calibrate_scores) on our development database. It is evaluated by the primary metric provided by NIST SRE 2019."
        ]
      }
    ],
    "qas": [
      {
        "question": "What was the baseline?",
        "question_id": "11360385dff0a9d7b8f4b106ba2b7fe15ca90d7c",
        "nlp_background": "",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "1b262b70d1ce9da1635c93baa62c8b1e4a97b412",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "61a1a60e2a9fe9c3a3ae907398cc0a8764390835",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "69fb04c5566525d2cce7349d0ca570c95f0395e0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Table1-1.png",
        "caption": "Table 1. Datasets Notations"
      },
      {
        "file": "1-Table3-1.png",
        "caption": "Table 3. Data usage for multitask and c-vector subsystems"
      },
      {
        "file": "2-Table5-1.png",
        "caption": "Table 5. Etdnn architecture"
      },
      {
        "file": "2-Figure1-1.png",
        "caption": "Fig. 1. multitask architecture for the speaker embedding extraction."
      },
      {
        "file": "2-Table6-1.png",
        "caption": "Table 6. ftdnn architecture"
      },
      {
        "file": "3-Table7-1.png",
        "caption": "Table 7. eftdnn architecture"
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Fig. 2. multitask architecture for the speaker embedding extraction."
      },
      {
        "file": "4-Table8-1.png",
        "caption": "Table 8. Subsystem performance on SRE18 DEV and EVAL set."
      }
    ]
  },
  "1707.09816": {
    "title": "Combining Thesaurus Knowledge and Probabilistic Topic Models",
    "abstract": "In this paper we present the approach of introducing thesaurus knowledge into probabilistic topic models. The main idea of the approach is based on the assumption that the frequencies of semantically related words and phrases, which are met in the same texts, should be enhanced: this action leads to their larger contribution into topics found in these texts. We have conducted experiments with several thesauri and found that for improving topic models, it is useful to utilize domain-specific knowledge. If a general thesaurus, such as WordNet, is used, the thesaurus-based improvement of topic models can be achieved with excluding hyponymy relations in combined topic models.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Currently, probabilistic topic models are important tools for improving automatic text processing including information retrieval, text categorization, summarization, etc. Besides, they can be useful in supporting expert analysis of document collections, news flows, or large volumes of messages in social networks BIBREF0 , BIBREF1 , BIBREF2 . To facilitate this analysis, such approaches as automatic topic labeling and various visualization techniques have been proposed BIBREF1 , BIBREF3 .",
          "Boyd-Graber et al. BIBREF4 indicate that to be understandable by humans, topics should be specific, coherent, and informative. Relationships between the topic components can be inferred. In BIBREF1 four topic visualization approaches are compared. The authors of the experiment concluded that manual topic labels include a considerable number of phrases; users prefer shorter labels with more general words and tend to incorporate phrases and more generic terminology when using more complex network graph. Blei and Lafferty BIBREF3 visualize topics with ngrams consisting of words mentioned in these topics. These works show that phrases and knowledge about hyponyms/hypernyms are important for topic representation.",
          "In this paper we describe an approach to integrate large manual lexical resources such as WordNet or EuroVoc into probabilistic topic models, as well as automatically extracted n-grams to improve coherence and informativeness of generated topics. The structure of the paper is as follows. In Section 2 we consider related works. Section 3 describes the proposed approach. Section 4 enumerates automatic quality measures used in experiments. Section 5 presents the results obtained on several text collections according to automatic measures. Section 6 describes the results of manual evaluation of combined topic models for Islam Internet-site thematic analysis."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Topic modeling approaches are unsupervised statistical algorithms that usually considers each document as a \"bag of words\". There were several attempts to enrich word-based topic models (=unigram topic models) with additional prior knowledge or multiword expressions.",
          "Andrzejewski et al. BIBREF5 incorporated knowledge by Must-Link and Cannot-Link primitives represented by a Dirichlet Forest prior. These primitives were then used in BIBREF6 , where similar words are encouraged to have similar topic distributions. However, all such methods incorporate knowledge in a hard and topic-independent way, which is a simplification since two words that are similar in one topic are not necessarily of equal importance for another topic.",
          "Xie et al. BIBREF7 proposed a Markov Random Field regularized LDA model (MRF-LDA), which utilizes the external knowledge to improve the coherence of topic modeling. Within a document, if two words are labeled as similar according to the external knowledge, their latent topic nodes are connected by an undirected edge and a binary potential function is defined to encourage them to share the same topic label. Distributional similarity of words is calculated beforehand on a large text corpus.",
          "In BIBREF8 , the authors gather so-called lexical relation sets (LR-sets) for word senses described in WordNet. The LR-sets include synonyms, antonyms and adjective-attribute related words. To adapt LR-sets to a specific domain corpus and to remove inappropriate lexical relations, the correlation matrix for word pairs in each LR-set is calculated. This matrix at the first step is used for filtrating inappropriate senses, then it is used to modify the initial LDA topic model according to the generalized Polya urn model described in BIBREF9 . The generalized Polya urn model boosts probabilities of related words in word-topic distributions.",
          "Gao and Wen BIBREF10 presented Semantic Similarity-Enhanced Topic Model that accounts for corpus-specific word co-occurrence and word semantic similarity calculated on WordNet paths between corresponding synsets using the generalized Polya urn model. They apply their topic model for categorizing short texts.",
          "All above-mentioned approaches on adding knowledge to topic models are limited to single words. Approaches using ngrams in topic models can be subdivided into two groups. The first group of methods tries to create a unified probabilistic model accounting unigrams and phrases. Bigram-based approaches include the Bigram Topic Model BIBREF11 and LDA Collocation Model BIBREF12 . In BIBREF13 the Topical N-Gram Model was proposed to allow the generation of ngrams based on the context. However, all these models are enough complex and hard to compute on real datasets.",
          "The second group of methods is based on preliminary extraction of ngrams and their further use in topics generation. Initial studies of this approach used only bigrams BIBREF14 , BIBREF15 . Nokel and Loukachevitch BIBREF16 proposed the LDA-SIM algorithm, which integrates top-ranked ngrams and terms of information-retrieval thesauri into topic models (thesaurus relations were not utilized). They create similarity sets of expressions having the same word components and sum up frequencies of similarity set members if they co-occur in the same text.",
          "In this paper we describe the approach to integrate whole manual thesauri into topic models together with multiword expressions."
        ]
      },
      {
        "section_name": "Approach to Integration Whole Thesauri into Topic Models",
        "paragraphs": [
          "In our approach we develop the idea of BIBREF16 that proposed to construct similarity sets between ngram phrases between each other and single words. Phrases and words are included in the same similarity set if they have the same component word, for example, weapon \u2013 nuclear weapon \u2013 weapon of mass destruction; discrimination \u2013 racial discrimination. It was supposed that if expressions from the same similarity set co-occur in the same document then their contribution into the document's topics is really more than it is presented with their frequencies, therefore their frequencies should be increased. In such an approach, the algorithm can \"see\" similarities between different multiword expressions with the same component word.",
          "In our approach, at first, we include related single words and phrases from a thesaurus such as WordNet or EuroVoc in these similarity sets. Then, we add preliminarily extracted ngrams into these sets and, this way, we use two different sources of external knowledge. We use the same LDA-SIM algorithm as described in BIBREF16 but study what types of semantic relations can be introduced into such similarity sets and be useful for improving topic models. The pseudocode of LDA-SIM algorithm is presented in Algorithm SECREF3 , where INLINEFORM0 is a similarity set, expressions in similarity sets can comprise single words, thesaurus phrases or generated noun compounds.",
          "We can compare this approach with the approaches applying the generalized Polya urn model BIBREF8 , BIBREF9 , BIBREF10 . To add prior knowledge, those approaches change topic distributions for related words globally in the collection. We modify topic probabilities for related words and phrases locally, in specific texts, only when related words (phrases) co-occur in these texts.",
          "[ht!] collection INLINEFORM0 , vocabulary INLINEFORM1 , number of topics INLINEFORM2 , initial INLINEFORM3 and INLINEFORM4 , sets of similar expressions INLINEFORM5 , hyperparameters INLINEFORM6 and INLINEFORM7 , INLINEFORM8 is the frequency of INLINEFORM9 in the document INLINEFORM10 distributions INLINEFORM11 and INLINEFORM12 not meet the stop criterion INLINEFORM13 INLINEFORM14 ",
          " INLINEFORM0 INLINEFORM1 ",
          " INLINEFORM0 ",
          " INLINEFORM0 ",
          " LDA-SIM algorithm"
        ]
      },
      {
        "section_name": "Automatic Measures to Estimate the Quality of Topic Models",
        "paragraphs": [
          "To estimate the quality of topic models, we use two main automatic measures: topic coherence and kernel uniqueness. For human content analysis, measures of topic coherence and kernel uniqueness are both important and complement each other. Topics can be coherent but have a lot of repetitions. On the other hand, generated topics can be very diverse, but incoherent within each topic.",
          "Topic coherence is an automatic metric of interpretability. It was shown that the coherence measure has a high correlation with the expert estimates of topic interpretability BIBREF9 , BIBREF17 . Mimno BIBREF9 described an experiment comparing expert evaluation of LDA-generated topics and automatic topic coherence measures. It was found that most \"bad\" topics consisted of words without clear relations between each other.",
          "Newman et al. BIBREF6 asked users to score topics on a 3-point scale, where 3=\u201cuseful\u201d (coherent) and 1=\u201cuseless\u201d (less coherent). They instructed the users that one indicator of usefulness is the ease by which one could think of a short label to describe a topic. Then several automatic measures, including WordNet-based measures and corpus co-occurrence measures, were compared. It was found that the best automatic measure having the largest correlation with human evaluation is word co-occurrence calculated as point-wise mutual information (PMI) on Wikipedia articles. Later Lau et al. BIBREF17 showed that normalized poinwise mutual information (NPMI) BIBREF18 calculated on Wikipedia articles correlates even more strongly with human scores.",
          "We calculate automatic topic coherence using two measure variants. The coherence of a topic is the median PMI (NPMI) of word pairs representing the topic, usually it is calculated for INLINEFORM0 most probable elements (in our study ten elements) in the topic. The coherence of the model is the median of the topic coherence. To make this measure more objective, it should be calculated on an external corpus BIBREF17 . In our case, we use Wikipedia dumps. DISPLAYFORM0 ",
          "Human-constructed topics usually have unique main words. The measure of kernel uniqueness shows to what extent topics are different from each other and is calculated as the number of unique elements among most probable elements of topics (kernels) in relation to the whole number of elements in kernels. DISPLAYFORM0 ",
          "If uniqueness of the topic kernels is closer to zero then many topics are similar to each other, contain the same words in their kernels. In this paper the kernel of a topic means the ten most probable words in the topic. We also calculated perplexity as the measure of language models. We use it for additional checking the model quality."
        ]
      },
      {
        "section_name": "Use of Automatic Measures to Assess Combined Models",
        "paragraphs": [
          "For evaluating topics with automatic quality measures, we used several English text collections and one Russian collection (Table TABREF7 ). We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 .",
          "At the preprocessing step, documents were processed by morphological analyzers. Also, we extracted noun groups as described in BIBREF16 . As baselines, we use the unigram LDA topic model and LDA topic model with added 1000 ngrams with maximal NC-value BIBREF20 extracted from the collection under analysis.",
          "As it was found before BIBREF14 , BIBREF16 , the addition of ngrams without accounting relations between their components considerably worsens the perplexity because of the vocabulary growth (for perplexity the less is the better) and practically does not change other automatic quality measures (Table 2).",
          "We add the Wordnet data in the following steps. At the first step, we include WordNet synonyms (including multiword expressions) into the proposed similarity sets (LDA-Sim+WNsyn). At this step, frequencies of synonyms found in the same document are summed up in process LDA topic learning as described in Algorithm SECREF3 . We can see that the kernel uniqueness becomes very low, topics are very close to each other in content (Table 2: LDA-Sim+WNsyn). At the second step, we add word direct relatives (hyponyms, hypernyms, etc.) to similarity sets. Now the frequencies of semantically related words are added up enhancing the contribution into all topics of the current document.",
          "The Table 2 shows that these two steps lead to great degradation of the topic model in most measures in comparison to the initial unigram model: uniqueness of kernels abruptly decreases, perplexity at the second step grows by several times (Table 2: LDA-Sim+WNsynrel). It is evident that at this step the model has a poor quality. When we look at the topics, the cause of the problem seems to be clear. We can see the overgeneralization of the obtained topics. The topics are built around very general words such as \"person\", \"organization\", \"year\", etc. These words were initially frequent in the collection and then received additional frequencies from their frequent synonyms and related words.",
          "Then we suppose that these general words were used in texts to discuss specific events and objects, therefore, we change the constructions of the similarity sets in the following way: we do not add word hyponyms to its similarity set. Thus, hyponyms, which are usually more specific and concrete, should obtain additional frequencies from upper synsets and increase their contributions into the document topics. But the frequencies and contribution of hypernyms into the topic of the document are not changed. And we see the great improvement of the model quality: the kernel uniqueness considerably improves, perplexity decreases to levels comparable with the unigram model, topic coherence characteristics also improve for most collections (Table 2:LDA-Sim+WNsynrel/hyp).",
          "We further use the WordNet-based similarity sets with n-grams having the same components as described in BIBREF16 . All measures significantly improve for all collections (Table 2:LDA-Sim+WNsr/hyp+Ngrams). At the last step, we try to apply the same approach to ngrams that was previously utilized to hyponym-hypernym relations: frequencies of shorter ngrams and words are summed to frequencies of longer ngrams but not vice versa. In this case we try to increase the contribution of more specific longer ngrams into topics. It can be seen (Table 2) that the kernel uniqueness grows significantly, at this step it is 1.3-1.6 times greater than for the baseline models achieving 0.76 on the ACL collection (Table 2:LDA-Sim+WNsr/hyp+Ngrams/l).",
          "At the second series of the experiments, we applied EuroVoc information retrieval thesaurus to two European Union collections: Europarl and JRC. In content, the EuroVoc thesaurus is much smaller than WordNet, it contains terms from economic and political domains and does not include general abstract words. The results are shown in Table 3. It can be seen that inclusion of EuroVoc synsets improves the topic coherence and increases kernel uniqueness (in contrast to results with WordNet). Adding ngrams further improves the topic coherence and kernel uniqueness.",
          "At last we experimented with the Russian banking collection and utilized RuThes thesaurus. In this case we obtained improvement already on RuThes synsets and again adding ngrams further improved topic coherence and kernel uniqueness (Table 4).",
          "It is worth noting that adding ngrams sometimes worsens the TC-NPMI measure, especially on the JRC collection. This is due to the fact that in these evaluation frameworks, the topics' top elements contain a lot of multiword expressions, which rarely occur in Wikipedia, used for the coherence calculation, therefore the utilized automatic coherence measures can have insufficient evidence for correct estimates."
        ]
      },
      {
        "section_name": "Manual Evaluation of Combined Topic Models",
        "paragraphs": [
          "To estimate the quality of topic models in a real task, we chose Islam informational portal \"Golos Islama\" (Islam Voice) (in Russian). This portal contains both news articles related to Islam and articles discussing Islam basics. We supposed that the thematic analysis of this specialized site can be significantly improved with domain-specific knowledge described in the thesaurus form. We extracted the site contents using Open Web Spider and obtained 26,839 pages.",
          "To combine knowledge with a topic model, we used RuThes thesaurus together with the additional block of the Islam thesaurus. The Islam thesaurus contains more than 5 thousand Islam-related terms including single words and expressions.",
          "For each combined model, we ran two experiments with 100 topics and with 200 topics. The generated topics were evaluated by two linguists, who had previously worked on the Islam thesaurus. The evaluation task was formulated as follows: the experts should read the top elements of the generated topics and try to formulate labels of these topics. The labels should be different for each topic in the set generated with a specific model. The experts should also assign scores to the topics' labels:",
          "Then we can sum up all the scores for each model under consideration and compare the total scores in value. Thus, maximum values of the topic score are 200 for a 100-topic model and 400 for a 200-topic model. In this experiment we do not measure inter-annotator agreement for each topic, but try to get expert's general impression.",
          "Due to the complicated character of the Islam portal contents for automatic extraction (numerous words and names difficult for Russian morphological analyzers), we did not use automatic extraction of multiword expressions and exploited only phrases described in RuThes or in the Islam Thesaurus. We added thesaurus phrases in two ways: most frequent 1000 phrases (as in BIBREF14 , BIBREF16 ) and phrases with frequency more than 10 (More10phrases): the number of such phrases is 9351.",
          "The results of the evaluation are shown in Table 5. The table contains the overall expert scores for a topic model (Score), kernel uniqueness as in the previous section (KernU), perplexity (Prpl). Also for each model kernels, we calculated the average number of known relations between topics\u2019s elements: thesaurus relations (synonyms and direct relations between concepts) and component-based relations between phrases (Relc).",
          "It can be seen that if we add phrases without accounting component similarity (Runs 2, 3), the quality of topics decreases: the more phrases are added, the more the quality degrades. The human scores also confirm this fact. But if the similarity between phrase components is considered then the quality of topics significantly improves and becomes better than for unigram models (Runs 4, 5). All measures are better. Relational coherence between kernel elements also grows. The number of added phrases is not very essential.",
          "Adding unary synonyms decreases the quality of the models (Run 6) according to human scores. But all other measures behave differently: kernel uniqueness is high, perplexity decreases, relational coherence grows. The problem of this model is in that non-topical, general words are grouped together, reinforce one another but do not look as related to any topic. Adding all thesaurus relations is not very beneficial (Runs 7, 8). If we consider all relations except hyponyms, the human scores are better for corresponding runs (Runs 9, 10). Relational coherence in topics\u2019 kernels achieves very high values: the quarter of all elements have some relations between each other, but it does not help to improve topics. The explanation is the same: general words can be grouped together.",
          "At last, we removed General Lexicon concepts from the RuThes data, which are top-level, non-thematic concepts that can be met in arbitrary domains BIBREF19 and considered all-relations and without-hyponyms variants (Runs 11, 12). These last variants achieved maximal human scores because they add thematic knowledge and avoid general knowledge, which can distort topics. Kernel uniqueness is also maximal.",
          "Table 6 shows similar topics obtained with the unigram, phrase-enriched (Run 5) and the thesaurus-enriched topic model (Run 12). The Run-5 model adds thesaurus phrases with frequency more than 10 and accounts for the component similarity between phrases. The Run-12 model accounts both component relations and hypernym thesaurus relations. All topics are of high quality, quite understandable. The experts evaluated them with the same high scores.",
          "Phrase-enriched and thesaurus-enriched topics convey the content using both single words and phrases. It can be seen that phrase-enriched topics contain more phrases. Sometimes the phrases can create not very convincing relations such as Russian church - Russian language. It is explainable but does not seem much topical in this case.",
          "The thesaurus topics seem to convey the contents in the most concentrated way. In the Syrian topic general word country is absent; instead of UN (United Nations), it contains word rebel, which is closer to the Syrian situation. In the Orthodox church topic, the unigram variant contains extra word year, relations of words Moscow and Kirill to other words in the topic can be inferred only from the encyclopedic knowledge."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper we presented the approach for introducing thesaurus information into topic models. The main idea of the approach is based on the assumption that if related words or phrases co-occur in the same text, their frequencies should be enhanced and this action leads to their mutual larger contribution into topics found in this text.",
          "In the experiments on four English collections, it was shown that the direct implementation of this idea using WordNet synonyms and/or direct relations leads to great degradation of the unigram model. But the correction of initial assumptions and excluding hyponyms from frequencies adding improve the model and makes it much better than the initial model in several measures. Adding ngrams in a similar manner further improves the model.",
          "Introducing information from domain-specific thesaurus EuroVoc led to improving the initial model without the additional assumption, which can be explained by the absence of general abstract words in such information-retrieval thesauri.",
          "We also considered thematic analysis of an Islam Internet site and evaluated the combined topic models manually. We found that the best, understandable topics are obtained by adding domain-specific thesaurus knowledge (domain terms, synonyms, and relations)."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which thesauri did they use?",
        "question_id": "e1ab241059ef1700738f885f051d724a7fcf283a",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "WordNet",
                "European Union EuroVoc",
                "RuThes"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For evaluating topics with automatic quality measures, we used several English text collections and one Russian collection (Table TABREF7 ). We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ],
              "highlighted_evidence": [
                "We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ]
            },
            "annotation_id": "08420993785e83068dbdfb0a25c2171224725b1c",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "WordNet",
                "EuroVoc",
                " RuThes"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For evaluating topics with automatic quality measures, we used several English text collections and one Russian collection (Table TABREF7 ). We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ],
              "highlighted_evidence": [
                " We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ]
            },
            "annotation_id": "563c9caee56077a0abaca8c6cf7641ed412b0ac2",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "WordNet ",
                "EuroVoc ",
                "RuThes "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For evaluating topics with automatic quality measures, we used several English text collections and one Russian collection (Table TABREF7 ). We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ],
              "highlighted_evidence": [
                "We experiment with three thesauri: WordNet (155 thousand entries), information-retrieval thesaurus of the European Union EuroVoc (15161 terms), and Russian thesaurus RuThes (115 thousand entries) BIBREF19 ."
              ]
            },
            "annotation_id": "a79209c610ba64924d36c1e5d1285043c72088e4",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1. Text collections for experiments"
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2. Integration of WordNet into topic models"
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3. Integration of EuroVoc into topic models"
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4. The results obtained for Russian Banking collection"
      },
      {
        "file": "9-Table5-1.png",
        "caption": "Table 5. Results of manual labeling of topic models for the Islam site"
      },
      {
        "file": "10-Table6-1.png",
        "caption": "Table 6. Comparison of similar topics in the unigram, phrase-based (Run 5) and the best thesaurus-enriched topic models (Run 12)."
      }
    ]
  },
  "1703.04009": {
    "title": "Automated Hate Speech Detection and the Problem of Offensive Language",
    "abstract": "A key challenge for automatic hate-speech detection on social media is the separation of hate speech from other instances of offensive language. Lexical detection methods tend to have low precision because they classify all messages containing particular terms as hate speech and previous work using supervised learning has failed to distinguish between the two categories. We used a crowd-sourced hate speech lexicon to collect tweets containing hate speech keywords. We use crowd-sourcing to label a sample of these tweets into three categories: those containing hate speech, only offensive language, and those with neither. We train a multi-class classifier to distinguish between these different categories. Close analysis of the predictions and the errors shows when we can reliably separate hate speech from other offensive language and when this differentiation is more difficult. We find that racist and homophobic tweets are more likely to be classified as hate speech but that sexist tweets are generally classified as offensive. Tweets without explicit hate keywords are also more difficult to classify.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "What constitutes hate speech and when does it differ from offensive language? No formal definition exists but there is a consensus that it is speech that targets disadvantaged social groups in a manner that is potentially harmful to them BIBREF0 , BIBREF1 . In the United States, hate speech is protected under the free speech provisions of the First Amendment, but it has been extensively debated in the legal sphere and with regards to speech codes on college campuses. In many countries, including the United Kingdom, Canada, and France, there are laws prohibiting hate speech, which tends to be defined as speech that targets minority groups in a way that could promote violence or social disorder. People convicted of using hate speech can often face large fines and even imprisonment. These laws extend to the internet and social media, leading many sites to create their own provisions against hate speech. Both Facebook and Twitter have responded to criticism for not doing enough to prevent hate speech on their sites by instituting policies to prohibit the use of their platforms for attacks on people based on characteristics like race, ethnicity, gender, and sexual orientation, or threats of violence towards others.",
          "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. In extreme cases this may also be language that threatens or incites violence, but limiting our definition only to such cases would exclude a large proportion of hate speech. Importantly, our definition does not include all instances of offensive language because people often use terms that are highly offensive to certain groups but in a qualitatively different manner. For example some African Americans often use the term n*gga in everyday language online BIBREF2 , people use terms like h*e and b*tch when quoting rap lyrics, and teenagers use homophobic slurs like f*g as they play video games. Such language is prevalent on social media BIBREF3 , making this boundary condition crucial for any usable hate speech detection system .",
          "Previous work on hate speech detection has identified this problem but many studies still tend to conflate hate speech and offensive language. In this paper we label tweets into three categories: hate speech, offensive language, or neither. We train a model to differentiate between these categories and then analyze the results in order to better understand how we can distinguish between them. Our results show that fine-grained labels can help in the task of hate speech detection and highlights some of the key challenges to accurate classification. We conclude that future work must better account for context and the heterogeneity in hate speech usage."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Bag-of-words approaches tend to have high recall but lead to high rates of false positives since the presence of offensive words can lead to the misclassification of tweets as hate speech BIBREF4 , BIBREF5 . Focusing on anti-black racism, BIBREF4 find that 86% of the time the reason a tweet was categorized as racist was because it contained offensive words. Given the relatively high prevalence of offensive language and curse words on social media this makes hate speech detection particularly challenging BIBREF3 . The difference between hate speech and other offensive language is often based upon subtle linguistic distinctions, for example tweets containing the word n*gger are more likely to be labeled as hate speech than n*gga BIBREF4 . Many can be ambiguous, for example the word gay can be used both pejoratively and in other contexts unrelated to hate speech BIBREF3 .",
          "Syntactic features have been leveraged to better identify the targets and intensity of hate speech, for example sentences where a relevant noun and verb occur (e.g. kill and Jews) BIBREF6 , the POS trigram DT jewish NN BIBREF2 , and the syntactic structure I <intensity > <user intent > <hate target >, e.g. I f*cking hate white people BIBREF7 .",
          "Other supervised approaches to hate speech classification have unfortunately conflated hate speech with offensive language, making it difficult to ascertain the extent to which they are really identifying hate speech BIBREF5 , BIBREF8 . Neural language models show promise in the task but existing work has used training data has a similarly broad definition of hate speech BIBREF9 . Non-linguistic features like the gender or ethnicity of the author can help improve hate speech classification but this information is often unavailable or unreliable on social media BIBREF8 ."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "We begin with a hate speech lexicon containing words and phrases identified by internet users as hate speech, compiled by Hatebase.org. Using the Twitter API we searched for tweets containing terms from the lexicon, resulting in a sample of tweets from 33,458 Twitter users. We extracted the time-line for each user, resulting in a set of 85.4 million tweets. From this corpus we then took a random sample of 25k tweets containing terms from the lexicon and had them manually coded by CrowdFlower (CF) workers. Workers were asked to label each tweet as one of three categories: hate speech, offensive but not hate speech, or neither offensive nor hate speech. They were provided with our definition along with a paragraph explaining it in further detail. Users were asked to think not just about the words appearing in a given tweet but about the context in which they were used. They were instructed that the presence of a particular word, however offensive, did not necessarily indicate a tweet is hate speech. Each tweet was coded by three or more people. The intercoder-agreement score provided by CF is 92%. We use the majority decision for each tweet to assign a label. Some tweets were not assigned labels as there was no majority class. This results in a sample of 24,802 labeled tweets.",
          "Only 5% of tweets were coded as hate speech by the majority of coders and only 1.3% were coded unanimously, demonstrating the imprecision of the Hatebase lexicon. This is much lower than a comparable study using Twitter, where 11.6% of tweets were flagged as hate speech BIBREF5 , likely because we use a stricter criteria for hate speech. The majority of the tweets were considered to be offensive language (76% at 2/3, 53% at 3/3) and the remainder were considered to be non-offensive (16.6% at 2/3, 11.8% at 3/3). We then constructed features from these tweets and used them to train a classifier."
        ]
      },
      {
        "section_name": "Features",
        "paragraphs": [
          "We lowercased each tweet and stemmed it using the Porter stemmer, then create bigram, unigram, and trigram features, each weighted by its TF-IDF. To capture information about the syntactic structure we use NLTK BIBREF10 to construct Penn Part-of-Speech (POS) tag unigrams, bigrams, and trigrams. To capture the quality of each tweet we use modified Flesch-Kincaid Grade Level and Flesch Reading Ease scores, where the number of sentences is fixed at one. We also use a sentiment lexicon designed for social media to assign sentiment scores to each tweet BIBREF11 . We also include binary and count indicators for hashtags, mentions, retweets, and URLs, as well as features for the number of characters, words, and syllables in each tweet."
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "We first use a logistic regression with L1 regularization to reduce the dimensionality of the data. We then test a variety of models that have been used in prior work: logistic regression, na\u00efve Bayes, decision trees, random forests, and linear SVMs. We tested each model using 5-fold cross validation, holding out 10% of the sample for evaluation to help prevent over-fitting. After using a grid-search to iterate over the models and parameters we find that the Logistic Regression and Linear SVM tended to perform significantly better than other models. We decided to use a logistic regression with L2 regularization for the final model as it more readily allows us to examine the predicted probabilities of class membership and has performed well in previous papers BIBREF5 , BIBREF8 . We trained the final model using the entire dataset and used it to predict the label for each tweet. We use a one-versus-rest framework where a separate classifier is trained for each class and the class label with the highest predicted probability across all classifiers is assigned to each tweet. All modeling was performing using scikit-learn BIBREF12 ."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "The best performing model has an overall precision 0.91, recall of 0.90, and F1 score of 0.90. Looking at Figure 1, however, we see that almost 40% of hate speech is misclassified: the precision and recall scores for the hate class are 0.44 and 0.61 respectively. Most of the misclassification occurs in the upper triangle of this matrix, suggesting that the model is biased towards classifying tweets as less hateful or offensive than the human coders. Far fewer tweets are classified as more offensive or hateful than their true category; approximately 5% of offensive and 2% of innocuous tweets have been erroneously classified as hate speech. To explore why these tweets have been misclassified we now look more closely at the tweets and their predicted classes.",
          "Tweets with the highest predicted probabilities of being hate speech tend to contain multiple racial or homophobic slurs, e.g. @JuanYeez shut yo beaner ass up sp*c and hop your f*ggot ass back across the border little n*gga and RT @eBeZa: Stupid f*cking n*gger LeBron. You flipping jungle bunny monkey f*ggot. Other tweets tend to be correctly identified as hate when they contained strongly racist or homophobic terms like n*gger and f*ggot. Interestingly, we also find cases where people use hate speech to respond to other hate speakers, such as this tweet where someone uses a homophobic slur to criticize someone else's racism: @MrMoonfrog @RacistNegro86 f*ck you, stupid ass coward b*tch f*ggot racist piece of sh*t.",
          "Turning to true hate speech classified as offensive it appears that tweets with the highest predicted probability of being offensive are genuinely less hateful and were perhaps mislabeled, for example When you realize how curiosity is a b*tch #CuriosityKilledMe may have been erroneously coded as hate speech if people thought that curiosity was a person, and Why no boycott of racist \"redskins\"? #Redskins #ChangeTheName contains a slur but is actually against racism. It is likely that coders skimmed these tweets too quickly, picking out words or phrases that appeared to be hateful without considering the context. Turning to borderline cases, where the probability of being offensive is marginally higher than hate speech, it appears that the majority are hate speech, both directed towards other Twitter users, @MDreyfus @NatFascist88 Sh*t your ass your moms p*ssy u Jew b*stard. Ur times coming. Heil Hitler! and general hateful statements like My advice of the day: If your a tranny...go f*ck your self!. These tweets fit our definition of hate speech but were likely misclassified because they do not contain any of the terms most strongly associated with hate speech. Finally, the hateful tweets incorrectly labeled as neither tend not to contain hate or curse words, for example If some one isn't an Anglo-Saxon Protestant, they have no right to be alive in the US. None at all, they are foreign filth contains a negative term, filth but no slur against a particular group. We also see that rarer types of hate speech, for example this anti-Chinese statement Every slant in #LA should be deported. Those scum have no right to be here. Chinatown should be bulldozed, are incorrectly classified. While the classifier performs well at prevalent forms of hate speech, particularly anti-black racism and homophobia, but is less reliable at detecting types of hate speech that occur infrequently, a problem noted by BIBREF13 ( BIBREF13 ).",
          "A key flaw in much previous work is that offensive language is mislabeled as hate speech due to an overly broad definition. Our multi-class framework allows us to minimize these errors; only 5% of our true offensive language was labeled as hate. The tweets correctly labeled as offensive tend to contain curse words and often sexist language, e.g. Why you worried bout that other h*e? Cuz that other h*e aint worried bout another h*e and I knew Kendrick Lamar was onto something when he said I call a b*tch a b*tch, a h*e a h*e, a woman a woman. Many of these tweets contain sexist terms like b*tch, p*ssy, and h*e. Human coders appear to consider racists or homophobic terms to be hateful but consider words that are sexist and derogatory towards women to be only offensive, consistent prior findings BIBREF8 .",
          "Looking at the tweets misclassified as hate speech we see that many contain multiple slurs, e.g. @SmogBaby: These h*es be lyin to all of us n*ggas and My n*gga mister meaner just hope back in the b*tch. While these tweets contain terms that can be considered racist and sexist it is apparent than many Twitter users use this type of language in their everyday communications. When they do contain racist language they tend to contain the term n*gga rather than n*gger, in line with the findings of BIBREF4 ( BIBREF4 ). We also found a few recurring phrases such as these h*es ain't loyal that were actually lyrics from rap songs that users were quoting. Classification of such tweets as hate speech leads us to overestimate the prevalence of the phenomenon. While our model still misclassifies some offensive language as hate speech we are able to avoid the vast majority of these errors by differentiating between the two.",
          "Finally, turning to the neither class, we see that tweets with the highest predicted probability of belonging to this class all appear to be innocuous and were included in the sample because they contained terms included in the Hatebase lexicon such as charlie and bird that are generally not used in a hateful manner. Tweets with overall positive sentiment and higher readability scores are more likely to belong to this class. The tweets in this category that have been misclassified as hate or offensive tend to mention race, sexuality, and other social categories that are targeted by hate speakers. Most appear to be misclassifications appear to be caused by on the presence of potentially offensive language, for example He's a damn good actor. As a gay man it's awesome to see an openly queer actor given the lead role for a major film contains the potentially the offensive terms gay and queer but uses them in a positive sense. This problem has been encountered in previous research BIBREF2 and illustrates the importance of taking context into account. We also found a small number of cases where the coders appear to have missed hate speech that was correctly identified by our model, e.g. @mayormcgunn @SenFeinstein White people need those weapons to defend themselves from the subhuman trash your sort unleashes on us. This finding is consistent with previous work that has found amateur coders to often be unreliable at identifying abusive content BIBREF13 , BIBREF14 ."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "If we conflate hate speech and offensive language then we erroneously consider many people to be hate speakers (errors in the lower triangle of Figure 1) and fail differentiate between commonplace offensive language and serious hate speech (errors in the upper triangle of Figure 1). Given the legal and moral implications of hate speech it is important that we are able to accurately distinguish between the two. Lexical methods are effective ways to identify potentially offensive terms but are inaccurate at identifying hate speech; only a small percentage of tweets flagged by the Hatebase lexicon were considered hate speech by human coders. While automated classification methods can achieve relatively high accuracy at differentiating between these different classes, close analysis of the results shows that the presence or absence of particular offensive or hateful terms can both help and hinder accurate classification.",
          "Consistent with previous work, we find that certain terms are particularly useful for distinguishing between hate speech and offensive language. While f*g, b*tch, and n*gga are used in both hate speech and offensive language, the terms f*ggot and n*gger are generally associated with hate speech. Many of the tweets considered most hateful contain multiple racial and homophobic slurs. While this allows us to easily identify some of the more egregious instances of hate speech it means that we are more likely to misclassify hate speech if it doesn't contain any curse words or offensive terms. To more accurately classify such cases we should find sources of training data that are hateful without necessarily using particular keywords or offensive language.",
          "Our results also illustrate how hate speech can be used in different ways: it can be directly send to a person or group of people targeted, it can be espoused to nobody in particular, and it can be used in conversation between people. Future work should distinguish between these different uses and look more closely at the social contexts and conversations in which hate speech occurs. We must also study more closely the people who use hate speech, focusing both on their individual characteristics and motivations and on the social structures they are embedded in.",
          "Hate speech is a difficult phenomenon to define and is not monolithic. Our classifications of hate speech tend to reflect our own subjective biases. People identify racist and homophobic slurs as hateful but tend to see sexist language as merely offensive. While our results show that people perform well at identifying some of the more egregious instances of hate speech, particularly anti-black racism and homophobia, it is important that we are cognizant of the social biases that enter into our algorithms and future work should aim to identify and correct these biases."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is their definition of hate speech?",
        "question_id": "a4b77a20e067789691e0ab246bc5b11913d77ae1",
        "nlp_background": "five",
        "topic_background": "research",
        "paper_read": "yes",
        "search_query": "Offensive language detection",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. In extreme cases this may also be language that threatens or incites violence, but limiting our definition only to such cases would exclude a large proportion of hate speech. Importantly, our definition does not include all instances of offensive language because people often use terms that are highly offensive to certain groups but in a qualitatively different manner. For example some African Americans often use the term n*gga in everyday language online BIBREF2 , people use terms like h*e and b*tch when quoting rap lyrics, and teenagers use homophobic slurs like f*g as they play video games. Such language is prevalent on social media BIBREF3 , making this boundary condition crucial for any usable hate speech detection system ."
              ],
              "highlighted_evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group."
              ]
            },
            "annotation_id": "25c1d626c5af8efbe83fdb95d72f4681508baa12",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. In extreme cases this may also be language that threatens or incites violence, but limiting our definition only to such cases would exclude a large proportion of hate speech. Importantly, our definition does not include all instances of offensive language because people often use terms that are highly offensive to certain groups but in a qualitatively different manner. For example some African Americans often use the term n*gga in everyday language online BIBREF2 , people use terms like h*e and b*tch when quoting rap lyrics, and teenagers use homophobic slurs like f*g as they play video games. Such language is prevalent on social media BIBREF3 , making this boundary condition crucial for any usable hate speech detection system ."
              ],
              "highlighted_evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group."
              ]
            },
            "annotation_id": "5a211d102cf9f618b294330b395cc59d937dfaa7",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group. In extreme cases this may also be language that threatens or incites violence, but limiting our definition only to such cases would exclude a large proportion of hate speech. Importantly, our definition does not include all instances of offensive language because people often use terms that are highly offensive to certain groups but in a qualitatively different manner. For example some African Americans often use the term n*gga in everyday language online BIBREF2 , people use terms like h*e and b*tch when quoting rap lyrics, and teenagers use homophobic slurs like f*g as they play video games. Such language is prevalent on social media BIBREF3 , making this boundary condition crucial for any usable hate speech detection system ."
              ],
              "highlighted_evidence": [
                "Drawing upon these definitions, we define hate speech as language that is used to expresses hatred towards a targeted group or is intended to be derogatory, to humiliate, or to insult the members of the group."
              ]
            },
            "annotation_id": "63eeeae80b446b0d1a3ae393b86fc6c53934995a",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: True versus predicted categories"
      }
    ]
  },
  "1911.03090": {
    "title": "What Would Elsa Do? Freezing Layers During Transformer Fine-Tuning",
    "abstract": "Pretrained transformer-based language models have achieved state of the art across countless tasks in natural language processing. These models are highly expressive, comprising at least a hundred million parameters and a dozen layers. Recent evidence suggests that only a few of the final layers need to be fine-tuned for high quality on downstream tasks. Naturally, a subsequent research question is, \"how many of the last layers do we need to fine-tune?\" In this paper, we precisely answer this question. We examine two recent pretrained language models, BERT and RoBERTa, across standard tasks in textual entailment, semantic similarity, sentiment analysis, and linguistic acceptability. We vary the number of final layers that are fine-tuned, then study the resulting change in task-specific effectiveness. We show that only a fourth of the final layers need to be fine-tuned to achieve 90% of the original quality. Surprisingly, we also find that fine-tuning all layers does not always help.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Transformer-based pretrained language models are a battle-tested solution to a plethora of natural language processing tasks. In this paradigm, a transformer-based language model is first trained on copious amounts of text, then fine-tuned on task-specific data. BERT BIBREF0, XLNet BIBREF1, and RoBERTa BIBREF2 are some of the most well-known ones, representing the current state of the art in natural language inference, question answering, and sentiment classification, to list a few. These models are extremely expressive, consisting of at least a hundred million parameters, a hundred attention heads, and a dozen layers.",
          "An emerging line of work questions the need for such a parameter-loaded model, especially on a single downstream task. BIBREF3, for example, note that only a few attention heads need to be retained in each layer for acceptable effectiveness. BIBREF4 find that, on many tasks, just the last few layers change the most after the fine-tuning process. We take these observations as evidence that only the last few layers necessarily need to be fine-tuned.",
          "The central objective of our paper is, then, to determine how many of the last layers actually need fine-tuning. Why is this an important subject of study? Pragmatically, a reasonable cutoff point saves computational memory across fine-tuning multiple tasks, which bolsters the effectiveness of existing parameter-saving methods BIBREF5. Pedagogically, understanding the relationship between the number of fine-tuned layers and the resulting model quality may guide future works in modeling.",
          "Our research contribution is a comprehensive evaluation, across multiple pretrained transformers and datasets, of the number of final layers needed for fine-tuning. We show that, on most tasks, we need to fine-tune only one fourth of the final layers to achieve within 10% parity with the full model. Surprisingly, on SST-2, a sentiment classification dataset, we find that not fine-tuning all of the layers leads to improved quality."
        ]
      },
      {
        "section_name": "Background and Related Work ::: Pretrained Language Models",
        "paragraphs": [
          "In the pretrained language modeling paradigm, a language model (LM) is trained on vast amounts of text, then fine-tuned on a specific downstream task. BIBREF6 are one of the first to successfully apply this idea, outperforming state of the art in question answering, textual entailment, and sentiment classification. Their model, dubbed ELMo, comprises a two-layer BiLSTM pretrained on the Billion Word Corpus BIBREF7.",
          "Furthering this approach with more data and improved modeling, BIBREF0 pretrain deep 12- and 24-layer bidirectional transformers BIBREF8 on the entirety of Wikipedia and BooksCorpus BIBREF9. Their approach, called BERT, achieves state of the art across all tasks in the General Language Understanding Evaluation (GLUE) benchmark BIBREF10, as well as the Stanford Question Answering Dataset (BIBREF11).",
          "As a result of this development, a flurry of recent papers has followed this more-data-plus-better-models principle. Two prominent examples include XLNet BIBREF1 and RoBERTa BIBREF2, both of which contest the present state of the art. XLNet proposes to pretrain two-stream attention-augmented transformers on an autoregressive LM objective, instead of the original cloze and next sentence prediction (NSP) tasks from BERT. RoBERTa primarily argues for pretraining longer, using more data, and removing the NSP task for BERT."
        ]
      },
      {
        "section_name": "Background and Related Work ::: Layerwise Interpretability",
        "paragraphs": [
          "The prevailing evidence in the neural network literature suggests that earlier layers extract universal features, while later ones perform task-specific modeling. BIBREF12 visualize the per-layer activations in image classification networks, finding that the first few layers function as corner and edge detectors, and the final layers as class-specific feature extractors. BIBREF13 demonstrate that the low- and high-level notions of content and style are separable in convolutional neural networks, with lower layers capturing content and higher layers style.",
          "Pretrained transformers. In the NLP literature, similar observations have been made for pretrained language models. BIBREF14 analyze BERT's attention and observe that the bottom layers attend broadly, while the top layers capture linguistic syntax. BIBREF4 find that the last few layers of BERT change the most after task-specific fine-tuning. Similar to our work, BIBREF5 fine-tune the top layers of BERT, as part of their baseline comparison for their model compression approach. However, none of the studies comprehensively examine the number of necessary final layers across multiple pretrained transformers and datasets."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "We conduct our experiments on NVIDIA Tesla V100 GPUs with CUDA v10.1. We run the models from the Transformers library (v2.1.1; BIBREF15) using PyTorch v1.2.0."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Models and Datasets",
        "paragraphs": [
          "We choose BERT BIBREF0 and RoBERTa BIBREF2 as the subjects of our study, since they represent state of the art and the same architecture. XLNet BIBREF1 is another alternative; however, they use a slightly different attention structure, and our preliminary experiments encountered difficulties in reproducibility with the Transformers library. Each model has base and large variants that contain 12 and 24 layers, respectively. We denote them by appending the variant name as a subscript to the model name.",
          "Within each variant, the two models display slight variability in parameter count\u2014110 and 125 million in the base variant, and 335 and 355 in the large one. These differences are mostly attributed to RoBERTa using many more embedding parameters\u2014exactly 63% more for both variants. For in-depth, layerwise statistics, see Table TABREF4.",
          "For our datasets, we use the GLUE benchmark, which comprises the tasks in natural language inference, sentiment classification, linguistic acceptability, and semantic similarity. Specifically, for natural language inference (NLI), it provides the Multigenre NLI (MNLI; BIBREF16), Question NLI (QNLI; BIBREF10), Recognizing Textual Entailment (RTE; BIBREF17), and Winograd NLI BIBREF18 datasets. For semantic textual similarity and paraphrasing, it contains the Microsoft Research Paraphrase Corpus (MRPC; BIBREF19), the Semantic Textual Similarity Benchmark (STS-B; BIBREF20), and Quora Question Pairs (QQP; BIBREF21). Finally, its single-sentence tasks consist of the binary-polarity Stanford Sentiment Treebank (SST-2; BIBREF22) and the Corpus of Linguistic Acceptability (CoLA; BIBREF23)."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Fine-Tuning Procedure",
        "paragraphs": [
          "Our fine-tuning procedure closely resembles those of BERT and RoBERTa. We choose the Adam optimizer BIBREF24 with a batch size of 16 and fine-tune BERT for 3 epochs and RoBERTa for 10, following the original papers. For hyperparameter tuning, the best learning rate is different for each task, and all of the original authors choose one between $1 \\times 10^{-5}$ and $5 \\times 10^{-5}$; thus, we perform line search over the interval with a step size of $1 \\times 10^{-5}$. We report the best results in Table TABREF5.",
          "On each model, we freeze the embeddings and the weights of the first $N$ layers, then fine-tune the rest using the best hyperparameters of the full model. Specifically, if $L$ is the number of layers, we explore $N = \\frac{L}{2}, \\frac{L}{2} + 1, \\dots , L$. Due to computational limitations, we set half as the cutoff point. Additionally, we restrict our comprehensive all-datasets exploration to the base variant of BERT, since the large model variants and RoBERTa are much more computationally intensive. On the smaller CoLA, SST-2, MRPC, and STS-B datasets, we comprehensively evaluate both models. These choices do not substantially affect our analysis."
        ]
      },
      {
        "section_name": "Analysis ::: Operating Points",
        "paragraphs": [
          "We report three relevant operating points in Tables TABREF6\u2013TABREF9: two extreme operating points and an intermediate one. The former is self-explanatory, indicating fine-tuning all or none of the nonoutput layers. The latter denotes the number of necessary layers for reaching at least 90% of the full model quality, excluding CoLA, which is an outlier.",
          "From the reported results in Tables TABREF6\u2013TABREF9, fine-tuning the last output layer and task-specific layers is insufficient for all tasks\u2014see the rows corresponding to 0, 12, and 24 frozen layers. However, we find that the first half of the model is unnecessary; the base models, for example, need fine-tuning of only 3\u20135 layers out of the 12 to reach 90% of the original quality\u2014see Table TABREF7, middle subrow of each row group. Similarly, fine-tuning only a fourth of the layers is sufficient for the large models (see Table TABREF9); only 6 layers out of 24 for BERT and 7 for RoBERTa."
        ]
      },
      {
        "section_name": "Analysis ::: Per-Layer Study",
        "paragraphs": [
          "In Figure FIGREF10, we examine how the relative quality changes with the number of frozen layers. To compute a relative score, we subtract each frozen model's results from its corresponding full model. The relative score aligns the two baselines at zero, allowing the fair comparison of the transformers. The graphs report the average of five trials to reduce the effects of outliers.",
          "When every component except the output layer and the task-specific layer is frozen, the fine-tuned model achieves only 64% of the original quality, on average. As more layers are fine-tuned, the model effectiveness often improves drastically\u2014see CoLA and STS-B, the first and fourth vertical pairs of subfigures from the left. This demonstrates that gains decompose nonadditively with respect to the number of frozen initial layers. Fine-tuning subsequent layers shows diminishing returns, with every model rapidly approaching the baseline quality at fine-tuning half of the network; hence, we believe that half is a reasonable cutoff point for characterizing the models.",
          "Finally, for the large variants of BERT and RoBERTa on SST-2 (second subfigure from both the top and the left), we observe a surprisingly consistent increase in quality when freezing 12\u201316 layers. This finding suggests that these models may be overparameterized for SST-2."
        ]
      },
      {
        "section_name": "Conclusions and Future Work",
        "paragraphs": [
          "In this paper, we present a comprehensive evaluation of the number of final layers that need to be fine-tuned for pretrained transformer-based language models. We find that only a fourth of the layers necessarily need to be fine-tuned to obtain 90% of the original quality. One line of future work is to conduct a similar, more fine-grained analysis on the contributions of the attention heads."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This research was supported by the Natural Sciences and Engineering Research Council (NSERC) of Canada, and enabled by computational resources provided by Compute Ontario and Compute Canada."
        ]
      }
    ],
    "qas": [
      {
        "question": "In what tasks does fine-tuning all layers hurt performance?",
        "question_id": "7c398615141ca416a32c9f72dbb785d3a6986a0f",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "Roberta",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SST-2"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Finally, for the large variants of BERT and RoBERTa on SST-2 (second subfigure from both the top and the left), we observe a surprisingly consistent increase in quality when freezing 12\u201316 layers. This finding suggests that these models may be overparameterized for SST-2."
              ],
              "highlighted_evidence": [
                "Finally, for the large variants of BERT and RoBERTa on SST-2 (second subfigure from both the top and the left), we observe a surprisingly consistent increase in quality when freezing 12\u201316 layers. "
              ]
            },
            "annotation_id": "0965c641c7eeb9f60ca3910da5095f6c3db84dd3",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "59b0ed8a4f50b62339d63ac766e6dfb915d12cfb",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SST-2"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our research contribution is a comprehensive evaluation, across multiple pretrained transformers and datasets, of the number of final layers needed for fine-tuning. We show that, on most tasks, we need to fine-tune only one fourth of the final layers to achieve within 10% parity with the full model. Surprisingly, on SST-2, a sentiment classification dataset, we find that not fine-tuning all of the layers leads to improved quality."
              ],
              "highlighted_evidence": [
                "Surprisingly, on SST-2, a sentiment classification dataset, we find that not fine-tuning all of the layers leads to improved quality."
              ]
            },
            "annotation_id": "d3b65d449f7112686f1cc2f8c00db60edecb75df",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Parameter statistics for the base and large variants of BERT and RoBERTa. Note that \u201cper-layer\u201d indicates the number of parameters in one intermediate layer, which is more relevant to our study."
      },
      {
        "file": "2-Table2-1.png",
        "caption": "Table 2: Reproduced results of BERT and RoBERTa on the development sets."
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Development set results of BERT, with none, some, and all of the nonoutput layer weights fine-tuned. Results are averaged across five runs."
      },
      {
        "file": "3-Table5-1.png",
        "caption": "Table 5: Development set results of all large models, with none, some, and all of the nonoutput layer weights fine-tuned. Results are averaged across five runs."
      },
      {
        "file": "3-Table4-1.png",
        "caption": "Table 4: Development set results of all base models, with none, some, and all of the nonoutput layer weights fine-tuned. Results are averaged across five runs."
      },
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: Relative change in quality compared to the full models, with respect to the number of frozen initial layers, represented by the x-axes."
      }
    ]
  },
  "1909.04242": {
    "title": "Mitigating Annotation Artifacts in Natural Language Inference Datasets to Improve Cross-dataset Generalization Ability",
    "abstract": "Natural language inference (NLI) aims at predicting the relationship between a given pair of premise and hypothesis. However, several works have found that there widely exists a bias pattern called annotation artifacts in NLI datasets, making it possible to identify the label only by looking at the hypothesis. This irregularity makes the evaluation results over-estimated and affects models' generalization ability. In this paper, we consider a more trust-worthy setting, i.e., cross-dataset evaluation. We explore the impacts of annotation artifacts in cross-dataset testing. Furthermore, we propose a training framework to mitigate the impacts of the bias pattern. Experimental results demonstrate that our methods can alleviate the negative effect of the artifacts and improve the generalization ability of models.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Natural language inference (NLI) is a widely-studied problem in natural language processing. It aims at comparing a pair of sentences (i.e. a premise and a hypothesis), and inferring the relationship between them (i.e., entailment, neutral and contradiction). Large-scaled datasets like SNLI BIBREF0 and MultiNLI BIBREF1 have been created by crowd-sourcing and fertilized NLI research substantially.",
          "However, several works BIBREF2, BIBREF3, BIBREF4 have pointed out that crowd-sourcing workers have brought a bias pattern named annotation artifacts in these NLI datasets. Such artifacts in hypotheses can reveal the labels and make it possible to predict the labels solely by looking at the hypotheses. For example, models trained on SNLI with only the hypotheses can achieve an accuracy of 67.0%, despite the always predicting the majority-class baseline is only 34.3% BIBREF2.",
          "Classifiers trained on NLI datasets are supposed to make predictions by understanding the semantic relationships between given sentence pairs. However, it is shown that models are unintentionally utilizing the annotation artifacts BIBREF4, BIBREF2. If the evaluation is conducted under a similar distribution as the training data, e.g., with the given testing set, models will enjoy additional advantages, making the evaluation results over-estimated. On the other hand, if the bias pattern cannot be generalized to the real-world, it may introduce noise to models, thus hurting the generalization ability.",
          "In this paper, we use cross-dataset testing to better assess models' generalization ability. We investigate the impacts of annotation artifacts in cross-dataset testing. Furthermore, we propose an easy-adopting debiasing training framework, which doesn't require any additional data or annotations, and apply it to the high-performing Densely Interactive Inference Network BIBREF5. Experiments show that our method can effectively mitigate the bias pattern and improve the cross-dataset generalization ability of models. To the best of our knowledge, our work is the first attempt to alleviate the annotation artifacts without any extra resources."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Frequently-used NLI datasets such as SNLI and MultiNLI are created by crowd-sourcing BIBREF0, BIBREF1, during which they present workers a premise and ask them to produce three hypotheses corresponding to labels. As BIBREF2 pointed out, workers may adopt some specific annotation strategies and heuristics when authoring hypotheses to save efforts, which produces certain patterns called annotation artifacts in the data. Models' trained on such datasets are heavily affected by the bias pattern BIBREF2.",
          "BIBREF4 further investigate models' robustness to the bias pattern using swapping operations. BIBREF6 demonstrate that the annotation artifacts widely exist among NLI datasets. They show that hypothesis-only-model, which refers to models trained and predict only with hypotheses, outperforms always predicting the majority-class in six of ten NLI datasets.",
          "The emergence of the pattern can be due to selection bias BIBREF7, BIBREF8, BIBREF9 in the datasets preparing procedure. Several works BIBREF10, BIBREF11 investigate the bias problem in relation inference datasest. BIBREF12 investigate the selection bias embodied in the comparing relationships in six natural language sentence matching datasets and propose a debiasing training and evaluation framework."
        ]
      },
      {
        "section_name": "Making Artifacts Unpredictable",
        "paragraphs": [
          "Essentially speaking, the problem of the bias pattern is that the artifacts in hypotheses are distributed differently among labels, so balancing them across labels may be a good solution to alleviate the impacts BIBREF2.",
          "Based on the idea proposed by BIBREF12, we demonstrate that we can make artifacts in biased datasets balanced across different classes by assigning specific weights for every sample. We refer the distribution of the acquired weighted dataset as artifact-balanced distribution. We consider a supervised NLI task, which is to predict the relationship label $y$ given a sentence pair $x$, and we denote the hypothesis in $x$ as $h$. Without loss of generality, we assume that the prior probability of different labels is equal, and then we have the following theorem.",
          "Theorem 1 For any classifier $f=f(x, h)$, and for any loss function $\\Delta (f(x, h), y)$, if we use $w = \\frac{1}{P(y|h)}$ as weight for every sample during training, it's equivalent to training with the artifact-balanced distribution.",
          "Detailed assumptions and the proof of the theorem is presented in Appendix SECREF6. With the theorem, we can simply use cross predictions to estimate $P(y|h)$ in origin datasets and use them as sample weights during training. The step-by-step procedure for artifact-balanced learning is presented in Algorithm 1.",
          "However, it is difficult to precisely estimate the probability $P(y|h)$. A minor error might lead to a significant difference to the weight, especially when the probability is close to zero. Thus, in practice, we use $w = \\frac{1}{(1-\\epsilon )P(y|h) + \\epsilon }$ as sample weights during training in order to improve the robustness. We can find that as $\\epsilon $ increases, the weights tend to be uniform, indicating that the debiasing effect decreases as the smooth term grows. Moreover, in order to keep the prior probability $P(Y)$ unchanged, we normalize the sum of weights of the three labels to the same."
        ]
      },
      {
        "section_name": "Experimental Results",
        "paragraphs": [
          "In this section, we present the experimental results for cross-dataset testing of artifacts and artifact-balanced learning. We show that cross-dataset testing is less affected by annotation artifacts, while there are still some influences more or less in different datasets. We also demonstrate that our proposed framework can mitigate the bias and improve the generalization ability of models."
        ]
      },
      {
        "section_name": "Experimental Results ::: Evaluation Scheme ::: Cross-dataset Testing",
        "paragraphs": [
          "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing.",
          "SNLI and MultiNLI are prepared by Human Elicited, in which workers are given a context and asked to produce hypotheses corresponding to labels. SICK and JOCI are created by Human Judged, referring that hypotheses and premises are automatically paired while labels are generated by humans BIBREF6. In order to maximumly mitigate the impacts of annotation artifacts during evaluations, we train and validate models respectively on SNLI and MultiNLI and test on both SICK and JOCI. We also report models' performances on SNLI and MultiNLI.",
          "As to SNLI, we use the same partition as BIBREF0. For MultiNLI, we separately use two origin validation sets (Matched and Mismatched) as the testing sets for convenience, and refer them as MMatch and MMismatch. We randomly select 10000 samples out of the origin training set for validation and use the rest for training. As to JOCI, we use the whole \u201cB\u201d subsets for testing, whose premises are from SNLI-train while hypotheses are generated based on world knowledge BIBREF13, and convert the score to NLI labels following BIBREF6. As to SICK, we use the whole dataset for testing."
        ]
      },
      {
        "section_name": "Experimental Results ::: Evaluation Scheme ::: Hard-Easy Testing",
        "paragraphs": [
          "To determine how biased the models are, we partition the testing set of SNLI and MMatch into two subsets: examples that the hypothesis-only model can be correctly classified as Easy and the rest as Hard as seen in BIBREF2. More detailed information is presented in Appendix SECREF14."
        ]
      },
      {
        "section_name": "Experimental Results ::: Experiment Setup",
        "paragraphs": [
          "We refer models trained only with hypotheses as hypothesis-only-model (Hyp), and models that utilize both premises and hypotheses as normal-model (Norm). We implement a simple LSTM model for Hyp and use DIIN BIBREF5 as Norm. We report AUC for Hyp and ACC for Norm. More details can be seen in Appendix SECREF15",
          "We estimate $P(y|h)$ for SNLI and MultiNLI respectively using BERT BIBREF15 with 10-fold predictions. To investigate the impacts of smooth terms, we choose a series of smooth values and present the results. Considering models may jiggle during the training phase due to the varied scale of weights, we sample examples with probabilities proportional to the weights for every mini-batch instead of adding weights to the loss directly.",
          "The evaluation results are reported in Table TABREF3."
        ]
      },
      {
        "section_name": "Experimental Results ::: Can Artifacts Generalize Across Datasets?",
        "paragraphs": [
          "Anotation Artifacts can be generalized across Human Elicited datasets. From the AUC of Hyp baseline trained with SNLI, we can see that the bias pattern of SNLI has a strong predictive ability in itself and the other two testing sets of Human Elicited. The behavior of those trained with MultiNLI is similar.",
          "Anotation Artifacts of SNLI and MultiNLI can be generalized to SICK. Unexpectedly, it is shown that Hyp baseline can get $0.6250$ (AUC) trained with SNLI and $0.6079$ (AUC) with MultiNLI when tested on SICK, indicating that the bias pattern of SNLI and MultiNLI are predictive on SICK. The results imply that the bias pattern can even be generalized across datasets prepared by different methods.",
          "Annotation Artifacts of SNLI are nearly neutral in JOCI, while MultiNLI is misleading. We find that AUC of Hyp baseline trained with SNLI is very close to $0.5$ on JOCI, indicating that JOCI is nearly neutral to artifacts in SNLI. However, when it comes to training with MultiNLI, the AUC of Hyp baseline is lower than $0.5$, indicating that the artifacts are misleading in JOCI."
        ]
      },
      {
        "section_name": "Experimental Results ::: Debiasing Results ::: Effectiveness of Debiasing",
        "paragraphs": [
          "Focusing on the results when smooth equals $0.01$ for SNLI and smooth equals $0.02$ for MultiNLI, we observe that the AUC of Hyp for all testing sets are approximately $0.5$, indicating Hyp's predictions are approximately equivalent to randomly guessing. Also, the gap between Hard and Easy for Norm significantly decreases comparing with the baseline. With the smooth, we can conclude that our method effectively alleviates the bias pattern.",
          "With other smooth terms, our method still has more or less debiasing abilities. In those testing sets which are not neutral to the bias pattern, the AUC of Hyp always come closer to $0.5$ comparing with the baseline with whatever smooth values. Performances of Norm on Hard and Easy also come closer comparing with the baseline. Norm trained with SNLI even exceed baseline in Hard with most smooth terms.",
          "From the results of Hyp, we can find a trend that the larger the smooth value is, the lower the level of debiasing is, while with a very small or even no smooth value, the AUC may be lower than $0.5$. As mentioned before, we owe this to the imperfect estimation of $P(y|h)$, and we can conclude that a proper smooth value is a prerequisite for the best debiasing effect."
        ]
      },
      {
        "section_name": "Experimental Results ::: Debiasing Results ::: Benefits of Debiasing",
        "paragraphs": [
          "Debiasing may improve models' generalization ability from two aspects: (1) Mitigate the misleading effect of annotation artifacts. (2) Improve models' semantic learning ability.",
          "When the annotation artifacts of the training set cannot be generalized to the testing set, which should be more common in the real-world, predicting by artifacts may hurt models' performance. Centering on the results of JOCI, in which the bias pattern of MultiNLI is misleading, we find that Norm trained with MultiNLI outperforms baseline after debiasing with all smooth values tested.",
          "Furthermore, debiasing can reduce models' dependence on the bias pattern during training, thus force models to better learn semantic information to make predictions. Norm trained with SNLI exceed baseline in JOCI with smooth terms $0.01$ and $0.1$. With larger smooth terms, Norm trained with both SNLI and MultiNLI exceeds baseline in SICK. Given the fact that JOCI is almost neutral to artifacts in SNLI, and the bias pattern of both SNLI and MultiNLI are even predictive in SICK, we owe these promotions to that our method improves models' semantic learning ability.",
          "As to other testing sets like SNLI, MMatch and MMismatch, we notice that the performance of Norm always decreases compared with the baseline. As mentioned before, both SNLI and MultiNLI are prepared by Huamn Elicited, and their artifacts can be generalized across each other. We owe the drop to that the detrimental effect of mitigating the predictable bias pattern exceeds the beneficial effect of the improvement of semantic learning ability."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we take a close look at the annotation artifacts in NLI datasets. We find that the bias pattern could be predictive or misleading in cross-dataset testing. Furthermore, we propose a debiasing framework and experiments demonstrate that it can effectively mitigate the impacts of the bias pattern and improve the cross-dataset generalization ability of models. However, it remains an open problem that how we should treat the annotation artifacts. We cannot assert whether the bias pattern should not exist at all or it is actually some kind of nature. We hope that our findings will encourage more explorations on reliable evaluation protocols for NLI models."
        ]
      },
      {
        "section_name": "Detailed Assumptions and Proof of Theorem @!START@UID1@!END@",
        "paragraphs": [
          "We make a few assumptions about an artifact-balanced distribution and how the biased datasets are generated from it, and demonstrate that we can train models fitting the artifact-balanced distribution using only the biased datasets.",
          "We consider the domain of the artifact-balanced distribution ${D}$ as $\\mathcal {X} \\times \\mathcal {A} \\times \\mathcal {Y} \\times \\mathcal {S}$, in which $\\mathcal {X}$ is the input variable space, $\\mathcal {Y}$ is the label space, $\\mathcal {A}$ is the feature space of annotation artifacts in hypotheses, $\\mathcal {S}$ is the selection intention space. We assume that the biased distribution $\\widehat{{D}}$ of origin datasets can be generated from the artifact-balanced distribution by selecting samples with $S = Y$, i.e., the selection intention matches with the label. We use $P(\\cdot )$ to represent the probability on $\\widehat{{D}}$ and use $Q(\\cdot )$ for ${D}$.",
          "We also make some assumptions about the artifact-balanced distribution. The first one is that the label is independent with the artifact in the hypothesis, defined as follows,",
          "The second one is that the selection intention is independent with $X$ and $Y$ when the annotation artifact is given,",
          "And we can prove the equivalence of training with weight $\\frac{1}{P(Y|A)}$ and fitting the artifact-balanced distribution. We first present an equation as follows,",
          "Without loss of generality, we can assume $Q(Y=i)=\\frac{1}{3}~(i=0,1,2)$ and get that,",
          "With the above derivation, we can prove the equivalence like following,",
          "As $Q(S=Y)$ is just a constant, training with the loss is equivalent to fitting the artifact-balanced distribution. Given hypotheses variable H, the probability $P(Y|A)$ can be replaced by $P(Y|H)$ since the predictive ability of hypotheses totally comes from the annotation artifacts, and we can have $w=\\frac{1}{P(Y|H)}$ as weights during training."
        ]
      },
      {
        "section_name": "Experiment Setting ::: Hard-Easy Datasets Setting",
        "paragraphs": [
          "For SNLI, we use Hard released by BIBREF2. For MMatch, we manually partition the set using fastText BIBREF18. And we summarize the size of the datasets used in Hard-Easy Testing below.",
          ""
        ]
      },
      {
        "section_name": "Experiment Setting ::: Experiment Setup",
        "paragraphs": [
          "For DIIN, we use settings same as BIBREF5 but do not use syntactical features. Priors of labels are normalized to be the same. For hypothesis-only-model, we implement a na\u00efve model with one LSTM layer and a three-layer MLP behind, implemented with Keras and Tensorflow backend BIBREF16. We use the 300-dimensional GloVe embeddings trained on the Common Crawl 840B tokens dataset BIBREF19 and keep them fixed during training. Batch Normalization BIBREF17 are applied after every hidden layer in MLP and we use Dropout BIBREF20 with rate 0.5 after the last hidden layer. We use RMSPropBIBREF21 as optimizer and set the learning rate as 1e-3. We set the gradient clipping to 1.0 and the batch size to 256."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which datasets do they use in the cross-dataset evaluation?",
        "question_id": "8b49423b7d1fa834128aa5038aa16c6ef3fdfa32",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "Inference",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SNLI",
                "MultiNLI",
                "JOCI",
                "SICK"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ],
              "highlighted_evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ]
            },
            "annotation_id": "6b8248c77ef112c7059a191c6e3a8c10ebd15329",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SNLI",
                "MultiNLI",
                "JOCI",
                "SICK"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ],
              "highlighted_evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ]
            },
            "annotation_id": "8f93e7dac49bbfcba496b5153ebd1bd22cd6079c",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SNLI BIBREF0",
                "MultiNLI BIBREF1",
                "JOCI BIBREF13",
                "SICK BIBREF14"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ],
              "highlighted_evidence": [
                "We utilize SNLI BIBREF0, MultiNLI BIBREF1, JOCI BIBREF13 and SICK BIBREF14 for cross-dataset testing."
              ]
            },
            "annotation_id": "f482f523a89c91c3431e60e9bb45729d2abb3877",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Evaluation Results of Hyp and Norm. Baseline refers to the model trained and validated without using weights. Hard, Easy refers to the Hard-Easy Testing generated from the testing set corresponding to the Trainset column. Results of Hyp are the average numbers of five runs with different random initialization. We report AUC for Hyp and ACC for Norm. \u201c*\u201d indicates where normal-model are better than the baseline."
      }
    ]
  },
  "2003.12139": {
    "title": "Integrating Crowdsourcing and Active Learning for Classification of Work-Life Events from Tweets",
    "abstract": "Social media, especially Twitter, is being increasingly used for research with predictive analytics. In social media studies, natural language processing (NLP) techniques are used in conjunction with expert-based, manual and qualitative analyses. However, social media data are unstructured and must undergo complex manipulation for research use. The manual annotation is the most resource and time-consuming process that multiple expert raters have to reach consensus on every item, but is essential to create gold-standard datasets for training NLP-based machine learning classifiers. To reduce the burden of the manual annotation, yet maintaining its reliability, we devised a crowdsourcing pipeline combined with active learning strategies. We demonstrated its effectiveness through a case study that identifies job loss events from individual tweets. We used Amazon Mechanical Turk platform to recruit annotators from the Internet and designed a number of quality control measures to assure annotation accuracy. We evaluated 4 different active learning strategies (i.e., least confident, entropy, vote entropy, and Kullback-Leibler divergence). The active learning strategies aim at reducing the number of tweets needed to reach a desired performance of automated classification. Results show that crowdsourcing is useful to create high-quality annotations and active learning helps in reducing the number of required tweets, although there was no substantial difference among the strategies tested.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Micro-blogging social media platforms have become very popular in recent years. One of the most popular platforms is Twitter, which allows users to broadcast short texts (i.e., 140 characters initially, and 280 characters in a recent platform update) in real time with almost no restrictions on content. Twitter is a source of people\u2019s attitudes, opinions, and thoughts toward the things that happen in their daily life. Twitter data are publicly accessible through Twitter application programming interface (API); and there are several tools to download and process these data. Twitter is being increasingly used as a valuable instrument for surveillance research and predictive analytics in many fields including epidemiology, psychology, and social sciences. For example, Bian et al. explored the relation between promotional information and laypeople\u2019s discussion on Twitter by using topic modeling and sentiment analysis BIBREF0. Zhao et al. assessed the mental health signals among sexual and gender minorities using Twitter data BIBREF1. Twitter data can be used to study and predict population-level targets, such as disease incidence BIBREF2, political trends BIBREF3, earthquake detection BIBREF4, and crime perdition BIBREF5, and individual-level outcomes or life events, such as job loss BIBREF6, depression BIBREF7, and adverse events BIBREF8. Since tweets are unstructured textual data, natural language processing (NLP) and machine learning, especially deep learning nowadays, are often used for preprocessing and analytics. However, for many studiesBIBREF9, BIBREF10, BIBREF11, especially those that analyze individual-level targets, manual annotations of several thousands of tweets, often by experts, is needed to create gold-standard training datasets, to be fed to the NLP and machine learning tools for subsequent, reliable automated processing of millions of tweets. Manual annotation is obviously labor intense and time consuming.",
          "Crowdsourcing can scale up manual labor by distributing tasks to a large set of workers working in parallel instead of a single people working serially BIBREF12. Commercial platforms such as Amazon\u2019s Mechanical Turk (MTurk, https://www.",
          "mturk.com/), make it easy to recruit a large crowd of people working remotely to perform time consuming manual tasks such as entity resolution BIBREF13, BIBREF14, image or sentiment annotation BIBREF15, BIBREF16. The annotation tasks published on MTurk can be done on a piecework basis and, given the very large pool of workers usually available (even by selecting a subset of those who have, say, a college degree), the tasks can be done almost immediately. However, any crowdsourcing service that solely relies on human workers will eventually be expensive when large datasets are needed, that is often the case when creating training datasets for NLP and deep learning tasks. Therefore, reducing the training dataset size (without losing performance and quality) would also improve efficiency while contain costs.",
          "Query optimization techniques (e.g., active learning) can reduce the number of tweets that need to be labeled, while yielding comparable performance for the downstream machine learning tasks BIBREF17, BIBREF18, BIBREF19. Active learning algorithms have been widely applied in various areas including NLP BIBREF20 and image processing BIBREF21. In a pool-based active learning scenario, data samples for training a machine learning algorithm (e.g., a classifier for identifying job loss events) are drawn from a pool of unlabeled data according to some forms of informativeness measure (a.k.a. active learning strategies BIBREF22), and then the most informative instances are selected to be annotated. For a classification task, in essence, an active learning strategy should be able to pick the \u201cbest\u201d samples to be labelled that will improve the classification performance the most.",
          "In this study, we integrated active learning into a crowdsourcing pipeline for the classification of life events based on individual tweets. We analyzed the quality of crowdsourcing annotations and then experimented with different machine/deep learning classifiers combined with different active learning strategies to answer the following two research questions (RQs):",
          "RQ1. How does (1) the amount of time that a human worker spends on and (2) the number of workers assigned to each annotation task impact the quality of an-notation results?",
          "RQ2. Which active learning strategy is most efficient and cost-effective to build event classification models using Twitter data?",
          "-5pt"
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "We first collected tweets based on a list of job loss-related keywords. We then randomly selected a set of sample tweets and had these tweets annotated (i.e., whether the tweet is a job loss event) using the Amazon MTurk platform. With these annotated tweets, we then evaluated 4 different active learning strategies (i.e., least confi-dent, entropy, vote entropy, and Kullback-Leibler (KL) divergence) through simulations."
        ]
      },
      {
        "section_name": "Methods ::: Data Collection",
        "paragraphs": [
          "Our data were collected from two data sources based on a list of job loss-related keywords. The keywords were developed using a snowball sampling process, where we started with an initial list of 8 keywords that indicates a job-loss event (e.g., \u201cgot fired\u201d and \u201clost my job\u201d). Using these keywords, we then queried (1) Twitter\u2019s own search engine (i.e., https://twitter.com/search-home?lang=en), and (2) a database of public random tweets that we have collected using the Twitter steaming application programming interface (API) from January 1, 2013 to December 30, 2017, to identify job loss-related tweets. We then manually reviewed a sample of randomly selected tweets to discover new job loss-related keywords. We repeated the search then review process iteratively until no new keywords were found. Through this process, we found 33 keywords from the historical random tweet database and 57 keywords through Twitter web search. We then (1) not only collected tweets based on the over-all of 68 unique keywords from the historical random tweet database, but also (2) crawled new Twitter data using Twitter search API from December 10, 2018 to December 26, 2018 (17 days)."
        ]
      },
      {
        "section_name": "Methods ::: Data Preprocessing",
        "paragraphs": [
          "We preprocessed the collected data to eliminate tweets that were (1) duplicated or (2) not written in English. For building classifiers, we preprocessed the tweets following the preprocessing steps used by GloVe BIBREF23 with minor modifications as follows: (1) all hashtags (e.g., \u201c#gotfired\u201d) were replaced with \u201c$<$hashtag$>$ PHRASE\u201d (e.g.,, \u201c$<$hashtag$>$ gotfired\u201d); (2) user mentions (e.g., \u201c$@$Rob_Bradley\u201d) were replaced with \u201c$<$user$>$\u201d; (3) web links (eg, \u201chttps://t.co/",
          "fMmFWAHEuM\u201d) were replaced with \u201c$<$url$>$\u201d; and (4) all emojis were replaced with \u201c$<$emoji$>$.\u201d"
        ]
      },
      {
        "section_name": "Methods ::: Classifier Selection",
        "paragraphs": [
          "Machine learning and deep learning have been wildly used in classification of tweets tasks. We evaluated 8 different classifiers: 4 traditional machine learning models (i.e., logistic regress [LR], Na\u00efve Bayes [NB], random forest [RF], and support vector machine [SVM]) and 4 deep learning models (i.e., convolutional neural network [CNN], recurrent neural network [RNN], long short-term memory [LSTM] RNN, and gated recurrent unit [GRU] RNN). 3,000 tweets out of 7,220 Amazon MTurk annotated dataset was used for classifier training (n = 2,000) and testing (n = 1,000). The rest of MTurk annotated dataset were used for the subsequent active learning experiments. Each classifier was trained 10 times and 95 confidence intervals (CI) for mean value were reported. We explored two language models as the features for the classifiers (i.e., n-gram and word-embedding). All the machine learning classifiers were developed with n-gram features; while we used both n-gram and word-embedding features on the CNN classifier to test which feature set is more suitable for deep learning classifiers. CNN classifier with word embedding features had a better performance which is consistent with other studies BIBREF24, BIBREF25 We then selected one machine learning and one deep learning classifiers based on the prediction performance (i.e., F-score). Logistic regression was used as the baseline classifier."
        ]
      },
      {
        "section_name": "Methods ::: Pool-based Active Learning",
        "paragraphs": [
          "In pool-based sampling for active learning, instances are drawn from a pool of samples according to some sort of informativeness measure, and then the most informative instances are selected to be annotated. This is the most common scenario in active learning studies BIBREF26. The informativeness measures of the pool instances are called active learning strategies (or query strategies). We evaluated 4 active learning strategies (i.e., least confident, entropy, vote entropy and KL divergence). Fig 1.C shows the workflow of our pool-based active learning experiments: for a given active learning strategy and classifiers trained with an initial set of training data (1) the classifiers make predictions of the remaining to-be-labelled dataset; (2) a set of samples is selected using the specific active learning strategy and annotated by human reviewers; (3) the classifiers are retrained with the newly annotated set of tweets. We repeated this process iteratively until the pool of data exhausts. For the least confident and entropy active learning strategies, we used the best performed machine learn-ing classifier and the best performed deep learning classifier plus the baseline classifier (LR). Note that vote entropy and KL divergence are query-by-committee strategies, which were tested upon three deep learning classifiers (i.e., CNN, RNN and LSTM) and three machine learning classifiers (i.e., LR, RF, and SVM) as two separate committees, respectively."
        ]
      },
      {
        "section_name": "Results ::: Data Collection",
        "paragraphs": [
          "Our data came from two different sources as shown in Table 1. First, we collected 2,803,164 tweets using the Twitter search API BIBREF27 from December 10, 2018 to December 26, 2018 base on a list of job loss-related keywords (n = 68). After filtering out duplicates and non-English tweets, 1,952,079 tweets were left. Second, we used the same list of keywords to identify relevant tweets from a database of historical random public tweets we collected from January 1, 2013 to December 30, 2017. We found 1,733,905 relevant tweets from this database. Due to the different mechanisms behind the two Twitter APIs (i.e., streaming API vs. search API), the volumes of the tweets from the two data sources were significantly different. For the Twitter search API, users can retrieve most of the public tweets related to the provided keywords within 10 to 14 days before the time of data collection; while the Twitter streaming API returns a random sample (i.e., roughly 1% to 20% varying across the years) of all public tweets at the time and covers a wide range of topics. After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
        ]
      },
      {
        "section_name": "Results ::: RQ1. How does (1) the amount of time that a human worker spends on and (2) the number of workers assigned to each annotation task impact the quality of annotation results?",
        "paragraphs": [
          "We randomly selected 7,220 tweets from our Twitter data based on keyword distributions and had those tweets annotated using workers recruited through Amazon MTurk. Each tweet was also annotated by an expert annotator (i.e., one of the authors). We treated the consensus answer of the crowdsourcing workers (i.e., at least 5 annotators for each tweet assignment) and the expert annotator as the gold-standard. Using control tweets is a common strategy to identify workers who cheat (e.g., randomly select an answer without reading the instructions and/or tweets) on annotation tasks. We introduced two control tweets in each annotation assignment, where each annotation assignment contains a total of 12 tweets (including the 2 control tweets). Only responses with the two control tweets answered corrected were considered valid responses and the worker would receive the 10 cents incentive.",
          "The amount of time that a worker spends on a task is another factor associated with annotation quality. We measured the time that one spent on clicking through the annotation task without thinking about the content and repeated the experiment five times. The mean amount time spent on the task is 57.01 (95% CI [47.19, 66.43]) seconds. Thus, responses with less than 47 seconds were considered invalid regardless how the control tweets were answered.",
          "We then did two experiments to explore the relation between the amount of time that workers spend on annotation tasks and annotation quality. Fig 2. A. shows annotation quality by selecting different amounts of lower cut-off time (i.e., only considering assignments where workers spent more time than the cut-off time as valid responses), which tests whether the annotation is of low quality when workers spent more time on the task. The performance of the crowdsourcing workers was measured by the agreement (i.e., Cohan\u2019s kappa) between labels from each crowdsourcing worker and the gold-standard labels. Fig 2. B. shows annotation quality by selecting different upper cut-off time (i.e., keep assignments whose time consumption were less than the cut-off time), which tests whether the annotation is of low quality when workers spent less time on the task. As shown in Fig. 2. A and B, it does not affect the annotation quality when a worker spent more time on the task; while, the annota-ion quality is significantly lower if the worker spent less than 90 seconds on the task.",
          "We also tested the annotation reliability (i.e., Fleiss\u2019 Kappa score) between using 3 workers vs. using 5 workers. The Fleiss\u2019 kappa score of 3 workers is 0.53 (95% CI [0.46, 0.61]. The Fleiss\u2019 kappa score of 5 workers is 0.56 (95% CI [0.51, 0.61]. Thus, using 3 workers vs. 5 workers does not make any difference on the annotation reliability, while it is obviously cheaper to use only 3 workers."
        ]
      },
      {
        "section_name": "Results ::: RQ2. Which active learning strategy is most efficient and cost-effective to build event classification models using Twitter data?",
        "paragraphs": [
          "We randomly selected 3,000 tweets from the 7,220 MTurk annotated dataset to build the initial classifiers. Two thousands out of 3,000 tweets were used to train the clas-sifiers and the rest 1,000 tweets were used as independent test dataset to benchmark their performance. We explored 4 machine learning classifiers (i.e., Logistic Regression [LR], Na\u00efve Bayes [NB], Random Forest [RF], and Support Vector Machine [SVM]) and 4 deep learning classifiers (i.e., Convolutional Neural Network [CNN], Recurrent Neural Network [RNN], Long Short-Term Memory [LSTM], and Gated Recurrent Unit [GRU]). Each classifier was trained 10 times. The performance was measured in terms of precision, recall, and F-score. 95% confidence intervals (CIs) of the mean F-score across the ten runs were also reported. Table 2 shows the perfor-mance of classifiers. We chose logistic regression as the baseline model. RF and CNN were chosen for subsequent active learning experiments, since they outperformed other machine learning and deep learning classifiers.",
          "We implemented a pool-based active learning pipeline to test which classifier and active learning strategy is most efficient to build up an event classification classifier of Twitter data. We queried the top 300 most \u201cinformative\u201d tweets from the rest of the pool (i.e., excluding the tweets used for training the classifiers) at each iteration. Table 3 shows the active learning and classifier combinations that we evaluated. The performance of the classifiers was measured by F-score. Fig 3 shows the results of the different active learning strategies combined with LR (i.e., the baseline), RF (i.e., the best performed machine learning model), and CNN (i.e., the best performed deep learning model). For both machine learning models (i.e., LR and RF), using the entropy strategy can reach the optimal performance the quickest (i.e., the least amount of tweets). While, the least confident algorithm does not have any clear advantages compared with random selection. For deep learning model (i.e., CNN), none of the active learning strategies tested are useful to improve the CNN classifier\u2019s performance. Fig 4 shows the results of query-by-committee algorithms (i.e., vote entropy and KL divergence) combined with machine learning and deep learning ensemble classifiers. Query-by-committee algorithms are slightly better than random selection when it applied to machine learning ensemble classifier. However, query-by-committee algorithms are not useful for the deep learning ensemble classifier."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "The goal of our study was to test the feasibility of building classifiers by using crowdsourcing and active learning strategies. We had 7,220 sample job loss-related tweets annotated using Amazon MTurk, tested 8 classification models, and evaluated 4 active learning strategies to answer our two RQs.",
          "The key benefit of crowdsourcing is to have a large number of workers available to carry out tasks on a piecework basis. This means that it is likely to get the crowd to start work on tasks almost immediately and be able to have a large number of tasks completed quickly. However, even welltrained workers are only human and can make mistakes. Our first RQ was to find an optimal and economical way to get reliable annotations from crowdsourcing. Beyond using control tweets, we tested different cut-off time to assess how the amount of time workers spent on the task would affect annotation quality. We found that the annotation quality is low if the tasks were finished within 90 seconds. We also found that the annotation quality is not affected by the number of workers (i.e., between 3 worker group vs 5 worker group), which was also demonstrated by Mozafari et al BIBREF28.",
          "In second RQ, we aimed to find which active learning strategy is most efficient and cost-effective to build event classification models using Twitter data. We started with selecting representative machine learning and deep learning classifiers. Among the 4 machine learning classifiers (i.e., LR, NB, RF, and SVM), LR and RF classifiers have the best performance on the task of identifying job loss events from tweets. Among the 4 deep learning methods (i.e., CNN, RNN, LSTM, LSTM with GRU), CNN has the best performance.",
          "In active learning, the learning algorithm is set to proactively select a subset of available examples to be manually labeled next from a pool of yet unlabeled instances. The fundamental idea behind the concept is that a machine learning algorithm could potentially achieve a better accuracy quicker and using fewer training data if it were allowed to choose the most informative data it wants to learn from. In our experiment, we found that the entropy algorithm is the best way to build machine learning models fast and efficiently. Vote entropy and KL divergence, the query-by-committee active learning methods are helpful for the training of machine learning ensemble classifiers. However, all the active learning strategies we tested do not work well with deep learning model (i.e., CNN) or deep learning-based ensemble classifier.",
          "We also recognize the limitations of our study. First, we only tested 5 classifiers (i.e., LR, RF, CNN, a machine learning ensemble classifier, and a deep learning classifier) and 4 active learning strategies (i.e., least confident, entropy, vote entropy, KL divergence). Other state-of-art methods for building tweet classifiers (e.g., BERT BIBREF29) and other active learning strategies (e.g., variance reduction BIBREF30) are worth exploring. Second, other crowdsourcing quality control methods such as using prequalification questions to identify high-quality workers also warrant further investigations. Third, the crowdsourcing and active learning pipeline can potentially be applied to other data and tasks. However, more experiments are needed to test the fea-sibility. Fourth, the current study only focused on which active learning strategy is most efficient and cost-effective to build event classification models using crowdsourcing labels. Other research questions such as how the correctness of the crowdsourced labels would impact classifier performance warrant future investigations.",
          "In sum, our study demonstrated that crowdsourcing with active learning is a possible way to build up machine learning classifiers efficiently. However, active learning strategies do not benefit deep learning classifiers in our study."
        ]
      },
      {
        "section_name": "Acknowledgement",
        "paragraphs": [
          "This study was supported by NSF Award #1734134."
        ]
      }
    ],
    "qas": [
      {
        "question": "How large is their tweets dataset?",
        "question_id": "471683ba6251b631f38a24d42b6dba6f52dee429",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "3,685,984 unique tweets"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our data came from two different sources as shown in Table 1. First, we collected 2,803,164 tweets using the Twitter search API BIBREF27 from December 10, 2018 to December 26, 2018 base on a list of job loss-related keywords (n = 68). After filtering out duplicates and non-English tweets, 1,952,079 tweets were left. Second, we used the same list of keywords to identify relevant tweets from a database of historical random public tweets we collected from January 1, 2013 to December 30, 2017. We found 1,733,905 relevant tweets from this database. Due to the different mechanisms behind the two Twitter APIs (i.e., streaming API vs. search API), the volumes of the tweets from the two data sources were significantly different. For the Twitter search API, users can retrieve most of the public tweets related to the provided keywords within 10 to 14 days before the time of data collection; while the Twitter streaming API returns a random sample (i.e., roughly 1% to 20% varying across the years) of all public tweets at the time and covers a wide range of topics. After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ],
              "highlighted_evidence": [
                "After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ]
            },
            "annotation_id": "24624499c37d589a53a3bee8244f0dbddc8c97e7",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "3,685,984 unique tweets"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our data came from two different sources as shown in Table 1. First, we collected 2,803,164 tweets using the Twitter search API BIBREF27 from December 10, 2018 to December 26, 2018 base on a list of job loss-related keywords (n = 68). After filtering out duplicates and non-English tweets, 1,952,079 tweets were left. Second, we used the same list of keywords to identify relevant tweets from a database of historical random public tweets we collected from January 1, 2013 to December 30, 2017. We found 1,733,905 relevant tweets from this database. Due to the different mechanisms behind the two Twitter APIs (i.e., streaming API vs. search API), the volumes of the tweets from the two data sources were significantly different. For the Twitter search API, users can retrieve most of the public tweets related to the provided keywords within 10 to 14 days before the time of data collection; while the Twitter streaming API returns a random sample (i.e., roughly 1% to 20% varying across the years) of all public tweets at the time and covers a wide range of topics. After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ],
              "highlighted_evidence": [
                " After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ]
            },
            "annotation_id": "ac69143002e1e7f723716d2ef207fe67c816e207",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "3,685,984 unique tweets"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our data came from two different sources as shown in Table 1. First, we collected 2,803,164 tweets using the Twitter search API BIBREF27 from December 10, 2018 to December 26, 2018 base on a list of job loss-related keywords (n = 68). After filtering out duplicates and non-English tweets, 1,952,079 tweets were left. Second, we used the same list of keywords to identify relevant tweets from a database of historical random public tweets we collected from January 1, 2013 to December 30, 2017. We found 1,733,905 relevant tweets from this database. Due to the different mechanisms behind the two Twitter APIs (i.e., streaming API vs. search API), the volumes of the tweets from the two data sources were significantly different. For the Twitter search API, users can retrieve most of the public tweets related to the provided keywords within 10 to 14 days before the time of data collection; while the Twitter streaming API returns a random sample (i.e., roughly 1% to 20% varying across the years) of all public tweets at the time and covers a wide range of topics. After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ],
              "highlighted_evidence": [
                "After integrating the tweets from the two data sources, there were 3,685,984 unique tweets."
              ]
            },
            "annotation_id": "f801ba29937f463fb05398e019f4972b988be729",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Fig. 1: The workflow of our Twitter analysis pipeline."
      },
      {
        "file": "7-Figure2-1.png",
        "caption": "Fig. 2: Annotation quality by selecting different cut-off time."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: The performance of machine learning and deep learning classifiers."
      },
      {
        "file": "8-Figure3-1.png",
        "caption": "Fig. 3: The performance of active learning strategies combined with linear regression, random forest, and convolutional neural network."
      },
      {
        "file": "9-Figure4-1.png",
        "caption": "Fig. 4: The performance of active learning strategies combined with machine learning and deep learning ensemble classifiers."
      }
    ]
  },
  "1809.03391": {
    "title": "Toward a Standardized and More Accurate Indonesian Part-of-Speech Tagging",
    "abstract": "Previous work in Indonesian part-of-speech (POS) tagging are hard to compare as they are not evaluated on a common dataset. Furthermore, in spite of the success of neural network models for English POS tagging, they are rarely explored for Indonesian. In this paper, we explored various techniques for Indonesian POS tagging, including rule-based, CRF, and neural network-based models. We evaluated our models on the IDN Tagged Corpus. A new state-of-the-art of 97.47 F1 score is achieved with a recurrent neural network. To provide a standard for future work, we release the dataset split that we used publicly.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Part-of-speech (POS) tagging is a process to tag tokens in a string with their corresponding part-of-speech (e.g., noun, verb, etc). POS tagging is considered as one of the most basic tasks in NLP, as it is usually the first component in an NLP pipeline. This is because POS tags are shown to be useful features in various NLP tasks, such as named entity recognition BIBREF0 , BIBREF1 , machine translation BIBREF2 , BIBREF3 and constituency parsing BIBREF4 . Therefore, for any language, building a successful NLP system usually requires a well-performing POS tagger.",
          "There are quite a number of research on Indonesian POS tagging BIBREF5 , BIBREF6 , BIBREF7 , BIBREF8 . However, almost all of them are not evaluated on a common dataset. Even when they are, their train-test split are not the same. This lack of a common benchmark dataset makes a fair comparison among these works difficult. Moreover, despite the success of neural network models for English POS tagging BIBREF9 , BIBREF10 , the use of neural networks is generally unexplored for Indonesian. As a result, published results may not reflect the actual state-of-the-art performance of Indonesian POS tagger.",
          "In this work, we explored different neural network architectures for Indonesian POS tagging. We evaluated our experiments on the IDN Tagged Corpus BIBREF11 . Our best model achieves 97.47 INLINEFORM0 score, a new state-of-the-art result for Indonesian POS tagging on the dataset. We release the dataset split that we used to serve as a benchmark for future work."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Pisceldo et al. BIBREF5 built an Indonesian POS tagger by employing a conditional random field (CRF) BIBREF12 and a maximum entropy model. They used contextual unigram and bigram features and achieved accuracy scores of 80-90% on PANL10N dataset tagged manually using their proposed tagset. The dataset consists of 15K sentences. Another work used a hidden Markov model enhanced with an affix tree to better handle out-of-vocabulary (OOV) words BIBREF6 . They evaluated their models on the same PANL10N dataset and achieved more than 90% overall accuracy and roughly 70% accuracy for the OOV cases. We note that while the datasets are the same, the split could be different. Thus, making a fair comparison between them is difficult.",
          "Dinakaramani et al. BIBREF11 proposed IDN Tagged Corpus, a new manually annotated POS tagging corpus for Indonesian. The corpus consists of 10K sentences and 250K tokens, and its tagset is different than that of the PANL10N dataset. The corpus is available online. A rule-based tagger is developed in BIBREF7 using the aformentioned dataset, and is able to achieve an accuracy of 80%.",
          "One of the neural network-based POS taggers for Indonesian is proposed in BIBREF8 . They used a feedforward neural network with an architecture similar to that proposed in BIBREF13 . They evaluated their methods on the new POS tagging corpus BIBREF11 and separated the evaluation of multi- and single-word expressions. They experimented with several word embedding algorithms trained on Indonesian Wikipedia data and reported macro-averaged INLINEFORM0 score of 91 and 73 for the single- and multi-word expression cases respectively. We remark that the choice of macro-averaged INLINEFORM1 score is more suitable than accuracy for POS tagging because of the class imbalance in the dataset. There are too many words with NN as the true POS tag, so accuracy is not the best metric in such case."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "We used the IDN Tagged Corpus proposed in BIBREF11 . The corpus contains 10K sentences and 250K tokens that are tagged manually. Due to the small size, we used 5-fold cross-validation to split the corpus into training, development, and test sets. We did not split multi-word expressions but treated them as if they are a single token. All 5 folds of the dataset are available publicly to serve as a benchmark for future work."
        ]
      },
      {
        "section_name": "Baselines",
        "paragraphs": [
          "We used two simple baselines: majority tag (Major) and memorization (Memo). Major simply predicts the majority POS tag found in the training set for all words. Memo remembers the word-tag assignments from the training set and uses them to predict the tags on the test set. If there is an unknown word, it simply outputs the majority tag found in the training set."
        ]
      },
      {
        "section_name": "Comparisons",
        "paragraphs": [
          "We adopted a rule-based tagger designed by Rashel et al. BIBREF14 as one of our comparisons. Firstly, the tagger tags named entities and multi-word expressions based on a dictionary. Then, it uses MorphInd BIBREF15 to tag the rest of the words. Finally, they employ 15 hand-crafted rules to resolve ambiguous tags in the post-processing step. We want to note that we did not use their provided tokenizer since the IDN Tagged Corpus dataset is already tokenized. Their implementation is available online.",
          "We used CRF BIBREF12 as another comparison since it is the most common non-neural model for sequence labeling tasks. We employed contextual words as well as affixes as features. For some context window size INLINEFORM0 , the complete list of features is:",
          "the current word, as well as INLINEFORM0 preceding and succeeding words;",
          "two and three leading characters of the current word and INLINEFORM0 preceding and succeeding words;",
          "two and three trailing characters of the current word and INLINEFORM0 preceding and succeeding words.",
          "The last two features are meant to capture prefixes and suffixes in Indonesian which usually consist of two or three characters. One advantage of this feature extraction approach is that it does not require language-specific tools such as stemmer or morphological segmenter. This advantage is particularly useful for Indonesian which does not have well-established tools for such purposes. We padded the input sentence with padding tokens to ensure that every token has enough preceding and succeeding words for context window size INLINEFORM0 . For the implementation, we used pycrfsuite.",
          "Our neural network-based POS tagger can be divided into 3 steps: embedding, encoding, and prediction. First, the tagger embeds the words and optionally additional features of such words (e.g., affixes). From this embedding process, we get vector representations of the words and the features. Next, the tagger learns contextual information in the encoding step via either a feedforward network with context window or a bidirectional LSTM BIBREF16 . Finally, in prediction step, the tagger predicts the POS tags from the output of the encoding step using either a softmax or a CRF layer.",
          "Embedding. In the embedding step, the tagger obtains vector representations of each word and additional features. We experimented with several additional features: prefixes, suffixes, and characters. Prefix features are the first 2 and 3 characters of the word. Likewise, suffix features are the last 2 and 3 characters of the word. For the character features, we followed BIBREF9 by embedding each character and composing the resulting vectors with a max-pooled CNN. The final embedding of a word is then the concatenation of all these vectors. Fig. FIGREF17 shows an illustration of the process.",
          "Encoding. In the encoding step, the tagger learns contextual information by using either a feedforward network with context window or a bidirectional LSTM (biLSTM). The feedforward network accepts as input the concatenation of the embedding of the current word and INLINEFORM0 preceding and succeeding words for some context window size INLINEFORM1 . Formally, given a sequence of word embedding INLINEFORM2 , the input of the feedforward network at timestep INLINEFORM3 is DISPLAYFORM0 ",
          "where INLINEFORM0 denotes a concatenation. The feedforward network then computes DISPLAYFORM0 ",
          " where INLINEFORM0 is the output vector, INLINEFORM1 is a dropout mask vector, and INLINEFORM2 are parameters. The output vector INLINEFORM3 has length equal to the number of possible tags. Its INLINEFORM4 -th component defines the (unnormalized) log probability of the INLINEFORM5 -th word having tag INLINEFORM6 .",
          "On the other hand, the biLSTM accepts as input the sequence of word embeddings, and for each timestep, the output from the forward and backward LSTM are concatenated to form the final output. Formally, the output at each timestep INLINEFORM0 can be expressed as DISPLAYFORM0 ",
          "where DISPLAYFORM0 ",
          " The vector INLINEFORM0 is then passed through INLINEFORM1 as before to obtain INLINEFORM2 .",
          "Prediction. In the prediction step, the tagger predicts the POS tag of the INLINEFORM0 -th word based on the output vector INLINEFORM1 . We tested two approaches: a softmax layer with greedy decoding and a CRF layer with Viterbi decoding. With a softmax layer, the tagger simply normalizes INLINEFORM2 and predicts using greedy decoding, i.e. picking the tag with the highest probability. In contrast, with a CRF layer, the tagger treats INLINEFORM3 as emission probability scores, models the tag-to-tag transition probability scores, and uses Viterbi algorithm to select the most probable tag sequence as the prediction. We refer readers to BIBREF17 to read more about how the CRF layer and Viterbi decoding work. We want to note that when we only embed words, encode using feedforward network, and predict using greedy decoding, the tagger is effectively the same as that in BIBREF8 . Also, when only the word and character features are used, with a biLSTM and CRF layer, the tagger is effectively the same as that in BIBREF9 . Our implementation code is available online."
        ]
      },
      {
        "section_name": "Experiments Setup",
        "paragraphs": [
          "For all models, we preprocessed the dataset by lowercasing all words, except when the characters were embedded. For the CRF model, we used L2 regularization whose coefficient was tuned to the development set. As we mentioned previously, we tuned the context window size INLINEFORM0 to the development set as well.",
          "For the neural tagger, we set the size of the word, affix, and character embedding to 100, 20, and 30 respectively. We applied dropout regularization to the embedding layers. The max-pooled CNN has 30 filters for each filter width. We set the feedforward network and the biLSTM to have 100 hidden units. We put a dropout layer before the biLSTM input layer. We tuned the learning rate, dropout rate, context window size, and CNN filter width to the development set. As we said earlier, we experimented with different configurations in the embedding, encoding, and prediction step. We evaluated each configuration on the development set as well.",
          "At training time, we used a batch size of 8, decayed the learning rate by half if the INLINEFORM0 score on the development set did not improve after 2 epochs, and stopped the training early if the score still did not improve after decaying the learning rate 5 times. To address the exploding gradient problem, we normalized the gradient norm at 1, following the suggestion in BIBREF18 . To handle the out-of-vocabulary problem, we converted singleton words and affixes occurring fewer than 5 times in the training data into a special token for unknown words/affixes."
        ]
      },
      {
        "section_name": "Evaluation",
        "paragraphs": [
          "Since the dataset is highly imbalanced (majority of words are nouns), using accuracy score as the evaluation metric is not appropriate as it gives a high score to a model that always predicts nouns regardless of input. Therefore, we decided to use INLINEFORM0 score which considers both precision and recall of the predictions.",
          "Since there are multiple tags, there are two flavors to compute an overall INLINEFORM0 score: micro and macro average. For POS tagging task where the tags do not span multiple words, micro-average INLINEFORM1 score is exactly the same as accuracy score. Thus, macro-average INLINEFORM2 score is our only option. However, there is still an issue. Macro-average INLINEFORM3 score computes the overall INLINEFORM4 score by averaging the INLINEFORM5 score of each tag. This approach means that when the model wrongly predicts a rarely occurring tag (e.g., foreign word), it is penalized as heavily as it does a frequent tag. To address this problem, we used weighted macro-average INLINEFORM6 score which takes into account the tag proportion imbalance. It computes the weighted average of the scores where each weight is equal to the corresponding tag's proportion in the dataset. This functionality is available in the scikit-learn library."
        ]
      },
      {
        "section_name": "Results and Discussion",
        "paragraphs": [
          "Firstly, we report on our tuning experiments for the neural tagger. Table TABREF27 shows the evaluation results of the many configurations of our neural tagger on the development set. We group the results by the encoding and prediction step configuration. For each group, we show the highest INLINEFORM0 score among many embedding configurations. As we can see, biLSTM with CRF layer achieves 97.60 INLINEFORM1 score, the best score on the development set. This result agrees with many previous work in neural sequence labeling that a bidirectional LSTM with CRF layer performs best BIBREF10 , BIBREF17 , BIBREF9 . Therefore, we will use this tagger to represent the neural model hereinafter.",
          "To understand the performance of the neural model for each tag, we plot the confusion matrix from the development set of the first fold in Fig. FIGREF30 . The figure shows that the model can predict most tags almost perfectly, except for X and WH tag. The X tag is described as \"a word or part of a sentence which its category is unknown or uncertain\". The X tag is rather rare, as it only appears 397 times out of over 250K tokens. Some words annotated as X are typos and slang words. Some foreign terms and abbreviations are also annotated with X. The model might get confused as such words are usually tagged with a noun tag (NN or NNP). We also see that the model seems to confuse question words (WH) such as apa (what) or siapa (who) as SC since these words may be used in subordinate clauses as well. Looking at the data closely, we found that the tagging of such words are inconsistent. This inconsistency contributes to the inability of the model to distinguish the two tags well.",
          "Next, we present the result of evaluating the baselines and other comparisons on the test set in Table TABREF28 . The INLINEFORM0 scores are averaged over the 5 cross-validation folds. We see that Major baseline performs very poorly compared to the Memo baseline, which surprisingly achieves over 90 INLINEFORM1 points. This result suggests that Memo is a more suitable baseline for this dataset in contrast with Major. The result also provides evidence to the usefulness of our evaluation metric which heavily penalizes a simple majority vote model. Furthermore, we notice that the rule-based tagger by Rashel et al. BIBREF7 performs worse than Memo, indicating that Memo is not just suitable but also quite a strong baseline. Moving on, we observe how CRF has 6 points advantage over Memo, signaling that incorporating contextual features and modeling tag-to-tag transitions are useful. Lastly, the biLSTM with CRF tagger performs the best with 97.47 INLINEFORM2 score.",
          "To understand how each feature in the embedding step affects the neural tagger, we performed feature ablation on the development set and put the result in Table TABREF29 . We see that with only words as features (first row), the neural tagger only achieves 96.06 INLINEFORM0 score. Employing character features boosts the score up to 97.42, a gain of 1.36 points. Adding prefix and suffix features improves the performance further by 0.08 and 0.10 points respectively. From this result, we see that it is the character features that positively affect the neural tagger the most."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We experimented with several baselines and comparisons for Indonesian POS tagging task. Our comparisons include a rule-based tagger, a well-established probabilistic model for sequence labeling (CRF), and a neural model. We tested many configurations for our neural model: the features (words, affixes, characters), the architecture (feedforward, biLSTM), and the output layer (softmax, CRF). We evaluated all our models on the IDN Tagged Corpus BIBREF11 , a manually annotated and publicly available Indonesian POS tagging dataset. Our best model achieves 97.47 INLINEFORM0 score, a new state-of-the-art result on the dataset. We make our cross-validation split available publicly to serve as a benchmark for future work."
        ]
      }
    ],
    "qas": [
      {
        "question": "what datasets have been used for this task?",
        "question_id": "183b385fb59ff1e3f658d4555a08b67c005a8734",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "IDN Tagged Corpus "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this work, we explored different neural network architectures for Indonesian POS tagging. We evaluated our experiments on the IDN Tagged Corpus BIBREF11 . Our best model achieves 97.47 INLINEFORM0 score, a new state-of-the-art result for Indonesian POS tagging on the dataset. We release the dataset split that we used to serve as a benchmark for future work."
              ],
              "highlighted_evidence": [
                "We evaluated our experiments on the IDN Tagged Corpus BIBREF11 ."
              ]
            },
            "annotation_id": "1a84f40e6a418da52b0d5c852ceeee97fa2bc5f3",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "IDN Tagged Corpus"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this work, we explored different neural network architectures for Indonesian POS tagging. We evaluated our experiments on the IDN Tagged Corpus BIBREF11 . Our best model achieves 97.47 INLINEFORM0 score, a new state-of-the-art result for Indonesian POS tagging on the dataset. We release the dataset split that we used to serve as a benchmark for future work."
              ],
              "highlighted_evidence": [
                "We evaluated our experiments on the IDN Tagged Corpus BIBREF11 ."
              ]
            },
            "annotation_id": "2e6120a1be977890a5317bb2f151582eb10390d3",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " IDN Tagged Corpus"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We used the IDN Tagged Corpus proposed in BIBREF11 . The corpus contains 10K sentences and 250K tokens that are tagged manually. Due to the small size, we used 5-fold cross-validation to split the corpus into training, development, and test sets. We did not split multi-word expressions but treated them as if they are a single token. All 5 folds of the dataset are available publicly to serve as a benchmark for future work."
              ],
              "highlighted_evidence": [
                "We used the IDN Tagged Corpus proposed in BIBREF11 ."
              ]
            },
            "annotation_id": "fe7ad4f5f5373931917bc3d7887c7f9b08f3f9cd",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1. Illustration of the embedding step. The word and its affixes are embedded to obtain their vector representations. Character embeddings of the word are composed with a max-pooled CNN. The final word embedding is the concatenation of all the result vectors."
      },
      {
        "file": "3-TableI-1.png",
        "caption": "Table I DEV F1 SCORE OF EACH NEURAL TAGGER ARCHITECTURE"
      },
      {
        "file": "4-TableII-1.png",
        "caption": "Table II TEST F1 SCORE OF EACH METHOD, AVERAGED OVER 5 FOLDS"
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2. Confusion matrix of the best biLSTM with CRF tagger from the development set of the first fold. The tagger seems to have difficulties dealing with words annotated as X and confuse WH as SC."
      }
    ]
  },
  "1906.04287": {
    "title": "Chinese Embedding via Stroke and Glyph Information: A Dual-channel View",
    "abstract": "Recent studies have consistently given positive hints that morphology is helpful in enriching word embeddings. In this paper, we argue that Chinese word embeddings can be substantially enriched by the morphological information hidden in characters which is reflected not only in strokes order sequentially, but also in character glyphs spatially. Then, we propose a novel Dual-channel Word Embedding (DWE) model to realize the joint learning of sequential and spatial information of characters. Through the evaluation on both word similarity and word analogy tasks, our model shows its rationality and superiority in modelling the morphology of Chinese.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Word embeddings are fixed-length vector representations for words BIBREF0 , BIBREF1 . In recent years, the morphology of words is drawing more and more attention BIBREF2 , especially for Chinese whose writing system is based on logograms.",
          "UTF8gbsn With the gradual exploration of the semantic features of Chinese, scholars have found that not only words and characters are important semantic carriers, but also stroke feature of Chinese characters is crucial for inferring semantics BIBREF3 . Actually, a Chinese word usually consists of several characters, and each character can be further decomposed into a stroke sequence which is certain and changeless, and this kind of stroke sequence is very similar to the construction of English words. In Chinese, a particular sequence of strokes can reflect the inherent semantics. As shown in the upper half of Figure FIGREF3 , the Chinese character \u201c\u9a7e\" (drive) can be decomposed into a sequence of eight strokes, where the last three strokes together correspond to a root character \u201c\u9a6c\" (horse) similar to the root \u201cclar\" of English word \u201cdeclare\" and \u201cclarify\".",
          "Moreover, Chinese is a language originated from Oracle Bone Inscriptions (a kind of hieroglyphics). Its character glyphs have a spatial structure similar to graphs which can convey abundant semantics BIBREF4 . Additionally, the critical reason why Chinese characters are so rich in morphological information is that they are composed of basic strokes in a 2-D spatial order. However, different spatial configurations of strokes may lead to different semantics. As shown in the lower half of Figure 1, three Chinese characters \u201c\u5165\" (enter), \u201c\u516b\" (eight) and \u201c\u4eba\" (man) share exactly a common stroke sequence, but they have completely different semantics because of their different spatial configurations.",
          "In addition, some biological investigations have confirmed that there are actually two processing channels for Chinese language. Specifically, Chinese readers not only activate the left brain which is a dominant hemisphere in processing alphabetic languages BIBREF5 , BIBREF6 , BIBREF7 , but also activate the areas of the right brain that are responsible for image processing and spatial information at the same time BIBREF8 . Therefore, we argue that the morphological information of characters in Chinese consists of two parts, i.e., the sequential information hidden in root-like strokes order, and the spatial information hidden in graph-like character glyphs. Along this line, we propose a novel Dual-channel Word Embedding (DWE) model for Chinese to realize the joint learning of sequential and spatial information in characters. Finally, we evaluate DWE on two representative tasks, where the experimental results exactly validate the superiority of DWE in capturing the morphological information of Chinese."
        ]
      },
      {
        "section_name": "Morphological Word Representations",
        "paragraphs": [
          "Traditional methods on getting word embeddings are mainly based on the distributional hypothesis BIBREF9 : words with similar contexts tend to have similar semantics. To explore more interpretable models, some scholars have gradually noticed the importance of the morphology of words in conveying semantics BIBREF10 , BIBREF11 , and some studies have proved that the morphology of words can indeed enrich the semantics of word embeddings BIBREF12 , BIBREF13 , BIBREF2 . More recently, Wieting et al. wieting2016charagram proposed to represent words using character n-gram count vectors. Further, Bojanowski et al. bojanowski2017enriching improved the classic skip-gram model BIBREF0 by taking subwords into account in the acquisition of word embeddings, which is instructive for us to regard certain stroke sequences as roots in English."
        ]
      },
      {
        "section_name": "Embedding for Chinese Language",
        "paragraphs": [
          "The complexity of Chinese itself has given birth to a lot of research on Chinese embedding, including the utilization of character features BIBREF14 and radicals BIBREF15 , BIBREF16 , BIBREF17 . Considering the 2-D graphic structure of Chinese characters, Su and Lee su2017learning creatively proposed to enhance word representations by character glyphs. Lately, Cao et al. cao2018cw2vec proposed that a Chinese word can be decomposed into a sequence of strokes which correspond to subwords in English, and Wu et al. wu2019glyce designed a Tianzige-CNN to model the spatial structure of Chinese characters from the perspective of image processing. However, their methods are either somewhat loose for the stroke criteria or unable to capture the interactions between strokes and character glyphs."
        ]
      },
      {
        "section_name": "DWE Model",
        "paragraphs": [
          "As we mentioned earlier, it is reasonable and imperative to learn Chinese word embeddings from two channels, i.e., a sequential stroke n-gram channel and a spatial glyph channel. Inspired by the previous works BIBREF14 , BIBREF18 , BIBREF4 , BIBREF19 , we propose to combine the representation of Chinese words with the representation of characters to obtain finer-grained semantics, so that unknown words can be identified and their relationship with other known Chinese characters can be found by distinguishing the common stroke sequences or character glyph they share.",
          "UTF8gbsn Our DWE model is shown in Figure FIGREF9 . For an arbitrary Chinese word INLINEFORM0 , e.g., \u201c\u9a7e\u8f66\", it will be firstly decomposed into several characters, e.g., \u201c\u9a7e\" and \u201c\u8f66\", and each of the characters will be further processed in a dual-channel character embedding sub-module to refine its morphological information. In sequential channel, each character can be decomposed into a stroke sequence according to the criteria of Chinese writing system as shown in Figure FIGREF3 . After retrieving the stroke sequence, we add special boundary symbols INLINEFORM1 and INLINEFORM2 at the beginning and end of it and adopt an efficient approach by utilizing the stroke n-gram method BIBREF3 to extract strokes order information for each character. More precisely, we firstly scan each character throughout the training corpus and obtain a stroke n-gram dictionary INLINEFORM3 . Then, we use INLINEFORM4 to denote the collection of stroke n-grams of each character INLINEFORM5 in INLINEFORM6 . While in spatial channel, to capture the semantics hidden in glyphs, we render the glyph INLINEFORM7 for each character INLINEFORM8 and apply a well-known CNN structure, LeNet BIBREF20 , to process each character glyph, which is also helpful to distinguish between those characters that are identical in strokes.",
          "After that, we combine the representation of words with the representation of characters and define the word embedding for INLINEFORM0 as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 and INLINEFORM1 are compositional operation. INLINEFORM6 is the word ID embedding and INLINEFORM7 is the number of characters in INLINEFORM8 .",
          "According to the previous work BIBREF0 , we compute the similarity between current word INLINEFORM0 and one of its context words INLINEFORM1 by defining a score function as INLINEFORM2 , where INLINEFORM3 and INLINEFORM4 are embedding vectors of INLINEFORM5 and INLINEFORM6 respectively. Following the previous works BIBREF0 , BIBREF21 , the objective function is defined as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is the number of negative samples and INLINEFORM1 is the expectation term. For each INLINEFORM2 in training corpus INLINEFORM3 , a set of negative samples INLINEFORM4 will be selected according to the distribution INLINEFORM5 , which is usually set as the word unigram distribution. And INLINEFORM6 is the sigmoid function."
        ]
      },
      {
        "section_name": "Dataset Preparation",
        "paragraphs": [
          "We download parts of Chinese Wikipedia articles from Large-Scale Chinese Datasets for NLP. For word segmentation and filtering the stopwords, we apply the jieba toolkit based on the stopwords table. Finally, we get 11,529,432 segmented words. In accordance with their work BIBREF14 , all items whose Unicode falls into the range between 0x4E00 and 0x9FA5 are Chinese characters. We crawl the stroke information of all 20,402 characters from an online dictionary and render each character glyph to a 28 INLINEFORM0 28 1-bit grayscale bitmap by using Pillow."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "We choose adagrad BIBREF23 as our optimizing algorithm, and we set the batch size as 4,096 and learning rate as 0.05. In practice, the slide window size INLINEFORM0 of stroke INLINEFORM1 -grams is set as INLINEFORM2 . The dimension of all word embeddings of different models is consistently set as 300. We use two test tasks to evaluate the performance of different models: one is word similarity, and the other is word analogy. A word similarity test consists of multiple word pairs and similarity scores annotated by humans. Good word representations should make the calculated similarity have a high rank correlation with human annotated scores, which is usually measured by the Spearman's correlation INLINEFORM3 BIBREF24 .",
          "The form of an analogy problem is like \u201cking\":\u201cqueen\" = \u201cman\":\u201c?\", and \u201cwoman\" is the most proper answer to \u201c?\". That is, in this task, given three words INLINEFORM0 , INLINEFORM1 , and INLINEFORM2 , the goal is to infer the fourth word INLINEFORM3 which satisfies \u201c INLINEFORM4 is to INLINEFORM5 that is similar to INLINEFORM6 is to INLINEFORM7 \". We use INLINEFORM8 BIBREF0 and INLINEFORM9 function BIBREF25 to calculate the most appropriate word INLINEFORM10 . By using the same data used in BIBREF14 and BIBREF3 , we adopt two manually-annotated datasets for Chinese word similarity task, i.e., wordsim-240 and wordsim-296 BIBREF26 and a three-group dataset for Chinese word analogy task."
        ]
      },
      {
        "section_name": "Baseline Methods",
        "paragraphs": [
          "We use gensim to implement both CBOW and Skipgram and apply the source codes pulished by the authors to implement CWE, JWE, GWE and GloVe. Since Cao et al. cao2018cw2vec did not publish their code, we follow their paper and reproduce cw2vec in mxnet which we also use to implement sisg BIBREF21 and our DWE. To encourage further research, we will publish our model and datasets."
        ]
      },
      {
        "section_name": "Experimental Results",
        "paragraphs": [
          "UTF8gbsn The experimental results are shown in Table TABREF11 . We can observe that our DWE model achieves the best results both on dataset wordsim-240 and wordsim-296 in the similarity task as expected because of the particularity of Chinese morphology, but it only improves the accuracy for the family group in the analogy task.",
          "Actually, it is not by chance that we get these results, because DWE has the advantage of distinguishing between morphologically related words, which can be verified by the results of the similarity task. Meanwhile, in the word analogy task, those words expressing family relations in Chinese are mostly compositional in their character glyphs. For example, in an analogy pair \u201c\u5144\u5f1f\" (brother) : \u201c\u59d0\u59b9\" (sister) = \u201c\u513f\u5b50\" (son) : \u201c\u5973\u513f\" (daughter), we can easily find that \u201c\u5144\u5f1f\" and \u201c\u513f\u5b50\" share an exactly common part of glyph \u201c\u513f\" (male relative of a junior generation) while \u201c\u59d0\u59b9\" and \u201c\u5973\u513f\" share an exactly common part of glyph \u201c\u5973\" (female), and this kind of morphological pattern can be accurately captured by our model. However, most of the names of countries, capitals and cities are transliterated words, and the relationship between the morphology and semantics of words is minimal, which is consistent with the findings reported in BIBREF4 . For instance, in an analogy pair \u201c\u897f\u73ed\u7259\" (Spain) : \u201c\u9a6c\u5fb7\u91cc\" (Madrid) = \u201c\u6cd5\u56fd\" (France) : \u201c\u5df4\u9ece\" (Paris), we cannot infer any relevance among these four words literally because they are all translated by pronunciation.",
          "In summary, since different words that are morphologically similar tend to have similar semantics in Chinese, simultaneously modeling the sequential and spatial information of characters from both stroke n-grams and glyph features can indeed improve the modeling of Chinese word representations substantially."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this article, we first analyzed the similarities and differences in terms of morphology between alphabetical languages and Chinese. Then, we delved deeper into the particularity of Chinese morphology and proposed our DWE model by taking into account the sequential information of strokes order and the spatial information of glyphs. Through the evaluation on two representative tasks, our model shows its superiority in capturing the morphological information of Chinese."
        ]
      }
    ],
    "qas": [
      {
        "question": "How much data do they use to train the embeddings?",
        "question_id": "5f7f4a1d4380c118a58ed506c057d3b7aa234c1e",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "11,529,432 segmented words and 20,402 characters",
              "evidence": [
                "We download parts of Chinese Wikipedia articles from Large-Scale Chinese Datasets for NLP. For word segmentation and filtering the stopwords, we apply the jieba toolkit based on the stopwords table. Finally, we get 11,529,432 segmented words. In accordance with their work BIBREF14 , all items whose Unicode falls into the range between 0x4E00 and 0x9FA5 are Chinese characters. We crawl the stroke information of all 20,402 characters from an online dictionary and render each character glyph to a 28 INLINEFORM0 28 1-bit grayscale bitmap by using Pillow."
              ],
              "highlighted_evidence": [
                "Finally, we get 11,529,432 segmented words. ",
                "We crawl the stroke information of all 20,402 characters from an online dictionary and render each character glyph to a 28 INLINEFORM0 28 1-bit grayscale bitmap by using Pillow."
              ]
            },
            "annotation_id": "0b58eb8ae6eced6e137d217f9d64bb1c40980b69",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "11,529,432 segmented words"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We download parts of Chinese Wikipedia articles from Large-Scale Chinese Datasets for NLP. For word segmentation and filtering the stopwords, we apply the jieba toolkit based on the stopwords table. Finally, we get 11,529,432 segmented words. In accordance with their work BIBREF14 , all items whose Unicode falls into the range between 0x4E00 and 0x9FA5 are Chinese characters. We crawl the stroke information of all 20,402 characters from an online dictionary and render each character glyph to a 28 INLINEFORM0 28 1-bit grayscale bitmap by using Pillow."
              ],
              "highlighted_evidence": [
                "Finally, we get 11,529,432 segmented words."
              ]
            },
            "annotation_id": "a286f11986c622ad1a927b922fab8b7501c4f55e",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "11,529,432 segmented words"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We download parts of Chinese Wikipedia articles from Large-Scale Chinese Datasets for NLP. For word segmentation and filtering the stopwords, we apply the jieba toolkit based on the stopwords table. Finally, we get 11,529,432 segmented words. In accordance with their work BIBREF14 , all items whose Unicode falls into the range between 0x4E00 and 0x9FA5 are Chinese characters. We crawl the stroke information of all 20,402 characters from an online dictionary and render each character glyph to a 28 INLINEFORM0 28 1-bit grayscale bitmap by using Pillow."
              ],
              "highlighted_evidence": [
                "We download parts of Chinese Wikipedia articles from Large-Scale Chinese Datasets for NLP. For word segmentation and filtering the stopwords, we apply the jieba toolkit based on the stopwords table. Finally, we get 11,529,432 segmented words.",
                "11529432 segmented "
              ]
            },
            "annotation_id": "ec4f368a2fccd7fdc0ae8ea91bdebe36ef970b0c",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: The upper part is an example for illustrating the inclusion relationship hidden in strokes order and character glyphs. The lower part reflects that a common stroke sequence may form different Chinese characters if their spatial configurations are different."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: An illustration of our Dual-channel Word Embedding (DWE) model."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Performance on word similarity and word analogy task. The dimension of embeddings is set as 300. The evaluation metric is \u03c1 for word similarity and accuracy percentage for word analogy."
      }
    ]
  },
  "1912.10162": {
    "title": "Design and implementation of an open source Greek POS Tagger and Entity Recognizer using spaCy",
    "abstract": "This paper proposes a machine learning approach to part-of-speech tagging and named entity recognition for Greek, focusing on the extraction of morphological features and classification of tokens into a small set of classes for named entities. The architecture model that was used is introduced. The greek version of the spaCy platform was added into the source code, a feature that did not exist before our contribution, and was used for building the models. Additionally, a part of speech tagger was trained that can detect the morphology of the tokens and performs higher than the state-of-the-art results when classifying only the part of speech. For named entity recognition using spaCy, a model that extends the standard ENAMEX type (organization, location, person) was built. Certain experiments that were conducted indicate the need for flexibility in out-of-vocabulary words and there is an effort for resolving this issue. Finally, the evaluation results are discussed.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "In the research field of Natural Language Processing (NLP) there are several tasks that contribute to understanding natural text. These tasks can manipulate natural language, such as tokenization process, and consequently can be used in other implementations, in order to extract syntactic or semantic information. One such task for syntactic components is Part of Speech Tagging (POS Tagging). Part of Speech Tagging in corpus linguistics is a process where a word is assigned with a label of the grammatical term, given the context it appears in. In many languages, POS Tagging models achieve an accuracy of 96 to 97 percent BIBREF0.",
          "Part of Speech Tagging for highly inflective languages, such as Greek is quite a difficult task. In the Greek Language, words can have different morphological forms, depending on the part of speech (verbs have up to ten different forms). For that purpose, there is a need for a tagset that can support morphological features for improvement of Greek POS Tagging BIBREF1.",
          "Another main task for extracting semantic information is Named Entity Recognition (NER). Named Entity Recognition is a process where a word or a set of words reference to a world object. Most Natural Language Processing models classify named entities that describe people, locations, organizations, following the ENAMEX type or can be more complex by detecting numerical types, like percentages (NUMEX) or dates (TIMEX) BIBREF2.",
          "The greek Part of Speech Tagging and Named Entity Recognition models presented in this paper were developed using the spaCy library BIBREF3. SpaCy is an open source, Natural Language Processing library that supports a variety of tasks, including POS Tagging, Named Entity Recognition, Dependency Parsing, etc. SpaCy uses sophisticated neural network-based models for the implementation of Natural Language Processing components that achieve state-of-the-art results in many of these tasks.",
          "In the following chapters the process for implementing Part of Speech Tagging and Named Entity Recognition for the Greek Language is explained. A dataset with extended POS Tags was found and matched to a set of morphological rules, according to a treebank. The dataset was then processed, fed to the spaCy model and used for training. Similarly, for Named Entity Recognition, datasets from different sources were compared to a custom set of rules for named entities. Finally, different experiments were conducted for evaluating the accuracy of the models."
        ]
      },
      {
        "section_name": "SpaCy's deep learning model for POS tagging and Named Entity Recognition",
        "paragraphs": [
          "SpaCy uses a deep learning formula for implementing NLP models, summarised as \u201cembed, encode, attend, predict\u201d. In spaCy's approach text is inserted in the model in the form of unique numerical values (ID) for every input that can represent a token of a corpus or a class of the NLP task (part of speech tag, named entity class). At the embedding stage, features such as the prefix, the suffix, the shape and the lowercase form of a word are used for the extraction of hashed values that reflect word similarities.",
          "At this stage a vocabulary with hashed values and their vectors exist in the model. For the exploitation of adjacent vectors in the state of encoding, values pass through the Convolutional Neural Network (CNN) and get merged with their context. The result of the encoding process is a matrix of vectors that represents information. Before the prediction of an ID, the matrix has to be passed through the Attention Layer of the CNN, using a query vector to summarize the input.",
          "At prediction, a Softmax function is used for the prediction of a super tag with part of speech and morphology information. Similarly for named entities, the available class is predicted. After the training process of the model, the CNN is able to be used for NLP tasks.",
          "In the latest release of spaCy the deep learning models are reported to be \u201c10 times smaller, 20% more accurate and cheaper to run than the previous generation\u201d BIBREF3. The models are implemented using Thinc, spaCy\u2019s machine learning library."
        ]
      },
      {
        "section_name": "Creating a Greek POS Tagger using spaCy",
        "paragraphs": [
          "The Institute for Language and Speech Processing was the first to implement a Part of Speech Tagger with morphological features and has evaluated the experiments in terms of the error rate of the predicted classes BIBREF4. These models can be accessed from web services offered by the Institute . However, the creation of a compound Greek POS tagger using spaCy, a fast and accurate NLP python framework is new.",
          "For the creation of a Part of Speech Tagger in the Greek Language a number of steps was followed. The tags from the \u201cMakedonia\u201d dataset, which is described below, were extracted and matched to a set of morphological rules. The tokens in the dataset were adjusted to annotation rules that the model will use. Different parameters in the configuration of spaCy's model were tested while training and their results are presented in SECREF6."
        ]
      },
      {
        "section_name": "Creating a Greek POS Tagger using spaCy ::: Dataset evaluation and selection",
        "paragraphs": [
          "The dataset comes from texts of the Greek newspaper \u201cMakedonia\u201d. The articles in the newspaper are categorized in different subjects, such as sports, health, economy and political news. Data retrieval was done from the website of the clarin project BIBREF5 and consist of a set of xml files with information at paragraph, sentence and word level. It must be underlined that this annotation was performed by the Institute for Language and Speech Processing and data is licenced under the CC - BY - NC - SA licence.",
          "Information about the dataset includes the tokens of a set of articles and their position in a sentence, the lemma and the part of speech of every token. The various values of POS tags were retrieved and incorporated into a tag map. The labels and morphology they describe are explained below."
        ]
      },
      {
        "section_name": "Creating a Greek POS Tagger using spaCy ::: Creation of the Tag Map with reference to Universal Dependencies",
        "paragraphs": [
          "Different labels were found at the dataset and were matched to a label map, where for each label the part of the speech and their morphology are analyzed. In more detail, the first two characters refer to the part of speech and accordingly extend to more information about it. The label map supports 16 standard part of speech tags: Adjective, Adposition, Adverb, Coordinating Conjuction, Determiner, Interjection, Noun, Numeral, Particle, Pronoun, Proper Noun, Punctuation, Subordinating Conjuction, Symbol, Verb and Other. Each tag describes morphological features of the word, depending on the part of the speech to which it refers like the gender, the number, and the case BIBREF6. It must be mentioned that the extraction of morphological rules and the matching with the tags was done using the Greek version of the Universal Dependencies BIBREF7."
        ]
      },
      {
        "section_name": "Creating a Greek POS Tagger using spaCy ::: POS Tagger training",
        "paragraphs": [
          "The articles from the newspaper were fed in spaCy library into the proper format for training. Different parameters were tested, in order to get the optimal result. The dataset was shuffled, using the same seed for all the experiments and was split into a train set (70%), a test set (20%) and a validation set (10%). Information was passed through the training algorithm in batches with an increasing batch size from 4 to 32 and a step of 1.001. Additionally, a dropout rate was configured in every batch, initialized to 0.6 which dropped during the training process to 0.4. Most of the experiments were trained using 30 epochs.",
          "The main area of study for the experiments focuses on three important components. At first, we investigate the difference in results between part of speech taggers that classify morphological features and taggers that detect only the part of speech. Moreover, we explore the significance of pretrained vectors used from a model and their effect on the extraction of better results. Most importantly, the usage of subwords of tokens from a tagger as embeddings is issued. For the experiments, precision, recall and f1 score are used as evaluation metrics."
        ]
      },
      {
        "section_name": "Creating a Greek POS Tagger using spaCy ::: Evaluation and comparison of results",
        "paragraphs": [
          "In the first experiment the model was trained using pretrained vectors extracted from two different sources, Common Crawl and Wikipedia and can be found at the official FastText web page BIBREF8. Both sources were trained on the same algorithm called FastText BIBREF9, an extension of Word2Vec that treats tokens as an average sum of sub-words and finds similarities of words based on their n-grams. The configuration of the FastText model for Wikipedia vectors is according to BIBREF10, whilst the model for CC vectors is a position-weight CBOW 5 length n-grams with a window size of 5 tokens and 10 negative words. The file with the Common Crawl vectors consists of 2.000.000 tokens with 300 dimension, whereas the file with the Wikipedia vectors consists of 300.000 tokens with 300 dimension.The results can be viewed in the following table, with the first part describing the Common Crawl results and the second one the Wikipedia results.",
          "At the results, POS and morph classes refer to the tag labels explained in SECREF4, whilst only POS classes relate to annotated labels that describe only the part of speech. It is evident that even though the CC vectors are noisy, coming from a web source, they lead to better results than Wikipedia, possibly because they have a larger variety of tokens.",
          "In the next experiment, the dataset was used for the composition of embeddings for the part of speech tagger. The dataset was trained on a FastText model with the same parameters that extracted the Common Crawl vectors. As a result, 140.000 vectors with 300 dimension were exported. It must be mentioned that the tagset with the morphological features was used.",
          "The values of the metrics in this case were almost as good and comparable to the CC ones. However, the model trained with a larger vocabulary had higher results. Also, the model with the dataset vectors did not have the flexibility to classify unknown words.",
          "As a next step, the test set of the dataset was altered by replacing words with syntactical mistakes to test the tolerance of the model in OOV words. Suffixes of verbs were altered and vowels were replaced with others, affecting 20% of the tokens of the dataset. Using again the more complex tagset for training, the results can be found in Table 3.",
          "What can be concluded is that the model did not have a flexibility in OOV words. Of course, this can also be an advantage, meaning that the model recognized the mismatch of a wrong word with its class.",
          "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. The resulting vectors were imported in the vocabulary with the CC vectors before training. The model was also trained using as a vocabulary the unknown words and the tokens from the Common Crawl vectors, both buffered in the same FastText model. Results are listed in Table 4.",
          "It was noticed that the model performed better when using the vectors from different FastText models. It was expected that the second experiment would have performed better, as the tokens were inserted into the same FastText model and the vectors exported from both sources should match."
        ]
      },
      {
        "section_name": "Creating a state of the art Named Entity Recognizer using spaCy",
        "paragraphs": [
          "In BIBREF11 the development of an entity recognizer with named entities that follow a proper set of rules is described with evaluation metrics that reach 86% for precision and 81% for recall. Our implementation follows these rules as well. Also, a pretrained model is offered from a library called polyglot for recognition BIBREF12, which has evaluated NER in Greek with statistical machine translation.",
          "For the creation of a Named Entity Recognizer in the Greek Language a number of steps was followed. The entities from the \u201cMakedonia\u201d dataset were extracted and annotated, forming a set of keywords that matched a specific set of rules the entities had to follow. These keywords were used to reform the dataset and also to find entities from a larger dataset, like Wikipedia. The spaCy model was trained using both datasets and their results are compared to a test set. Additionally, the spaCy model was trained using as a feature the POS tags of the tokens. All results are presented in SECREF13."
        ]
      },
      {
        "section_name": "Creating a state of the art Named Entity Recognizer using spaCy ::: Dataset evaluation and selection",
        "paragraphs": [
          "In the \u201cMakedonia\u201d dataset information about named entities is organized with the index of the character the named entity starts, the index of the character the named entity ends and the class of the named entity. The dataset was parsed and the named entities were added into the keyword list, with every record representing the token (or the set of tokens) and its class. Noise was removed from the list and the records were sorted by the length of the entity. The keyword list had an average of 72.000 records."
        ]
      },
      {
        "section_name": "Creating a state of the art Named Entity Recognizer using spaCy ::: Usage of Wikipedia dataset for training",
        "paragraphs": [
          "In order to gain more information about the context of the Greek entities, a percentage of Greek Wikipedia was used. After applying sentence and token segmentation on Wikipedia text and using a pretrained model from polyglot, the keyword list increased. The keyword list had at this point about 350,000 records and consisted of 4 classes: location (LOC), organization (ORG), person (PERSON) and facility (FAC). A percentage of Greek Wikipedia was parsed and used for training in spaCy. The results from the training are presented in SECREF13."
        ]
      },
      {
        "section_name": "Creating a state of the art Named Entity Recognizer using spaCy ::: Evaluation and comparison of results",
        "paragraphs": [
          "Both datasets were fed into the library in proper format for training. In training process, the entity recognizer had the same configuration with the POS tagger, using the same percentages for train, validation and test sets. It must be noted that all the models used the Common Crawl pretrained vectors for a vocabulary. The results are compared using the macro F1 score.",
          "At first the datasets from both sources (Makedonia, Wikipedia) were used for training with 10 iterations and testing from the model. The results can be viewed in the following table:",
          "It seemed that the average F1 score was higher for the Makedonia corpus, as it was the basis of the configuration for the keyword list. In order to have an objective evaluation, the results of each corpus per entity class were observed.",
          "Both sources had good results in non entity tokens, which affected the F1 score. Moreover, the model did not perform well for facilities, as polyglot's Greek recognizer does not support that class and FAC entities cover a small amount of the list.",
          "In the second experiment, the datasets were compared to a common test set that followed the desired set of rules.",
          "Again, the Makedonia corpus performed better, because of the proper annotation on the keyword list.",
          "In an experiment worth mentioning the correlation of the part of speech with the performance of the recognizer was explored. In this experiment, both pipelines (part of speech, entity recognition) were used for training with 30 iterations and the model was trained twice: with and without the usage of the part of speech information for recognition.",
          "It is evident that the recognizer did not gain knowledge from the part of speech tags of the tokens."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "Natural Language Processing meets numerous problems in its applications, especially in uncommon languages such as Greek. This paper proposes a machine learning approach to part-of-speech tagging and named entity recognition for Greek, a highly inflected language using spaCy, a very robust and popular framework. Although significant work has been done, there are several more things that can be accomplished. The need of more datasets for the Greek language is evident, but the results are quite satisfying, comparable to other languages."
        ]
      }
    ],
    "qas": [
      {
        "question": "What are the issues identified for out-of-vocabulary words?",
        "question_id": "0a5fd0e5f4ab12be57be20416a5ea7c3db5fb662",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "morphology",
        "question_writer": "486a870694ba60f1a1e7e4ec13e328164cd4b43c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "model did not have a flexibility in OOV words",
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector",
                "It was noticed that the model performed better when using the vectors from different FastText models"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The values of the metrics in this case were almost as good and comparable to the CC ones. However, the model trained with a larger vocabulary had higher results. Also, the model with the dataset vectors did not have the flexibility to classify unknown words.",
                "As a next step, the test set of the dataset was altered by replacing words with syntactical mistakes to test the tolerance of the model in OOV words. Suffixes of verbs were altered and vowels were replaced with others, affecting 20% of the tokens of the dataset. Using again the more complex tagset for training, the results can be found in Table 3.",
                "What can be concluded is that the model did not have a flexibility in OOV words. Of course, this can also be an advantage, meaning that the model recognized the mismatch of a wrong word with its class.",
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. The resulting vectors were imported in the vocabulary with the CC vectors before training. The model was also trained using as a vocabulary the unknown words and the tokens from the Common Crawl vectors, both buffered in the same FastText model. Results are listed in Table 4.",
                "It was noticed that the model performed better when using the vectors from different FastText models. It was expected that the second experiment would have performed better, as the tokens were inserted into the same FastText model and the vectors exported from both sources should match."
              ],
              "highlighted_evidence": [
                "Also, the model with the dataset vectors did not have the flexibility to classify unknown words.\n\nAs a next step, the test set of the dataset was altered by replacing words with syntactical mistakes to test the tolerance of the model in OOV words. Suffixes of verbs were altered and vowels were replaced with others, affecting 20% of the tokens of the dataset. Using again the more complex tagset for training, the results can be found in Table 3.\n\nWhat can be concluded is that the model did not have a flexibility in OOV words. Of course, this can also be an advantage, meaning that the model recognized the mismatch of a wrong word with its class.\n\nOne disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. The resulting vectors were imported in the vocabulary with the CC vectors before training. The model was also trained using as a vocabulary the unknown words and the tokens from the Common Crawl vectors, both buffered in the same FastText model. Results are listed in Table 4.\n\nIt was noticed that the model performed better when using the vectors from different FastText models."
              ]
            },
            "annotation_id": "42cd2ca5121830f67b272b59ddd74a5e7e27617b",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "for unknown words the model assigned a zero vector"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. The resulting vectors were imported in the vocabulary with the CC vectors before training. The model was also trained using as a vocabulary the unknown words and the tokens from the Common Crawl vectors, both buffered in the same FastText model. Results are listed in Table 4."
              ],
              "highlighted_evidence": [
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results."
              ]
            },
            "annotation_id": "587e9747cf63f3ff6388885294b69b26186af164",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Also, the model with the dataset vectors did not have the flexibility to classify unknown words.",
                "the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The values of the metrics in this case were almost as good and comparable to the CC ones. However, the model trained with a larger vocabulary had higher results. Also, the model with the dataset vectors did not have the flexibility to classify unknown words.",
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. The resulting vectors were imported in the vocabulary with the CC vectors before training. The model was also trained using as a vocabulary the unknown words and the tokens from the Common Crawl vectors, both buffered in the same FastText model. Results are listed in Table 4."
              ],
              "highlighted_evidence": [
                "The values of the metrics in this case were almost as good and comparable to the CC ones. However, the model trained with a larger vocabulary had higher results. Also, the model with the dataset vectors did not have the flexibility to classify unknown words.",
                "One disadvantage that the previous model had is that for unknown words the model assigned a zero vector, affecting the testing results. In order to minimize this problem, the unknown words were first passed through a FastText model to get a vector from their subwords. "
              ]
            },
            "annotation_id": "dd73ede58ac296f7031d3767739d2cc855788e1a",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Results based on CommonCrawl pretrained vectors and based on Wikipedia pretrained vectors"
      },
      {
        "file": "3-Table4-1.png",
        "caption": "Table 4: Common Crawl pretrained + vectors annotated from out of vocabulary words and all vectors annotated from FastText (Common Crawl pretrained and from out of vocabulary words)"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Usage of pretrained vectors from dataset"
      },
      {
        "file": "4-Table6-1.png",
        "caption": "Table 6: Results of the different train sets per class"
      },
      {
        "file": "4-Table7-1.png",
        "caption": "Table 7: Comparison of results with common test set"
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Comparison of Macro Average F1 score with different train sets"
      }
    ]
  },
  "1909.13184": {
    "title": "Towards Automatic Bot Detection in Twitter for Health-related Tasks",
    "abstract": "With the increasing use of social media data for health-related research, the credibility of the information from this source has been questioned as the posts may originate from automated accounts or \"bots\". While automatic bot detection approaches have been proposed, there are none that have been evaluated on users posting health-related information. In this paper, we extend an existing bot detection system and customize it for health-related research. Using a dataset of Twitter users, we first show that the system, which was designed for political bot detection, underperforms when applied to health-related Twitter users. We then incorporate additional features and a statistical machine learning classifier to significantly improve bot detection performance. Our approach obtains F_1 scores of 0.7 for the \"bot\" class, representing improvements of 0.339. Our approach is customizable and generalizable for bot detection in other health-related social media cohorts.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "In recent years, social media has evolved into an important source of information for various types of health-related research. Social networks encapsulate large volumes of data associated with diverse health topics, generated by active user bases in continuous growth. Twitter, for example, has 330 million monthly active users worldwide that generate almost 500 million micro-blogs (tweets) per day. For some years, the use of the platform to share personal health information has been growing, particularly amongst people living with one or more chronic conditions and those living with disability. Twenty percent of social network site users living with chronic conditions gather and share health information on the sites, compared with 12% of social network site users who report no chronic conditions. Social media data is thus being widely used for health-related research, for tasks such as adverse drug reaction detection BIBREF0, syndromic surveillance BIBREF1, subject recruitment for cancer trials BIBREF2, and characterizing drug abuse BIBREF3, to name a few. Twitter is particularly popular in research due to the availability of the public streaming API, which releases a sample of publicly posted data in real time. While early health-related research from social media focused almost exclusively on population-level studies, some very recent research tasks have focused on performing longitudinal data analysis at the user level, such as mining health-related information from cohorts of pregnant women BIBREF4.",
          "When conducting user-level studies from social media, one challenge is to ascertain the credibility of the information posted. Particularly, it is important to verify, when deriving statistical estimates from user cohorts, that the user accounts represent humans and not bots (accounts that can be controlled to automatically produce content and interact with other profiles)BIBREF5, BIBREF6. Bots may spread false information by automatically retweeting posts without a human verifying the facts or to influence public opinions on particular topics on purpose BIBREF5, BIBREF7, BIBREF8. For example, a recent study BIBREF9 showed that the highest proportion of anti-vaccine content is generated by accounts with unknown or intermediate bot scores, meaning that the existing methods were not able to fully determine if they were indeed bots. Automatic bot detection techniques mostly rely on extracting features from users' profiles and their social networks BIBREF10, BIBREF11. Some studies have used Honeypot profiles on Twitter to identify and analyze bots BIBREF12, while other studies have analyzed social proximity BIBREF13 or both social and content proximities BIBREF10, tweet timing intervals BIBREF14, or user-level content-based and graph-based features BIBREF15. However, in response to efforts towards keeping Twitter bot-free, bots have evolved and changed to overcome the detection techniques BIBREF16.",
          "The objectives of this study are to (i) evaluate an existing bot detection system on user-level datasets selected for their health-related content, and (ii) extend the bot detection system for effective application within the health realm. Bot detection approaches have been published in the past few years, but most of the code and data necessary for reproducing the published results were not made available BIBREF17, BIBREF18, BIBREF19. The only system for which we found both operational code and data available, Botometer BIBREF20 (formerly BotOrNot), was chosen as the benchmark system for this study. To the best of our knowledge, this paper presents the first study on health-related bot detection. We have made the classification code and training set of annotated users available at (we will provide a URL with the camera-ready version of the paper)."
        ]
      },
      {
        "section_name": "Methods ::: Corpus",
        "paragraphs": [
          "To identify bots in health-related social media data, we retrieved a sample of $10,417$ users from a database containing more than 400 million publicly available tweets posted by more than $100,000$ users who have announced their pregnancy on Twitter BIBREF4. This sample is based on related work for detecting users who have mentioned various pregnancy outcomes in their tweets. Two professional annotators manually categorized the $10,417$ users as \"bot,\" \"non-bot,\" or \"unavailable,\" based on their publicly available Twitter sites. Users were annotated broadly as \"bot\" if, in contrast to users annotated as \"non-bot,\" they do not appear to be posting personal information. Users were annotated as \"unavailable\" if their Twitter sites could not be viewed at the time of annotation, due to modifying their privacy settings or being removed or suspended from Twitter. Based on 1000 overlapping annotations, their inter-annotator agreement (IAA) was $\\kappa $ = $0.93$ (Cohen\u2019s kappa BIBREF21), considered \"almost perfect agreement\" BIBREF22. Their IAA does not include disagreements resulting from the change of a user's status to or from \"unavailable\" in the time between the first and second annotations. Upon resolving the disagreements, 413 $(4\\%)$ users were annotated as \"bot,\" 7849 $(75.35\\%)$ as \"non-bot,\" and $20.69$ $(19.9\\%)$ as \"unavailable\"."
        ]
      },
      {
        "section_name": "Methods ::: Classification",
        "paragraphs": [
          "We used the 8262 \"bot\" and \"non-bot\" users in experiments to train and evaluate three classification systems. We split the users into $80\\%$ (training) and $20\\%$ (test) sets, stratified based on the distribution of \"bot\" and \"non-bot\" users. The training set includes $61,160,686$ tweets posted by 6610 users, and the held-out test set includes $15,703,735$ tweets posted by 1652 users. First, we evaluated Botometer on our held-out test set. Botometer is a publicly available bot detection system designed for political dot detection. It outputs a score between 0 and 1 for a user, representing the likelihood that a user is a bot. Second, we used the Botometer score for each user as a feature in training a gradient boosting classifier which is a decision tree-based ensemble machine learning algorithm with gradient boosting BIBREF23 and can be used to address class imbalance. To adapt the Botometer scores to our binary classification task, we set the threshold to $0.47$, based on performing 5-fold cross validation over the training set. To further address the class imbalance, we used the Synthetic Minority Over-sampling Technique (SMOTE)BIBREF24 to create artificial instances of \"bot\" users in the training set. We also performed 5-fold cross validation over the training set to optimize parameters for the classifier; we used exponential as the loss function, set the number of estimators to 200, and set the learning rate to $0.1$. Third, we used the classifier with an extended set of features that are not used by Botometer. Based on our manual annotation, we consider the following features to be potentially informative for distinguishing \"bot\" and \"non-bot\" users in health-related data:",
          "Tweet Diversity. Considering that \"bot\" users may re-post the same tweets, we used the ratio of a user's unique tweets to the total number of tweets posted by the user, where 0 indicates that the user has posted only the same tweet multiple times, and 1 indicates that each tweet is unique and has been posted only once. As Figure 1 illustrates, a subset of \"bot\" users (in the training set) have posted more of the same tweets than \"non-bot\" users.",
          "URL score. During manual annotation, we found that \"bot\" users' tweets frequently contain URLs (e.g., advertisements for health-related products, such as medications), so we use the ratio of the number of a user's tweets containing a URL to the total number of tweets posted by the user.",
          "Mean Daily Posts. Considering that \"bot\" users may post tweets more frequently than \"non-bot\" users, we measured the average and standard deviation of the number of tweets posted daily by a user. As Figure 1 illustrates, a subset of \"bot\" users post, on average, more tweets daily than \"non-bot\" users.",
          "Topics. Considering that \"bot\" users may post tweets about a limited number of targeted topics, we used topic modeling to the measure the heterogeneity of topics in a user's tweets. We used Latent Dirichlet Allocation (LDA)BIBREF25 to extract the top five topics from all of the users' 1000 most recent tweets (or all the tweets if a user has posted less than 1000 tweets), and used the mean of the weights of each topic across all of a user's tweets.",
          "Mean Post Length. Considering that the length of tweets may be different between \"bot\" and \"non-bot\" users, we used the mean word length and standard deviation of a user's tweets.",
          "Profile Picture. In addition to tweet-related features, we used features based on information in users' profiles. Considering that a \"non-bot\" user's profile picture may be more likely to contain a face, we used a publicly available system to detect the number of faces in a profile picture. As Figure 2, illustrates a face was not detected in the profile picture of the majority of \"non-bot\" users (in the training set), whereas at least one face was detected in the profile picture of the majority of \"bot\" users.",
          "User Name. Finally, we used a publicly available lexicon to detect the presence or absence of a person's name in a user name. As Figure 2 illustrates, the name of a person is present (1) in approximately half of \"non-bot\" user names, whereas the name of a person is absent (0) in the majority of \"bot\" user names."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Table 1 presents the precision, recall, and F$_1$-scores for the three bot detection systems evaluated on the held-out test set. The F$_1$-score for the \"bot\" class indicates that Botometer ($0.361$), designed for political bot detection, does not generalize well for detecting \"bot\" users in health-related data. Although the classifier with only the Botometer score as a feature ($0.286$) performs even worse than the default Botometer system, our extended feature set significantly improves performance ($0.700$). For imbalanced data, a higher F$_1$-score for the majority class is typical; in this case, it reflects that we have modeled the detection of \"bot\" users based on their natural distribution in health-related data."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "Our results demonstrate that (i) a publicly available bot detection system, designed for political bot detection, underperforms when applied to health-related data, and (ii) extending the system with simple features derived from health-related data significantly improves performance. An F$_1$-score of $0.700$ for the \"bot\" class represents a promising benchmark for automatic classification of highly imbalanced Twitter data and, in this case, for detecting users who are not reporting information about their own pregnancy on Twitter. Detecting such users is particularly important in the process of automatically selecting cohortsBIBREF26 from a population of social media users for user-level observational studiesBIBREF27.",
          "A brief error analysis of the 25 false negatives users (in the held-out test set of 1652 users) from the classifier with the extended feature set reveals that, while only one of the users is an account that automatically re-posts other users' tweets, the majority of the errors can be attributed to our broad definition of \"bot\" users, which includes health-related companies, organizations, forums, clubs, and support groups that are not posting personal information. These users are particularly challenging to automatically identify as \"bot\" users because, with humans posting on behalf of an online maternity store, or to a pregnancy forum, for example, their tweets resemble those posted by \"non-bot\" users. In future work, we will focus on deriving features for modeling the nuances that distinguish such \"bot\" users."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "As the use of social networks, such as Twitter, in health research is increasing, there is a growing need to validate the credibility of the data prior to making conclusions. The presence of bots in social media presents a crucial problem, particularly because bots may be customized to perpetuate specific biased or false information, or to execute advertising or marketing goals. We demonstrate that, while existing systems have been successful in detecting bots in other domains, they do not perform as well for detecting health-related bots. Using a machine learning algorithm on top of an existing bot detection system, and a set of simple derived features, we were able to significantly improve bot detection performance in health-related data. Introducing more features would likely contribute to further improving performance, which we will explore in future work."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This study was funded in part by the National Library of Medicine (NLM) (grant number: R01LM011176) and the National Institute on Drug Abuse (NIDA) (grant number: R01DA046619) of the National Institutes of Health (NIH). The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do the authors report results on only English datasets?",
        "question_id": "4379a3ece3fdb93b71db43f62833f5f724c49842",
        "nlp_background": "five",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "twitter",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Table 1 presents the precision, recall, and F$_1$-scores for the three bot detection systems evaluated on the held-out test set. The F$_1$-score for the \"bot\" class indicates that Botometer ($0.361$), designed for political bot detection, does not generalize well for detecting \"bot\" users in health-related data. Although the classifier with only the Botometer score as a feature ($0.286$) performs even worse than the default Botometer system, our extended feature set significantly improves performance ($0.700$). For imbalanced data, a higher F$_1$-score for the majority class is typical; in this case, it reflects that we have modeled the detection of \"bot\" users based on their natural distribution in health-related data."
              ],
              "highlighted_evidence": [
                "Table 1 presents the precision, recall, and F$_1$-scores for the three bot detection systems evaluated on the held-out test set. The F$_1$-score for the \"bot\" class indicates that Botometer ($0.361$), designed for political bot detection, does not generalize well for detecting \"bot\" users in health-related data. "
              ]
            },
            "annotation_id": "0bb652250238b8a2bc1611bbb65d3066b9af10cf",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "28f414828dbd453c48239b09751c59ab82373c6b",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "e5def8aa3b90557a540ea619defeb5c52810c940",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: The distribution of features for \u201dbot\u201d and \u201dnon-bot\u201d users in the training set."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: The distribution of faces detected in profile pictures and names detected in user names for \u201dbot\u201d and \u201dnonbot\u201d users in the training set."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Precision, recall, and F1-score for three bot detection systems evaluated on a held-out test set of 1652 users. Precision, recall, and F1-scores are reported for the \u201dnon-bot\u201d class (NB), the \u201dbot\u201d class (B), and an average of the two classes (avg.)."
      }
    ]
  },
  "1910.13793": {
    "title": "Time to Take Emoji Seriously: They Vastly Improve Casual Conversational Models",
    "abstract": "Graphical emoji are ubiquitous in modern-day online conversations. So is a single thumbs-up emoji able to signify an agreement, without any words. We argue that the current state-of-the-art systems are ill-equipped to correctly interpret these emoji, especially in a conversational context. However, in a casual context, the benefits might be high: a better understanding of users' utterances and more natural, emoji-rich responses.  ::: With this in mind, we modify BERT to fully support emoji, both from the Unicode Standard and custom emoji. This modified BERT is then trained on a corpus of question-answer (QA) tuples with a high number of emoji, where we're able to increase the 1-of-100 accuracy from 12.7% for the current state-of-the-art to 17.8% for our model with emoji support.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The prevalent use of emoji\u2014and their text-based precursors\u2014is mostly unaddressed in current natural language processing (NLP) tasks. The support of the Unicode Standard BIBREF0 for emoji characters in 2010 ushered in a wide-spread, international adoption of these graphical elements in casual contexts. Interpreting the meaning of these characters has been challenging however, since they take on multiple semantic roles BIBREF1.",
          "Whether or not emoji are used depends on the context of a text or conversation, with more formal settings generally being less tolerating. So is the popular aligned corpus Europarl BIBREF2 naturally devoid of emoji. Technical limitations, like no Unicode support, also limit its use. This in turn affects commonly used corpora, tokenizers, and pre-trained networks.",
          "Take for example the Ubuntu Dialog Corpus by BIBREF3, a commonly used corpus for multi-turn systems. This dataset was collected from an Internet Relay Chat (IRC) room casually discussing the operating system Ubuntu. IRC nodes usually support the ASCII text encoding, so there's no support for graphical emoji. However, in the 7,189,051 utterances, there are only 9946 happy emoticons (i.e. :-) and the cruelly denosed :) version) and 2125 sad emoticons.",
          "Word embeddings are also handling emoji poorly: Word2vec BIBREF4 with the commonly used pre-trained Google News vectors doesn't support the graphical emoji at all and vectors for textual emoticons are inconsistent. As another example with contextualized word embeddings, there are also no emoji or textual emoticons in the vocabulary list of BERT BIBREF5 by default and support for emoji is only recently added to the tokenizer. The same is true for GPT-2 BIBREF6. As all downstream systems, ranging from multilingual r\u00e9sum\u00e9 parsing to fallacy detection BIBREF7, rely on the completeness of these embeddings, this lack of emoji support can affect the performance of some of these systems.",
          "Another challenge is that emoji usage isn't static. Think of shifting conventions, different cultures, and newly added emoji to the Unicode list. Several applications also use their own custom emoji, like chat application Slack and streaming service Twitch. This becomes an issue for methods that leverage the Unicode description BIBREF8 or that rely on manual annotations BIBREF9.",
          "Our contribution with this paper is two-fold: firstly, we argue that the current use\u2014or rather non-existing use\u2014of emoji in the tokenizing, training, and the datasets themselves is insufficient. Secondly, we attempt to quantify the significance of incorporating emoji-based features by presenting a fine-tuned model. We then compare this model to a baseline, but without special attention to emoji.",
          "Section SECREF2 will start with an overview of work on emoji representations, emoji-based models and analysis of emoji usage. A brief introduction in conversational systems will also be given. Section SECREF3 will then look into popular datasets with and without emoji and then introduce the dataset we used.",
          "Our model will then be discussed in Section SECREF4, including the tokenization in Subsection SECREF4, training setup in Subsection SECREF6 and evaluation in Subsection SECREF10. This brings us to the results of our experiment, which is discussed in Section SECREF5 and finally our conclusion and future work are presented in Section SECREF6."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Inspired by the work on word representations, BIBREF8 presented Emoji2vec. This system generates a vector representation that's even compatible with the Word2vec representations, so they can be used together. This compatibility makes it easy to quickly incorporate Emoji2vec in existing systems that use Word2vec.",
          "The main drawback is that the emoji representations are trained on the Unicode descriptions. As a consequence, the representations only capture a limited meaning and do not account for shifting or incorrect use of emoji in the real world. For example, a peach emoji could be considered a double entendre, due to the resemblance to a woman's posterior. This is of course mentioned nowhere in the Unicode description. Which shows that the meaning of an emoji is how users interpret it, so also accidental incorrect use can cause issues BIBREF10.",
          "In spirit, BIBREF11 is similar to our work. Their system, DeepMoji, illustrates the importance of emoji for sentiment, emotion, and sarcasm classification. For these tasks, they used a dataset of 1246 million tweets containing at least one emoji. However, the authors use the emoji in those tweets not for the DeepMoji model input, but as an target label. With a slightly better agreement score than humans on the sentiment task, this supports our hypothesis that emoji carry the overall meaning of an utterance.",
          "BIBREF12 focus on a predicting one emoji based on the textual content. Interestingly, they looked into both English and Spanish tweets and compared a range of systems for a shared task at SemEval 2018: Multilingual Emoji Prediction. This shared task shows that emoji are getting more attention, but how their task is set up also highlights the current lack of high quality datasets with emoji.",
          "The same shared task was tackled by BIBREF13 and a year later by BIBREF14, which made use of a pre-processor and tokenizer from BIBREF15. This tokenizer replaces some emoji and emoticons by tokens related to their meaning. So is \\o/ replaced with <happy>. Naturally, this approach suffers from the same issues as described before. And even though it's really useful to have some basic, out-of-the-box support for emoticons thanks to this work, we think that this strategy is too reducing to capture subtle nuances.",
          "An analysis on the use of emoji on a global scale is done by BIBREF16. For this, the authors used geo-tagged tweets, which also allowed them to correlate the popularity of certain emoji with development indicators. This shows that the information encoded by emoji\u2014and of course the accompanying tweet\u2014is not limited to sentiment or emotion. Also BIBREF17 analyze the uses of emoji on social networks. Their approach consists of finding information networks between emoji and English words with LINE BIBREF18.",
          "An interesting aspect of emoji usage is analyzed by BIBREF19. In this work, the correlation between the use of Fitzpatrick skin tone BIBREF20 modifiers and the perceived skin tone of the user. This research shows that users are inclined to use representing emoji for themselves. BIBREF19 reported that no negative sentiment was associated with specific skin tone modifiers."
        ]
      },
      {
        "section_name": "Related work ::: Conversational AI systems",
        "paragraphs": [
          "The research on conversational AI has been focussing on various aspects, including building high-quality datasets BIBREF3, BIBREF25, BIBREF22, BIBREF23, BIBREF26, BIBREF27, adding customizable personalities BIBREF23, BIBREF28, BIBREF29 or conjoining the efforts with regard to different datasets, models and evaluation practices BIBREF26. With these combined efforts, businesses and the general public quickly began developing ambitious use-cases, like customer support agents on social networks.",
          "The proposed models in this field are diverse and largely depending on how the problem is formulated. When considering free-form responses, generative models like GPT BIBREF30, GPT-2 BIBREF6 or seq2seq BIBREF31 are appropriate. When the conversational task is modeled as a response selection task to pick the correct response out of $N$ candidates BIBREF32, BIBREF26, BIBREF33, this can be a language model like BERT BIBREF5 with a dedicated head."
        ]
      },
      {
        "section_name": "Emoji-rich datasets are hard to find",
        "paragraphs": [
          "Emoji are commonly used in casual settings, like on social media or in casual conversations. In conversations\u2014as opposed to relatively context-free social media posts\u2014an emoji alone can be an utterance by itself. And with a direct impact for some applications, like customer support, we focus on conversational datasets. We hope the conversational community has the most direct benefit from these emoji-enabled models. Of course, the conclusions we'll draw don't have to be limited to this field.",
          "Table TABREF1 gives an overview of frequently used and interesting conversational datasets. The lacuna of emoji-rich reference datasets was already mentioned in Section SECREF1 and is in our opinion one of the factors that emoji remain fairly underutilized.",
          "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances.",
          "The tweets were filtered on hyper links and personal identifiers, but Unicode emoji characters were preserved. As emoji are frequently used on Twitter, this resulted in a dataset with 170 of the 2000 tuples containing at least one emoji character."
        ]
      },
      {
        "section_name": "Fine-tuning BERT with emoji support",
        "paragraphs": [
          "We continue training of a multilingual BERT model BIBREF5 with new tokens for emoji and fine-tune this model and a baseline on the dataset discussed in Section SECREF4. This approach is explained in Subsection SECREF4 and the training itself is discussed in Subsection SECREF6. At last, the evaluation is then discussed in Subsection SECREF10."
        ]
      },
      {
        "section_name": "Fine-tuning BERT with emoji support ::: Tokenizing emoji",
        "paragraphs": [
          "We add new tokens to the BERT tokenizer for 2740 emoji from the Unicode Full Emoji List BIBREF0, as well as some aliases (in the form of :happy: as is a common notation for emoji). In total, 3627 emoji tokens are added to the vocabulary.",
          "We converted all UTF-8 encoded emoji to a textual alias for two reasons. First, this mitigates potential issues with text encodings that could drop the emoji. Second, this is also a common notation format for custom emoji, so we have one uniform token format. Aside from this attention to emoji, we use WordPiece embeddings BIBREF34 in the same manner as BIBREF5."
        ]
      },
      {
        "section_name": "Fine-tuning BERT with emoji support ::: Training and fine-tuning",
        "paragraphs": [
          "We start from 12-headed multilingual BERT (bert-base-multilingual-cased), which has 110M parameters. For the model with emoji support, the number of tokens is increased, so new vectors are appended at the end of the embeddings matrix. We then continue training on the language modeling task. We use the default configuration as is also used by BIBREF5 where randomly selected tokens are replaced by:",
          "a mask token: 80% chance,",
          "another random word: 10% chance,",
          "the original word: 10% chance.",
          "This model is trained for 100 epochs with the Adam BIBREF35 optimizer. The learning rate is set to the commonly used $lr=5\\cdot 10^{-5}$ and $\\epsilon = 10^{-8}$. No hyper-parameter tuning was done, as the results are acceptable on their own and are sufficient to allow conclusions for this paper. The loss is cross entropy BIBREF36.",
          "We then fine-tune both models, with and without emoji tokenization, on the sentence prediction task with a training set of 70%. We again use the Adam optimizer with the same settings and with binary cross entropy. In this case, the training was limited to 10 epochs. To mitigate the need for weighting and other class imbalance issues, we trained with pairs of positive and negative candidates. This is in contract to the evaluation, where 99 negative candidates are used. However, since each candidate is considered on its own merit during evaluation, this discrepancy won't affect the performance.",
          "For the formulation of the fine-tuning task, we use the same approach as BIBREF5. The first input sentence is joined with the second sentence, separated by a special [SEP] token, as can be seen in Figure FIGREF5. The model, with a specialized head for next sentence prediction, then outputs a correlation score."
        ]
      },
      {
        "section_name": "Fine-tuning BERT with emoji support ::: evaluation metrics",
        "paragraphs": [
          "Finally, our model is compared against the pre-trained version of BERT without special emoji tokens. We evaluate both this baseline and our model as a response selection task. In this case, the system has to select the most appropriate response out $N=100$ candidates. This is a more restricted problem, where the 1-of-100 accuracy BIBREF26 is a popular evaluation metric.",
          "Note that 1-in-100 accuracy gives a summary of the model performance for a particular dataset. Since not all 99 negative responses are necessarily bad choices, the resulting score is in part dependent on the prior distribution of a dataset. For example, BIBREF26 compares models for three datasets, where the best performing model has a score of 30.6 for OpenSubtitles BIBREF22 and 84.2 for AmazonQA BIBREF21.",
          "Aside from the 1-of-100 accuracy, we also present the mean rank of the correct response. Since the Twitter dataset is focussed on customer service, the correct response is sometimes similar to others. The mean rank, also out of $N=100$, can differentiate whether or not the model is still selecting good responses. For each input sentence, a rank of 1 means the positive response is ranked highest and is thus correctly selected and a rank of $N$ signifies the positive response was\u2014incorrectly\u2014considered the worst-matching candidate."
        ]
      },
      {
        "section_name": "Emoji provide additional context to response selection models",
        "paragraphs": [
          "After training of the language model with additional tokens for all Unicode emoji, we achieved a final perplexity of 2.0281. For comparison, the BERT model with 16 heads achieved a perplexity of 3.23 BIBREF5, but this is on a general dataset.",
          "For the sentence prediction task, Table TABREF11 shows the results of the baseline and our model with additional emoji tokens. For each of the 600 utterance pairs of the held-out test set, we added 99 randomly selected negative candidates, as described in Subsection SECREF10. The 1-out-of-100 accuracy measures how often the true candidate was correctly selected and the mean rank gives an indication of how the model performs if it fails to correctly select the positive candidate.",
          "The baseline correctly picks 12.7% of all candidate responses, out of 100. Given that the dataset is focussed on support questions and multiple responses are likely to be relevant, this baseline already performs admirable. For reference, a BERT model on the OpenSubtitles dataset BIBREF22 achieves a 1-of-100 accuracy between 12.2% and 17.5%, depending on the model size BIBREF26.",
          "Our model improves on this baseline with a 1-of-100 accuracy of 17.8%. The mean rank remains almost the same. This indicates that the emoji tokens do help with with picking the correct response, but don't really aide when selecting alternative suitable candidates. One possible explanation is that when emoji are used (this is the case for 8.75% of all utterances), including those tokens helps matching those based on those emoji and their meaning. When there are no emoji present, our model might be just as clueless as the baseline."
        ]
      },
      {
        "section_name": "Conclusion and future work",
        "paragraphs": [
          "In this paper we discussed the current state of emoji usage for conversational systems, which mainly lacks large baseline datasets. When looking at public datasets, conversational AI makers have to choose between dataset size and emoji support, with some datasets at least containing a few textual emoticons. We argued that this duality results in systems that fail to capture some information encoded in those emoji and in turn fail to respond adequately.",
          "Based on this premise, we investigated how a response selection system based on BERT can be modified to support emoji. We proposed a format and tokenization method that's indifferent to current Unicode specifications, and thus also works for datasets containing custom emoji.",
          "Evaluation of this emoji-aware system increased the 1-of-100 accuracy from 12.7% for the baseline to 17.8%. Thus showing that supporting emoji correctly can help increasing performance for more casual systems, without having to rely on labeling or external descriptions for those emoji.",
          "However, the lack of high-quality, general datasets with emoji limits our conversational model. Working towards larger casual conversational datasets would help both for our model, and for the conversational NLP community in general.",
          "We investigated the impact of emoji for conversational models and one could argue that these conclusions\u2014or even the BERT model\u2014can be generalized. We didn't investigate whether other tasks also benefited from our fine-tuned BERT model with the additional emoji tokens.",
          "During evaluation, we also observed utterances with only emoji characters. Even with our model that supports emoji, it could still be difficult to extract information like the subject of a conversation. Some of these utterances\u2014but not all\u2014were part of a larger conversation, so an interesting question could be how additional information affects the model.",
          ""
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "This work was supported by the Research Foundation - Flanders under EOS No. 30992574.",
          ""
        ]
      }
    ],
    "qas": [
      {
        "question": "Do the QA tuples fall under a specific domain?",
        "question_id": "0d9241e904bd2bbf5b9a6ed7b5fc929651d3e28e",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "conversations, which consist of at least one question and one free-form answer"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ],
              "highlighted_evidence": [
                "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ]
            },
            "annotation_id": "0be85a8f150b7ceaa945949a86ae2a7b1d91b5ae",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ],
              "highlighted_evidence": [
                "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ]
            },
            "annotation_id": "d2c4ffcc288939d106afb3439beb4527bf748ef2",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "For our models, we'll use a customer support dataset with a relatively high usage of emoji. The dataset contains 2000 tuples collected by BIBREF24 that are sourced from Twitter. They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ],
              "highlighted_evidence": [
                "They provide conversations, which consist of at least one question and one free-form answer. Some conversations are longer, in this case we ignored the previous context and only looked at the last tuple. This dataset illustrates that even when contacting companies, Twitter users keep using emoji relatively often, 8.75% of all utterances."
              ]
            },
            "annotation_id": "cef4585dca952a5d0e2ba75e6ffae6313438e57b",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Overview of the support for both graphical emoji and textual emoticons for common corpora. No support is indicated with an em bar (\u2014). Otherwise, we provide the fraction of utterances with at least one emoji or emoticon."
      },
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: Illustration of the use of BERT for a response selection task."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Illustration the tokenization process for BERT. The illustrated input is an actual sample from the test set. Notice the emoji is replaced by a descriptive token."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: 1-of-100 accuracy and mean ranking out of 100 candidates on the test set of 600 utterance tuples."
      }
    ]
  },
  "1906.11085": {
    "title": "Enhancing PIO Element Detection in Medical Text Using Contextualized Embedding",
    "abstract": "In this paper, we investigate a new approach to Population, Intervention and Outcome (PIO) element detection, a common task in Evidence Based Medicine (EBM). The purpose of this study is two-fold: to build a training dataset for PIO element detection with minimum redundancy and ambiguity and to investigate possible options in utilizing state of the art embedding methods for the task of PIO element detection. For the former purpose, we build a new and improved dataset by investigating the shortcomings of previously released datasets. For the latter purpose, we leverage the state of the art text embedding, Bidirectional Encoder Representations from Transformers (BERT), and build a multi-label classifier. We show that choosing a domain specific pre-trained embedding further optimizes the performance of the classifier. Furthermore, we show that the model could be enhanced by using ensemble methods and boosting techniques provided that features are adequately chosen.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Evidence-based medicine (EBM) is of primary importance in the medical field. Its goal is to present statistical analyses of issues of clinical focus based on retrieving and analyzing numerous papers in the medical literature BIBREF0 . The PubMed database is one of the most commonly used databases in EBM BIBREF1 .",
          "Biomedical papers, describing randomized controlled trials in medical intervention, are published at a high rate every year. The volume of these publications makes it very challenging for physicians to find the best medical intervention for a given patient group and condition BIBREF2 . Computational methods and natural language processing (NLP) could be adopted in order to expedite the process of biomedical evidence synthesis. Specifically, NLP tasks applied to well structured documents and queries can help physicians extract appropriate information to identify the best available evidence in the context of medical treatment.",
          "Clinical questions are formed using the PIO framework, where clinical issues are broken down into four components: Population/Problem (P), Intervention (I), Comparator (C), and Outcome (O). We will refer to these categories as PIO elements, by using the common practice of merging the C and I categories. In BIBREF3 a literature screening performed in 10 systematic reviews was studied. It was found that using the PIO framework can significantly improve literature screening efficacy. Therefore, efficient extraction of PIO elements is a key feature of many EBM applications and could be thought of as a multi-label sentence classification problem.",
          "Previous works on PIO element extraction focused on classical NLP methods, such as Naive Bayes (NB), Support Vector Machines (SVM) and Conditional Random Fields (CRF) BIBREF4 , BIBREF5 . These models are shallow and limited in terms of modeling capacity. Furthermore, most of these classifiers are trained to extract PIO elements one by one which is sub-optimal since this approach does not allow the use of shared structure among the individual classifiers.",
          "Deep neural network models have increased in popularity in the field of NLP. They have pushed the state of the art of text representation and information retrieval. More specifically, these techniques enhanced NLP algorithms through the use of contextualized text embeddings at word, sentence, and paragraph levels BIBREF6 , BIBREF7 , BIBREF8 , BIBREF9 , BIBREF10 , BIBREF11 .",
          "More recently, jin2018pico proposed a bidirectional long short term memory (LSTM) model to simultaneously extract PIO components from PubMed abstracts. To our knowledge, that study was the first in which a deep learning framework was used to extract PIO elements from PubMed abstracts.",
          "In the present paper, we build a dataset of PIO elements by improving the methodology found in BIBREF12 . Furthermore, we built a multi-label PIO classifier, along with a boosting framework, based on the state of the art text embedding, BERT. This embedding model has been proven to offer a better contextualization compared to a bidirectional LSTM model BIBREF9 ."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "In this study, we introduce PICONET, a multi-label dataset consisting of sequences with labels Population/Problem (P), Intervention (I), and Outcome (O). This dataset was created by collecting structured abstracts from PubMed and carefully choosing abstract headings representative of the desired categories. The present approach is an improvement over a similar approach used in BIBREF12 .",
          "Our aim was to perform automatic labeling while removing as much ambiguity as possible. We performed a search on April 11, 2019 on PubMed for 363,078 structured abstracts with the following filters: Article Types (Clinical Trial), Species (Humans), and Languages (English). Structured abstract sections from PubMed have labels such as introduction, goals, study design, findings, or discussion; however, the majority of these labels are not useful for P, I, and O extraction since most are general (e.g. methods) and do not isolate a specific P, I, O sequence. Therefore, in order to narrow down abstract sections that correspond to the P label, for example, we needed to find a subset of labels such as, but not limited to population, patients, and subjects. We performed a lemmatization of the abstract section labels in order to cluster similar categories such as subject and subjects. Using this approach, we carefully chose candidate labels for each P, I, and O, and manually looked at a small number of samples for each label to determine if text was representative.",
          "Since our goal was to collect sequences that are uniquely representative of a description of Population, Intervention, and Outcome, we avoided a keyword-based approach such as in BIBREF12 . For example, using a keyword-based approach would yield a sequence labeled population and methods with the label P, but such abstract sections were not purely about the population and contained information about the interventions and study design making them poor candidates for a P label. Thus, we were able to extract portions of abstracts pertaining to P, I, and O categories while minimizing ambiguity and redundancy. Moreover, in the dataset from BIBREF12 , a section labeled as P that contained more than one sentence would be split into multiple P sentences to be included in the dataset. We avoided this approach and kept the full abstract sections. The full abstracts were kept in conjunction with our belief that keeping the full section retains more feature-rich sequences for each sequence, and that individual sentences from long abstract sections can be poor candidates for the corresponding label.",
          "For sections with labels such as population and intervention, we created a mutli-label. We also included negative examples by taking sentences from sections with headings such as aim. Furthermore, we cleaned the remaining data with various approaches including, but not limited to, language identification, removal of missing values, cleaning unicode characters, and filtering for sequences between 5 and 200 words, inclusive."
        ]
      },
      {
        "section_name": "Background",
        "paragraphs": [
          "BERT (Bidirectional Encoder Representations from Transformers) is a deep bidirectional attention text embedding model. The idea behind this model is to pre-train a bidirectional representation by jointly conditioning on both left and right contexts in all layers using a transformer BIBREF13 , BIBREF9 . Like any other language model, BERT can be pre-trained on different contexts. A contextualized representation is generally optimized for downstream NLP tasks.",
          "Since its release, BERT has been pre-trained on a multitude of corpora. In the following, we describe different BERT embedding versions used for our classification problem. The first version is based on the original BERT release BIBREF9 . This model is pre-trained on the BooksCorpus (800M words) BIBREF14 and English Wikipedia (2,500M words). For Wikipedia, text passages were extracted while lists were ignored. The second version is BioBERT BIBREF15 , which was trained on biomedical corpora: PubMed (4.5B words) and PMC (13.5B words)."
        ]
      },
      {
        "section_name": "The Model",
        "paragraphs": [
          "The classification model is built on top of the BERT representation by adding a dense layer corresponding to the multi-label classifier with three output neurons corresponding to PIO labels. In order to insure that independent probabilities are assigned to the labels, as a loss function we have chosen the binary cross entropy with logits (BCEWithLogits) defined by DISPLAYFORM0 ",
          "where t and y are the target and output vectors, respectively; n is the number of independent targets (n=3). The outputs are computed by applying the logistic function to the weighted sums of the last hidden layer activations, s, DISPLAYFORM0 DISPLAYFORM1 ",
          "For the original BERT model, we have chosen the smallest uncased model, Bert-Base. The model has 12 attention layers and all texts are converted to lowercase by the tokenizer BIBREF9 . The architecture of the model is illustrated in Figure FIGREF7 .",
          "Using this framework, we trained the model using the two pretrained embedding models described in the previous section. It is worth to mention that the embedding is contextualized during the training phase. For both models, the pretrained embedding layer is frozen during the first epoch (the embedding vectors are not updated). After the first epoch, the embedding layer is unfrozen and the vectors are fine-tuned for the classification task during training. The advantage of this approach is that few parameters need to be learned from scratch BIBREF16 , BIBREF11 , BIBREF9 ."
        ]
      },
      {
        "section_name": "Performance Comparison",
        "paragraphs": [
          "In order to quantify the performance of the classification model, we computed the precision and recall scores. On average, it was found that the model leads to better results when trained using the BioBERT embedding. In addition, the performance of the PIO classifier was measured by averaging the three Area Under Receiver Operating Characteristic Curve (ROC_AUC) scores for P, I, and O. The ROC_AUC score of 0.9951 was obtained by the model using the general BERT embedding. This score was improved to 0.9971 when using the BioBERT model pre-trained on medical context. The results are illustrated in Figure FIGREF9 ."
        ]
      },
      {
        "section_name": "Model Boosting ",
        "paragraphs": [
          "We further applied ensemble methods to enhance the model. This approach consists of combining predictions from base classifiers with features of the input data to increase the accuracy of the model BIBREF17 .",
          "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. In this study, we use a library implemented by Microsoft BIBREF18 . In our model, we learn a linear combination of the prediction given by the base classifiers and the input text features to predict the labels. As features, we consider the average term frequency-inverse document frequency (TF-IDF) score for each instance and the frequency of occurrence of quantitative information elements (QIEF) (e.g. percentage, population, dose of medicine). Finally, the output of the binary cross entropy with logits layer (predicted probabilities for the three classes) and the feature information are fed to the LGBM.",
          "We train the base classifier using the original training dataset, using INLINEFORM0 of the whole data as training dataset, and use a five-fold cross-validation framework to train the LGBM on the remaining INLINEFORM1 of the data to avoid any information leakage. We train the LGBM on four folds and test on the excluded one and repeat the process for all five folds.",
          "The results of the LGBM classifier for the different boosting frameworks and the scores from the base classifiers are illustrated in Table TABREF14 . The highest average ROC_AUC score of 0.9998 is obtained in the case of combining the two base learners along with the TF-IDF and QIEF features."
        ]
      },
      {
        "section_name": "Discussion and Conclusion",
        "paragraphs": [
          "In this paper, we presented an improved methodology to extract PIO elements, with reduced ambiguity, from abstracts of medical papers. The proposed technique was used to build a dataset of PIO elements that we call PICONET. We further proposed a model of PIO elements classification using state of the art BERT embedding. It has been shown that using the contextualized BioBERT embedding improved the accuracy of the classifier. This result reinforces the idea of the importance of embedding contextualization in subsequent classification tasks in this specific context.",
          "In order to enhance the accuracy of the model, we investigated an ensemble method based on the LGBM algorithm. We trained the LGBM model, with the above models as base learners, to optimize the classification by learning a linear combination of the predicted probabilities, for the three classes, with the TF-IDF and QIEF scores. The results indicate that these text features were adequate for boosting the contextualized classification model. We compared the performance of the classifier when using the features with one of the base learners and the case where we combine the base learners along with the features. We obtained the best performance in the latter case.",
          "The present work resulted in the creation of a PIO elements dataset, PICONET, and a classification tool. These constitute an important component of our system of automatic mining of medical abstracts. We intend to extend the dataset to full medical articles. The model will be modified to take into account the higher complexity of full text data and more efficient features for model boosting will be investigated."
        ]
      }
    ],
    "qas": [
      {
        "question": "what boosting techniques were used?",
        "question_id": "04796aaa59eeb2176339c0651838670fd916074d",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Light Gradient Boosting Machine (LGBM)"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. In this study, we use a library implemented by Microsoft BIBREF18 . In our model, we learn a linear combination of the prediction given by the base classifiers and the input text features to predict the labels. As features, we consider the average term frequency-inverse document frequency (TF-IDF) score for each instance and the frequency of occurrence of quantitative information elements (QIEF) (e.g. percentage, population, dose of medicine). Finally, the output of the binary cross entropy with logits layer (predicted probabilities for the three classes) and the feature information are fed to the LGBM."
              ],
              "highlighted_evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees."
              ]
            },
            "annotation_id": "1923f34f957352c90e9aa26eefe1b1299ab58121",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Light Gradient Boosting Machine"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. In this study, we use a library implemented by Microsoft BIBREF18 . In our model, we learn a linear combination of the prediction given by the base classifiers and the input text features to predict the labels. As features, we consider the average term frequency-inverse document frequency (TF-IDF) score for each instance and the frequency of occurrence of quantitative information elements (QIEF) (e.g. percentage, population, dose of medicine). Finally, the output of the binary cross entropy with logits layer (predicted probabilities for the three classes) and the feature information are fed to the LGBM."
              ],
              "highlighted_evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. "
              ]
            },
            "annotation_id": "863dc2194c86e3a786a38819fc3cb96df5fe0565",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Light Gradient Boosting Machine"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. In this study, we use a library implemented by Microsoft BIBREF18 . In our model, we learn a linear combination of the prediction given by the base classifiers and the input text features to predict the labels. As features, we consider the average term frequency-inverse document frequency (TF-IDF) score for each instance and the frequency of occurrence of quantitative information elements (QIEF) (e.g. percentage, population, dose of medicine). Finally, the output of the binary cross entropy with logits layer (predicted probabilities for the three classes) and the feature information are fed to the LGBM."
              ],
              "highlighted_evidence": [
                "We investigate an important family of ensemble methods known as boosting, and more specifically a Light Gradient Boosting Machine (LGBM) algorithm, which consists of an implementation of fast gradient boosting on decision trees. "
              ]
            },
            "annotation_id": "cfd5caff8b3e463423fa306493380bbe850600e5",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Number of occurrences of each category P, I and O in abstracts."
      },
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Structure of the classifier."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Performance of the classifiers in terms of ROC AUC and F1 scores."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: ROC AUC scores and confusion matrices."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: An illustration of the LGBM framework: : combining the two base models and the TF-IDF and QIEF features."
      }
    ]
  },
  "1908.09892": {
    "title": "Does BERT agree? Evaluating knowledge of structure dependence through agreement relations",
    "abstract": "Learning representations that accurately model semantics is an important goal of natural language processing research. Many semantic phenomena depend on syntactic structure. Recent work examines the extent to which state-of-the-art models for pre-training representations, such as BERT, capture such structure-dependent phenomena, but is largely restricted to one phenomenon in English: number agreement between subjects and verbs. We evaluate BERT's sensitivity to four types of structure-dependent agreement relations in a new semi-automatically curated dataset across 26 languages. We show that both the single-language and multilingual BERT models capture syntax-sensitive agreement patterns well in general, but we also highlight the specific linguistic contexts in which their performance degrades.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Learning general-purpose sentence representations which accurately model sentential semantic content is a current goal of natural language processing research BIBREF0, BIBREF1, BIBREF2, BIBREF3. A prominent and successful approach is to pre-train neural networks to encode sentences into fixed length vectors BIBREF4, BIBREF5, with common architecture choices based on recurrent neural networks BIBREF6, BIBREF7, convolutional neural networks, or transformers BIBREF8. Many core linguistic phenomena that one would like to model in general-purpose sentence representations depend on syntactic structure BIBREF9, BIBREF10. Despite the fact that none of the aforementioned architectures have explicit syntactic structural representations, there is some evidence that these models can approximate such structure-dependent phenomena under certain conditions BIBREF11, BIBREF12, BIBREF13, BIBREF14, in addition to their widespread success in practical tasks.",
          "The recently introduced BERT model BIBREF15, which is based on transformers, achieves state-of-the-art results on eleven natural language processing tasks. In this work, we assess BERT's ability to learn structure-dependent linguistic phenomena of agreement relations. To test whether BERT is sensitive to agreement relations, we use the cloze test BIBREF16, in which we mask out one of two words in an agreement relation and ask BERT to predict the masked word, one of the two tasks on which BERT is initially trained.",
          "BIBREF17 adapted the experimental setup of BIBREF13, BIBREF11 and BIBREF18 to use the cloze test to assess BERT's sensitivity to number agreement in English subject-verb agreement relations. The results showed that the single-language BERT model performed surprisingly well at this task (above 80% accuracy in all experiments), even when there were multiple \u201cdistractors\u201d in the sentence (other nouns that differed from the subject in number). This suggests that BERT is actually learning to approximate structure-dependent computation, and not simply relying on flawed heuristics.",
          "However, English subject-verb agreement is a rather restricted phenomenon, with the majority of verbs having only two inflected forms and only one morphosyntactic feature (number) involved. To what extent does Goldberg's BIBREF17 result hold for subject-verb agreement in other languages, including more morphologically rich ones, as well as for other types of agreement relations? Building on Goldberg's BIBREF17 work, we expand the experiment to 26 languages and four types of agreement relations, which include more challenging examples.",
          "In Section 2, we define what is meant by agreement relations and outline the particular agreement relations under study. Section 3 introduces our newly curated cross-linguistic dataset of agreement relations, while section 4 discusses our experimental setup. We report the results of our experiments in section 5. All data and code are available at https://github.com/geoffbacon/does-bert-agree."
        ]
      },
      {
        "section_name": "Structure-dependent agreement relations",
        "paragraphs": [
          "Agreement phenomena are an important and cross-linguistically common property of natural languages, and as such have been extensively studied in syntax and morphology BIBREF19. Languages often express grammatical features, such as number and gender, through inflectional morphology. An agreement relation is a morphophonologically overt co-variance in feature values between two words in a syntactic relationship BIBREF20. In other words, agreement refers to when the morphosyntactic features of one word are reflected in its syntactic dependents. In this way, agreement relations are overt markers of covert syntactic structure. Thus, evaluating a model's ability to capture agreement relations is also an evaluation of its ability to capture syntactic structure.",
          "Following BIBREF21, we call the syntactically dependent word the \u201ctarget\u201d of the agreement relation, and the word with which it agrees we call the \u201ccontroller\u201d. An example of an agreement relation in English is given in (UNKREF2), in which the inflected form of the verb be (are) reflects the plural number of its syntactic head keys. In all examples in this section, the controller and target are given in bold. In this example, keys is the controller and are is the target of the agreement relation.",
          "The keys to the door are on the table.",
          "The agreement relation in (UNKREF2) is between a subject and its verb, but there are other types of agreement relations. In addition to subject-verb agreement, three other types of agreement relations are cross-linguistically common: agreement of noun with i) determiner, ii) attributive adjective and iii) predicate adjective BIBREF22. The latter two types are distinguished by whether the adjective modifies the noun within a noun phrase or whether it is predicated of the subject of a clause. The first two types are sometimes categorized as nominal concord rather than agreement, but for our purposes this is merely a difference in terminology.",
          "The morphosyntactic feature in the agreement relation in (UNKREF2) is number, a feature that is cross-linguistically common in agreement systems. In addition to number, the most commonly involved in agreement relations are gender, case and person BIBREF22.",
          "With its comparatively limited inflectional morphology, English only exhibits subject-verb and determiner agreement (in demonstratives, \u201cthis\u201d vs. \u201cthese\u201d) and even then only agrees for number. Languages with richer inflectional morphology tend to display more agreement types and involve more features. French, for example, employs all four types of agreement relations. Examples are given in (UNKREF3)-(UNKREF6). The subject and verb in (UNKREF3) agree for number, while the noun and determiner in (UNKREF4), the noun and attributive adjective in (UNKREF5) and the subject and predicated adjective in (UNKREF6) agree for both number and gender.",
          "`The keys to the door are on the table.'",
          "`I can see the keys.'",
          "`I no longer want the completely broken keys.'",
          "`The keys to the door are broken.'",
          "Previous work using agreement relations to assess knowledge of syntactic structure in modern neural networks has focussed on subject-verb agreement in number BIBREF17, BIBREF11, BIBREF13. In our work, we study all four types of agreement relations and all four features discussed above. Moreover, previous work using any method to assess BERT's knowledge of syntactic structure has focussed exclusively on the single-language English model BIBREF23, BIBREF17, BIBREF24, BIBREF25, BIBREF26, BIBREF27. We expand this line of work to 26 languages. Not all languages in our sample exhibit all four types of agreement nor use all four features examined, but they all exhibit at least one of the agreement types involving at least one of the features."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "Our study requires two types of data. First, we need sentences containing agreement relations. We mask out one of the words in the agreement relation and ask BERT to predict the masked word. We are interested in BERT's ability to predict words that respect the agreement relation, that is, words which share the morphosyntactic features of the word with which it agrees. To measure this, we need to know the feature values for each word in BERT's vocabulary. This is our second type of data. Throughout this paper, we refer to the first type of data as the cloze data, and the second as the feature data.",
          "In the design of our datasets, we followed two principles. First, we chose data sources that are available across multiple languages, because we are interested in cross-linguistic generality. The languages in this study are those with sufficiently large data sources that also appear in the multilingual BERT model. Second, we use naturally-occurring data (cf. BIBREF18)."
        ]
      },
      {
        "section_name": "Data ::: Cloze data",
        "paragraphs": [
          "We sourced our cloze data from version 2.4 of the Universal Dependencies treebanks BIBREF28. The UD treebanks use a consistent schema across all languages to annotate naturally occurring sentences at the word level with rich grammatical information. We used the part-of-speech and dependency information to identify potential agreement relations. Specifically, we identified all instances of subject-verb, noun-determiner, noun-attributive adjective and subject-predicate adjective word pairs. We then used the morphosyntactic annotations for number, gender, case and person to filter out word pairs that disagree due to errors in the underlying data source (e.g. one is annotated as plural while the other is singular) or that are not annotated for any of the four features.",
          "This method is language-agnostic, but due to errors in the underlying UD corpora, yielded some false positives (e.g. predicate adjective agreement in English). To correct for this, we consulted reference grammars of each language to note which of the four types of agreement exist in the language. We removed all examples that are of the wrong type for the language (8% of harvested examples). Across the 26 languages, we curated almost one million cloze examples. Their breakdown across agreement type and language is shown in Tables 1 and 2.",
          "In all four types of agreement studied, the controller of the agreement is a noun or pronoun, while the target can be a determiner, adjective or verb. Because of this part-of-speech restriction, we chose to mask out the controller in every cloze example so that BERT is evaluated against the same vocabulary across all four types. This also means that we only need to collect feature data on nouns and pronouns."
        ]
      },
      {
        "section_name": "Data ::: Feature data",
        "paragraphs": [
          "Our feature data comes from both the UD and the UniMorph projects BIBREF29. The UniMorph project also uses a consistent schema across all languages to annotate word types with morphological features. Although this schema is not the same as that used in UD, there is a deterministic mapping between the two BIBREF30.",
          "In this work, a word can take on a particular bundle of feature values (e.g. singular, feminine and third person) if it appears with those features in either UD or UniMorph. The UniMorph data directly specifies what bundles of feature values a word can take on. For the Universal Dependencies data, we say a word can take on a particular bundle if we ever see it with that bundle of feature values in a Universal Dependencies corpus for that language. Both sources individually allow for a word to have multiple feature bundles (e.g. sheep in English can be singular or plural). In these cases, we keep all possible feature bundles. Finally, we filter out words that do not appear in BERT's vocabulary."
        ]
      },
      {
        "section_name": "Experiment",
        "paragraphs": [
          "Our experiment is designed to measure BERT's ability to model syntactic structure. Our experimental set up is an adaptation of that of BIBREF17. As in previous work, we mask one word involved in an agreement relation and ask BERT to predict it. BIBREF17, following BIBREF13, considered a correct prediction to be one in which the masked word receives a higher probability than other inflected forms of the lemma. For example, when dogs is masked, a correct response gives more probability to dogs than dog. This evaluation leaves open the possibility that selectional restrictions or frequency are responsible for the results rather than sensitivity to syntactic structure BIBREF11. To remove this possibility, we take into account all words of the same part-of-speech as the masked word. Concretely, we consider a correct prediction to be one in which the average probability of all possible correct words is higher than that of all incorrect words. By \u201ccorrect words\u201d, we mean words with the exact same feature values and the same part of speech as the masked word. By \u201cincorrect words\u201d, we mean words of the same part of speech as the masked word but that differ from the masked word with respect to at least one feature value. We ignore cloze examples in which there are fewer than 10 possible correct and 10 incorrect answers in our feature data. The average example in our cloze data is evaluated using 1,468 words, compared with 2 in BIBREF17.",
          "Following BIBREF17, we use the pre-trained BERT models from the original authors, but through the PyTorch implementation. BIBREF17 showed that in his experiments the base BERT model performed better than the larger model, so we restrict our attention to the base model. For English, we use the model trained only on English data, whereas for all other languages we use the multilingual model."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Overall, BERT performs well on our experimental task, suggesting that it is able to model syntactic structure. BERT was correct in 94.3% of all cloze examples. This high performance is found across all four types of agreement relations. Figure FIGREF13 shows that BERT performed above 90% accuracy in each type. Performance is best on determiner and attributive agreement relations, while worst on subject-verb and predicate adjective.",
          "In figure FIGREF14, we see BERT's performance for each language. BERT performs well for the majority of languages, although some fare much worse than others. It is important to note that it is an unfair comparison because even though the datasets were curated using the same methodology, each language's dataset is different. It is possible, for example, that the examples we have for Basque are simply harder than they are for Portuguese.",
          "Finally, we ask how BERT's performance is affected by distance between the controller and the target, as well as the number of distractors. Figure FIGREF15 shows BERT's performance, aggregated over all languages and types, as a function of the distance involved in the agreement, while figure FIGREF16 shows the same for number of distractors. There is a slight but consistent decrease in performance as the distance and the number of distractors increase. The decline in performance begins later in figure FIGREF16 but drops more rapidly once it does."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Given the success of large pre-trained language representation models on downstream tasks, it is not surprising that that the field wants to understand the extent of their linguistic knowledge. In our work, we looked exclusively at the predictions BERT makes at the word level. BIBREF24 and BIBREF26 examined the internal representations of BERT to find that syntactic concepts are learned at lower levels than semantic concepts. BIBREF23 are also interested in syntactic knowledge and propose a method to evaluate whether entire syntax trees are embedded in a linear transformation of a model's word representation space, finding that BERT does capture such information. As a complementary approach, BIBREF27 studied the attention mechanism of BERT, finding clear correlates with interpretable linguistic structures such as direct objects, and suggest that BERT's success is due in part to its syntactic awareness. However, by subjecting it to existing psycholinguistic tasks, BIBREF32 found that BERT fails in its ability to understand negation. In concurrent work, BIBREF33 show that BERT does not consistently outperform LSTM-based models on English subject-verb agreement tasks."
        ]
      },
      {
        "section_name": "Conclusions & future work",
        "paragraphs": [
          "Core linguistic phenomena depend on syntactic structure. Yet current state-of-the-art models in language representations, such as BERT, do not have explicit syntactic structural representations. Previous work by BIBREF17 showed that BERT captures English subject-verb number agreement well despite this lack of explicit structural representation. We replicated this result using a different evaluation methodology that addresses shortcomings in the original methodology and expanded the study to 26 languages. Our study further broadened existing work by considering the most cross-linguistically common agreement types as well as the most common morphosyntactic features. The main result of this expansion into more languages, types and features is that BERT, without explicit syntactic structure, is still able to capture syntax-sensitive agreement patterns well. However, our analysis highlights an important qualification of this result. We showed that BERT's ability to model syntax-sensitive agreement relations decreases slightly as the dependency becomes longer range, and as the number of distractors increases. We release our new curated cross-linguistic datasets and code in the hope that it is useful to future research that may probe why this pattern appears.",
          "The experimental setup we used has some known limitations. First, in certain languages some of the cloze examples we studied contain redundant information. Even when one word from an agreement relation is masked out, other cues remain in the sentence (e.g. when masking out the noun for a French attributive adjective agreement relation, number information is still available from the determiner). To counter this in future work, we plan to run our experiment twice, masking out the controller and then the target. Second, we used a different evaluation scheme than previous work BIBREF17 by averaging BERT's predictions over many word types and plan to compare both schemes in future work."
        ]
      }
    ],
    "qas": [
      {
        "question": "What types of agreement relations do they explore?",
        "question_id": "654fe0109502f2ed2dc8dad359dbbce4393e03dc",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "BERT",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "subject-verb",
                "noun-determiner",
                "noun-attributive adjective",
                "subject-predicate adjective"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We sourced our cloze data from version 2.4 of the Universal Dependencies treebanks BIBREF28. The UD treebanks use a consistent schema across all languages to annotate naturally occurring sentences at the word level with rich grammatical information. We used the part-of-speech and dependency information to identify potential agreement relations. Specifically, we identified all instances of subject-verb, noun-determiner, noun-attributive adjective and subject-predicate adjective word pairs. We then used the morphosyntactic annotations for number, gender, case and person to filter out word pairs that disagree due to errors in the underlying data source (e.g. one is annotated as plural while the other is singular) or that are not annotated for any of the four features."
              ],
              "highlighted_evidence": [
                "Specifically, we identified all instances of subject-verb, noun-determiner, noun-attributive adjective and subject-predicate adjective word pairs. "
              ]
            },
            "annotation_id": "78b3096097e3ac98c1ab1b83d8bc583d699f7b6a",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The subject and verb in (UNKREF3) agree for number, while the noun and determiner in (UNKREF4), the noun and attributive adjective in (UNKREF5) and the subject and predicated adjective in (UNKREF6) agree for both number and gender."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "With its comparatively limited inflectional morphology, English only exhibits subject-verb and determiner agreement (in demonstratives, \u201cthis\u201d vs. \u201cthese\u201d) and even then only agrees for number. Languages with richer inflectional morphology tend to display more agreement types and involve more features. French, for example, employs all four types of agreement relations. Examples are given in (UNKREF3)-(UNKREF6). The subject and verb in (UNKREF3) agree for number, while the noun and determiner in (UNKREF4), the noun and attributive adjective in (UNKREF5) and the subject and predicated adjective in (UNKREF6) agree for both number and gender.",
                "`The keys to the door are on the table.'",
                "`I can see the keys.'",
                "`I no longer want the completely broken keys.'",
                "`The keys to the door are broken.'"
              ],
              "highlighted_evidence": [
                " The subject and verb in (UNKREF3) agree for number, while the noun and determiner in (UNKREF4), the noun and attributive adjective in (UNKREF5) and the subject and predicated adjective in (UNKREF6) agree for both number and gender.",
                "The subject and verb in (UNKREF3) agree for number, while the noun and determiner in (UNKREF4), the noun and attributive adjective in (UNKREF5) and the subject and predicated adjective in (UNKREF6) agree for both number and gender.\n\n`The keys to the door are on the table.'\n\n`I can see the keys.'\n\n`I no longer want the completely broken keys.'\n\n`The keys to the door are broken.'"
              ]
            },
            "annotation_id": "be4d9736d02be63c5aaba8b9765bc82adf2c952f",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Subject-verb agreement,  noun-determiner agreement,  noun -attributive adjective agreement and noun-predicate adjective agreement.",
              "evidence": [
                "The agreement relation in (UNKREF2) is between a subject and its verb, but there are other types of agreement relations. In addition to subject-verb agreement, three other types of agreement relations are cross-linguistically common: agreement of noun with i) determiner, ii) attributive adjective and iii) predicate adjective BIBREF22. The latter two types are distinguished by whether the adjective modifies the noun within a noun phrase or whether it is predicated of the subject of a clause. The first two types are sometimes categorized as nominal concord rather than agreement, but for our purposes this is merely a difference in terminology.",
                "Previous work using agreement relations to assess knowledge of syntactic structure in modern neural networks has focussed on subject-verb agreement in number BIBREF17, BIBREF11, BIBREF13. In our work, we study all four types of agreement relations and all four features discussed above. Moreover, previous work using any method to assess BERT's knowledge of syntactic structure has focussed exclusively on the single-language English model BIBREF23, BIBREF17, BIBREF24, BIBREF25, BIBREF26, BIBREF27. We expand this line of work to 26 languages. Not all languages in our sample exhibit all four types of agreement nor use all four features examined, but they all exhibit at least one of the agreement types involving at least one of the features."
              ],
              "highlighted_evidence": [
                " In addition to subject-verb agreement, three other types of agreement relations are cross-linguistically common: agreement of noun with i) determiner, ii) attributive adjective and iii) predicate adjective BIBREF22. ",
                "In our work, we study all four types of agreement relations and all four features discussed above. "
              ]
            },
            "annotation_id": "c881baf071de6075ed860daa084c667f6ed05b20",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Number of cloze examples per agreement type in our new cross-linguistic dataset on agreement relations. Previous work has largely focused on subjectverb agreement in English."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Language statistics of our new cross-linguistic dataset on agreement relations. Most previous work has focused on English. \u201c# cloze\u201d is the number of cloze examples curated for each language, and \u201c# feature bundles\u201d is the number of unique sets of morphosyntactic features harvested for word types in BERT\u2019s vocabulary."
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Accuracy per agreement type aggregated across all languages. In all four types, BERT performed above 90% accuracy. Accuracy is slightly lower for predicate adjectives and subject-verb agreement relations, which typically have longer distance dependencies. Error bars are bootstrapped 95% confidence intervals."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Accuracy as a function of distance between controller and target of agreement, aggregated across all languages and agreement types. BERT is relatively robust to longer-distance dependencies but does show a small decrease as the dependency length increases. Error bars are bootstrapped 95% confidence intervals."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Accuracy per language aggregated across all four agreement types. In all 26 languages, BERT performs above 60% accuracy. In most languages BERT performs above 90% accuracy, although performance is significantly lower for a handful of languages. Error bars are bootstrapped 95% confidence intervals."
      },
      {
        "file": "6-Figure4-1.png",
        "caption": "Figure 4: Accuracy as a function of number of distractors (other nouns in the sentence with different feature values), aggregated across all languages and agreement types. As with distance, BERT is quite robust to distractors although there is a more noticeable decrease in accuracy as more distractors are present. Error bars are bootstrapped 95% confidence intervals."
      }
    ]
  },
  "2004.01970": {
    "title": "BAE: BERT-based Adversarial Examples for Text Classification",
    "abstract": "Modern text classification models are susceptible to adversarial examples, perturbed versions of the original text indiscernible by humans but which get misclassified by the model. We present BAE, a powerful black box attack for generating grammatically correct and semantically coherent adversarial examples. BAE replaces and inserts tokens in the original text by masking a portion of the text and leveraging a language model to generate alternatives for the masked tokens. Compared to prior work, we show that BAE performs a stronger attack on three widely used models for seven text classification datasets.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Recent studies have shown the vulnerability of ML models to adversarial attacks, small perturbations which lead to misclassification of inputs. Adversarial example generation in NLP BIBREF0 is more challenging than in common computer vision tasks BIBREF1, BIBREF2, BIBREF3 due to two main reasons: the discrete nature of input space and ensuring semantic coherence with the original sentence. A major bottleneck in applying gradient based BIBREF4 or generator model BIBREF5 based approaches to generate adversarial examples in NLP is the backward propagation of the perturbations from the continuous embedding space to the discrete token space.",
          "Recent works for attacking text models rely on introducing errors at the character level in words BIBREF6, BIBREF7 or adding and deleting words BIBREF8, BIBREF9, BIBREF10, etc. for creating adversarial examples. These techniques often result in adversarial examples which are unnatural looking and lack grammatical correctness, and thus can be easily identified by humans.",
          "TextFooler BIBREF11 is a black-box attack, that uses rule based synonym replacement from a fixed word embedding space to generate adversarial examples. These adversarial examples do not account for the overall semantics of the sentence, and consider only the token level similarity using word embeddings. This can lead to out-of-context and unnaturally complex replacements (see Table ), which can be easily identifiable by humans.",
          "The recent advent of powerful language models BIBREF12, BIBREF13 in NLP has paved the way for using them in various downstream applications. In this paper, we present a simple yet novel technique: BAE (BERT-based Adversarial Examples), which uses a language model (LM) for token replacement to best fit the overall context. We perturb an input sentence by either replacing a token or inserting a new token in the sentence, by means of masking a part of the input and using a LM to fill in the mask (See Figure FIGREF1). BAE relies on the powerful BERT masked LM for ensuring grammatical correctness of the adversarial examples. Our attack beats the previous baselines by a large margin and confirms the inherent vulnerabilities of modern text classification models to adversarial attacks. Moreover, BAE produces more richer and natural looking adversarial examples as it uses the semantics learned by a LM.",
          "To the best of our knowledge, we are the first to use a LM for adversarial example generation. We summarize our major contributions as follows:",
          "",
          "We propose BAE, a novel strategy for generating natural looking adversarial examples using a masked language model.",
          "We introduce 4 BAE attack modes, all of which are almost always stronger than previous baselines on 7 text classification datasets.",
          "We show that, surprisingly, just a few replace/insert operations can reduce the accuracy of even a powerful BERT-based classifier by over $80\\%$ on some datasets.",
          ""
        ]
      },
      {
        "section_name": "Methodology",
        "paragraphs": [
          "Problem Definition We are given a dataset $(S,Y) = \\lbrace (\\mathbb {S}_1,y_1),(\\mathbb {S}_2,y_2)\\dots (\\mathbb {S}_m,y_m)\\rbrace $ and a trained classification model $C:\\mathbb {S}\\rightarrow Y$. We assume the soft-label black-box setting where the attacker can only query the classifier for output probabilities on a given input, and does not have access to the model parameters, gradients or training data. For an input pair $(\\mathbb {S},y)$, we want to generate an adversarial example $\\mathbb {S}_{adv}$ such that $C(\\mathbb {S}_{adv}){\\ne }y$ where $\\mathbb {S}_{adv}$ is natural looking, grammatically correct and semantically similar to $\\mathbb {S}$ (by some pre-defined definition",
          "of similarity).",
          "BAE For generating adversarial example $\\mathbb {S}_{adv}$, we define two perturbations on the input $\\mathbb {S}$:",
          "Replace a token $t \\in \\mathbb {S}$ with another",
          "Insert a new token $t^{\\prime }$ in $\\mathbb {S}$",
          "Some tokens in the input are more attended to by $C$ than others, and therefore contribute more towards the final prediction. Replacing these tokens or inserting a new token adjacent to them can thus have a stronger effect on altering the classifier prediction. We estimate the token importance $I_i$ of each token $t_i \\in \\mathbb {S}=[t_1, \\dots , t_n]$, by deleting $t_i$ from $\\mathbb {S}$ and computing the decrease in probability of predicting the correct label $y$, similar to BIBREF11.",
          "While the motivation for replacing tokens in decreasing order of importance is clear, we conjecture that adjacent insertions in this same order can lead to a powerful attack. This intuition stems from the fact that the inserted token changes the local context around the original token.",
          "The Replace (R) and Insert (I) operations are performed on a token $t$ by masking it and inserting a mask token adjacent to it in $\\mathbb {S}$ respectively. The pre-trained BERT masked language model (MLM) is used to predict the mask tokens (See Figure FIGREF1).",
          "BERT is a powerful LM trained on a large training corpus ($\\sim $ 2 billion words), and hence the predicted mask tokens fit well grammatically in $\\mathbb {S}$. The BERT-MLM does not however guarantee semantic coherence to the original text $\\mathbb {S}$ as demonstrated by the following simple example. Consider the sentence: `the food was good'. For replacing the token `good', BERT-MLM may predict the tokens `nice' and `bad', both of which fit well into the context of the sentence. However, replacing `good' with `bad' changes the original sentiment of the sentence.",
          "To ensure semantic similarity on introducing perturbations in the input text, we filter the set of top K masked tokens (K is a pre-defined constant) predicted by BERT-MLM using a Universal Sentence Encoder (USE) BIBREF14 based sentence similarity scorer. For the R operations we add an additional check for grammatical correctness of the generated adversarial example by filtering out predicted tokens that do not form the same part of speech (POS) as the original token $t_i$ in the sentence.",
          "To choose the token for a perturbation (R/I) that best attacks the model from the filtered set of predicted tokens:",
          "If there are multiple tokens can cause $C$ to misclassify $\\mathbb {S}$ when they replace the mask, we choose the token which makes $\\mathbb {S}_{adv}$ most similar to the original $\\mathbb {S}$ based on the USE score.",
          "If no token causes misclassification, we choose the perturbation that decreases the prediction probability $P(C(\\mathbb {S}_{adv}){=}y)$ the most.",
          "The perturbations are applied iteratively to the input tokens in decreasing order of importance, until either $C(\\mathbb {S}_{adv}){\\ne }y$ (successful attack) or all the tokens of $\\mathbb {S}$ have been perturbed (failed attack).",
          "We present 4 attack modes for BAE based on the R and I operations, where for each token $t$ in $\\mathbb {S}$:",
          "BAE-R: Replace token $t$ (See Algorithm )",
          "BAE-I: Insert a token to the left or right of $t$",
          "BAE-R/I: Either replace token $t$ or insert a token to the left or right of $t$",
          "BAE-R+I: First replace token $t$, then insert a token to the left or right of $t$"
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification.",
          "We use 3 popular text classification models: word-LSTM BIBREF20, word-CNN BIBREF21 and a fine-tuned BERT BIBREF12 base-uncased classifier. For each dataset we train the model on the training data and perform the adversarial attack on the test data. For complete model details refer to Appendix.",
          "As a baseline, we consider TextFooler BIBREF11 which performs synonym replacement using a fixed word embedding space BIBREF22. We only consider the top $K{=}50$ synonyms from the MLM predictions and set a threshold of 0.8 for the cosine similarity between USE based embeddings of the adversarial and input text.",
          "Results We perform the 4 modes of our attack and summarize the results in Table . Across datasets and models, our BAE attacks are almost always more effective than the baseline attack, achieving significant drops of 40-80% in test accuracies, with higher average semantic similarities as shown in parentheses. BAE-R+I is the strongest attack since it allows both replacement and insertion at the same token position, with just one exception. We observe a general trend that the BAE-R and BAE-I attacks often perform comparably, while the BAE-R/I and BAE-R+I attacks are much stronger. We observe that the BERT-based classifier is more robust to the BAE and TextFooler attacks than the word-LSTM and word-CNN models which can be attributed to its large size and pre-training on a large corpus.",
          "The baseline attack is often stronger than the BAE-R and BAE-I attacks for the BERT based classifier. We attribute this to the shared parameter space between the BERT-MLM and the BERT classifier before fine-tuning. The predicted tokens from BERT-MLM may not drastically change the internal representations learned by the BERT classifier, hindering their ability to adversarially affect the classifier prediction.",
          "Effectiveness We study the effectiveness of BAE on limiting the number of R/I operations permitted on the original text. We plot the attack performance as a function of maximum $\\%$ perturbation (ratio of number of word replacements and insertions to the length of the original text) for the TREC dataset. From Figure , we clearly observe that the BAE attacks are consistently stronger than TextFooler. The classifier models are relatively robust to perturbations up to 20$\\%$, while the effectiveness saturates at 40-50$\\%$. Surprisingly, a 50$\\%$ perturbation for the TREC dataset translates to replacing or inserting just 3-4 words, due to the short text lengths.",
          "Qualitative Examples We present adversarial examples generated by the attacks on a sentence from the IMDB and Yelp datasets in Table . BAE produces more natural looking examples than TextFooler as tokens predicted by the BERT-MLM fit well in the sentence context. TextFooler tends to replace words with complex synonyms, which can be easily detected. Moreover, BAE's additional degree of freedom to insert tokens allows for a successful attack with fewer perturbations.",
          "Human Evaluation We consider successful adversarial examples generated from the Amazon and IMDB datasets and verify their sentiment and grammatical correctness. Human evaluators annotated the sentiment and the grammar (Likert scale of 1-5) of randomly shuffled adversarial examples and original texts. From Table , BAE and TextFooler have inferior accuracies compared to the Original, showing they are not always perfect. However, BAE has much better grammar scores, suggesting more natural looking adversarial examples.",
          "Ablation Study We analyze the benefits of R/I operations in BAE in Table . From the table, the splits $\\mathbb {A}$ and $\\mathbb {B}$ are the $\\%$ of test points which compulsorily need I and R operations respectively for a successful attack. We can observe that the split $\\mathbb {A}$ is larger than $\\mathbb {B}$ thereby indicating the importance of the I operation over R. Test points in split require both R and I operations for a successful attack. Interestingly, split is largest for Subj, which is the most robust to attack (Table ) and hence needs both R/I operations. Thus, this study gives positive insights towards the importance of having the flexibility to both replace and insert words.",
          "Refer to the Appendix for additional results, effectiveness graphs and details of human evaluation."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we have presented a novel technique for generating adversarial examples (BAE) based on a language model. The results obtained on several text classification datasets demonstrate the strength and effectiveness of our attack."
        ]
      }
    ],
    "qas": [
      {
        "question": "what text classification datasets do they evaluate on?",
        "question_id": "da21bcaa8e3a9eadc8a5194fd57ae797e93c3049",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Amazon",
                "Yelp",
                "IMDB",
                "MR",
                "MPQA",
                "Subj",
                "TREC"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ],
              "highlighted_evidence": [
                "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ]
            },
            "annotation_id": "77daec4575ca13c45a644dbc2322a7117e77b193",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Amazon",
                "Yelp",
                "IMDB ",
                "MR ",
                "MPQA ",
                "Subj",
                "TREC"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ],
              "highlighted_evidence": [
                "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ]
            },
            "annotation_id": "9e51a10c6cf653c124a6fe33b1cdf662a00db90e",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Amazon, Yelp, IMDB",
                "MR BIBREF16",
                "MPQA BIBREF17",
                "Subj BIBREF18",
                "TREC BIBREF19"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Datasets and Models We evaluate our adversarial attacks on different text classification datasets from tasks such as sentiment classification, subjectivity detection and question type classification. Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ],
              "highlighted_evidence": [
                "Amazon, Yelp, IMDB are sentence-level sentiment classification datasets which have been used in recent work BIBREF15 while MR BIBREF16 contains movie reviews based on sentiment polarity. MPQA BIBREF17 is a dataset for opinion polarity detection, Subj BIBREF18 for classifying a sentence as subjective or objective and TREC BIBREF19 is a dataset for question type classification."
              ]
            },
            "annotation_id": "b094b56dbd1b110417bdb1805c23e3459a701466",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: We use BERT-MLM to predict masked tokens in a given text for generating adversarial examples. The MASK token replaces a given word (BAE-R attack) or is inserted to the left/right of the word (BAE-I attack). Actual predictions made by the BERT-MLM are shown (they fit well into the sentence context)"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Test accuracies on adversarial attack across models and datasets. The average semantic similarity between the original and adversarial examples are mentioned in parentheses for the baseline and the strongest BAE attack."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Summary statistics for the datasets"
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Graphs comparing the performance of the attacks on the TREC question classification dataset, as a function of maximum % perturbation to the input. All BAE attacks outperform the baseline TEXTFOOLER ."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Qualitative examples of each attack on the BERT classifier (Replacements: Red, Inserts: Blue)"
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: A denotes the % of test instances which are successfully attacked by BAE-R/I, but not BAE-R , i.e, ((R/I)\u2229 R) ; B : (R/I)\u2229 I ; C : (R/I)\u2229 R\u2229 I"
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Human evaluation of accuracies and grammaticality scores. TF refers to TextFooler."
      },
      {
        "file": "7-Table1-1.png",
        "caption": "Table 1: Test accuracies on adversarial attack across models and datasets. The average semantic similarity between the original and adversarial examples are mentioned in parentheses."
      },
      {
        "file": "7-Figure4-1.png",
        "caption": "Figure 4: Yelp"
      },
      {
        "file": "8-Figure8-1.png",
        "caption": "Figure 8: Subj"
      }
    ]
  },
  "1806.03369": {
    "title": "#SarcasmDetection is soooo general! Towards a Domain-Independent Approach for Detecting Sarcasm",
    "abstract": "Automatic sarcasm detection methods have traditionally been designed for maximum performance on a specific domain. This poses challenges for those wishing to transfer those approaches to other existing or novel domains, which may be typified by very different language characteristics. We develop a general set of features and evaluate it under different training scenarios utilizing in-domain and/or out-of-domain training data. The best-performing scenario, training on both while employing a domain adaptation step, achieves an F1 of 0.780, which is well above baseline F1-measures of 0.515 and 0.345. We also show that the approach outperforms the best results from prior work on the same target domain.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Sarcasm, a creative device used to communicate an intended meaning that is actually the opposite of its literal meaning, is notoriously difficult to convey and interpret through text, in part because doing so relies heavily upon shared contextual understandings that can be marked more easily by altered prosody (e.g., emphasis upon certain words) or non-verbal signals (e.g., rolling one's eyes). It is a complex process even for humans, and in fact an inability to detect sarcasm has been linked with a number of neurocognitive disorders, including dementia BIBREF0 . It is similarly a challenging open task in natural language processing, and has direct implications to a number of other critical application areas, such as sentiment analysis.",
          "Most research on automatic sarcasm detection to date has focused on the Twitter domain, which boasts an ample source of publicly-available data, some of which is already self-labeled by users for the presence of sarcasm (e.g., with #sarcasm). However, Twitter is highly informal, space-restricted, and subject to frequent topic fluctuations from one post to the next due to the ebb and flow of current events\u2014in short, it is not broadly representative of most text domains. Thus, sarcasm detectors trained using features designed for maximum Twitter performance are not necessarily transferable to other domains. Despite this, it is desirable to develop approaches that can harness the more generalizable information present in the abundance of Twitter data.",
          "In this work, we develop a set of domain-independent features for sarcasm detection and show that the features generally perform well across text domains. Further, we validate that domain adaptation can be applied to sarcasm detection to leverage patterns in out-of-domain training data, even when results from training only on that source domain data are extremely bad (far below baseline results), to improve over training on only the target data or over training on the simply combined dataset. Finally, we make a new dataset of sarcastic and non-sarcastic tweets available online as a resource to other researchers."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "The majority of work on automatic sarcasm detection has been done using Twitter, and to a smaller extent Amazon product reviews. Research outside of those domains has been scarce, but interesting. Notably, Burfoot and Baldwin Burfoot:2009:ASD:1667583.1667633 automatically detected satirical news articles using unigrams, lexical features, and semantic validity features, and Justo et al. Justo2014124 used n-gram, linguistic, and semantic features to detect the presence of sarcasm in the Internet Argument Corpus BIBREF1 . The remainder of this section describes prior work with Twitter and Amazon."
        ]
      },
      {
        "section_name": "Sarcasm Detection on Twitter",
        "paragraphs": [
          "Twitter is a micro-blogging service that allows users to post short \u201ctweets\u201d to share content or describe their feelings or opinions in 140 characters or less. For researchers, it boasts a low cost of annotation and plentiful supply of data (users often self-label their tweets using the \u201c#\u201d symbol\u2014many explicitly label their sarcastic tweets using the hashtag \u201c#sarcasm\u201d). A variety of approaches have been taken toward automatically detecting sarcasm on Twitter, including explicitly using the information present in a tweet's hashtag(s); Maynard and Greenwood maynard2014cares learned which hashtags characteristically corresponded with sarcastic tweets, and used the presence of those indicators to predict other sarcastic tweets, with high success. BIBREF2 liebrecht2013perfect detected sarcasm in Dutch tweets using unigram, bigram, and trigram features.",
          " BIBREF3 Rajadesingan:2015:SDT:2684822.2685316 detected sarcastic tweets based on features adapted from behavioral models of sarcasm usage, drawing extensively from individual users' Twitter histories and relying heavily on situational context and user characteristics. The system also employed lexical features and grammatical correctness as a means of modelling different aspects of the user's behavior.",
          "Other researchers have had success identifying sarcasm by a tweet's use of positive sentiment to describe a negative situation BIBREF4 , employing contextual BIBREF5 or pragmatic BIBREF6 features, and observing the writing style and emotional scenario of a tweet BIBREF7 . An underlying theme among these methods is that the features are generally designed specifically for use with tweets. A major challenge in developing a more general approach for sarcasm detection lies in developing features that are present across many domains, yet still specific enough to reliably capture the differences between sarcastic and non-sarcastic text.",
          "Finally, some researchers have recently explored approaches that rely on word embeddings and/or carefully tailored neural networks, rather than on task-specific feature design BIBREF8 , BIBREF9 , BIBREF10 . Since neural networks offer little transparency, it is uncertain whether the features learned in these approaches would be easily transferable across text domains for this task (prior research on other tasks suggests that the features computed by deep neural networks grow increasingly specific to the training dataset\u2014and in turn, to the training domain\u2014with each layer BIBREF11 ). Although an interesting question, the focus herein is on uncovering the specific types of features capable of leveraging general patterns for sarcasm detection, and this can be more easily examined using shallower learning algorithms."
        ]
      },
      {
        "section_name": "Sarcasm Detection on Amazon Reviews",
        "paragraphs": [
          "Research on automatic sarcasm detection in other domains has been limited, but recently a publicly-available corpus of sarcastic and non-sarcastic Amazon product reviews was released by Filatova FILATOVA12.661 to facilitate research. BIBREF12 buschmeier-cimiano-klinger:2014:W14-26 test many feature combinations on this dataset, including those based on metadata (e.g., Amazon star rating), sentiment, grammar, the presence of interjections (e.g., \u201cwow\u201d) or laughter (e.g., through onomatopoeia or acronyms such as \u201clol\u201d), the presence of emoticons, and bag-of-words features. Their highest F1 (0.744) is achieved using all of these with a logistic regression classifier; however, using only the star rating, they still achieve an F1 of 0.717. This highlights the need for high-performing, general features for sarcasm detection; metadata features are highly domain-specific, and even bag-of-words trends may be unique to certain domains (\u201ctrump\u201d was one of the most common unigrams in our own Twitter training set, but only occurred once across all Amazon product reviews).",
          "Prior to the release of Filatova's dataset, BIBREF13 davidov-tsur-rappoport:2010:CONLL developed a semi-supervised approach to classify tweets or Amazon reviews as sarcastic or non-sarcastic by clustering samples based on grammatical features and the full or partial presence of automatically-extracted text patterns. They evaluated their work on a sample of the classified instances annotated by anonymous users on Amazon Mechanical Turk. They tested several different seed sets with their approach, one of which contained a mixture of positive Amazon reviews, positive #sarcasm-tagged tweets, and a manually-selected sample of negative tweets. Although they did not report test results on Amazon reviews using this seed set, they did report test results on #sarcasm-tagged tweets, achieving an F-measure of 0.545. Their work is the closest to ours, because it attempts to harness training samples from both the Twitter and Amazon review domains."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "Data was taken from two domains: Twitter, and Amazon product reviews. The Amazon reviews were from the publicly available sarcasm corpus developed by Filatova FILATOVA12.661. To build our Twitter dataset, tweets containing exactly one of the trailing hashtags \u201c#sarcasm,\u201d \u201c#happiness,\u201d \u201c#sadness,\u201d \u201c#anger,\u201d \u201c#surprise,\u201d \u201c#fear,\u201d and \u201c#disgust\u201d were downloaded regularly during February and March 2016. Tweets containing the latter six hashtags, corresponding to Ekman's six basic emotions BIBREF14 , were labeled as non-sarcastic. Those hashtags were chosen because their associated tweets were expected to still express opinions, similarly to sarcastic tweets, but in a non-sarcastic way. Tweets containing #sarcasm were labeled as sarcastic; annotating tweets with the #sarcasm hashtag as such is consistent with the vast majority of prior work in the Twitter domain BIBREF6 , BIBREF2 , BIBREF15 , BIBREF3 , BIBREF5 , BIBREF8 , BIBREF10 .",
          "The downloaded tweets were filtered to remove retweets, \u201c@replies,\u201d and tweets containing links. Retweets were removed to avoid having duplicate copies of identical tweets in the dataset, @replies were removed in case the hashtag referred to content in the tweet to which it replied rather than content in the tweet itself, and tweets with links were likewise removed in case the hashtag referred to content in the link rather than in the tweet itself. Requiring that the specified hashtag trailed the rest of the tweet (it could only be followed by other hashtags) was done based on the observation that when sarcastic or emotional hashtags occur in the main tweet body, the tweet generally discusses sarcasm or the specified emotion, rather than actually expressing sarcasm or the specified emotion. Finally, requiring that only one of the specified hashtags trailed the tweet eliminated cases of ambiguity between sarcastic and non-sarcastic tweets. All trailing \u201c#sarcasm\u201d or emotion hashtags were removed from the data before training and testing, and both datasets were randomly divided into training (80%) and testing (20%) sets. Further details are shown in Table TABREF6 ."
        ]
      },
      {
        "section_name": "Features",
        "paragraphs": [
          "Three feature sets were developed (one general, and two targeted toward Twitter and Amazon, respectively). Resources used to develop the features are described in Table TABREF9 . Five classifiers (Na\u00efve Bayes, J48, Bagging, DecisionTable, and SVM), all from the Weka library, were tested using five-fold cross-validation on the training sets, and the highest-scoring (Na\u00efve Bayes) was selected for use on the test set.",
          "The Twitter- (T) and Amazon-specific (A) features are shown in Table TABREF11 . Domain-specific features were still computed for instances from the other domain unless it was impossible to compute those features in that domain (i.e., Amazon Star Rating for Twitter instances), in which case they were left empty. Twitter-specific features are based on the work of BIBREF15 maynard2014cares and BIBREF4 RiloffSarcasm. Maynard and Greenwood detect sarcastic tweets by checking for the presence of learned hashtags that correspond with sarcastic tweets, as well as sarcasm-indicator phrases and emoticons. We construct binary features based on their work, and on Riloff et al.'s work RiloffSarcasm, which determined whether or not a tweet was sarcastic by checking for positive sentiment phrases contrasting with negative situations (both of which were learned from other sarcastic tweets). We also add a feature indicating the presence of laughter terms. Amazon-based features are primarily borrowed from BIBREF12 's buschmeier-cimiano-klinger:2014:W14-26 earlier work on the Amazon dataset. [4]Individual binary features for each of the sarcasm hashtags (5 features) and laughter tokens (9 features) were also included.",
          "We model some of our general features after those from BIBREF4 RiloffSarcasm, under the premise that the underlying principle that sarcasm often associates positive expressions with negative situations holds true across domains. Since positive sentiment phrases and negative situations learned from tweets are unlikely to generalize to different domains, we instead use three sentiment lexicons to build features that capture positive and negative sentiment rather than checking for specific learned phrases. Likewise, rather than bootstrapping specific negative situations from Twitter, we calculate the pointwise mutual information (PMI) between the most positive or negative word in the instance and the n-grams that immediately proceed it to create a more general version of the feature. Other general features developed for this work rely on syntactic characteristics, or are bag-of-words-style features corresponding to the tokens most strongly correlated or most common in sarcastic and non-sarcastic instances from Twitter and Amazon training data. All general features are outlined in Table TABREF14 ."
        ]
      },
      {
        "section_name": "Evaluation",
        "paragraphs": [
          "The features used for each train/test scenario are shown in the first column of Table TABREF18 . Twitter Features refers to all features listed in Table TABREF11 preceded by the parenthetical (T), and Amazon Features to all features preceded by (A). General: Other Polarity includes the positive and negative percentages, average polarities, overall polarities, and largest polarity gap features from Table TABREF14 . General: Subjectivity includes the % strongly subjective positive words, % weakly subjective positive words, and their negative counterparts. We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic.",
          "Results are reported for models trained only on Twitter, only on Amazon, on both training sets, and on both training sets when Daum\u00e9's daumeiii:2007:ACLMain EasyAdapt technique is applied, employing Twitter as the algorithm's source domain and Amazon as its target domain. EasyAdapt works by modifying the feature space so that it contains three mappings of the original features: a general (source + target) version, a source-only version, and a target-only version. More specifically, assuming an input feature set INLINEFORM0 for some INLINEFORM1 , where INLINEFORM2 is the number of features in the set, EasyAdapt transforms INLINEFORM3 to the augmented set, INLINEFORM4 . The mappings INLINEFORM5 for the source and target domain data, respectively, are defined as INLINEFORM6 and INLINEFORM7 , where INLINEFORM8 is the zero vector. Refer to Daum\u00e9 daumeiii:2007:ACLMain for an in-depth discussion of this technique.",
          "Each model was tested on the Amazon test data (the model trained only on Twitter was also tested on the Twitter test set). Amazon reviews were selected as the target domain since the Twitter dataset was much larger than the Amazon dataset; this scenario is more consistent with the typically stated goal of domain adaptation (a large labeled out-of-domain source dataset and a small amount of labeled data in the target domain), and most clearly highlights the need for a domain-general approach. [6]Part-of-speech is considered in MPQA; Amazon and Twitter data was tagged using Stanford CoreNLP BIBREF20 and the Twitter POS-tagger BIBREF21 , respectively.",
          "Finally, we include the best results reported by BIBREF12 buschmeier-cimiano-klinger:2014:W14-26 on the same Amazon dataset. For a more direct comparison between our work and theirs, we also report the results from using all of our features under the same classification conditions as theirs (10-fold cross-validation using scikit-learn's Logistic Regression, tuning with an F1 objective). We refer to the latter case as Our Results, Same Classifier as Prior Best."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "The results, including each of the training scenarios noted earlier, are presented in Table TABREF18 . Precision, recall, and F1 on the positive (sarcastic) class were recorded. The highest F1 achieved (0.780) among all cases was from training on the EasyAdapted Twitter and Amazon data. In comparison, training only on the Amazon reviews produced an F1 of 0.713 (training and testing only on Amazon reviews with our features but with the same classifier and cross-validation settings as BIBREF12 buschmeier-cimiano-klinger:2014:W14-26 led to an F1 of 0.752, outperforming prior best results on that dataset). Training on both without EasyAdapt led to an F1 of 0.595 (or 0.715 when training only on Amazon-specific features), and finally, training only on Twitter data led to an F1 of 0.276. Training and testing on Twitter produced an F1 of 0.583 when training on all features."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "When testing on Amazon reviews, the worst-performing case was that in which the classifier was trained only on Twitter data (it did not manage to outperform either baseline). This underscores the inherent variations in the data across the two domains; despite the fact that many of the features were deliberately designed to be generalizable and robust to domain-specific idiosyncrasies, the different trends across domains still confused the classifier.",
          "However, combining all of that same Twitter data with a much smaller amount of Amazon data (3998 Twitter training instances relative to 1003 Amazon training instances) and applying EasyAdapt to the combined dataset performed quite well ( INLINEFORM0 =0.780). The classifier was able to take advantage of a wealth of additional Twitter samples that had led to terrible performance on their own ( INLINEFORM1 =0.276). Thus, the high performance demonstrated when the EasyAdapt algorithm is applied to the training data from the two domains is particularly impressive. It shows that more data is indeed better data\u2014provided that the proper features are selected and the classifier is properly guided in handling it.",
          "Overall, the system cut the error rate from .256 to .220, representing a 14% relative reduction in error over prior best results on the Amazon dataset. Our results testing on Twitter are not directly comparable to others, since prior work's datasets could not be released; however, our results ( INLINEFORM0 =0.583) are in line with those reported previously ( BIBREF4 RiloffSarcasm: INLINEFORM1 =0.51; BIBREF13 davidov-tsur-rappoport:2010:CONLL: INLINEFORM2 =0.545). Additionally, our Twitter data did not contain many indicators shown to be discriminative in the past (leading our general features to be better predictors of sarcasm even when training/testing entirely within the domain), and our focus in developing features was on general performance rather than performance on Twitter specifically.",
          "Both datasets were somewhat noisy. Many full-length reviews that were marked as \u201csarcastic\u201d were only partially so, and included other sentences that were not sarcastic at all. This may have been particularly problematic when strong polarity was present in those sentences. An example of this is shown in Figure FIGREF20 , where the highlighted portion of the review indicates the sarcastic segment submitted by the annotator, and awesome, the most polar word in the entire review (circled), is outside that highlighted sentence.",
          "Since tweets are self-labeled, users' own varying definitions of sarcasm lead to some extreme idiosyncrasies in the kinds of tweets labeled as sarcastic. Sarcastic tweets were also often dependent upon outside context. Some examples include (#sarcasm tags were removed in the actual dataset): \u201cMy daughter's 5th grade play went over as professional, flawless, and well rehearsed as a Trump speech. #sarcasm,\u201d \u201c#MilanAlessandria Mario Balotelli scored the fifth goal in the 5-0 win. He should play for the #Azzurri at #EURO2016. #sarcasm,\u201d and \u201cGood morning #sarcasm.\u201d",
          "Finally, some past research has found that it is more difficult to discriminate between sarcastic and non-sarcastic texts when the non-sarcastic texts contain sentiment BIBREF6 , BIBREF8 . Since our non-sarcastic tweets are emotionally-charged, our classifier may have exhibited lower performance than it would have with only neutral non-sarcastic tweets. Since distinguishing between literal and sarcastic sentiment is useful for real-world applications of sarcasm detection, we consider the presence of sentiment in our dataset to be a worthwhile challenge.",
          "Regarding the general features developed for this work, the polarity- and subjectivity-based features performed well, while performance using only PMI features was lower. PMI scores in particular may have been negatively impacted by common Twitter characteristics, such as the trend to join keywords together in hashtags, and the use of acronyms that are unconventional in other domains. These issues could be addressed to some extent in the future via word segmentation tools, spell-checkers, and acronym expansion."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "This work develops a set of domain-independent features and demonstrates their usefulness for general sarcasm detection. Moreover, it shows that by applying a domain adaptation step to the extracted features, even a surplus of \u201cbad\u201d training data can be used to improve the performance of the classifier on target domain data, reducing error by 14% relative to prior work. The Twitter corpus described in this paper is publicly available for research purposes,[2] and represents a substantial contribution to multiple NLP sub-communities. This shared corpus of tweets annotated for sarcasm will hasten the advancement of further research. In the future, we plan to extend our approach to detect sarcasm in a completely novel domain, literature, eventually integrating the work into an application to support reading comprehension."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This material is based upon work supported by the NSF Graduate Research Fellowship Program under Grant 1144248, and the NSF under Grant 1262860. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation."
        ]
      }
    ],
    "qas": [
      {
        "question": "what are the baseline models?",
        "question_id": "eaed0b721cc3137b964f5265c7ecf76f565053e9",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "the All Sarcasm case",
                "the Random case"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The features used for each train/test scenario are shown in the first column of Table TABREF18 . Twitter Features refers to all features listed in Table TABREF11 preceded by the parenthetical (T), and Amazon Features to all features preceded by (A). General: Other Polarity includes the positive and negative percentages, average polarities, overall polarities, and largest polarity gap features from Table TABREF14 . General: Subjectivity includes the % strongly subjective positive words, % weakly subjective positive words, and their negative counterparts. We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ],
              "highlighted_evidence": [
                "We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ]
            },
            "annotation_id": "0f0570bb2d261afc23702e407b54e4d1086650c0",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "All Sarcasm case assumes that every instance is sarcastic",
                " Random case randomly assigns each instance as sarcastic or non-sarcastic"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The features used for each train/test scenario are shown in the first column of Table TABREF18 . Twitter Features refers to all features listed in Table TABREF11 preceded by the parenthetical (T), and Amazon Features to all features preceded by (A). General: Other Polarity includes the positive and negative percentages, average polarities, overall polarities, and largest polarity gap features from Table TABREF14 . General: Subjectivity includes the % strongly subjective positive words, % weakly subjective positive words, and their negative counterparts. We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ],
              "highlighted_evidence": [
                "We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ]
            },
            "annotation_id": "83a6afac7c644e7cba8e44059e2665f0386478e1",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "All Sarcasm",
                "Random case"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The features used for each train/test scenario are shown in the first column of Table TABREF18 . Twitter Features refers to all features listed in Table TABREF11 preceded by the parenthetical (T), and Amazon Features to all features preceded by (A). General: Other Polarity includes the positive and negative percentages, average polarities, overall polarities, and largest polarity gap features from Table TABREF14 . General: Subjectivity includes the % strongly subjective positive words, % weakly subjective positive words, and their negative counterparts. We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ],
              "highlighted_evidence": [
                "We also include two baselines: the All Sarcasm case assumes that every instance is sarcastic, and the Random case randomly assigns each instance as sarcastic or non-sarcastic."
              ]
            },
            "annotation_id": "8c851b694df2e7d610b5bf6e6508917d8992e68e",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Twitter and Amazon Dataset Distributions"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Domain-Specific Features"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Lexical Resources"
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: General Feature Set"
      },
      {
        "file": "5-Table5-1.png",
        "caption": "Table 5: Test Results \u2014 Full Analysis"
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Example from Amazon Product Reviews"
      }
    ]
  },
  "2003.07459": {
    "title": "Offensive Language Identification in Greek",
    "abstract": "As offensive language has become a rising issue for online communities and social media platforms, researchers have been investigating ways of coping with abusive content and developing systems to detect its different types: cyberbullying, hate speech, aggression, etc. With a few notable exceptions, most research on this topic so far has dealt with English. This is mostly due to the availability of language resources for English. To address this shortcoming, this paper presents the first Greek annotated dataset for offensive language identification: the Offensive Greek Tweet Dataset (OGTD). OGTD is a manually annotated dataset containing 4,779 posts from Twitter annotated as offensive and not offensive. Along with a detailed description of the dataset, we evaluate several computational models trained and tested on this data.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "In the age of social media, offensive content online has become prevalent in recent years. There are many types of offensive content online such as racist and sexist posts and insults and threats targeted at individuals or groups. As such content increasingly occurs online, it has become a growing issue for online communities. This has come to the attention of social media platforms and authorities underlining the urgency to moderate and deal with such content. Several studies in NLP have approached offensive language identification applying machine learning and deep learning systems on annotated data to identify such content. Researchers in the field have worked with different definitions of offensive language with hate speech being the most studied among these types BIBREF0. BIBREF1 investigate the similarity between these sub-tasks. With a few noteworthy exceptions, most research so far has dealt with English, due to the availability of language resources. This gap in the literature recently started to be addressed with studies on Spanish BIBREF2, Hindi BIBREF3, and German BIBREF4, to name a few.",
          "In this paper we contribute in this direction presenting the first Greek annotated dataset for offensive language identification: the Offensive Greek Tweet Dataset (OGTD). OGTD uses a working definition of offensive language inspired by the OLID dataset for English BIBREF5 used in the recent OffensEval (SemEval-2019 Task 6) BIBREF6. In its version, 1.0 OGTD contains nearly 4,800 posts collected from Twitter and manually annotated by a team of volunteers, resulting in a high-quality annotated dataset. We trained a number of systems on this dataset and our best results have been obtained from a system using LSTMs and GRU with attention which achieved 0.89 F1 score."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "The bulk of work on detecting abusive posts online addressed particular types of such language like textual attacks and hate speech BIBREF7, aggression BIBREF3, and others. OGTD considers a more general definition of offensiveness inspired by the first layer of the hierarchical annotation model described in BIBREF5. BIBREF5 model distinguishes targeted from general profanity, and considers the target of offensive posts as indicators of potential hate speech posts (insults targeted at groups) and cyberbulling posts (insults targeted at individuals).",
          "",
          "Offensive Language: Previous work presented a dataset with sentences labelled as flame (i.e. attacking or containing abusive words) or okay BIBREF8 with a Na\u00efve Bayes hybrid classifier and a user offensiveness estimation using an offensive lexicon and sentence syntactic structures BIBREF9. A dataset of 3.3M comments from the Yahoo Finance and News website, labelled as abusive or clean, was utilized in several experiments using n-grams, linguistic and syntactic features, combined with different types of word and comment embeddings as distributional semantics features BIBREF10. The usefulness of character n-grams for abusive language detection was explored on the same dataset with three different methods BIBREF11. The most recent project expanded on existing ideas for defining offensive language and presented the OLID (Offensive Language Identification Dataset), a corpus of Twitter posts hierarchically annotated on three levels, whether they contain offensive language or not, whether the offense is targeted and finally, the target of the offense BIBREF5. A CNN (Convolutional neural network) deep learning approach outperformed every model trained, with pre-trained FastText embeddings and updateable embeddings learned by the model as features. In OffensEval (SemEval-2019 Task 6), participants had the opportunity to use the OLID to train their own systems, with the top teams outperforming the original models trained on the dataset.",
          "",
          "Hate Speech: A study dataset of tweets posted after the murder of Drummer Lee Rigby in the UK, manually annotated as offensive or antagonistic in terms of race ethnicity or religion for hate speech identification with multiple classifiers BIBREF12. A logistic regression classifier trained with paragraph2vec word representations of comments from Yahoo Finance BIBREF13. The latest approaches in detecting hate speech include a dataset of Twitter posts, labelled as hateful, offensive or clean, used to train a logistic regression classifier with part-of-speech and word n-grams and a sentiment lexicon BIBREF0 and a linear SVM trained on character 4-grams, with an extra RBF SVM meta-classifier that boosts accuracy in hateful language detection BIBREF14. Both attempts tried to distinguish offensive language and hate speech, with the hate class being the hardest to classify.",
          ""
        ]
      },
      {
        "section_name": "Related Work ::: Non-English Datasets",
        "paragraphs": [
          "Research on other languages includes datasets such as: A Dutch corpus of posts from the social networking site Ask.fm for the detection of cyberbullying BIBREF15, a German Twitter corpus exploring the issue of hate speech targeted to refugees BIBREF16, another Dutch corpus using data from two anti-Islamic groups in Facebook BIBREF17, a hate speech corpus in Italian BIBREF18, an abusive language corpus in Arabic BIBREF19, a corpus of offensive comments from Facebook and Reddit in Danish BIBREF20, another Twitter corpus in German BIBREF4 for GermEval2018, a second Italian corpus from Facebook and Twitter BIBREF21, an aggressive post corpus from Mexican Twitter in Spanish BIBREF2 and finally an aggressive comments corpus from Facebook in Hindi BIBREF3. SemEval 2019 presented a novel task: Multilingual detection of hate speech specifically against immigrants and women with a dataset from Twitter, in English and Spanish BIBREF22."
        ]
      },
      {
        "section_name": "The OGTD Dataset",
        "paragraphs": [
          "The posts in OGTD v1.0 were collected between May and June, 2019. We used the Twitter API initially collecting tweets from popular and trending hashtags in Greece, including television programs such as series, reality and entertainment shows. Due to the municipal, regional as well as the European Parliament election taking place at the time, many hashtags included tweets discussing the elections. The intuition behind this approach is that Twitter as a microblogging service often gathers complaints and profane comments on widely viewed television and politics, and as such, this period was a good opportunity for data collection.",
          "Following the methodology described in BIBREF5 and others, including a recent comparable Danish dataset BIBREF20, we collected tweets using keywords such as sensitive or obscene language. Queries for tweets containing common curse words and expressions usually found in offensive messages in Greek as keywords (such as the well-known word for \u201casshole\u201d, \u201c\u03bc\u03b1\u03bb\u03ac\u03ba\u03b1\u03c2\u201d (malakas) or \u201cgo to hell\u201d, \u201c\u03c3\u03c4\u03bf \u03b4\u03b9\u03ac\u03bf\u03bb\u03bf\u201d (sto diaolo), etc.) returned a large number of tweets. Aiming to compile a dataset including offensive tweets of diverse types (sexist, racist, etc.) targeted at various social groups, the Twitter API was queried with expletives such as \u201c\u03c0\u03bf\u03c5\u03c4\u03ac\u03bd\u03b1\u201d (poutana, \u201cwhore\u201d), \u201c\u03ba\u03b1\u03c1\u03b9\u03cc\u03bb\u03b1\u201d (kariola, \u201cbitch\u201d), \u201c\u03c0\u03bf\u03cd\u03c3\u03c4\u03b7\u03c2\u201d (poustis, \u201cfaggot\u201d), etc. and their plural forms, to explore the semantic and pragmatic differences of the expletives mentioned above in their different contextual environments. The challenge is to recognize between ironic and insulting uses of these swear words, a common phenomenon in Greek.",
          "The final query for data collection was for tweets containing \u201c\u03b5\u03af\u03c3\u03b1\u03b9\u201d (eisai, \u201cyou are\u201d) as a keyword, inspired by BIBREF5. This particular keyword is considered a stop word as it is quite common and frequent in languages but was suspected to prove helpful for building the dataset for this particular project, as offensive language often follows the following structure: auxiliary verb (be) + noun/adjective. The immediacy of social media and specifically Twitter provides the opportunity for targeted insults to be investigated, following data mining of tweets including \u201cyou are\u201d as a keyword. In fact, many tweets present in the dataset showed users verbally insulting other users or famous people and TV personas, confirming that \u201c\u03b5\u03af\u03c3\u03b1\u03b9\u201d was a facilitating keyword for the task in question."
        ]
      },
      {
        "section_name": "The OGTD Dataset ::: Pre-processing and annotation",
        "paragraphs": [
          "We collected a set of 49,154 tweets. URLs, Emojis and Emoticons were removed, while usernames and user mentions were filtered as @USER following the same methodology described in OLID BIBREF5. Duplicate punctuation such as question and exclamation marks was normalized. After removing duplicate tweets, the dataset was comprised of 46,218 tweets of which 5,000 were randomly sampled for annotation. We used LightTag to annotate the dataset due to its simple and straightforward user interface and limitless annotations, provided by the software creators.",
          "Based on explicit annotation guidelines written in Greek and our proposal of the definition of offensive language, a team of three volunteers were asked to classify each tweet found in the dataset with one of the following tags: Offensive, Not Offensive and Spam, which was introduced to filter out spam from the dataset. Inter-annotator agreement was subsequently calculated and labels with 100% agreement were deemed acceptable annotations. In cases of disagreement, labels with majority agreement above 66% were selected as the actual annotations of the tweets in question. For labels with complete disagreement between annotators, one of the authors of this paper reviewed the tweets with two extra human judges, to get the desired majority agreement above 66%. Figure FIGREF6 is a confusion matrix that shows the inter-annotator agreement or reliability, statistically measured by Cohen's kappa coefficient. The benchmark annotated dataset produced contained 4,779 tweets, containing over 29% offensive content. The final distribution of labels in the new Offensive Greek Tweet Dataset (OGTD), along with the breakdown of the data into training and testing, is showing in Table TABREF5."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "Before experimenting with OGTD, an unique aspect of Greek which is the accentuation of characters for correct pronunciation needed to be normalized. When posting a tweet, many users omit accents due to their haste, resulting in a mixed dataset containing fully accented tweets, partially-accented tweets, and non-accented tweets. To achieve data uniformity and to avoid ambiguity, every word is lower-cased and then normalized to its non-accented equivalent.",
          "Several experiments were conducted with the OGTD, each one utilizing a different combination from a pool of features (e.g. TF/IDF unigrams, bigrams, POS and dependency relation tags) to train machine learning models. These features were selected based on previous methodology used by researchers and taking the dataset size into consideration. The TF-IDF weighted features are often used for text classification and are useful for determining how important a word is to a post in a corpus. The threshold for corpus specific words was set to 80%, ignoring terms appearing in more than 80% of the documents while the minimum document frequency was set to 6, and both unigrams and bigrams were tested. Given the consistent use of linguistic features for training machine learning models and results from previous work for offensive language detection, part-of-speech (POS) and dependency relation tags were considered as additional features. Using the spaCy pipeline for Greek, POS-tags and dependency relations were extracted for every token in a tweet, which were then transformed to count matrices. A sentiment lexicon was considered, but one suitable for this project is as of yet unavailable for Greek.",
          "For the first six deep learning models we used Greek word embeddings trained on a large Greek web corpus BIBREF23. Each Greek word can be represented with a 300 dimensional vector using the trained model. The vector then can be used to feed in to the deep learning models which will be described in section SECREF16. For the last deep learning architecture we wanted to use a BERT BIBREF24 model trained on Greek. However there was no BERT model available for Greek language. The model that came closest our requirement was multilingual BERT model trained on 108 languages BIBREF24 including Greek. Since training BERT is a very computationaly expensive task we used the available multilingual BERT cased model for the sixth deep learning architecture."
        ]
      },
      {
        "section_name": "Methods ::: Models ::: Classical Machine Learning Models",
        "paragraphs": [
          "Every classical model was considered on the condition it could take matrices as input for fitting and was trained with the default settings because of the size of the dataset. Five models were trained: Two SVMs, one with linear kernel and the other with a radial basis function kernel (RBF), both with a value of 1 in the penalty parameter C of the error term. The gamma value of the RBF SVM which indicates how much influence a single training example has, was set to 2. The third classifier trained was another linear classifier with Stochastic Gradient Descent (SGDC) learning. The gradient of the loss is estimated each sample at a time and the SGDC is updated along the way with a decreasing learning rate. The parameters for maximum epochs and the stopping criterion were defined using the default values in scikit-learn. The final classifier was two models based on the Bayes theorem: Multinomial Na\u00efve Bayes, which works with occurrence counts, and Bernoulli Na\u00efve Bayes, which is designed for binary features."
        ]
      },
      {
        "section_name": "Methods ::: Models ::: Deep Learning Models",
        "paragraphs": [
          "Six different deep learning models were considered. All of these models have been used in an aggression detection task. The models are Pooled GRU BIBREF25, Stacked LSTM with Attention BIBREF25, LSTM and GRU with Attention BIBREF25, 2D Convolution with Pooling BIBREF26, GRU with Capsule BIBREF27, LSTM with Capsule and Attention BIBREF26 and BERT BIBREF24. These models has been used in HASOC 2019 and achieved a third place finish in English task and a eighth place finish in German and Hindi subtasks BIBREF26. Parameters described in BIBREF26 were used as the default parameters in order to ease the training process. The code for the deep learning has been made available on Github ."
        ]
      },
      {
        "section_name": "Methods ::: Results",
        "paragraphs": [
          "The performance of individual classifiers for offensive language identification with TF/IDF unigram features is demonstrated in table TABREF8 below. We can see that both linear classifiers (SVM and SGDC) outperform the other classifiers in terms of macro-F1, which does not take label imbalance into account. The Linear SVM and SGDC perform almost identically, with the Linear SVM performing slightly better in recall score for the Not Offensive class and SGDC in recall score for the Offensive class. Bernoulli Na\u00efve Bayes performs better than all classifiers in recall score for the Offensive class but yields the lowest precision score of all classifiers. While the RBF SVM and Multinomial Na\u00efve Bayes yield better recall score for the Not Offensive class, their recall scores for the Offensive class are really low. For a binary text classification task like offensive language detection, a high recall score for both classes, especially for the Offensive class, is important for a model to be considered successful. Thus, the Linear SVM can be considered the marginally best model trained with OGTD, as its weighted average precision and recall scores are higher.",
          "Models trained with TF/IDF bigram features performed worse, with scores of all evaluation metrics dropping with the exception of Multinomial Na\u00efve Bayes which improved in F1-score for the Not Offensive class. The full results are reported in table TABREF9 below. Three other approaches were opted for training the models with the implementation of POS and dependency relation tags via a transformation pipeline, also including TF/IDF unigram features, performing better than the addition of bigrams.",
          "Experiments with linguistic features were conducted, to inspect their efficiency for this task. For these experiments, the RBF SVM was not used due to data handling problems by the model in the scikit-learn library. In the first experiment, TF/IDF unigram features were combined with POS and dependency relation tags. The results of implementing all three features are shown in table TABREF10 below. While the Linear SVM model improved the recall score on the previous model trained with bigrams, the other models show a significant drop in their performance.",
          "In the next experiment, POS tags were used in conjunction with TF/IDF unigram features. Surprisingly, the addition of POS tags in the Linear SVM yields the same F1-score as the first model trained on TF/IDF unigram features, yielding lower precision scores for both classes, while the recall score for the Offensive class improved marginally. The Na\u00efve Bayes models show a marginal decrease in their performance. On the other hand, the performance of SGDC significantly decreases with POS tags only and, interestingly enough, its recall score for the Offensive class is the worst among classifiers. The complete results are presented in table TABREF11 below.",
          "The experiment with linguistic features was the combination of dependency relation tags with TF/IDF unigrams. This experimented yielded the same F1-score of 80% as the other Linear SVM classifiers, performing almost identically with the previous model trained with POS tags, only bested in precision for the Offensive class. While the recall score for Offensive instances improves on the first model trained only on TF/IDF unigrams by 0.01%, the recall score for Not Offensive instances drops by the same amount. The recall score for the Not Offensive class was already high, so this increase in recall score could slightly facilitate the offensive language detection task. Without improving upon the first SGDC presented, the SGDC rised in performance overall and as for the Na\u00efve Bayes representatives, the both the Multinomial and Bernoulli approaches performed better than in the second experiment. The complete results are shown in table TABREF12 below.",
          "The performance of the deep learning models is presented in table TABREF18. As we can see LSTM and GRU with Attention outperformed all the other models in-terms of macro-f1. Notably it outperformed all other classifical models and deep learning models in precision, recall and f1 for Offensive class as well as the Not Offensive class. However, fine tuning BERT-Base Multilingual Cased model did not achieve good results. For this task monolingual Greek word embeddings perform significantly better than the multilingual bert embeddings. LSTM and GRU with Attention can be considered as the best model trained for OGTD."
        ]
      },
      {
        "section_name": "Methods ::: Discussion",
        "paragraphs": [
          "The data annotated in OGTD proved to be facilitating in offensive language detection with a significant success for Greek, taking into consideration its size and label distribution, with the best model (LSTM and GRU with Attention) achieving a F1-macro of 0.89. Among the classical machine learning approaches, the linear SVM model achieved the best results, 0.80, whereas the the Stochastic Gradient Descent (SGD) learning classifier yielded the best recall score for the Offensive class, at 0.61. In terms of features used, TF/IDF matrices of word unigrams proved to work work well with multiple classical ML classifiers. Overall, it is clear that deep learning models with word embedding feature provide better results than the classical machine learning models.",
          "Of the linguistic features, POS tags improved the performance of the Linear SVM marginally in terms of recall for the Offensive class, other classifiers deteriorated in their performance.It is not yet clear whether this is due to the accuracy of the Greek model available for spaCy in producing such tags or the tags themselves as features and is a subject that can be explored with further improvements of spaCy or other NLP tools developed for Greek. The dataset itself contains many instances with neologisms, creative uses of language or and even rare slang words, therefore training the existing model with such instances could improve both spaCy's accuracy for POS and dependency relation tags and the Linear SVM's performance in text classification for Greek."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This paper presented the Offensive Greek Tweet Dataset (OGTD), a manually annotated dataset for offensive language identification and the first Greek dataset of its kind. The OGTD v1.0 contains a total of 4,779 tweets, encompassing posts related to an array of topics popular among Greek people (e.g. political elections, TV shows, etc.). Tweets were manually annotated by a team volunteers through an annotation platform. We used the same guidelines used in the annotation of the English OLID dataset BIBREF5. Finally, we run several machine learning and deep learning classifiers and the best results were achieved by a LSTM and GRU with Attention model."
        ]
      },
      {
        "section_name": "Conclusion ::: Ongoing - OGTD v2.0 and OffensEval 2020",
        "paragraphs": [
          "We have recently released OGTD v2.0 as training data for OffensEval 2020 (SemEval-2020 Task 12) BIBREF28. The reasoning behind the expansion of the dataset was to have a larger Greek dataset for the competition. New posts were collected in November 2019 following the same approach we used to compile v1.0 described in this paper. This second batch of tweets included tweets with trending hashtags, shows and topics from Greece at the time. Additionally, keywords that proved to retrieve interesting tweets in the first version were once again used in the search, along with new keywords like pejorative terms. When the collection was finished, 5,508 tweets were randomly sampled to be then annotated by a team of volunteers. The annotation guidelines were the same ones we used for v1.0. OGTD v2.0 combines the existing with the newly annotated tweets in a larger dataset of 10,287 instances.",
          "Finally, both OGTD v1.0 and v2.0 provide the opportunity for researchers to test cross-lingual learning methods as it can be used in conjunction with the English OLID and other datasets annotated using the same guidelines such as the one by sigurbergsson2019offensive for Danish and by coltekikin2020 for Turkish while simultaneously facilitating the development of language resources for NLP in Greek."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We would like to acknowledge Maria, Raphael and Anastasia, the team of volunteer annotators that provided their free time and efforts to help us produce v1.0 of the dataset of Greek tweets for offensive language detection, as well as Fotini and that helped review tweets with ambivalent labels. Additionally, we would like to express our sincere gratitude to the LightTag team and especially to Tal Perry for granting us free use for their annotation platform."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which method best performs on the offensive language identification task?",
        "question_id": "f61268905626c0b2a715282478a5e373adda516c",
        "nlp_background": "two",
        "topic_background": "research",
        "paper_read": "no",
        "search_query": "language identification",
        "question_writer": "486a870694ba60f1a1e7e4ec13e328164cd4b43c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "LSTM and GRU with Attention can be considered as the best model trained for OGTD"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The performance of the deep learning models is presented in table TABREF18. As we can see LSTM and GRU with Attention outperformed all the other models in-terms of macro-f1. Notably it outperformed all other classifical models and deep learning models in precision, recall and f1 for Offensive class as well as the Not Offensive class. However, fine tuning BERT-Base Multilingual Cased model did not achieve good results. For this task monolingual Greek word embeddings perform significantly better than the multilingual bert embeddings. LSTM and GRU with Attention can be considered as the best model trained for OGTD."
              ],
              "highlighted_evidence": [
                "As we can see LSTM and GRU with Attention outperformed all the other models in-terms of macro-f1. Notably it outperformed all other classifical models and deep learning models in precision, recall and f1 for Offensive class as well as the Not Offensive class. However, fine tuning BERT-Base Multilingual Cased model did not achieve good results. For this task monolingual Greek word embeddings perform significantly better than the multilingual bert embeddings. LSTM and GRU with Attention can be considered as the best model trained for OGTD."
              ]
            },
            "annotation_id": "0f2828411996920c7eff25cede613d43394c9c37",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "LSTMs and GRU with attention"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this paper we contribute in this direction presenting the first Greek annotated dataset for offensive language identification: the Offensive Greek Tweet Dataset (OGTD). OGTD uses a working definition of offensive language inspired by the OLID dataset for English BIBREF5 used in the recent OffensEval (SemEval-2019 Task 6) BIBREF6. In its version, 1.0 OGTD contains nearly 4,800 posts collected from Twitter and manually annotated by a team of volunteers, resulting in a high-quality annotated dataset. We trained a number of systems on this dataset and our best results have been obtained from a system using LSTMs and GRU with attention which achieved 0.89 F1 score."
              ],
              "highlighted_evidence": [
                "We trained a number of systems on this dataset and our best results have been obtained from a system using LSTMs and GRU with attention which achieved 0.89 F1 score."
              ]
            },
            "annotation_id": "3d931a0af386cd6f59c1a792d1cba07ddc3aac90",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " a system using LSTMs and GRU with attention"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this paper we contribute in this direction presenting the first Greek annotated dataset for offensive language identification: the Offensive Greek Tweet Dataset (OGTD). OGTD uses a working definition of offensive language inspired by the OLID dataset for English BIBREF5 used in the recent OffensEval (SemEval-2019 Task 6) BIBREF6. In its version, 1.0 OGTD contains nearly 4,800 posts collected from Twitter and manually annotated by a team of volunteers, resulting in a high-quality annotated dataset. We trained a number of systems on this dataset and our best results have been obtained from a system using LSTMs and GRU with attention which achieved 0.89 F1 score."
              ],
              "highlighted_evidence": [
                "We trained a number of systems on this dataset and our best results have been obtained from a system using LSTMs and GRU with attention which achieved 0.89 F1 score."
              ]
            },
            "annotation_id": "e281e93bd7296afe35276749f2b7fcb20091b269",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Distribution of labels in the OGTD v1.0."
      },
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Cohen\u2019s Kappa for each pair of annotators"
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Results for offensive language detection with TF/IDF unigram features. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Results for offensive language detection with TF/IDF bigram features. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Results for offensive language detection with TF/IDF unigram features, POS and dependency relation tags. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Results for offensive language detection with TF/IDF unigram features and POS tags. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "4-Table6-1.png",
        "caption": "Table 6: Results for offensive language detection with TF/IDF unigram features and dependency relation tags. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "5-Table7-1.png",
        "caption": "Table 7: Results for offensive language detection for Deep Learning models with Greek word embeddings. For each model, Precision (P), Recall (R), and F1 are reported on all classes, and weighted averages. Macro-F1 is also listed (best in bold)."
      },
      {
        "file": "6-Table8-1.png",
        "caption": "Table 8: Distribution of labels in the OGTD v2.0."
      }
    ]
  },
  "1803.08614": {
    "title": "MultiBooked: A Corpus of Basque and Catalan Hotel Reviews Annotated for Aspect-level Sentiment Classification",
    "abstract": "While sentiment analysis has become an established field in the NLP community, research into languages other than English has been hindered by the lack of resources. Although much research in multi-lingual and cross-lingual sentiment analysis has focused on unsupervised or semi-supervised approaches, these still require a large number of resources and do not reach the performance of supervised approaches. With this in mind, we introduce two datasets for supervised aspect-level sentiment analysis in Basque and Catalan, both of which are under-resourced languages. We provide high-quality annotations and benchmarks with the hope that they will be useful to the growing community of researchers working on these languages.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Sentiment analysis has become an established field with a number of subfields (aspect-level sentiment analysis, social media sentiment analysis, cross-lingual sentiment analysis), all of which require some kind of annotated resource, either to train a machine-learning based classifier or to test the performance of proposed approaches.",
          "Although much research into multi-lingual and cross-lingual sentiment analysis has focused on unsupervised or semi-supervised approaches BIBREF0 , BIBREF1 , BIBREF2 , these techniques still require certain resources (linked wordnets, seed lexicon) and do not generally reach the performance of supervised approaches.",
          "In English the state-of-the-art for binary sentiment analysis often reaches nearly 90 percent accuracy BIBREF3 , BIBREF4 , BIBREF5 , but for other languages there is a marked drop in accuracy. This is mainly due to the lack of annotations and resources in these languages. This is especially true of corpora annotated at aspect-level. Unlike document- or tweet-level annotation, aspect-level annotation requires a large amount of effort from the annotators, which further reduces the likelihood of finding an aspect-level sentiment corpus in under-resourced languages. We are, however, aware of one corpus annotated for aspects in German BIBREF6 , although German is not a particularly low-resource language.",
          "The movement towards multi-lingual datasets for sentiment analysis is important because many languages offer different challenges, such as complex morphology or highly productive word formation, which can not be overcome by focusing only on English data.",
          "The novelty of this work lies in creating corpora which cover both Basque and Catalan languages and are annotated in such a way that they are compatible with similarly compiled corpora available in a number of languages BIBREF7 . This allows for further research into cross-lingual sentiment analysis, as well as introducing the first resource for aspect-level sentiment analysis in Catalan and Basque. The corpus is available at http://hdl.handle.net/10230/33928 or https://jbarnesspain.github.io/resources/."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "In English there are many datasets available for document- and sentence-level sentiment analysis across different domains and at different levels of annotation BIBREF8 , BIBREF9 , BIBREF10 , BIBREF11 , BIBREF12 . These resources have been built up over a period of more than a decade and are currently necessary to achieve state-of-the-art performance.",
          "Corpora annotated at fine-grained levels (opinion- or aspect-level) require more effort from annotators, but are able to capture information which is not present at document- or sentence-level, such as nested opinions or differing polarities of different aspects of a single entity. In English, the MPQA corpus BIBREF13 has been widely used in fine-grained opinion research. More recently, a number of SemEval tasks have concentrated on aspect-level sentiment analysis BIBREF14 , BIBREF15 , BIBREF16 .",
          "The Iberian peninsula contains two official languages (Portuguese and Spanish), as well as three co-official languages (Basque, Catalan, and Galician) and several smaller languages (Aragonese, Gascon). The two official languages do have available resources for sentiment at tweet-level BIBREF17 , BIBREF18 , as well as at aspect-level BIBREF7 , BIBREF19 , BIBREF20 . The co-official languages, however, have almost none. The authors are aware of a small discourse-related sentiment corpus available in Basque BIBREF21 , as well as a stance corpus in Catalan BIBREF22 . These resources, however, are limited in size and scope."
        ]
      },
      {
        "section_name": "Data Collection",
        "paragraphs": [
          "In order to improve the lack of data in low-resource languages, we introduce two aspect-level sentiment datasets to the community, available for Catalan and Basque. To collect suitable corpora, we crawl hotel reviews from www.booking.com. Booking.com allows you to search for reviews in Catalan, but it does not include Basque. Therefore, for Basque we crawled reviews from a number of other websites that allow users to comment on their stay",
          "Many of the reviews that we found through crawling are either 1) in Spanish, 2) include a mix of Spanish and the target language, or 3) do not contain any sentiment phrases. Therefore, we use a simple language identification method in order to remove any Spanish or mixed reviews and also remove any reviews that are shorter than 7 tokens. This finally gave us a total of 568 reviews in Catalan and 343 reviews in Basque, collected from November 2015 to January 2016.",
          "We preprocess them through a very light normalization, after which we perform tokenization, pos-tagging and lemmatization using Ixa-pipes Agerri2014.",
          "Our final documents are in KAF/NAF format BIBREF23 , BIBREF24 . This is a stand-off xml format originally from the Kyoto project BIBREF23 and allows us to enrich our documents with many layers of linguistic information, such as the pos tag of a word, its lemma, whether it is a polar word, and if so, if it has an opinion holder or target. The advantage of this format is that we do not have to change the original text in any way."
        ]
      },
      {
        "section_name": "Annotation",
        "paragraphs": [
          "For annotation, we adopt the approach taken in the OpeNER project BIBREF7 , where annotators are free to choose both the span and label for any part of the text."
        ]
      },
      {
        "section_name": "Guidelines",
        "paragraphs": [
          "In the OpeNER annotation scheme (see Table TABREF8 for a short summary), an annotator reads a review and must first decide if there is any positive or negative attitudes in the sentence. If there are, they then decide if the sentence is on topic. Since these reviews are about hotels, we constrain the opinion targets and opinion expressions to those that deal with aspects of the hotel. Annotators should annotate the span of text which refers to:",
          "opinion holders,",
          "opinion targets,",
          "and opinion expressions.",
          "If any opinion expression is found, the annotators must then also determine the polarity of the expression, which can be strong negative, negative, positive, or strong positive. As the opinion holder and targets are often implicit, we only require that each review has at least one annotated opinion expression.",
          "For the strong positive and strong negative labels, annotators must use clues such as adverbial modifiers ('very bad'), inherently strong adjectives ('horrible'), and any use of capitalization, repetition, or punctuation ('BAAAAD!!!!!') in order to decide between the default polarity and the strong version."
        ]
      },
      {
        "section_name": "Process",
        "paragraphs": [
          "We used the KafAnnotator Tool BIBREF7 to annotate each review. This tool allows the user to select a span of tokens and to annotate them as any of the four labels mentioned in Section SECREF3 .",
          "The annotation of each corpus was performed in three phases: first, each annotator annotated a small number of reviews (20-50), after which they compared annotations and discussed any differences. Second, the annotators annotated half of the remaining reviews and met again to discuss any new differences. Finally, they annotated the remaining reviews. For cases of conflict after the final iteration, a third annotator decided between the two.",
          "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
        ]
      },
      {
        "section_name": "Dataset Characteristics",
        "paragraphs": [
          "The reviews are typical hotel reviews, which often mention various aspects of the hotel or experience and the polarity towards these aspects. An example is shown in Example",
          "Statistics for the two corpora are shown in Table TABREF12 ."
        ]
      },
      {
        "section_name": "Agreement Scores",
        "paragraphs": [
          "Common metrics for determining inter-annotator agreement, e.g. Cohen's Kappa BIBREF25 or Fleiss' Kappa BIBREF26 , can not be applied when annotating sequences, as the annotators are free to choose which parts of a sequence to include. Therefore, we use the agr metric BIBREF13 , which is defined as: DISPLAYFORM0 ",
          "where INLINEFORM0 and INLINEFORM1 are annotators and INLINEFORM2 and INLINEFORM3 are the set of annotations for each annotator. If we consider INLINEFORM4 to be the gold standard, INLINEFORM5 corresponds to the recall of the system, and precision if INLINEFORM6 is the gold standard. For each pair of annotations, we report the average of the INLINEFORM7 metric with both annotators as the temporary gold standard, DISPLAYFORM0 ",
          "Perfect agreement, therefore, is 1.0 and no agreement whatsoever is 0.0. Similar annotation projects BIBREF13 report INLINEFORM0 scores that range between 0.6 and 0.8 in general.",
          "For polarity, we assign integers to each label (Strong Negative: 0, Negative: 1, Positive: 2, Strong Positive: 3). For each sentence of length INLINEFORM0 , we take the mean squared error (MSE), DISPLAYFORM0 ",
          "where INLINEFORM0 and INLINEFORM1 are the sets of annotations for the sentence in question. This approach punishes larger discrepancies in polarity more than small discrepancies, i.e. if annotator 1 decides an opinion expression is strong negative and annotator two that the same expression is positive, this will be reflected in a larger MSE score than if annotator 2 had chosen negative. Perfect agreement between annotators would lead to a MSE of 0.0, with the maximum depending on the length of the phrase. For a phrase of ten words, the worst MSE possible (assuming annotator 1 labeled all words strong positive and annotator 2 labeled them strong negative) would be a 9.0. We take the mean of all the MSE scores in the corpus.",
          "Inter-annotator agreement is reported in Table TABREF17 .",
          "The inter-annotator agreement for target and expressions is high and in line with previous annotation efforts BIBREF13 , given the fact that annotators could choose any span for these labels and were not limited to the number of annotations they could make. This reflects the clarity of the guidelines used to guide the annotation process.",
          "The agreement score for opinion holders is somewhat lower and stems from the fact that there were relatively few instances of explicit opinion holders. Additionally, Catalan and Basque both have agreement features for verbs, which could be considered an implicit mention of the opinion holder. This is not always clear, however. Finally, the mean squared error of the polarity scores shows that annotators generally agree on where and which polarity score should be given. Again, the mean squared error in this annotation scheme requires both annotators to choose the same span and the same polarity to achieve perfect agreement."
        ]
      },
      {
        "section_name": "Difficult Examples",
        "paragraphs": [
          "During annotation, there were certain sentences which presented a great deal of problems for the annotators. Many of these are difficult because of 1) nested opinions, 2) implicit opinions reported only through the presence or absence of certain aspects, or 3) the difficulty to identify the span of an expression. Here, we give examples of each difficulty and detail how these were resolved during the annotation process.",
          "In the Basque sentence in Example UID18 , we can see that there are two distinct levels of aspects. First, the aspect `hotel', which has a positive polarity and then the sub-aspect `workers'. We avoid the problem of deciding which is the opinion target by treating these as two separate opinions, whose targets are `hotel' and `workers'.",
          "If there was an implicit opinion based on the presence or absence of a desirable aspect, such as the one seen in Example UID19 , we asked annotators to identify the phrase that indicates presence or absence, i.e. `there was', as the opinion phrase.",
          "Finally, in order to improve overlap in span selection, we instructed annotators to choose the smallest span possible that retains the necessary information. Even after several iterations, however, there were still discrepancies with difficult examples, such as the one shown in Example UID20 , where the opinion target could be either `attention', `the attention', or `the attention that the staff gave'."
        ]
      },
      {
        "section_name": "Benchmarks",
        "paragraphs": [
          "In order to provide a simple baseline, we frame the extraction of opinion holders, targets, and phrases as a sequence labeling task and map the NAF tags to BIO tags for the opinions in each review. These tags serve as the gold labels which will need to be predicted at test time. We also perform classification of the polarity of opinion expressions.",
          "For the extraction of opinion holders, targets, and expressions we train a Conditional Random Field (CRF) on standard features for supervised sequence labeling (word-, subword-, and part-of-speech information of the current word and previous words). For the classification of the polarity of opinion expressions, we use a Bag-of-Words approach to extract features and then train a linear SVM classifier",
          "For evaluation, we perform a 10-fold cross-validation with 80 percent of the data reserved for training during each fold. For extraction and classification, we report the weighted INLINEFORM0 score. The results of the benchmark experiment (shown in Table TABREF23 ) show that these simple baselines achieve results which are somewhat lower but still comparable to similar tasks in English BIBREF5 . The drop is not surprising given that we use a relatively simple baseline system and due to the fact that Catalan and Basque have richer morphological systems than English, which were not exploited."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper we have presented the MultiBooked corpus \u2013 a corpus of hotel reviews annotated for aspect-level sentiment analysis available in Basque and Catalan. The aim of this annotation project is to allow researchers to enable research on supervised aspect-level sentiment analysis in Basque and Catalan, as well as provide useful data for cross- and multi-lingual sentiment analysis. We also provide inter-annotator agreement scores and benchmarks, as well as making the corpus available to the community."
        ]
      },
      {
        "section_name": "Language Resource References",
        "paragraphs": [
          "lrec lit"
        ]
      }
    ],
    "qas": [
      {
        "question": "What is the size of their published dataset?",
        "question_id": "9b05d5f723a8a452522907778a084b52e27fd924",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "911",
              "evidence": [
                "Many of the reviews that we found through crawling are either 1) in Spanish, 2) include a mix of Spanish and the target language, or 3) do not contain any sentiment phrases. Therefore, we use a simple language identification method in order to remove any Spanish or mixed reviews and also remove any reviews that are shorter than 7 tokens. This finally gave us a total of 568 reviews in Catalan and 343 reviews in Basque, collected from November 2015 to January 2016."
              ],
              "highlighted_evidence": [
                "This finally gave us a total of 568 reviews in Catalan and 343 reviews in Basque, collected from November 2015 to January 2016."
              ]
            },
            "annotation_id": "5b9fe5d6bb7265e432c36d03f86c9d10090ecc95",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
              ],
              "highlighted_evidence": [
                "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
              ]
            },
            "annotation_id": "7b14d1e2ff363459c184548d479fb019638f0b6a",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "910",
              "evidence": [
                "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
              ],
              "highlighted_evidence": [
                "The final Catalan corpus contains 567 annotated reviews and the final Basque corpus 343."
              ]
            },
            "annotation_id": "c098b15751ef5b5b4a0663b13894740d2b0533f9",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Simplified annotation guidelines."
      },
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: An opinion annotation following the annotation scheme detailed in Section 4.1.."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Corpus Statistics"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Inter-annotator agreement scores. AvgAgr score is reported for targets, expressions and holders and averaged mean squared error is reported for polarity."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Weighted F1 scores for extraction of opinion targets, expressions and holders, as well as the weighted F1 for classification of polarity."
      }
    ]
  },
  "1909.08250": {
    "title": "Natural Language Generation for Non-Expert Users",
    "abstract": "Motivated by the difficulty in presenting computational results, especially when the results are a collection of atoms in a logical language, to users, who are not proficient in computer programming and/or the logical representation of the results, we propose a system for automatic generation of natural language descriptions for applications targeting mainstream users. Differently from many earlier systems with the same aim, the proposed system does not employ templates for the generation task. It assumes that there exist some natural language sentences in the application domain and uses this repository for the natural language description. It does not require, however, a large corpus as it is often required in machine learning approaches. The systems consist of two main components. The first one aims at analyzing the sentences and constructs a Grammatical Framework (GF) for given sentences and is implemented using the Stanford parser and an answer set program. The second component is for sentence construction and relies on GF Library. The paper includes two use cases to demostrate the capability of the system. As the sentence construction is done via GF, the paper includes a use case evaluation showing that the proposed system could also be utilized in addressing a challenge to create an abstract Wikipedia, which is recently discussed in the BlueSky session of the 2018 International Semantic Web Conference.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Natural language generation (NLG) has been one of the key topics of research in natural language processing, which was highlighted by the huge body of work on NLG surveyed in BIBREF0, BIBREF1. With the advances of several devices capable of understanding spoken language and conducting conversation with human (e.g., Google Home, Amazon Echo) and the shrinking gap created by the digital devices, it is not difficult to foresee that the market and application areas of NLG systems will continue to grow, especially in applications whose users are non-experts. In such application, a user often asks for certain information and waits for the answer and a NLG module would return the answer in spoken language instead of text such as in question-answering systems or recommendation systems. The NLG system in these two applications uses templates to generate the answers in natural language for the users. A more advanced NLG system in this direction is described in BIBREF2, which works with ontologies annotated using the Attempto language and can generate a natural language description for workflows created by the systems built in the Phylotastic project. The applications targeted by these systems are significantly different from NLG systems, whose main purpose is to generate high-quality natural language description of objects or reports, such as those reported in the recent AAAI conference BIBREF3, BIBREF4, BIBREF5.",
          "The present paper is motivated by the need to generate natural language description of computational results to non-expert users such as those developed in the Phylotastic project. In this project, the users are experts in evolutionary biology but are none experts in ontologies and web services. When a user places a request, he/she will receive a workflow consisting of web services, whose inputs and outputs are specified by instances of classes in the ontologies working with web services, as well as the ordering and relationships between the services. To assist the user in understanding the workflow, a natural language description of the workflow is generated. In order to accomplish the task, the NLG system in the Phylotastic project proposes to annotate elements of the ontologies using Attempto, a simple subset of English with precisely defined syntax and semantics.",
          "In this paper, we propose a system that addresses the limitation of the system discussed in the Phylotastic project BIBREF2. Specifically, we assume that the annotations given in an ontology are natural language sentences. This is a reasonable assumption given that the developers of an ontology are usually those who have intimate knowledge about entities described in the ontology and often have some sort of comments about classes, objects, and instances of the ontology. We then show that the system is very flexible and can be used for the same purpose with new ontologies.",
          "The rest of the paper is organized as follows. Section SECREF2 briefly reviews the basics of Grammatical Framework (GF)BIBREF6. Section SECREF3 describes the main modules of the system. Section SECREF4 includes two use cases of the system using an available ontologies against in the context of reasoning about ontologies. Specifically, it compares with the system used in the Phylotastic project and an ontology about people. This section also contains a use case that highlights the versatility of the proposed system by addressing a challenge to create an abstract Wikipedia BIBREF7. Related works are discussed in Section SECREF5. Section SECREF6 concludes the paper."
        ]
      },
      {
        "section_name": "Background: Grammatical Framework",
        "paragraphs": [
          "The Grammatical Framework (GF) BIBREF6 is a system used for working with grammars. The GF Resource Grammar Library (RGL) covering syntax of various languages is the standard library for GF. A GF program has two main parts. The first part is the Abstract syntax which defines what meanings can be expressed by a grammar. The abstract syntax defines categories (i.e., types of meaning) and functions (i.e., meaning-building components). An example of an abstract syntax:",
          "Here, Message, People, Action and Entity are types of meanings. startcat flag states that Message is the default start category for parsing and generation. simple_sent is a function accepting 3 parameters, of type People, Action, Entity. This function returns a meaning of Message category. Intuitively, each function in the abstract syntax represents a rule in a grammar. The combination of rules used to construct a meaning type can be seen as a syntax tree.",
          "The second part is composed of one or more concrete syntax specifications. Each concrete syntax defines the representation of meanings in each output language. For example, to demostrate the idea that one meaning can be represented by different concrete syntaxes, we create two concrete syntaxes for two different languages: English and Italian. To translate a sentence to different languages, we only need to provide the strings representing each word in corresponding languages. The GF libraries will take responsibility to concatenate the provided strings according to the language grammar to create a complete sentence, which is the representations of the meaning, in the targeted language. The corresponding concrete syntaxes that map functions in the abstract grammar above to strings in English and in Italian is:",
          "In these concrete syntaxes, the linearization type definition (lincat) states that Message, People, Action and Entity are type Cl (clause), NP (noun phrase), V2 (two-place verb), and NP respectively. Linearization definitions (lin) indicate what strings are assigned to each of the meanings defined in the abstract syntax. To reduce same string declaration, the operator (oper) section defines some placeholders for strings that can be used in linearization. The mkNP, mkN, mkV2, etc. are standard constructors from ConstructorsEng/Jpn library which returns an object of the type NP, N or V2 respectively.",
          "GF has been used in a variety of applications, such as query-answering systems, voice communication, language learning, text analysis and translation, natural language generation BIBREF8, BIBREF9, automatic translation.",
          "The translation from English to Italian can be performed as follows in the GF API:",
          "The above command line produces a syntax tree of the sentence \u201cBill plays soccer\u201d then turn that tree into a PeopleIta sentence (in Italian) which is displayed in the second line. Figure FIGREF6 shows the meaning in the abstract syntax is represented in Japanese and in Italian, i.e. the two strings represent the same meaning."
        ]
      },
      {
        "section_name": "Method",
        "paragraphs": [
          "To generate a sentence, we need a sentence structure and vocabularies. Our system is developed to emulate the process of a person learning a new language and has to make guesses to understand new sentences from time to time. For example, someone, who understands the sentence \u201cBill plays a game\u201d would not fully understand the sentence \u201cBill plays a popular board game\u201d without knowing the meaning of \u201cpopular\u201d and \u201cboard game\u201d but could infer that the latter sentence indicates that its subject plays a type of game.",
          "The overall design of our system is given in Figure FIGREF7. Given a paragraph, our system produces a GF program (a pair of an abstract and a concrete syntax), which can be used for sentence generation. The system consists of two components, understanding sentences and generating GF grammar. The first component is divided into two sub-components, one for recognizing the sentence structure and one for recognizing the sentence components. The second component consists of a GF grammar encoder and a GF grammar exporter. The encoder is responsible for generating a GF grammar for each sentence, while the exporter aggregates the grammars generated from the encoder, and produces a comprehensive grammar for the whole paragraph."
        ]
      },
      {
        "section_name": "Method ::: Sentence Structure Recognition",
        "paragraphs": [
          "The sentence structure recognition process involves 2 modules: natural language processing (NLP) module and logical reasoning on result from NLP module. In this paper, we make use of the Stanford Parser tools described in BIBREF10, BIBREF11, BIBREF12, BIBREF13, BIBREF14",
          "The NLP module tokenizes the input free text to produce a dependency-based parse tree and part-of-speech tag (POS tag). The dependency-based parse tree and the POS tag are then transform into an answer set program (ASP) BIBREF15 which contains only facts. Table TABREF13 shows the transformation of the result of NLP module into an ASP program for the sentence \u201cBill plays a game\u201d. In this table, nsubj, det, dobj and punct denote relations in the dependency-based parse tree, and mean nominal subject, determiner, direct object and punctuation respectively. Full description of all relations in a dependency-based parse tree can be found in the Universal Dependency website. The second set of notations are the POS tag PRP, VBP, DT and NN corresponding to pronoun, verb, determiner and noun. Readers can find the full list of POS tag in Penn Treebank Project.",
          "From the collection of the dependency atoms from the dependency-based parse tree, we determine the structure of a sentence using an ASP program, called $\\Pi _1$ (Listing ).",
          "Each of the rule above can be read as if the right-hand side is true then the left-hand side must be true. These rules define five possible structures of a sentence represented by the atom structure(x,y). $x$ and $y$ in the atom structure(x,y) denote the type of the structure and the number of dependency relations applied to activate the rule generating this atom, respectively. We refer to $y$ as the $i$-value of the structure. For example, $structure(1,1)$ will be recognized if the nsubj relation is in the dependency-based parse tree; $structure(3,3)$ needs 3 dependency relations to be actived: nsubj, xcomp and dobj. We often use structure #$x$ to indicate a structure of type $x$.",
          "Together with the collection of the atoms encoding the relations in the dependency-based parse tree, $\\Pi _1$ generates several atoms of the form $structure(x,y)$ for a sentence. Among all these atoms, an atom with the highest $i$-value represents the structure constructed using the highest number of dependency relations. And hence, that structure is the most informative structure that is recoginized for the sentence. Observe that $structure(1,1)$ is the most simplified structure of any sentence."
        ]
      },
      {
        "section_name": "Method ::: Sentence Components Recognition",
        "paragraphs": [
          "The goal of this step is to identify the relationship between elements of a sentence structure and chunks of words in a sentence from the POS tags and the dependency-based parse tree. For example, the sentence \u201cBill plays a game\u201d is encoded by a structure #2 and we expect that Bill, plays, and game correspond to the subject, verb, and object, respectively.",
          "We begin with recognizing the main words (components) that play the most important roles in the sentence based on a given sentence structure. This is achieved by program $\\Pi _2$ (Listing ). The first four rules of $\\Pi _2$ determine the main subject and verb of the sentence whose structure is #1, #2, #3, or #5. Structure #4 requires a special treatment since the components following tobe can be of different forms. For instance, in \u201cCathy is gorgeous,\u201d the part after tobe is an adjective, but in \u201cCathy is a beautiful girl,\u201d the part after tobe is a noun, though, with adjective beautiful. This is done using the four last rules of $\\Pi _2$.",
          "The result of program $\\Pi _2$ is an one-to-one mapping of some of the words in the sentence into the importaint components of a sentence, called main components, i.e. subject, object and verb. The mapping is constructed by using the core arguments in Universal Dependency Relations . Since not every word in the sentence is in a core argument relation, there are some words in the sentence that are not in the domain of the mapping that $\\Pi _2$ produces. We denote these words are complement components. To identify these words, we encode the Non-core dependents and Nominal dependents from Universal Dependency Relations into the set of rules in program $\\Pi _3$.",
          "Program $\\Pi _3$ (Listing ), together with the atoms extracted from the dependency-based parse tree such as $compound(P,N)$ ($N$ is compound noun at the position $P$ in the sentence), $amod(P,J)$ ($J$ is an adjective modifier), etc., is used to identify the complement components of the main components computed by $\\Pi _2$ while maintaining the structure of the sentence created by $\\Pi _1$. For example, a complement of a noun could be another noun (as \u201cboard\u201d in \u201cboard game\u201d), or an adjective (as \u201cpopular\u201d in \u201cpopular board game\u201d), or a preposition (as \u201cfor adults\u201d in \u201cboard game for adults\u201d).",
          "The input of Program $\\Pi _3$ is the position ($pos$) of the word in the sentence. Program $\\Pi _3$ is called whenever there is a new complement component discovered. That way of recursive calls is to identify the maximal chunk of the words that support the main components of the sentence. The result of this module is a list of vocabularies for the next steps."
        ]
      },
      {
        "section_name": "Method ::: GF Grammar Encoder",
        "paragraphs": [
          "The goal of the encoder is to identify appropriate GF rules for the construction of a GF grammar of a sentence given its structure and its components identified in the previous two modules. This is necessary since a sentence can be encoded in GF by more than one set of rules; for example, the sentence \u201cBill wants to play a game\u201d can be encoded by the rules",
          "Bill $\\rightarrow $ NP, want $\\rightarrow $ VV, play $\\rightarrow $ V2, game $\\rightarrow $ NP and one of the sets of GF rules in the table below:",
          "",
          "In GF, NP, VV, V2, VP, and Cl stand for noun phrase, verb-phrase-complement verb, two-place verb, verb phrase and clause, respectively. Note that although the set of GF grammatical rules can be used to construct a constituency-based parse tree , the reverse direction is not always true. To the best of our knowledge, there exists no algorithm for converting a constituency-based parse tree to a set GF grammar rules. We therefore need to identify the GF rules for each sentence structure.",
          "In our system, a GF rule is assigned to a structure initially (Table TABREF19). Each rule in Table TABREF19 represents the first level of the constituency-based parse tree. It acts as the coordinator for all other succeeding rules.",
          "Given the seed components identified in Section SECREF15 and the above GF rules, a GF grammar for each sentence can be constructed. However, this grammar can only be used to generate fairly simple sentences. For example, for the sentence \u201cBill plays a popular board game with his close friends.\u201d, a GF grammar for structure #2 can be constructed, which can only generate the sentence \u201cBill plays game.\u201d because it does not contain any complement components identified in Section SECREF15. Therefore, we assgin a set of GF rules for the construction of each parameter in the GF rules in Table TABREF19. The set of GF rules has to follow two conventions. The first one is after applying the set of rules to some components of the sentence, the type of the production is one of the type in Table TABREF19, e.g. $NP$, $VP$, $Cl$, $V2$, .... The second convention is that the GF encoder will select the rules as the order from top to bottom in Table TABREF20. Note that the encoder always has information of what type of input and output for the rule it is looking for.",
          "For instance, we have \u201cgame\u201d is the object (main components), and we know that we have to construct \u201cgame\u201d in the result GF grammar to be a NP (noun phrase). Program $\\Pi _2$ identifies that there are two complement components for the word \u201cgame\u201d, which are \u201cboard\u201d and \u201cpopular\u201d, a noun and an adjective respectively. The GF encoder then select the set of rules: N $\\rightarrow $ N $\\rightarrow $ CN and A $\\rightarrow $ AP to create the common noun \u201cboard game\u201d and the adjective phrase first. The next rule is AP $\\rightarrow $ CN $\\rightarrow $ CN. The last rule to be applied is CN $\\rightarrow $ NP. The selection is easily decided since the input and the output of the rules are pre-determined, and there is no ambiguity in the selection process.",
          "The encoder uses the GF rules and the components identified by the previous subsections to produce different constructors for different components of a sentence. A part of the output of the GF encoder for the object \u201cgame\u201d is",
          "The encoder will also create the operators that will be included in the oper section of the GF grammar for supporting the new constructor. For example, the following operators will be generated for serving the Game constructor above:"
        ]
      },
      {
        "section_name": "Method ::: GF Grammar Exporter",
        "paragraphs": [
          "The GF Grammar Exporter has the simplest job among all modules in the system. It creates a GF program for a paragraph using the GF grammars created for the sentences of the paragraph. By taking the union of all respective elements of each grammar for each sentence, i.e., categories, functions, linearizations and operators, the Grammar Exporter will group them into the set of categories (respectively, categories, functions, linearizations, operators) of the final grammar."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We describe our method of generating natural language in two applications. The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. To test the feasibility of the approach, we also conduct another use case with the second ontology, that is entirely different from the ontologies used in the Phylotastic project. The ontology is about people and includes descriptions for certain class.",
          "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference BIBREF7. We create an intermediate representation that can be used to translate the original article in English to another language. In this use case, we translate the intermediate representation back to English and measure how the translated version stacks up again the original one. We assess the generation quality automatically with BLEU-3 and ROUGE-L (F measure). BLEU BIBREF16 and ROUGE BIBREF17 algorithms are chosen to evaluate our generator since the central idea of both metrixes is \u201cthe closer a machine translation is to a professional human translation, the better it is\u201d, thus, they are well-aligned with our use cases' purpose. In short, the higher BLUE and ROUGE score are, the more similar the hypothesis text and the reference text is. In our use case, the hypothesis for BLEU and ROUGE is the generated English content from the intermediate representation, and the reference text is the original text from Wikipedia."
        ]
      },
      {
        "section_name": "Experiments ::: NLG for Annotated Ontologies",
        "paragraphs": [
          "As described in BIBREF2, the author's system retrieves a set of atoms from an ASP program such as those in Listing where phylotastic FindScientificNamesFromWeb GET was shortened to service, propagates the atoms, and constructs a set of sentences having similar structure to the sentence \u201cThe input of phylotastic FindScientificNamesFromWeb GET is a web link. Its outputs are a set of species names and a set of scientific names\u201d. In this sentence, phylotastic FindScientificNamesFromWeb GET is the name of the service involved in the workflow of the Phylotastic project. All of the arguments of the atoms above are the names of classes and instances from Phylotastic ontology.",
          "We replace the original Attempto annotations with the natural language annotations as in Table TABREF24 and test with our system.",
          "With the same set of atoms as in Listing , our system generates the following description \u201cInput of phylotastic FindScientificNamesFromWeb GET is web link. Type of web link is url. Output of phylotastic FindScientificNamesFromWeb GET is scientific names. Output of phylotastic FindScientificNamesFromWeb GET is species names. Type of scientific names is names. Type of species name is names.\u201d.",
          "We also test our system with the people ontology as noted above. We extract all comments about people and replace compound sentences with simple sentences, e.g., \u201cMick is male and drives a white van\u201d is replaced by the two sentences \u201cMick is male\u201d and \u201cMick drives a white van.\u201d to create a collection of sample sentences. We then use our system to generate a GF program which is used to generate sentences for RDF tuples. Sample outputs for some tuples are in Table TABREF25. This shows that for targeted applications, our system could do a reasonable job."
        ]
      },
      {
        "section_name": "Experiments ::: Intermediate Representation for Wiki Pages",
        "paragraphs": [
          "Since our system creates a GF program for a set of sentences, it could be used as an intermediate representation of a paragraph. This intermediate representation could be used by GF for automatic translation as GF is well-suited for cross-languages translation. On the other hand, we need to assess whether the intermediate representation is meaningful. This use case aims at checking the adequacy of the representation. To do so, we generate the English sentences from the GF program and evaluate the quality of these sentences against the original ones. We randomly select 5 articles from 3 Wikipedia portals: People, Mathematics and Food & Drink.",
          "With the small set of rules introducing in this paper to recognize sentence structure, there would be very limited 4-gram in the generated text appearing in original Wikipedia corpus. Therefore, we use BLEU-3 with equal weight distribution instead of BLEU-4 to assess the generated content. Table TABREF27 shows the summary of the number of assessable sentences from our system. Out of 62 sentences from 3 portals, the system cannot determine the structure 2 sentences in Mathematics due to their complexity. This low number of failure shows that our 5 proposed sentence structures effectively act as a lower bound on sentence recognition module.",
          "In terms of quality, Table TABREF28 shows the average of BLEU and ROUGE score for each portal. Note that the average BLUE score is calculated only on BLEU assessable sentences, while average ROUGE score is calculated on the sentences whose structure can be recognized and encoded by our system. We note that the BLEU or ROUGE score might not be sufficiently high for a good quality translation. We believe that two reasons contribute to this low score. First, the present system uses fairly simple sentence structures. Second, it does not consider the use of relative clauses to enrich the sentences. This feature will be added to the next version of the system.",
          "Table TABREF32 summarizes the result of this use case. On the left are the paragraphs extracted from the Wikipedia page about Rice in Food & Drink, Decimal in Mathematics, and about Alieu Ebrima Cham Joof from People. As we can see, the main points of the paragraphs are maintained."
        ]
      },
      {
        "section_name": "Related Works",
        "paragraphs": [
          "The systems developed in BIBREF18, BIBREF19, BIBREF3 use statistical generation method to produce descriptions of tables or explanation and recommendation from users' reviews of an item. All three systems are capable of generating high quality descriptions and/or explanations. In comparing to these systems, our system does not use the statistical generation method. Instead, we use Grammatical Framework for the generation task. A key difference between these systems and our system lies in the requirement of a large corpus of text in a specific domain for training and generation of these systems. Our system can work with very limited data and a wide range of domains.",
          "Another method for generating natural language explanation for an question-answering system is proposed in BIBREF20, BIBREF4. BIBREF20 (BIBREF20) describes a system that can give reasonable and supportive evidence to the answer to a question asked to an image, while BIBREF4 (BIBREF4) generates explanations for scheduling problem using argumentation. BIBREF21 (BIBREF21) use ASP to develop a system answering questions in the do-it-yourself domain. These papers use templates to generate answers. The generated GF program generated by our system, that is used for the NLG task, is automatically created from a provided input.",
          "The sophisticated system presented by BIBREF5 translates both question and the given natural language text to logical representation, and uses logical reasoning to produce the answer. Our system is similar to their system in that both employ recent developments of NLP into solving NLG problems."
        ]
      },
      {
        "section_name": "Conclusions and Future Work",
        "paragraphs": [
          "We propose a system implemented using answer set programming (ASP) and Grammatical Framework (GF), for automatic generation of natural language descriptions in applications targeting mainstream users. The system does not require a large corpus for the generation task and can be used in different types of applications.",
          "In the first type of applications, the system can work with annotated ontologies to translate a set of atoms\u2014representing the answer to a query to the ontology\u2014to a set of sentences. To do so, the system extracts the annotations related to the atoms in the answer and creates a GF program that is then used to generate natural language description of the given set of atoms. In the second type of applications, the system receives a paragraph of text and generates an intermediate representation\u2014as a GF program\u2014for the paragraph, which can be used for different purpose such as cross-translation, addressing a need identified in BIBREF7 .",
          "Our use cases with different ontologies and Wikipedia portals provide encouraging results. They also point to possible improvements that we plan to introduce to the next version of the system. We will focus on processing relative clauses and enriching the set of sentence structures, especially for compound and complex sentences."
        ]
      }
    ],
    "qas": [
      {
        "question": "What are two use cases that demonstrate capability of created system?",
        "question_id": "de4e949c6917ff6933f5fa2a3062ba703aba014c",
        "nlp_background": "zero",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "computer vision",
        "question_writer": "258ee4069f740c400c0049a2580945a1cc7f044c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project",
                "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We describe our method of generating natural language in two applications. The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. To test the feasibility of the approach, we also conduct another use case with the second ontology, that is entirely different from the ontologies used in the Phylotastic project. The ontology is about people and includes descriptions for certain class.",
                "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference BIBREF7. We create an intermediate representation that can be used to translate the original article in English to another language. In this use case, we translate the intermediate representation back to English and measure how the translated version stacks up again the original one. We assess the generation quality automatically with BLEU-3 and ROUGE-L (F measure). BLEU BIBREF16 and ROUGE BIBREF17 algorithms are chosen to evaluate our generator since the central idea of both metrixes is \u201cthe closer a machine translation is to a professional human translation, the better it is\u201d, thus, they are well-aligned with our use cases' purpose. In short, the higher BLUE and ROUGE score are, the more similar the hypothesis text and the reference text is. In our use case, the hypothesis for BLEU and ROUGE is the generated English content from the intermediate representation, and the reference text is the original text from Wikipedia."
              ],
              "highlighted_evidence": [
                "The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2.",
                "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference BIBREF7."
              ]
            },
            "annotation_id": "43ebc2d9edc303d284df660bacdda40cc3b8f2ef",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "natural language description for workflow created by the system built in the Phylotastic project",
                "about people and includes descriptions for certain class"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We describe our method of generating natural language in two applications. The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. To test the feasibility of the approach, we also conduct another use case with the second ontology, that is entirely different from the ontologies used in the Phylotastic project. The ontology is about people and includes descriptions for certain class."
              ],
              "highlighted_evidence": [
                "We describe our method of generating natural language in two applications. The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. To test the feasibility of the approach, we also conduct another use case with the second ontology, that is entirely different from the ontologies used in the Phylotastic project. The ontology is about people and includes descriptions for certain class."
              ]
            },
            "annotation_id": "99d32acecde92827b18f32a4b6804bccbb367561",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "The first application is to build a natural language description of the ontologies built in an evolutionary biology project called Phylotastic, so that biologists can understand the output, without knowledge of ontologies. The second aims to create an abstract or intermediate representation of the Wikipedia pages from the BlueSky session in 2018.",
              "evidence": [
                "We describe our method of generating natural language in two applications. The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. To test the feasibility of the approach, we also conduct another use case with the second ontology, that is entirely different from the ontologies used in the Phylotastic project. The ontology is about people and includes descriptions for certain class.",
                "The present paper is motivated by the need to generate natural language description of computational results to non-expert users such as those developed in the Phylotastic project. In this project, the users are experts in evolutionary biology but are none experts in ontologies and web services. When a user places a request, he/she will receive a workflow consisting of web services, whose inputs and outputs are specified by instances of classes in the ontologies working with web services, as well as the ordering and relationships between the services. To assist the user in understanding the workflow, a natural language description of the workflow is generated. In order to accomplish the task, the NLG system in the Phylotastic project proposes to annotate elements of the ontologies using Attempto, a simple subset of English with precisely defined syntax and semantics.",
                "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference BIBREF7. We create an intermediate representation that can be used to translate the original article in English to another language. In this use case, we translate the intermediate representation back to English and measure how the translated version stacks up again the original one. We assess the generation quality automatically with BLEU-3 and ROUGE-L (F measure). BLEU BIBREF16 and ROUGE BIBREF17 algorithms are chosen to evaluate our generator since the central idea of both metrixes is \u201cthe closer a machine translation is to a professional human translation, the better it is\u201d, thus, they are well-aligned with our use cases' purpose. In short, the higher BLUE and ROUGE score are, the more similar the hypothesis text and the reference text is. In our use case, the hypothesis for BLEU and ROUGE is the generated English content from the intermediate representation, and the reference text is the original text from Wikipedia.",
                "Experiments ::: Intermediate Representation for Wiki Pages",
                "Since our system creates a GF program for a set of sentences, it could be used as an intermediate representation of a paragraph. This intermediate representation could be used by GF for automatic translation as GF is well-suited for cross-languages translation. On the other hand, we need to assess whether the intermediate representation is meaningful. This use case aims at checking the adequacy of the representation. To do so, we generate the English sentences from the GF program and evaluate the quality of these sentences against the original ones. We randomly select 5 articles from 3 Wikipedia portals: People, Mathematics and Food & Drink."
              ],
              "highlighted_evidence": [
                "The first application is to generate a natural language description for workflow created by the system built in the Phylotastic project described in BIBREF2. Instead of requiring that the ontologies are annotated using Attempto, we use natural language sentences to annotate the ontologies. ",
                "The present paper is motivated by the need to generate natural language description of computational results to non-expert users such as those developed in the Phylotastic project. In this project, the users are experts in evolutionary biology but are none experts in ontologies and web services.",
                "The second application targets the challenge of creating an abstract Wikipedia from the BlueSky session of 2018 International Semantic Web Conference BIBREF7. We create an intermediate representation that can be used to translate the original article in English to another language. In this use case, we translate the intermediate representation back to English and measure how the translated version stacks up again the original one. ",
                "Experiments ::: Intermediate Representation for Wiki Pages\nSince our system creates a GF program for a set of sentences, it could be used as an intermediate representation of a paragraph. This intermediate representation could be used by GF for automatic translation as GF is well-suited for cross-languages translation. On the other hand, we need to assess whether the intermediate representation is meaningful. "
              ]
            },
            "annotation_id": "9fba0066c7471c32b436f9a62637a0883b877be0",
            "worker_id": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: Google translation for the Japanese sentence generated by GF. The two sentences in English and in Italian are the two representations of the meaning encoded in the abstract syntax."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: System Overview"
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Transformation from NLP result to asp program"
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: GF Rules Assigned to Each Structure"
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: Extended GF Rules"
      },
      {
        "file": "10-Table4-1.png",
        "caption": "Table 4: Atoms from Phylotastic project and its annotation"
      },
      {
        "file": "10-Table5-1.png",
        "caption": "Table 5: Sample outputs for the people ontology."
      },
      {
        "file": "11-Table6-1.png",
        "caption": "Table 6: BLEU assessable sentences"
      },
      {
        "file": "11-Table7-1.png",
        "caption": "Table 7: BLUE and ROUGE score"
      },
      {
        "file": "12-Table8-1.png",
        "caption": "Table 8: Original sentences extracted from Wikipedia and corresponding generated sentences"
      }
    ]
  },
  "1612.07486": {
    "title": "Continuous multilinguality with language vectors",
    "abstract": "Most existing models for multilingual natural language processing (NLP) treat language as a discrete category, and make predictions for either one language or the other. In contrast, we propose using continuous vector representations of language. We show that these can be learned efficiently with a character-based neural language model, and used to improve inference about language varieties not seen during training. In experiments with 1303 Bible translations into 990 different languages, we empirically explore the capacity of multilingual language models, and also show that the language vectors capture genetic relationships between languages.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Neural language models BIBREF0 , BIBREF1 , BIBREF2 have become an essential component in several areas of natural language processing (NLP), such as machine translation, speech recognition and image captioning. They have also become a common benchmarking application in machine learning research on recurrent neural networks (RNN), because producing an accurate probabilistic model of human language is a very challenging task which requires all levels of linguistic analysis, from pragmatics to phonology, to be taken into account.",
          "A typical language model is trained on text in a single language, and if one needs to model multiple languages the standard solution is to train a separate model for each language. This presupposes large quantities of monolingual data in each of the languages that needs to be covered and each model with its parameters is completely independent of any of the other models.",
          "We propose instead to use a single model with real-valued vectors to indicate the language used, and to train this model with a large number of languages. We thus get a language model whose predictive distribution INLINEFORM0 is a continuous function of the language vector INLINEFORM1 , a property that is trivially extended to other neural NLP models. In this paper, we explore the \u201clanguage space\u201d containing these vectors, and in particular explore what happens when we move beyond the points representing the languages of the training corpus.",
          "The motivation of combining languages into one single model is at least two-fold: First of all, languages are related and share many features and properties, a fact that is ignored when using independent models. The second motivation is data sparseness, an issue that heavily influences the reliability of data-driven models. Resources are scarce for most languages in the world (and also for most domains in otherwise well-supported languages), which makes it hard to train reasonable parameters. By combining data from many languages, we hope to mitigate this issue.",
          "In contrast to related work, we focus on massively multilingual data sets to cover for the first time a substantial amount of the linguistic diversity in the world in a project related to data-driven language modeling. We do not presuppose any prior knowledge about language similarities and evolution and let the model discover relations on its own purely by looking at the data. The only supervision that is giving during training is a language identifier as a one-hot encoding. From that and the actual training examples, the system learns dense vector representations for each language included in our data set along with the character-level RNN parameters of the language model itself."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Multilingual language models is not a new idea BIBREF3 , the novelty of our work lies primarily in the use of language vectors and the empirical evaluation using nearly a thousand languages.",
          "Concurrent with this work, Johnson2016zeroshot conducted a study using neural machine translation (NMT), where a sub-word decoder is told which language to generate by means of a special language identifier token in the source sentence. This is close to our model, although beyond a simple interpolation experiment (as in our sec:generating) they did not further explore the language vectors, which would have been challenging to do given the small number of languages used in their study.",
          "Ammar2016manylanguages used one-hot language identifiers as input to a multilingual word-based dependency parser, based on multilingual word embeddings. Given that they report this resulting in higher accuracy than using features from a typological database, it is a reasonable guess that their system learned language vectors which were able to encode syntactic properties relevant to the task. Unfortunately, they also did not look closer at the language vector space, which would have been interesting given the relatively large and diverse sample of languages represented in the Universal Dependencies treebanks.",
          "Our evaluation in sec:clustering calls to mind previous work on automatic language classification, by Wichmann2010evaluating among others. However, our purpose is not to detect genealogical relationships, even though we use the strong correlation between such classifications and our language vectors as evidence that the vector space captures sensible information about languages."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "We base our experiments on a large collection of Bible translations crawled from the web, coming from various sources and periods of times. Any other multilingual data collection would work as well, but with the selected corpus we have the advantage that we cover the same genre and roughly the same coverage for each language involved. It is also easy to divide the data into training and test sets by using Bible verse numbers, which allows us to control for semantic similarity between languages in a way that would have been difficult in a corpus that is not multi-parallel. Altogether we have 1,303 translations in 990 languages that we can use for our purposes. These were chosen so that the model alphabet size is below 1000 symbols, which was satisfied by choosing only translations in Latin, Cyrillic or Greek script.",
          "Certainly, there are disadvantages as well, such as the limited size (roughly 500 million tokens in total, with most languages having only one translation of the New Testament each, with roughly 200 thousand tokens), the narrow domain and the high overlap of named entities. The latter can lead to some unexpected effects when using nonsensical language vectors, as the model will then generate a sequence of random names.",
          "The corpus deviates in some ways from an ideal multi-parallel corpus. Most translations are of the complete New Testament, whereas around 300 also contain the Old Testament (thus several times longer), and around ten contain only portions of the New Testament. Additionally, several languages have multiple translations, which are then concatenated. These translations may vary in age and style, but historical versions of languages (with their own ISO 639-3 code) are treated as distinct languages. During training we enforce a uniform distribution between languages when selecting training examples."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "Our model is based on a standard stacked character-based LSTM BIBREF4 with two layers, followed by a hidden layer and a final output layer with softmax activations. The only modification made to accommodate the fact that we train the model with text in nearly a thousand languages, rather than one, is that language embedding vectors are concatenated to the inputs of the LSTMs at each time step and the hidden layer before the softmax. We used three separate embeddings for these levels, in an attempt to capture different types of information about languages. The model structure is summarized in fig:model.",
          "In our experiments we use 1024-dimensional LSTMs, 128-dimensional character embeddings, and 64-dimensional language embeddings. Layer normalization BIBREF5 is used, but no dropout or other regularization since the amount of data is very large (about 3 billion characters) and training examples are seen at most twice. For smaller models early stopping is used. We use Adam BIBREF6 for optimization. Training takes between an hour and a few days on a K40 GPU, depending on the data size."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "In this section, we present several experiments with the model described. For exploring the language vector space, we use hierarchical agglomerative clustering for visualization. For measuring performance, we use cross-entropy on held out-data. For this, we use a set of the 128 most commonly translated Bible verses, to ensure that the held-out set is as large and overlapping as possible among languages."
        ]
      },
      {
        "section_name": "Model capacity",
        "paragraphs": [
          "Our first experiment tries to answer what happens when more and more languages are added to the model. There are two settings: adding languages in a random order, or adding the most closely related languages first. Cross-entropy plots for these settings are shown in fig:random and fig:swe.",
          "In both cases, the model degrades gracefully (or even improves) for a number of languages, but then degrades linearly (i.e. exponential growth of perplexity) with exponentially increasing number of languages.",
          "For comparison, fig:swesize compares this to the effect of decreasing the number of parameters in the LSTM by successively halving the hidden state size. Here the behavior is similar, but unlike the Swedish model which got somewhat better when closely related languages were added, the increase in cross-entropy is monotone. It would be interesting to investigate how the number of model parameters needs to be scaled up in order to accommodate the additional languages, but unfortunately the computational resources for such an experiment increases with the number of languages and would not be practical to carry out with our current equipment."
        ]
      },
      {
        "section_name": "Structure of the language space",
        "paragraphs": [
          "We now take a look at the language vectors found during training with the full model of 990 languages. fig:germanic shows a hierarchical clustering of the subset of Germanic languages, which closely matches the established genetic relationships in this language family. While our experiments indicate that finding more remote relationships (say, connecting the Germanic languages to the Celtic) is difficult for the model, it is clear that the language vectors preserves similarity properties between languages.",
          "In additional experiments we found the overall structure of these clusterings to be relatively stable across models, but for very similar languages (such as Danish and the two varieties of Norwegian) the hierarchy might differ, and the some holds for languages or groups that are significantly different from the major groups. An example from fig:germanic is English, which is traditionally classified as a West Germanic language with strong influences from North Germanic as well as Romance languages. In the figure English is (weakly) grouped with the West Germanic languages, but in other experiments it is instead weakly grouped with North Germanic."
        ]
      },
      {
        "section_name": "Generating Text",
        "paragraphs": [
          "Since our language model is conditioned on a language vector, we can gain some intuitive understanding of the language space by generating text from different points in it. These points could be either one of the vectors learned during training, or some arbitrary other point. tab:interpolation shows text samples from different points along the line between Modern English [eng] and Middle English [enm]. Consistent with the results of Johnson2016zeroshot, it appears that the interesting region lies rather close to 0.5. Compare also to our fig:eng-deu, which shows that up until about a third of the way between English and German, the language model is nearly perfectly tuned to English."
        ]
      },
      {
        "section_name": "Mixing and Interpolating Between Languages",
        "paragraphs": [
          "By means of cross-entropy, we can also visualize the relation between languages in the multilingual space. Figure FIGREF12 plots the interpolation results for two relatively dissimilar languages, English and German. As expected, once the language vector moves too close to the German one, model performance drops drastically.",
          "More interesting results can be obtained if we interpolate between two language variants and compute cross-entropy of a text that represents an intermediate form. fig:eng-enm shows the cross-entropy of the King James Version of the Bible (published 1611), when interpolating between Modern English (1500\u2013) and Middle English (1050\u20131500). The optimal point turns out to be close to the midway point between them."
        ]
      },
      {
        "section_name": "Language identification",
        "paragraphs": [
          "If we have a sample of an unknown language or language variant, it is possible to estimate its language vector by backpropagating through the language model with all parameters except the language vector fixed. We found that a very small set of sentences is enough to give a considerable improvement in cross-entropy on held-out sentences. In this experiment, we used 32 sentences from the King James Version of the Bible. Using the resulting language vector, test set cross-entropy improved from 1.39 (using the Modern English language vector as initial value) to 1.35. This is comparable to the result obtained in sec:interpolation, except that here we do not restrict the search space to points on a straight line between two language vectors."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "We have shown that language vectors, dense vector representations of natural languages, can be learned efficiently from raw text and possess several interesting properties. First, they capture language similarity to the extent that language family trees can be reconstructed by clustering the vectors. Second, they allow us to interpolate between languages in a sensible way, and even allow adopting the model using a very small set of text, simply by optimizing the language vector."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they explore how their word representations vary across languages?",
        "question_id": "4cf05da602669a4c09c91ff5a1baae6e30adefdf",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We now take a look at the language vectors found during training with the full model of 990 languages. fig:germanic shows a hierarchical clustering of the subset of Germanic languages, which closely matches the established genetic relationships in this language family. While our experiments indicate that finding more remote relationships (say, connecting the Germanic languages to the Celtic) is difficult for the model, it is clear that the language vectors preserves similarity properties between languages."
              ],
              "highlighted_evidence": [
                "We now take a look at the language vectors found during training with the full model of 990 languages. fig:germanic shows a hierarchical clustering of the subset of Germanic languages, which closely matches the established genetic relationships in this language family. While our experiments indicate that finding more remote relationships (say, connecting the Germanic languages to the Celtic) is difficult for the model, it is clear that the language vectors preserves similarity properties between languages."
              ]
            },
            "annotation_id": "35a52b94300bc1ef86915f6c453ed28e95f65fa8",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "In contrast to related work, we focus on massively multilingual data sets to cover for the first time a substantial amount of the linguistic diversity in the world in a project related to data-driven language modeling. We do not presuppose any prior knowledge about language similarities and evolution and let the model discover relations on its own purely by looking at the data. The only supervision that is giving during training is a language identifier as a one-hot encoding. From that and the actual training examples, the system learns dense vector representations for each language included in our data set along with the character-level RNN parameters of the language model itself."
              ],
              "highlighted_evidence": [
                "From that and the actual training examples, the system learns dense vector representations for each language included in our data set along with the character-level RNN parameters of the language model itself."
              ]
            },
            "annotation_id": "3d997e92d027b0bbdaec1eb72b757998dbdaa3e7",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "6d03fa2b0e09db6e32d531d7e9c9e7cab3ec353a",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Schematic of our model. The three parts of the language vector are concatenated with the inputs to the two LSTM:s and the final softmax layer."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Cross-entropy of the test sets from the first four languages added to our model. At the leftmost point (x = 1), only Chayahuita is used for training the model so no results are available for the other languages."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Cross-entropy of the test sets from Scandinavian languages. The languages added at each step are: Swedish, Norwegian+Danish, Icelandic+Faroese, remaining Germanic, remaining Indo-European, all remaining languages."
      },
      {
        "file": "3-Figure4-1.png",
        "caption": "Figure 4: Cross-entropy of the Swedish test set, given two conditions: increasing number of languages by the given factor (adding the most similar languages first) or decreasing number of parameters by the same factor (for a monolingual model, which is why the curves meet at x = 1)."
      },
      {
        "file": "4-Figure5-1.png",
        "caption": "Figure 5: Hierarchical clustering of language vectors of Germanic languages."
      },
      {
        "file": "4-Figure6-1.png",
        "caption": "Figure 6: Cross-entropy of interpolated language models for English and German measured on English held-out text."
      },
      {
        "file": "5-Figure7-1.png",
        "caption": "Figure 7: Cross-entropy of interpolated language models for modern and middle English tested on data from the King James Bible."
      }
    ]
  },
  "1612.03762": {
    "title": "From narrative descriptions to MedDRA: automagically encoding adverse drug reactions",
    "abstract": "The collection of narrative spontaneous reports is an irreplaceable source for the prompt detection of suspected adverse drug reactions (ADRs): qualified domain experts manually revise a huge amount of narrative descriptions and then encode texts according to MedDRA standard terminology. The manual annotation of narrative documents with medical terminology is a subtle and expensive task, since the number of reports is growing up day-by-day. MagiCoder, a Natural Language Processing algorithm, is proposed for the automatic encoding of free-text descriptions into MedDRA terms. MagiCoder procedure is efficient in terms of computational complexity (in particular, it is linear in the size of the narrative input and the terminology). We tested it on a large dataset of about 4500 manually revised reports, by performing an automated comparison between human and MagiCoder revisions. For the current base version of MagiCoder, we measured: on short descriptions, an average recall of $86\\%$ and an average precision of $88\\%$; on medium-long descriptions (up to 255 characters), an average recall of $64\\%$ and an average precision of $63\\%$. From a practical point of view, MagiCoder reduces the time required for encoding ADR reports. Pharmacologists have simply to review and validate the MagiCoder terms proposed by the application, instead of choosing the right terms among the 70K low level terms of MedDRA. Such improvement in the efficiency of pharmacologists' work has a relevant impact also on the quality of the subsequent data analysis. We developed MagiCoder for the Italian pharmacovigilance language. However, our proposal is based on a general approach, not depending on the considered language nor the term dictionary.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Pharmacovigilance includes all activities aimed to systematically study risks and benefits related to the correct use of marketed drugs. The development of a new drug, which begins with the production and ends with the commercialization of a pharmaceutical product, considers both pre-clinical studies (usually tests on animals) and clinical studies (tests on patients). After these phases, a pharmaceutical company can require the authorization for the commercialization of the new drug. Notwithstanding, whereas at this stage drug benefits are well-know, results about drug safety are not conclusive BIBREF0 . The pre-marketing tests cited above have some limitations: they involve a small number of patients; they exclude relevant subgroups of population such as children and elders; the experimentation period is relatively short, less than two years; the experimentation does not deal with possibly concomitant pathologies, or with the concurrent use of other drugs. For all these reasons, non-common Adverse Drug Reactions (ADRs), such as slowly-developing pathologies (e.g., carcinogenesis) or pathologies related to specific groups of patients, are hardly discovered before the commercialization. It may happen that drugs are withdrawn from the market after the detection of unexpected collateral effects. Thus, it stands to reason that the post-marketing control of ADRs is a necessity, considering the mass production of drugs. As a consequence, pharmacovigilance plays a crucial role in human healthcare improvement BIBREF0 .",
          "Spontaneous reporting is the main method pharmacovigilance adopts in order to identify adverse drug reactions. Through spontaneous reporting, health care professionals, patients, and pharmaceutical companies can voluntarily send information about suspected ADRs to the national regulatory authority. The spontaneous reporting is an important activity. It provides pharmacologists and regulatory authorities with early alerts, by considering every drug on the market and every patient category.",
          "The Italian system of pharmacovigilance requires that in each local healthcare structure (about 320 in Italy) there is a qualified person responsible for pharmacovigilance. Her/his assignment is to collect reports of suspected ADRs and to send them to the National Network of Pharmacovigilance (RNF, in Italian) within seven days since they have been received. Once reports have been notified and sent to RNF they are analysed by both local pharmacovigilance centres and by the Drug Italian Agency (AIFA). Subsequently, they are sent to Eudravigilance BIBREF1 and to VigiBase BIBREF2 (the European and the worldwide pharmacovigilance network RNF is part of, respectively). In general, spontaneous ADR reports are filled out by health care professionals (e.g., medical specialists, general practitioners, nurses), but also by citizens. In last years, the number of ADR reports in Italy has grown rapidly, going from approximately ten thousand in 2006 to around sixty thousand in 2014 BIBREF3 , as shown in Figure FIGREF3 .",
          "Since the post-marketing surveillance of drugs is of paramount importance, such an increase is certainly positive. At the same time, the manual review of the reports became difficult and often unbearable both by people responsible for pharmacovigilance and by regional centres. Indeed, each report must be checked, in order to control its quality; it is consequently encoded and transferred to RNF via \u201ccopy by hand\u201d (actually, a printed copy).",
          "Recently, to increase the efficiency in collecting and managing ADR reports, a web application, called VigiFarmaco, has been designed and implemented for the Italian pharmacovigilance. Through VigiFarmaco, a spontaneous report can be filled out online by both healthcare professionals and citizens (through different user-friendly forms), as anonymous or registered users. The user is guided in compiling the report, since it has to be filled step-by-step (each phase corresponds to a different report section, i.e., \u201cPatient\u201d, \u201cAdverse Drug Reaction\u201d, \u201cDrug Treatments\u201d, and \u201cReporter\u201d, respectively). At each step, data are validated and only when all of them have been correctly inserted the report can be successfully submitted.",
          "Once ADR reports are submitted, they need to be validated by a pharmacovigilance supervisor. VigiFarmaco provides support also in this phase and is useful also for pharmacovigilance supervisors. Indeed, VigiFarmaco reports are high-quality documents, since they are automatically validated (the presence, the format, and the consistency of data are validated at the filling time). As a consequence, they are easier to review (especially with respect to printed reports). Moreover, thanks to VigiFarmaco, pharmacologists can send reports (actually, XML files BIBREF4 ) to RNF by simply clicking a button, after reviewing it.",
          "Online reports have grown up to become the 30% of the total number of Italian reports. As expected, it has been possible to observe that the average time between the dispatch of online reports and the insertion into RNF is sensibly shorter with respect to the insertion from printed reports. Notwithstanding, there is an operation which still requires the manual intervention of responsibles for pharmacovigilance also for online report revisions: the encoding in MedDRA terminology of the free text, through which the reporter describes one or more adverse drug reactions. MedDRA (Medical Dictionary for Regulatory Activities) is a medical terminology introduced with the purpose to standardize and facilitate the sharing of information about medicinal products in particular with respect to regulatory activities BIBREF5 . The description of a suspected ADR through narrative text could seem redundant/useless. Indeed, one could reasonably imagine sound solutions based either on an autocompletion form or on a menu with MedDRA terms. In these solutions, the description of ADRs would be directly encoded by the reporter and no expert work for MedDRA terminology extraction would be required. However, such solutions are not completely suited for the pharmacovigilance domain and the narrative description of ADRs remains a desirable feature, for at least two reasons. First, the description of an ADR by means of one of the seventy thousand MedDRA terms is a complex task. In most cases, the reporter who points out the adverse reaction is not an expert in MedDRA terminology. This holds in particular for citizens, but it is still valid for several professionals. Thus, describing ADRs by means of natural language sentences is simpler. Second, the choice of the suitable term(s) from a given list or from an autocompletion field can influence the reporter and limit her/his expressiveness. As a consequence, the quality of the description would be also in this case undermined. Therefore, VigiFarmaco offers a free-text field for specifying the ADR with all the possible details, without any restriction about the content or strict limits to the length of the written text. Consequently, MedDRA encoding has then to be manually implemented by qualified people responsible for pharmacovigilance, before the transmission to RNF. As this work is expensive in terms of time and attention required, a problem about the accuracy of the encoding may occur given the continuous growing of the number of reports.",
          "According to the described scenario, in this paper we propose INLINEFORM0 , an original Natural Language Processing (NLP) BIBREF6 algorithm and related software tool, which automatically assigns one or more terms from a dictionary to a narrative text. A preliminary version of INLINEFORM1 has been proposed in BIBREF7 . MagiCoder has been first developed for supporting pharmacovigilance supervisors in using VigiFarmaco, providing them with an initial automatic MedDRA encoding of the ADR descriptions in the online reports collected by VigiFarmaco, that the supervisors check and may correct or accept as it is. In this way, the encoding task, previously completely manual, becomes semi-automatic, reducing errors and the required time for accomplishing it. In spite of its first goal, MagiCoder has now evolved in an autonomous algorithm and software usable in all contexts where terms from a dictionary have to be recognized in a free narrative text. With respect to other solutions already available in literature and market, MagiCoder has been designed to be efficient and less computationally expensive, unsupervised, and with no need of training. MagiCoder uses stemming to be independent from singular/plural and masculine/feminine forms. Moreover, it uses string distance and other techniques to find best matching terms, discarding similar and non optimal terms.",
          "With respect to the first version BIBREF7 , we extended our proposal following several directions. First of all, we refined the procedure: MagiCoder has been equipped with some heuristic criteria and we started to address the problem of including auxiliary dictionaries (e.g., in order to deal with synonyms). MagiCoder computational complexity has been carefully studied and we will show that it is linear in the size of the dictionary (in this case, the number of LLTs in MedDRA) and the text description. We performed an accurate test of MagiCoder performances: by means of well-known statistical measures, we collected a significant set of quantitative information about the effective behavior of the procedure. We largely discuss some crucial key-points we met in the development of this version of MagiCoder, proposing short-time solutions we are addressing as work in progress, such as changes in stemming algorithm, considering synonyms, term filtering heuristics.",
          "The paper is organized as follows. In Section SECREF2 we provide some background notions and we discuss related work. In Section SECREF3 we present the algorithm MagiCoder, by providing both a qualitative description and the pseudocode. In Section SECREF4 we spend some words about the user interface of the related software tool. In Section SECREF5 we explain the benchmark we developed to test INLINEFORM0 performances and its results. Section SECREF6 is devoted to some discussions. Finally, in Section SECREF7 we summarize the main features of our work and sketch some future research lines."
        ]
      },
      {
        "section_name": "Natural language processing and text mining in medicine",
        "paragraphs": [
          "Automatic detection of adverse drug reactions from text has recently received an increasing interest in pharmacovigilance research. Narrative descriptions of ADRs come from heterogeneous sources: spontaneous reporting, Electronic Health Records, Clinical Reports, and social media. In BIBREF8 , BIBREF9 , BIBREF10 , BIBREF11 , BIBREF12 some NLP approaches have been proposed for the extraction of ADRs from text. In BIBREF13 , the authors collect narrative discharge summaries from the Clinical Information System at New York Presbyterian Hospital. MedLEE, an NLP system, is applied to this collection, for identifing medication events and entities, which could be potential adverse drug events. Co-occurrence statistics with adjusted volume tests were used to detect associations between the two types of entities, to calculate the strengths of the associations, and to determine their cutoff thresholds. In BIBREF14 , the authors report on the adaptation of a machine learning-based system for the identification and extraction of ADRs in case reports. The role of NLP approaches in optimised machine learning algorithms is also explored in BIBREF15 , where the authors address the problem of automatic detection of ADR assertive text segments from several sources, focusing on data posted by users on social media (Twitter and DailyStrenght, a health care oriented social media). Existing methodologies for NLP are discussed and an experimental comparison between NLP-based machine learning algorithms over data sets from different sources is proposed. Moreover, the authors address the issue of data imbalance for ADR description task. In BIBREF16 the authors propose to use association mining and Proportional Reporting Ratio (PRR, a well-know pharmacovigilance statistical index) to mine the associations between drugs and adverse reactions from the user contributed content in social media. In order to extract adverse reactions from on-line text (from health care communities), the authors apply the Consumer Health Vocabulary to generate ADR lexicon. ADR lexicon is a computerized collection of health expressions derived from actual consumer utterances, linked to professional concepts and reviewed and validated by professionals and consumers. Narrative text is preprocessed following standard NLP techniques (such as stop word removal, see Section SECREF12 ). An experiment using ten drugs and five adverse drug reactions is proposed. The Food and Drug Administration alerts are used as the gold standard, to test the performance of the proposed techniques. The authors developed algorithms to identify ADRs from threads of drugs, and implemented association mining to calculate leverage and lift for each possible pair of drugs and adverse reactions in the dataset. At the same time, PRR is also calculated.",
          "Other related papers about pharmacovigilance and machine learning or data mining are BIBREF17 , BIBREF18 . In BIBREF19 , a text extraction tool is implemented on the .NET platform for preprocessing text (removal of stop words, Porter stemming BIBREF20 and use of synonyms) and matching medical terms using permutations of words and spelling variations (Soundex, Levenshtein distance and Longest common subsequence distance BIBREF21 ). Its performance has been evaluated on both manually extracted medical terms from summaries of product characteristics and unstructured adverse effect texts from Martindale (a medical reference for information about drugs and medicines) using the WHO-ART and MedDRA medical terminologies. A lot of linguistic features have been considered and a careful analysis of performances has been provided. In BIBREF22 the authors develop an algorithm in order to help coders in the subtle task of auto-assigning ICD-9 codes to clinical narrative descriptions. Similarly to MagiCoder, input descriptions are proposed as free text. The test experiment takes into account a reasoned data set of manually annotated radiology reports, chosen to cover all coding classes according to ICD-9 hierarchy and classification: the test obtains an accuracy of INLINEFORM0 ."
        ]
      },
      {
        "section_name": "MedDRA Dictionary",
        "paragraphs": [
          "The Medical Dictionary for Regulatory Activities (MedDRA) BIBREF5 is a medical terminology used to classify adverse event information associated with the use of biopharmaceuticals and other medical products (e.g., medical devices and vaccines). Coding these data to a standard set of MedDRA terms allows health authorities and the biopharmaceutical industry to exchange and analyze data related to the safe use of medical products BIBREF23 . It has been developed by the International Conference on Harmonization (ICH); it belongs to the International Federation of Pharmaceutical Manufacturers and Associations (IFPMA); it is controlled and periodically revised by the MedDRA Mainteinance And Service Organization (MSSO). MedDRA is available in eleven European languages and in Chinese and Japanese too. It is updated twice a year (in March and in September), following a collaboration-based approach: everyone can propose new reasonable updates or changes (due to effects of events as the onset of new pathologies) and a team of experts eventually decides about the publication of updates. MedDRA terms are organised into a hierarchy: the SOC (System Organ Class) level includes the most general terms; the LLT (Low Level Terms) level includes more specific terminologies. Between SOC and LLT there are three intermediate levels: HLGT (High Level Group Terms), HLT (High Level Terms), and PT (Preferred Terms).",
          "The encoding of ADRs through MedDRA is extremely important for report analysis as for a prompt detection of problems related to drug-based treatments. Thanks to MedDRA it is possible to group similar/analogous cases described in different ways (e.g., by synonyms) or with different details/levels of abstraction.",
          "Table TABREF8 shows an example of the hierarchy: reaction Itch is described starting from Skin disorders (SOC), Epidermal conditions (HLGT), Dermatitis and Eczema (HLT), and Asteatotic Eczema (PT). Preferred Terms are Low Level Terms chosen to be representative of a group of terms. It should be stressed that the hierarchy is multiaxial: for example, a PT can be grouped into one or more HLT, but it belongs to only one primary SOC term."
        ]
      },
      {
        "section_name": "MagiCoder: an NLP software for ADR automatic encoding",
        "paragraphs": [
          "A natural language ADR description is a completely free text. The user has no limitations, she/he can potentially write everything: a number of online ADR descriptions actually contain information not directly related to drug effects. Thus, an NLP software has to face and solve many issues: Trivial orthographical errors; Use of singular versus plural nouns; The so called \u201cfalse positives\u201d, i.e., syntactically retrieved inappropriate results, which are closely resembling to correct solutions; The structure of the sentence, i.e., the way an assertion is built up in a given language. Also the \u201cintelligent\u201d detection of linguistic connectives is a crucial issue. For example, the presence of a negation can potentially change the overall meaning of a description.",
          "In general, a satisfactory automatic support of human reasoning and work is a subtle task: for example, the uncontrolled extension of the dictionary with auxiliary synonymous (see Section SECREF66 ) or the naive ad hoc management of particular cases, can limit the efficiency and the desired of the algorithm. For these reasons, we carefully designed INLINEFORM0 , even through a side-by-side collaboration between pharmacologists and computer scientists, in order to yield an efficient tool, capable to really support pharmacovigilance activities.",
          "In literature, several NLP algorithms already exist, and several interesting approaches (such as the so called morpho-analysis of natural language) have been studied and proposed BIBREF24 , BIBREF6 , BIBREF25 . According to the described pharmacovigilance domain, we considered algorithms for the morpho-analysis and the part-of-speech (PoS) extraction techniques BIBREF24 , BIBREF6 too powerful and general purpose for the solution of our problem. Indeed, in most cases ADR descriptions are written in a very succinct way, without using verbs, punctuation, or other lexical items, and introducing acronyms. Moreover, clinical and technical words are often not recognized correctly because not included in usual dictionaries. All these considerations limit the benefits of using morpho-analysis and PoS for our purposes.",
          "Thus, we decided to design and develop an ad hoc algorithm for the problem we are facing, namely that of deriving MedDRA terms from narrative text and mapping segments of text in effective LLTs. This task has to be done in a very feasible time (we want that each interaction user/MagiCoder requires less than a second) and the solution offered to the expert has to be readable and useful. Therefore, we decided to ignore the structure of the narrative description and address the issue in a simpler way. Main features of MagiCoder can be summarized as follows:",
          "In this paper we consider the Italian context of Pharmacovigilance and, as a consequence, we will consider and process by MagiCoder textual descriptions written in Italian language. We will discuss the potentiality of MagiCoder on other languages and some preliminary results in Section SECREF7 ."
        ]
      },
      {
        "section_name": "MagiCoder: overview",
        "paragraphs": [
          "The main idea of INLINEFORM0 is that a single linear scan of the free-text is sufficient, in order to recognize INLINEFORM1 terms.",
          "From an abstract point of view, we try to recognize, in the narrative description, single words belonging to LLTs, which do not necessarily occupy consecutive positions in the text. This way, we try to \u201creconstruct\u201d MedDRA terms, taking into account the fact that in a description the reporter can permute or omit words. As we will show, MagiCoder has not to deal with computationally expensive tasks, such as taking into account subroutines for permutations and combinations of words (as, for example, in BIBREF19 ).",
          "We can distinguish five phases in the procedure that will be discussed in detail in Sections UID18 , UID19 , UID20 , UID23 , UID28 , respectively.",
          "Definition of ad hoc data structures: the design of data structures is central to perform an efficient computation; our main data structures are hash tables, in order to guarantee an efficient access both to MedDRA terms and to words belonging to MedDRA terms.",
          "Preprocessing of the original text: tokenization (i.e., segmentation of the text into syntactical units), stemming (i.e., reduction of words to a particular root form), elimination of computationally irrelevant words.",
          "Word-by-word linear scan of the description and \u201cvoting task\u201d: a word \u201cvotes\u201d LLTs it belongs to. For each term voted by one or more words, we store some information about the retrieved syntactical matching.",
          "Weights calculation: recognized terms are weighted depending on information about syntactical matching.",
          "Sorting of voted terms and winning terms release: the set of voted term is pruned, terms are sorted and finally a solution (a set of winning terms) is released.",
          "The algorithm proceeds with a word-by-word comparison. We iterate on the preprocessed text and we test if a single word INLINEFORM0 , a token, occurs into one or many LLTs.",
          "In order to efficiently test if a token belongs to one or more LLTs, we need to know which words belong to each term. The LLT level of MedDRA is actually a set of phrases, i.e., sequences of words. By scanning these sequences, we build a meta-dictionary of all the words which compose LLTs. As we will describe in Section SECREF48 , in INLINEFORM0 time units (where INLINEFORM1 and INLINEFORM2 are the cardinality of the set of LLTs and the length of the longest LLT in MedDRA, respectively) we build a hash table having all the words occurring in MedDRA as keys, where the value associated to key INLINEFORM3 contains information about the set of LLTs containing INLINEFORM4 . This way, we can verify the presence in MedDRA of a word INLINEFORM5 encountered in the ADR description in constant time. We call this meta-dictionary INLINEFORM6 . We build a meta dictionary also from a stemmed version of MedDRA, to verify the presence of stemmed descriptions. We call it INLINEFORM7 . Finally, also the MedDRA dictionary is loaded into a hash table according to LLT identifiers and, in general, all our main data structures are hash tables.",
          "We aim to stress that, to retain efficiency, we preferred exact string matching with respect to approximate string matching, when looking for a word into the meta dictionary. Approximate string matching would allow us to retrieve terms that would be lost in exact string matching (e.g., we could recognize misspelled words in the ADR description), but it would worsen the performances of the text recognition tool, since direct access to the dictionary would not be possible. We discuss the problem of retrieving syntactical variations of the same words and the problem of addressing orthographical errors in Section SECREF7 .",
          "Given a natural language ADR description, the text has to be preprocessed in order to perform an efficient computation. We adopt a well-know technique such as tokenization BIBREF26 : a phrase is reduced to tokens, i.e., syntactical units which often, as in our case, correspond to words. A tokenized text can be easily manipulated as an enumerable object, e.g., an array. A stop word is a word that can be considered irrelevant for the text analysis (e.g., an article or an interjection). Words classified as stop-words are removed from the tokenized text. In particular, in this release of our software we decided to not take into account connectives, e.g., conjunctions, disjunctions, negations. The role of connectives, in particular of negation, is discussed in Section SECREF6 .",
          "A fruitful preliminary work is the extraction of the corresponding stemmed version from the original tokenized and stop-word free text. Stemming is a linguistic technique that, given a word, reduces it to a particular kind of root form BIBREF20 , BIBREF26 . It is useful in text analysis, in order to avoid problems such as missing word recognition due to singular/plural forms (e.g., hand/hands). In some cases, stemming procedures are able to recognize the same root both for the adjectival and the noun form of a word. Stemming is also potentially harmful, since it can generate so called \u201cfalse positives\u201d terms. A meaningful example can be found in Italian language. The plural of the word mano (in English, hand) is mani (in English, hands), and their stemmed root is man, which is also the stemmed version of mania (in English, mania). Several stemming algorithms exist, and their impact on the performances of MagiCoder is discussed in Section SECREF6 .",
          " INLINEFORM0 scans the text word-by-word (remember that each word corresponds to a token) once and performs a \u201cvoting task\u201d: at the INLINEFORM1 -th step, it marks (i.e., \u201cvotes\u201d) with index INLINEFORM2 each LLT INLINEFORM3 containing the current ( INLINEFORM4 -th) word of the ADR description. Moreover, it keeps track of the position where the INLINEFORM5 -th word occurs in INLINEFORM6 .",
          " INLINEFORM0 tries to find a word match both for the exact and the stemmed version of the meta dictionary and keeps track of the kind of match it has eventually found. It updates a flag, initially set to 0, if at least a stemmed matching is found in an LLT. If a word INLINEFORM1 has been exactly recognized in a term INLINEFORM2 , the match between the stemmed versions of INLINEFORM3 and INLINEFORM4 is not considered. At the end of the scan, the procedure has built a sub-dictionary containing only terms \u201cvoted\u201d at least by one word. We call INLINEFORM5 the sub-dictionary of voted terms.",
          "Each voted term INLINEFORM0 is equipped with two auxiliary data structures, containing, respectively:",
          "the positions of the voting words in the ADR description; we call INLINEFORM0 this sequence of indexes;",
          "the positions of the voted words in the MedDRA term INLINEFORM0 ; we call INLINEFORM1 this sequence of indexes.",
          "Moreover, we endow each voted term INLINEFORM0 with a third structure that will contain the sorting criteria we define below; we will call it INLINEFORM1 .",
          "Let us now introduce some notations we will use in the following. We denote as INLINEFORM0 the function that, given an LLT INLINEFORM1 , returns the number of words contained in INLINEFORM2 (excluding the stop words). We denote as INLINEFORM3 (resp. INLINEFORM4 ) the function that returns the number of indexes belonging to INLINEFORM5 (resp. INLINEFORM6 ). We denote as INLINEFORM7 and INLINEFORM8 the functions that return the maximum and the minimum indexes in INLINEFORM9 , respectively.",
          "From now on, sometimes we explicitly list the complete denomination of a terms: we will use the notation \u201cname\u201d(id), where \u201cname\u201d is the MedDRA description and id is its identifier, that is possibly used to refer to the term. Let us exemplify these notions by introducing an example. Consider the following ADR description: \u201canaphylactic shock (hypotension + cutaneous rash) 1 hour after taking the drug\u201d. Words in it are numbered from 0 (anaphylactic) to 9 (drug). The complete set of data structures coming from the task is too big to be reported here, thus we focus only on two LLTs. At the end of the voting task, INLINEFORM0 will include, among others, \u201cAnaphylactic shock\u201d (10002199) and \u201cAnaphylactic reaction to drug\u201d (10054844). We will have that INLINEFORM1 (i.e., \u201canaphylactic\u201d and \u201cshock\u201d) while INLINEFORM2 (i.e., \u201canaphylactic\u201d and \u201cdrug\u201d). On the other hand, INLINEFORM3 , revealing that both words in the term have been voted, while INLINEFORM4 , suggesting that only two out of three words in the term have been voted (in particular, \u201creaction\u201d has not been voted). In this example all words in the description have been voted without using the stemming.",
          "After the voting task, selected terms have to be ordered. Notice that a purely syntactical recognition of words in LLTs potentially generates a large number of voted terms. For example, in the Italian version of MedDRA, the word \u201cmale\u201d (in English, \u201cpain\u201d) occurs 3385 times.",
          "So we have to: i) filter a subset of highly feasible solutions, by means of quantitative weights we assigns to candidate solutions; ii) choose a good final selection strategy in order to release a small set of final \u201cwinning\u201d MedDRA terms (this latter point will be discussed in Section UID28 ).",
          "For this purpose, we define four criteria to assign \u201cweights\u201d to voted terms accordingly.",
          "In the following, INLINEFORM0 is a normalization factor (w.r.t. the length, in terms of words, of the LLT INLINEFORM1 ). First three criteria have 0 as optimum value and 1 as worst value, while the fourth criterion has optimum value to 1 and it grows in worst cases.",
          "",
          "First, we consider how much part of the words of each voted LLT have not been recognized. INLINEFORM0 ",
          "In the example we introduced before, we have that INLINEFORM0 (i.e., all words of the terms have been recognized in the description) while INLINEFORM1 (i.e., one word out of three has not been recognized in the description).",
          "",
          "The algorithm considers whether a perfect matching has been performed using or not stemmed words. INLINEFORM0 is simply a flag. INLINEFORM1 holds if stemming has been used at least once in the voting procedure of INLINEFORM2 , and it is valued 1, otherwise it is valued 0.",
          "For example, INLINEFORM0 and INLINEFORM1 .",
          "",
          "The use of stemming allows one to find a number of (otherwise lost) matches. As side effect, we often obtain a quite large set of joint winner candidate terms. In this phase, we introduce a string distance comparison between recognized words in the original text and voted LLTs. Among the possible string metrics, we use the so called pair distance BIBREF27 , which is robust with respect to word permutation. Thus, INLINEFORM0 ",
          "where INLINEFORM0 is the pair distance function (between strings INLINEFORM1 and INLINEFORM2 ) and INLINEFORM3 is the term \u201crebuilt\u201d from the words in ADR description corresponding to indexes in INLINEFORM4 .",
          "For example, INLINEFORM0 (i.e., the concatenation of the voters and the term are equal) and INLINEFORM1 .",
          "",
          "We want to estimate how an LLT has been covered. INLINEFORM0 ",
          "The intuitive meaning of the criterion is to quantify the \u201cquality\u201d of the coverage. If an LLT has been covered by nearby words, it will be considered a good candidate for the solution. This criterion has to be carefully implemented, taking into account possible duplicated voted words.",
          "After computing (and storing) the weights related to the above criteria, for each voted term INLINEFORM0 we have the data structure INLINEFORM1 , containing the weights corresponding to the four criteria. These weights will be used, after a first heuristic selection, to sort a subset of the syntactically retrieved terms.",
          "Continuing the example introduced before, we have that INLINEFORM0 while INLINEFORM1 . Thus, concluding, we obtain that INLINEFORM2 while INLINEFORM3 .",
          "In order to provide an effective support to pharmacovigilance experts' work, it is important to offer only a small set of good candidate solutions. As previously said, the pure syntactical recognition of MedDRA terms into a free-text generates a possibly large set of results. Therefore, the releasing strategy has to be carefully designed in order to select onlt best suitable solutions. We will provide an heuristic selection, followed by a sorting of the survived voted terms; then we propose a release phase of solutions, further refined by a final heuristic criterium.",
          "As a first step, we provide an initial pruning of the syntactically retrieved terms guided by the ordered-phrases heuristic criterium. In the ordered-phrases criterium we reintroduce the order of words in the narrative description as a selection discriminating factor. From the set of selected LLTs, we remove those terms where voters (i.e., tokens in the original free text) appear in the ADR description in a relative order different from that of the corresponing voted tokens in the LLT. We do that only for those LLTs having voters that voted for more than one term.",
          "Let us consider the following example. On the (Italian) narrative description \u201cedema della glottide-lingua, parestesia al volto, dispnea\u201d (in English, \u201cedema glottis-tongue, facial paresthesia, dyspnoea\u201d), the voting procedure of MagiCoder finds, among the solutions, the MedDRA terms \u201cEdema della glottide\u201d (\u201cEdema glottis\u201d), \u201cEdema della lingua\u201d (\u201cEdema tongue\u201d), \u201cEdema del volto\u201d (\u201cEdema face\u201d), \u201cParestesia della lingua\u201d (\u201cParesthesia tongue\u201d), and \u201cDispnea\u201d (\u201cDyspnoea\u201d). The ordererd-phrase criterium removes LLT \u201cParestesia della lingua\u201d from the set of candidate solutions because \u201clingua\u201d votes for two terms but in the narrative text it appears before than \u201cparestesia\u201d while in the LLT it appears after.",
          "We call INLINEFORM0 the set of voted terms after the selection by the ordered-phrases criterium. We proceed then by ordering INLINEFORM1 : we use a multiple-value sorting on elements in INLINEFORM2 , for each INLINEFORM3 . The obtained subdictionary is dubbed as INLINEFORM4 and it has possibly most suitable solutions on top.",
          "After this phase, the selection of the \u201cwinning terms\u201d takes place. The main idea is to select and return a subset of voted terms which \u201ccovers\u201d the ADR description. We create the set INLINEFORM0 as follows. We iterate on the ordered dictionary and for each INLINEFORM1 we select INLINEFORM2 if all the following conditions hold:",
          " INLINEFORM0 is completely covered, i.e., INLINEFORM1 ;",
          " INLINEFORM0 does not already belong to INLINEFORM1 ;",
          " INLINEFORM0 is not a prefix of another selected term INLINEFORM1 ;",
          " INLINEFORM0 has been voted without stemming (i.e., INLINEFORM1 ) or, for any INLINEFORM2 , INLINEFORM3 has not been covered (i.e., none term voted by INLINEFORM4 has been already selected) or INLINEFORM5 has not been exactly covered (i.e., only its stem has been recognized in some term INLINEFORM6 ).",
          "At this stage, we have a set of MedDRA terms which \u201ccovers\u201d the narrative description. We further select a subset INLINEFORM0 of INLINEFORM1 with a second heuristic, the maximal-set-of-voters criterium.",
          "The maximal-set-of-voters criterium deletes from the solution those terms which can be considered \u201cextensions\u201d of other ones. For each pair of terms INLINEFORM0 and INLINEFORM1 , it checks if INLINEFORM2 is a subset of INLINEFORM3 (considered as sets of indexes). If it is the case, INLINEFORM4 is removed from INLINEFORM5 .",
          "In INLINEFORM0 we do not need to consider ad hoc subroutines to address permutations and combinations of words (as it is done, for example, in BIBREF19 ). In Natural Language Processing, permutations and combinations of words are important, since in spoken language the order of words can change w.r.t. the formal structure of the sentences. Moreover, some words can be omitted, while the sentence still retains the same meaning. These aspects come for free from our voting procedure: after the scan, we retrieve the information that a set of words covers a term INLINEFORM1 , but the order between words does not necessarily matter."
        ]
      },
      {
        "section_name": "MagiCoder: structure of the algorithm",
        "paragraphs": [
          "Figure SECREF34 depicts the pseudocode of MagiCoder. We represent dictionaries either as sets of words or as sets of functions. We describe the main procedures and functions used in the pseudocode.",
          "Procedure INLINEFORM0 takes the narrative description, performs tokenization and stop-word removal and puts it into an array of words.",
          "Procedures INLINEFORM0 and INLINEFORM1 get LLTs and create a dictionary of words and of their stemmed versions, respectively, which belong to LLTs, retaining the information about the set of terms containing each word.",
          "By the functional notation INLINEFORM0 (resp., INLINEFORM1 ), we refer to the set of LLTs containing the word INLINEFORM2 (resp., the stem of INLINEFORM3 ).",
          "Function INLINEFORM0 returns the stemmed version of word INLINEFORM1 .",
          "Function INLINEFORM0 returns the position of word INLINEFORM1 in term INLINEFORM2 .",
          " INLINEFORM0 is a flag, initially set to 0, which holds 1 if at least a stemmed matching with the MedDRA term INLINEFORM1 is found.",
          " INLINEFORM0 , INLINEFORM1 , INLINEFORM2 are arrays and INLINEFORM3 appends INLINEFORM4 to array INLINEFORM5 , where INLINEFORM6 may be an element or a sequence of elements.",
          " INLINEFORM0 ( INLINEFORM1 ) are the weights related to the criteria defined in Section UID23 .",
          "Procedure INLINEFORM0 performs the multi-value sorting of the array INLINEFORM1 based on the values of the properties INLINEFORM2 of its elements.",
          "Procedure INLINEFORM0 , where INLINEFORM1 is a set of terms and INLINEFORM2 is a term, tests whether INLINEFORM3 (considered as a string) is prefix of a term in INLINEFORM4 . Dually, procedure INLINEFORM5 tests if in INLINEFORM6 there are one or more prefixes of INLINEFORM7 , and eventually remove them from INLINEFORM8 .",
          "Function INLINEFORM0 specifies whether a word INLINEFORM1 has been already covered (i.e., a term voted by INLINEFORM2 has been selected) in the (partial) solution during the term release: INLINEFORM3 holds 1 if INLINEFORM4 has been covered (with or without stemming) and it holds 0 otherwise. We assume that before starting the final phase of building the solution (i.e., the returned set of LLTs), INLINEFORM5 for any word INLINEFORM6 belonging to the description.",
          "Procedures INLINEFORM0 and INLINEFORM1 , where INLINEFORM2 is a set of terms, implement ordered-phrases and maximal-set-of-voters criteria (defined in Section UID28 ), respectively.",
          "Function INLINEFORM0 , returns the first INLINEFORM1 elements of an ordered set INLINEFORM2 . If INLINEFORM3 , the function returns the complete list of ordered terms and INLINEFORM4 nil values.",
          "[!t] MagiCoder( INLINEFORM0 text, INLINEFORM1 dictionary, INLINEFORM2 integer)",
          " INLINEFORM0 : the narrative description;",
          " INLINEFORM0 : a data structure containing the MedDRA INLINEFORM1 s;",
          " INLINEFORM0 : the maximum number of winning terms that have to be released by the procedure an ordered set of LLTs INLINEFORM1 = CreateMetaDict( INLINEFORM2 ) INLINEFORM3 = CreateStemMetaDict( INLINEFORM4 ) adr_clear = Preprocessing( INLINEFORM5 ) adr_length = adr_clear.length INLINEFORM6 = INLINEFORM7 for each non-stop-word in the description (i INLINEFORM8 test whether the current word belongs to MedDRA adr_clear[i] INLINEFORM9 for each term containing the word t INLINEFORM10 (adr_clear[i]) keep track of the index of the voting word INLINEFORM11 [ INLINEFORM12 ,i] keep track of the index of the recognized word in INLINEFORM13 INLINEFORM14 [ INLINEFORM15 , INLINEFORM16 (adr_clear[i])]",
          " INLINEFORM0 = INLINEFORM1 test if the current (stemmed) word belongs the stemmed MedDRA stem(adr_clear[i]) INLINEFORM2 t INLINEFORM3 (stem(adr_clear[i])) test if the current term has not been exactly voted by the same word i INLINEFORM4 INLINEFORM5 [ INLINEFORM6 , i] INLINEFORM7 [ INLINEFORM8 , INLINEFORM9 (adr_clear[i])] keep track that INLINEFORM10 has been covered by a stemmed word INLINEFORM11 = true INLINEFORM12 = INLINEFORM13 for each voted term, calculate the four weights of the corresponding criteria t INLINEFORM14 INLINEFORM15 [ INLINEFORM16 ] filtering of the voted terms by the first heuristic criterium INLINEFORM17 multiple value sorting of the voted terms INLINEFORM18 = sortby( INLINEFORM19 ) t INLINEFORM20 index INLINEFORM21 select a term INLINEFORM22 if it has been completely covered, its i-th voting word has not been covered or if its i-th voting word has been perfectly recognized in INLINEFORM23 and if INLINEFORM24 is not prefix of another already selected terms INLINEFORM25 AND (( INLINEFORM26 = false OR (mark(adr_clear(index))=0)) AND t INLINEFORM27 AND prefix( INLINEFORM28 ,t)=false) mark(adr_clear(index))=1 remove from the selected term set all terms which are prefix of INLINEFORM29 INLINEFORM30 = remove_prefix( INLINEFORM31 ,t) INLINEFORM32 = INLINEFORM33 filtering of the finally selected terms by the second heuristic criterium INLINEFORM34 INLINEFORM35 INLINEFORM36 Pseudocode of MagiCoder"
        ]
      },
      {
        "section_name": "MagiCoder complexity analysis",
        "paragraphs": [
          "Let us now conclude this section by sketching the analysis of the computational complexity of MagiCoder.",
          "Let INLINEFORM0 be the input size (the length, in terms of words, of the narrative description). Let INLINEFORM1 be the cardinality of the dictionary (i.e., the number of terms). Moreover, let INLINEFORM2 be the number of distinct words occurring in the dictionary and let INLINEFORM3 be the length of the longest term in the dictionary. For MedDRA, we have about 75K terms ( INLINEFORM4 ) and 17K unique words ( INLINEFORM5 ). Notice that, reasonably, INLINEFORM6 is a small constant for any dictionary; in particular, for MedDRA we have INLINEFORM7 . We assume that all update operations on auxiliary data structures require constant time INLINEFORM8 .",
          "Building meta-dictionaries INLINEFORM0 and INLINEFORM1 requires INLINEFORM2 time units. In fact, the simplest procedure to build these hash tables is to scan the LLT dictionary and, for each term INLINEFORM3 , to verify for each word INLINEFORM4 belonging to INLINEFORM5 whether INLINEFORM6 is a key in the hash table (this can be done in constant time). If INLINEFORM7 is a key, then we have to update the values associated to INLINEFORM8 , i.e., we add INLINEFORM9 to the set of terms containing INLINEFORM10 . Otherwise, we add the new key INLINEFORM11 and the associated term INLINEFORM12 to the hash table. We note that these meta-dictionaries are computed only once when the MedDRA dictionary changes (twice per year), then as many narrative texts as we want can be encoded without the need to rebuild them.",
          "It can be easily verified that the voting procedure requires in the worst case INLINEFORM0 steps: this is a totally conservative bound, since this worst case should imply that each word of the description appears in all the terms of the dictionary. A simple analysis of the occurrences of the words in MedDRA shows that this worst case never occurs: in fact, the maximal absolute frequency of a MedDRA word is 3937, and the average of the frequencies of the words is 19.1. Thus, usually, real computational complexity is much less of this worst case.",
          "The computation of criteria-related weights requires INLINEFORM0 time units. In particular: both criterion one and criterion two require INLINEFORM1 time steps; criterion three require INLINEFORM2 (we assume to absorb the complexity of the pair distance function); criterion four requires INLINEFORM3 time units.",
          "The subsequent multi-value sorting based on computed weights is a sorting algorithm which complexity can be approximated to INLINEFORM0 , based on the comparison of objects of four elements (i.e., the weights of the four criteria). Since the number of the criteria-related weights involved in the multi-sorting is constant, it can be neglected. Thus, the complexity of multi-value sorting can be considered to be INLINEFORM1 .",
          "Finally, to derive the best solutions actually requires INLINEFORM0 steps. The ordered-phrases criterium requires INLINEFORM1 ; the maximal set of voters criterium takes INLINEFORM2 time units.",
          "Thus, we conclude that MagiCoder requires in the worst case INLINEFORM0 computational steps. We again highlight that this is a (very) worst case scenario, while in average it performs quite better. Moreover, we did not take into account that each phase works on a subset of terms of the previous phase, and the size of these subset rapidly decreases in common application.",
          "the selection phase works only on voted terms, thus, in common applications, on a subset of the original dictionary."
        ]
      },
      {
        "section_name": "Software implementation: the user interface",
        "paragraphs": [
          "MagiCoder has been implemented as a VigiFarmaco plug-in: people responsible for pharmacovigilance can consider the results of the auto-encoding of the narrative description and then revise and validate it. Figure FIGREF50 shows a screenshot of VigiFarmaco during this task. In the top part of the screen it is possible to observe the five sections composing a report. The screenshot actually shows the result of a human-MagiCoder interaction: by pressing the button \u201cAutocodifica in MedDRA\u201d (in English, \u201cMedDRA auto-encoding\u201d), the responsible for pharmacovigilance obtains a MedDRA encoding corresponding to the natural language ADR in the field \u201cDescrizione\" (in English, \u201cDescription\u201d). Up to six solutions are proposed as the best MedDRA term candidates returned by MagiCoder: the responsible can refuse a term (through the trash icon), change one or more terms (by an option menu), or simply validate the automatic encoding and switch to the next section \u201cFarmaci\u201d (in English, \u201cDrugs\u201d). The maximum number of six terms to be shown has been chosen in order to supply pharmacovigilance experts with a set of terms extended enough to represent the described adverse drug reaction but not so large to be redundant or excessive.",
          "We are testing MagiCoder performances in the daily pharmacovigilance activities. Preliminary qualitative results show that MagiCoder drastically reduces the amount of work required for the revision of a report, allowing the pharmacovigilance stakeholders to provide high quality data about suspected ADRs."
        ]
      },
      {
        "section_name": "Testing MagiCoder performances",
        "paragraphs": [
          "In this section we describe the experiments we performed to evaluate MagiCoder performances. The test exploits a large amount of manually revised reports we obtained from VigiSegn BIBREF3 .",
          "We briefly recall two metrics we used to evaluate MagiCoder: precision and recall.",
          "In statistical hypothesis and in particular in binary classification BIBREF28 , two main kinds of errors are pointed out: false positive errors (FP) and false negative errors (FN). In our setting, these errors can be viewed as follows: a false positive error is the inopportune retrieval of a \u201cwrong\u201d LLT, i.e., a term which does not correctly encode the textual description; a false negative error is the failure in the recognition of a \u201cgood\u201d LLT, i.e., a term which effectively encode (a part of) the narrative description and that would have been selected by a human expert. As dual notions of false positive and false negative, one can define correct results, i.e., true positive (TP) and true negative (TN): in our case, a true positive is a correctly returned LLT, and a true negative is an LLT which, correctly, has not been recognized as a solution.",
          "Following the information retrieval tradition, the standard approach to system evaluation revolves around the notion of relevant and non-relevant solution (in information retrieval, a solution is represented by a document BIBREF28 ). We provide here a straightforward definition of relevant solution. A relevant solution is a MedDRA term which correctly encode the narrative description provided to MagiCoder. A retrieved solution is trivially defined as an output term, independently from its relevance. We dub the sets of relevant solutions and retrieved solutions as INLINEFORM0 and INLINEFORM1 , respectively.",
          "The evaluation of the false positive and the false negative rates, and in particular of the impact of relevant solutions among the whole set of retrieved solutions, are crucial measures in order to estimate the quality of the automatic encoding.",
          "The precision (P), also called positive predictive value, is the percentage of retrieved solutions that are relevant. The recall (R), also called sensitivity, is the percentage of all relevant solutions returned by the system.",
          "Table TABREF51 summarizes formulas for precision and recall. We provide formulas both in terms of relevant/retrieved solutions and false positives, true positives and false negatives.",
          "It is worth noting that the binary classification of solutions as relevant or non-relevant is referred to as the gold standard judgment of relevance. In our case, the gold standard has to be represented by a human encoding of a narrative description, i.e., a set of MedDRA terms choosen by a pharmacovigilance expert. Such a set is assumed to be definitively correct (only correct solutions are returned) and complete (all correct solutions have been returned)."
        ]
      },
      {
        "section_name": "Experiment about MagiCoder performances",
        "paragraphs": [
          "To evaluate MagiCoder performances, we developed a benchmark, which automatically compares MagiCoder behavior with human encoding on already manually revised and validated ADR reports.",
          "For this purpose, we exploited VigiSegn, a data warehouse and OLAP system that has been developed for the Italian Pharmacovigilance National Center BIBREF3 . This system is based on the open source business intelligence suite Pentaho. VigiSegn offers a large number of encoded ADRs. The encoding has been manually performed and validated by experts working at pharmacovigilance centres. Encoding results have then been sent to the national regulatory authority, AIFA.",
          "We performed a test composed by the following steps.",
          "We launch an ETL procedure through Pentaho Data Integration. Reports are transferred from VigiSegn to an ad hoc database TestDB. The dataset covers all the 4445 reports received, revised and validated during the year 2014 for the Italian region Veneto.",
          "The ETL procedure extracts the narrative descriptions from reports stored in TestDB. For each description, the procedure calls MagiCoder from",
          "VigiFarmaco; the output, i.e., a list of MedDRA terms, is stored in a table of TestDB.",
          "Manual and automatic encodings of each report are finally compared through an SQL query. In order to have two uniform data sets, we compared only those reports where MagiCoder recognized at most six terms, i.e., the maximum number of terms that human experts are allowed to select through the VigiFarmaco user interface. Moreover, we map each LLT term recognized by both the human experts and MagiCoder to its corresponding preferred term. Results are discussed below in Section UID57 .",
          "Table TABREF58 shows the results of this first performance test. We group narrative descriptions by increasing length (in terms of characters). We note that reported results are computed considering terms at PT level. By moving to PT level, instead of using the LLT level, we group together terms that represent the same medical concept (i.e., the same adverse reaction). In this way, we do not consider an error when MagiCoder and the human expert use two different LLTs for representing the same adverse event. The use of the LLT level for reporting purpose and the PT level for analysis purpose is suggested also by MedDRA BIBREF5 . With common PT we mean the percentage of preferred terms retrieved by human reviewers that have been recognized also by MagiCoder. Reported performances are summarized also in FIGREF59 . Note that, false positive and false negative errors are required to be as small as possible, while common PT, recall, and precision have to be as large as possible.",
          "MagiCoder behaves very well on very short descriptions (class 1) and on short ones (class 2). Recall and precision remain greater than 50% up to class 4. Notice that very long descriptions (class 5), on which performances drastically decrease, represent a negligible percentage of the whole set (less than 0.3%). Some remarks are mandatory. It is worth noting that this test simply estimates how much, for each report, the MagiCoder behavior is similar to the manual work, without considering the effective quality of the manual encoding. Clearly, as a set of official reports, revised and sent to RNF, we assume to deal with an high-quality encoding: notwithstanding, some errors in the human encoding possibly occur. Moreover, the query we perform to compare manual and automatic encoding is, obviously, quantitative. For each VigiSegn report, the query is able to detect common retrieved terms and terms returned either by the human expert or by MagiCoder. It is not able to fairly test redundancy errors: human experts make some encoding choices in order to avoid repetitions. Thus, an LLT INLINEFORM0 returned by MagiCoder that has not been selected by the expert because redundant is not truly a false positive. As a significative counterpart, as previously said, we notice that some reports contain slightly human omissions/errors. This suggest the evidence that we are underestimating MagiCoder performances. See the next section for some simple but significative examples."
        ]
      },
      {
        "section_name": "Examples",
        "paragraphs": [
          "Table TABREF61 provides some examples of the behavior of MagiCoder. We propose some free-text ADR descriptions from TestDB and we provide both the manual and the automatic encodings into LLT terms. We also provide the English translation of the natural language texts (we actually provide a quite straightforward literal translation).",
          "",
          "In Table TABREF61 we use the following notations: INLINEFORM0 and INLINEFORM1 are two identical LLTs retrieved both by the human and the automatic encoding; INLINEFORM2 and INLINEFORM3 are two semantically equivalent or similar LLTs (i.e., LLTs with the same PT) retrieved by the human and the automatic encoding, respectively; we use bold type to denote terms that have been recognized by MagiCoder but that have not been encoded by the reviewer; we use italic type in D1, D2, D3 to denote text recognized only by MagiCoder. For example, in description D3, \u201ccefalea\u201d (in English, \u201cheadache\u201d) is retrieved and encoded both by the human reviewer and MagiCoder; in description D2, ADR \u201cfebbre\u201d (in English, \u201cfever') has been encoded with the term itself by the algorithm, whereas the reviewer encoded it with its synonym \u201cpiressia\u201d; in D1, ADR \u201cipotensione\u201d (in English, \u201chypotension\u201d) has been retrieved only by MagiCoder.",
          "To exemplify how the ordered phrase heuristic works, we can notice that in D2 MagiCoder did not retrieve the MedDRA term \u201cVescicole in sede di vaccinazione\u201d (10069623), Italian for \u201cVaccination site vesicles\u201d. It belongs to the set of the voted solutions (since INLINEFORM0 ), but it has been pruned from the list of the winning terms by the ordered-phrase heuristic criterium."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "We discuss here some interesting points we met developing MagiCoder. We explain the choices we made and consider some open questions."
        ]
      },
      {
        "section_name": "Stemming and performance of the NLP software",
        "paragraphs": [
          "Stemming is a useful tool for natural language processing and text searching and classification. The extraction of the stemmed form of a word is a non-trivial operation, and algorithms for stemming are very efficient. In particular, stemming for Italian language is extremely critic: this is due to the complexity of language and the number of linguistic variations and exceptions.",
          "For the first implementation of MagiCoder as VigiFarmaco plug-in, we used a robust implementation of the Italian stemming procedure. The procedure takes into account subtle properties of the language; in addition of the simple recognition of words up to plurals and genres, it is able, in the majority of cases, to recognize an adjectival form of a noun by extracting the same syntactical root.",
          "Despite the efficiency of this auxiliary algorithm, we noticed that the recognition of some MedDRA terms have been lost: in some sense, this stemming algorithm is too \u201caggressive\u201d and, in some cases, counterintuitive. For example, the Italian adjective \u201cpsichiatrico\u201d (in English, psichiatric) and its plural form \u201cpsichiatrici\u201d have two different stems, \u201cpsichiatr\u201d and \u201cpsichiatric\u201d, respectively. Thus, in this case the stemmer fails in recognizing the singular and plural forms of the same word.",
          "We then decided to adopt the stemming algorithm also used in Apache Lucene, an open source text search engine library. This procedure is less refined w.r.t. the stemming algorithm cited above, and can be considered as a \u201clight\u201d stemmer: it simply elides the final vowels of a word. This induces a conservative approach and a uniform processing of the whole set of MedDRA words. This is unsatisfactory for a general problem of text processing, but it is fruitful in our setting. We repeated the MagiCoder testing both with the classical and the light stemmer: in the latter case, we measure a global enhancement of MagiCoder performance. Regarding common retrieved preferred terms, we reveal an average enhancement of about INLINEFORM0 : percentages for classes 1, 2, 3, 4 and 5 move from INLINEFORM1 , INLINEFORM2 , INLINEFORM3 , INLINEFORM4 , INLINEFORM5 , respectively, to values in Table TABREF58 . It is reasonable to think that a simple stemming algorithm maintains the recognition of words up to plurals and genres, but in most cases, the recognition up to noun or adjectival form is potentially lost. Notwithstanding, we claim that it is possible to reduce this disadvantage thanks to the embedding in the dictionary of a reasonable set of synonyms of LLTs (see Section SECREF66 )."
        ]
      },
      {
        "section_name": "Synonyms",
        "paragraphs": [
          "MagiCoder performs a pure syntactical recognition (up to stemming) of words in the narrative description: no semantical information is used in the current version of the algorithm. In written informal language, synonyms are frequently used. A natural evolution of our NLP software may be the addition of an Italian thesaurus dictionary. This would appear a trivial extension: one could try to match MedDRA both with original words and their synonyms, and try to maximize the set of retrieved terms. We performed a preliminary test, and we observed a drastic deterioration of MagiCoder performances (both in terms of correctness and completeness): on average, common PT percentages decreases of 24%. The main reason is related to the nature of Italian language: synonymical groups include words related by figurative meaning. For example, among the synonyms of the word \u201cfaccia\u201d (in English, \u201cface\u201d), one finds \u201cviso\u201d (in English \u201cvisage\u201d), which is semantically related, but also \u201cespressione\u201d (in English, \u201cexpression\u201d), which is not relevant in the considered medical context. Moreover, the use of synonyms of words in ADR text leads to an uncontrolled growth of the voted terms, that barely can be later dropped in the final terms release. Furthermore, the word-by-word recognition performed by MagiCoder, with the uncontrolled increase of the processed tokens (original words plus synonyms plus possible combinations), could induce a serious worsening of the computational complexity. Thus, we claim that this is not the most suitable way to address the problem and the designing of an efficient strategy to solve this problem is not trivial.",
          "We are developing a different solution, working side-by-side with the pharmacovigilance experts. The idea, vaguely inspired by the Consumer Health Vocabulary (recalled in Section SECREF2 and used in BIBREF16 ), is to collect a set of pseudo-LLTs, in order to enlarge the MedDRA official terminology and to generate a new ADR lexicon. This will be done on the basis of frequently retrieved locutions which are semantically equivalent to LLTs. A pseudo LLT will be regularly voted and sorted by MagiCoder and, if selected, the software will release the official (semantically equivalent) MedDRA term. Notice that, conversely to the single word synonyms solution, each pseudo-LLT is related to one and only one official term: this clearly controls the complexity deterioration. Up to now, we added to the official MedDRA terminology a set of about 1300 locutions. We automatically generated such a lexicon by considering three nouns that frequently occur in MedDRA, \u201caumento\u201d, \u201cdiminuzione\u201d e \u201criduzione\u201d (in English \u201cincrease\u201d, \u201cdecrease\u201d, and \u201creduction\u201d, respectively) and their adjectival form. For each LLT containing one of these nouns (resp., adjectives) we generate an equivalent term taking into account the corresponding adjective (resp., noun).",
          "This small set of synonyms induces a global improvement of MagiCoder performances on classes 4 and 5. For Class 4, both common retrieved PT percentage, precision and recall increase of INLINEFORM0 . For Class 5, we observe some significative increment: common retrieved PT moves from INLINEFORM1 to INLINEFORM2 ; precision moves from INLINEFORM3 to INLINEFORM4 ; recall moves from INLINEFORM5 to INLINEFORM6 .",
          "Also false negative and false positive rates suggest that the building of the MedDRA-thesaurus is a promising extension. False negatives move from INLINEFORM0 to INLINEFORM1 for Class 4 and from INLINEFORM2 to INLINEFORM3 for Class 5. False positive percentage decrease of INLINEFORM4 both for Class 4 and Class 5.",
          "Class 5, which enjoys a particular advantage from the introduction of the pseudo-LLTs, represents a small slice of the set of reports. Notwithstanding, these cases are very arduous to address, and we have, at least, a good evidence of the validity of our approach."
        ]
      },
      {
        "section_name": "Connectives in the narrative descriptions",
        "paragraphs": [
          "As previously said, in MagiCoder we do not take into account the structure of written sentences. In this sense, our procedure is radically different from those based on the so called part-of-speech (PoS) BIBREF29 , powerful methodologies able to perform the morpho-syntactical analysis of texts, labeling each lexical item with its grammatical properties. PoS-based text analyzers are also able to detect and deal with logical connectives such as conjunctions, disjunctions and negations. Even if connectives generally play a central role in the logical foundation of natural languages, they have a minor relevance in the problem we are addressing: ADR reports are on average badly/hurriedly written, or they do not have a complex structure (we empirically noted this also for long descriptions). Notwithstanding, negation deserves a distinct consideration, since the presence of a negation can drastically change the meaning of a phrase. First, we evaluated the frequency of negation connectives in ADR reports: we considered the same sample exploited in Section SECREF52 , and we counted the occurrences of the words \u201cnon\u201d (Italian for \u201cnot\u201d) and \u201csenza\u201d (Italian for \u201cwithout\u201d): we detected potential negations in 162 reports (i.e., only in the INLINEFORM0 of the total number, 4445). Even though negative sentences seem to be uncommon in ADR descriptions, the detection of negative forms is a short-term issue we plan to address. As a first step, we plan to recognize words that may represent negations and to signal them to the reviewer through the graphical UI. In this way, the software sends to the report reviewer an alert about the (possible) failure of the syntactical recognition."
        ]
      },
      {
        "section_name": "On the selection of voted terms",
        "paragraphs": [
          "As previously said, in order to provide an effective support to human revision work, it is necessary to provide only a small set of possible solutions. To this end, in the selection phase (described in Section UID28 ), we performed drastic cuts on voted LLTs. For example, only completely covered LLTs can contribute to the set of winning terms. This is clearly a restrictive threshold, that makes completely sense in a context where at most six solutions can be returned. In a less restrictive setting, one can relax the threshold above and try to understand how to filter more \u201cpromising\u201d solutions among partially covered terms. In this perspective, we developed a further criterion, the Coverage Distribution, based on assumptions we made about the structure of (Italian) sentences. The following formula simply sums the indexes of the covered words for INLINEFORM0 : INLINEFORM1 ",
          "If INLINEFORM0 is small, it means that words in the first positions of term INLINEFORM1 have been covered. We defined INLINEFORM2 to discriminate between possibly joint winning terms. Indeed, an Italian medical description of a pathology has frequently the following shape: name of the pathology+\u201clocation\u201d or adjective. Intuitively, we privilege terms for which the recognized words are probably the ones describing the pathology. The addition of INLINEFORM3 (with the discard of condition INLINEFORM4 in the final selection) could improve the quality of the solution if a larger set of winning terms is admissible or in the case in which the complete ordered list of voted terms is returned."
        ]
      },
      {
        "section_name": "Conclusions and future work",
        "paragraphs": [
          "In this paper we proposed MagiCoder, a simple and efficient NLP software, able to provide a concrete support to the pharmacovigilance task, in the revision of ADR spontaneous reports. MagiCoder takes in input a narrative description of a suspected ADR and produces as outcome a list of MedDRA terms that \u201ccovers\u201d the medical meaning of the free-text description. Differently from other BioNLP software proposed in literature, we developed an original text processing procedure. Preliminary results about MagiCoder performances are encouraging. Let us sketch here some ongoing and future work.",
          "We are addressing the task to include ad hoc knowledges, as the MedDRA-thesaurus described in Section SECREF66 . We are also proving that MagiCoder is robust with respect to language (and dictionary) changes. The way the algorithm has been developed suggests that MagiCoder can be a valid tool also for narrative descriptions written in English. Indeed, the algorithm retrieves a set of words, which covers an LLT INLINEFORM0 , from a free-text description, only slightly considering the order between words or the structure of the sentence. This way, we avoid the problem of \u201cspecializing\u201d MagiCoder for any given language. We plan to test MagiCoder on the English MedDRA and, moreover, we aim to test our procedure on different dictionaries (e.g., ICD-9 classification, WHO-ART, SNOMED CT). We are collecting several sources of manually annotated corpora, as potential testing platforms. Moreover, we plan to address the management of orthographical errors possibly contained in narrative ADR descriptions. We did not take into account this issue in the current version of MagiCoder. A solution could include an ad hoc (medical term-oriented) spell checker in VigiFarmaco, to point out to the user that she/he is doing some error in writing the current word in the free description field. This should drastically reduce users' orthographical errors without heavy side effects in MagiCoder development and performances. Finally, we aim to apply MagiCoder (and its refinements) to different sources for ADR detection, such as drug information leaflets and social media BIBREF16 , BIBREF30 ."
        ]
      }
    ],
    "qas": [
      {
        "question": "Did they test the idea that the system reduces the time needed to encode ADR reports on real pharmacologists? ",
        "question_id": "95af7aaea3ce9dab4cf64e2229ce9b98381dd050",
        "nlp_background": "five",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Let us now conclude this section by sketching the analysis of the computational complexity of MagiCoder.",
                "Finally, to derive the best solutions actually requires INLINEFORM0 steps. The ordered-phrases criterium requires INLINEFORM1 ; the maximal set of voters criterium takes INLINEFORM2 time units.",
                "Thus, we conclude that MagiCoder requires in the worst case INLINEFORM0 computational steps. We again highlight that this is a (very) worst case scenario, while in average it performs quite better. Moreover, we did not take into account that each phase works on a subset of terms of the previous phase, and the size of these subset rapidly decreases in common application.",
                "the selection phase works only on voted terms, thus, in common applications, on a subset of the original dictionary."
              ],
              "highlighted_evidence": [
                "Let us now conclude this section by sketching the analysis of the computational complexity of MagiCoder.\n\n",
                "Finally, to derive the best solutions actually requires INLINEFORM0 steps. The ordered-phrases criterium requires INLINEFORM1 ; the maximal set of voters criterium takes INLINEFORM2 time units.\n\nThus, we conclude that MagiCoder requires in the worst case INLINEFORM0 computational steps. We again highlight that this is a (very) worst case scenario, while in average it performs quite better. Moreover, we did not take into account that each phase works on a subset of terms of the previous phase, and the size of these subset rapidly decreases in common application.\n\nthe selection phase works only on voted terms, thus, in common applications, on a subset of the original dictionary."
              ]
            },
            "annotation_id": "4ee9a4dfe6fbdeba295baad2c405c2ac8f676329",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "To evaluate MagiCoder performances, we developed a benchmark, which automatically compares MagiCoder behavior with human encoding on already manually revised and validated ADR reports."
              ],
              "highlighted_evidence": [
                "To evaluate MagiCoder performances, we developed a benchmark, which automatically compares MagiCoder behavior with human encoding on already manually revised and validated ADR reports."
              ]
            },
            "annotation_id": "5250a250a7bcfa33dbe9e4c4827185a257330be0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We are testing MagiCoder performances in the daily pharmacovigilance activities. Preliminary qualitative results show that MagiCoder drastically reduces the amount of work required for the revision of a report, allowing the pharmacovigilance stakeholders to provide high quality data about suspected ADRs."
              ],
              "highlighted_evidence": [
                "Preliminary qualitative results show that MagiCoder drastically reduces the amount of work required for the revision of a report, allowing the pharmacovigilance stakeholders to provide high quality data about suspected ADRs."
              ]
            },
            "annotation_id": "a9553739783c00e14782ce4714c31ce07dbfce67",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: The yearly increasing number of reports about suspected adverse reactions induced by drugs in Italy."
      },
      {
        "file": "7-Table1-1.png",
        "caption": "Table 1: MedDRA Hierarchy - an Example"
      },
      {
        "file": "19-Figure3-1.png",
        "caption": "Figure 3: A partial screenshot of VigiFarmaco User Interface"
      },
      {
        "file": "20-Table2-1.png",
        "caption": "Table 2: Performance and correctness measures"
      },
      {
        "file": "21-Table3-1.png",
        "caption": "Table 3: First results of MagiCoder performances"
      },
      {
        "file": "22-Figure4-1.png",
        "caption": "Figure 4: Graphical representation of MagiCoder performances"
      },
      {
        "file": "23-Table4-1.png",
        "caption": "Table 4: Examples of MagiCoder behavior"
      }
    ]
  },
  "1906.01010": {
    "title": "A computational linguistic study of personal recovery in bipolar disorder",
    "abstract": "Mental health research can benefit increasingly fruitfully from computational linguistics methods, given the abundant availability of language data in the internet and advances of computational tools. This interdisciplinary project will collect and analyse social media data of individuals diagnosed with bipolar disorder with regard to their recovery experiences. Personal recovery - living a satisfying and contributing life along symptoms of severe mental health issues - so far has only been investigated qualitatively with structured interviews and quantitatively with standardised questionnaires with mainly English-speaking participants in Western countries. Complementary to this evidence, computational linguistic methods allow us to analyse first-person accounts shared online in large quantities, representing unstructured settings and a more heterogeneous, multilingual population, to draw a more complete picture of the aspects and mechanisms of personal recovery in bipolar disorder.",
    "full_text": [
      {
        "section_name": "Introduction and background",
        "paragraphs": [
          "Recent years have witnessed increased performance in many computational linguistics tasks such as syntactic and semantic parsing BIBREF0 , BIBREF1 , emotion classification BIBREF2 , and sentiment analysis BIBREF3 , BIBREF4 , BIBREF5 , especially concerning the applicability of such tools to noisy online data. Moreover, the field has made substantial progress in developing multilingual models and extending semantic annotation resources to languages beyond English BIBREF6 , BIBREF7 , BIBREF8 , BIBREF9 .",
          "Concurrently, it has been argued for mental health research that it would constitute a `valuable critical step' BIBREF10 to analyse first-hand accounts by individuals with lived experience of severe mental health issues in blog posts, tweets, and discussion forums. Several severe mental health difficulties, e.g., bipolar disorder (BD) and schizophrenia are considered as chronic and clinical recovery, defined as being relapse and symptom free for a sustained period of time BIBREF11 , is considered difficult to achieve BIBREF12 , BIBREF13 , BIBREF14 . Moreover, clinically recovered individuals often do not regain full social and educational/vocational functioning BIBREF15 , BIBREF16 . Therefore, research originating from initiatives by people with lived experience of mental health issues has been advocating emphasis on the individual's goals in recovery BIBREF17 , BIBREF18 . This movement gave rise to the concept of personal recovery BIBREF19 , BIBREF20 , loosely defined as a `way of living a satisfying, hopeful, and contributing life even with limitations caused by illness' BIBREF18 . The aspects of personal recovery have been conceptualised in various ways BIBREF21 , BIBREF22 , BIBREF23 . According to the frequently used CHIME model BIBREF24 , its main components are Connectedness, Hope and optimism, Identity, Meaning and purpose, and Empowerment. Here, we focus on BD, which is characterised by recurring episodes of depressed and elated (hypomanic or manic) mood BIBREF25 , BIBREF12 . Bipolar spectrum disorders were estimated to affect approximately 2% of the UK population BIBREF13 with rates ranging from 0.1%-4.4% across 11 other European, American and Asian countries BIBREF26 . Moreover, BD is associated with a high risk of suicide BIBREF27 , making its prevention and treatment important tasks for society. BD-specific personal recovery research is motivated by mainly two facts: First, the pole of positive/elevated mood and ongoing mood instability constitute core features of BD and pose special challenges compared to other mental health issues, such as unipolar depression BIBREF25 . Second, unlike for some other severe mental health difficulties, return to normal functioning is achievable given appropriate treatment BIBREF28 , BIBREF16 , BIBREF29 .",
          "A substantial body of qualitative and quantitative research has shown the importance of personal recovery for individuals diagnosed with BD BIBREF22 , BIBREF25 , BIBREF30 , BIBREF31 , BIBREF23 . Qualitative evidence mainly comes from (semi-)structured interviews and focus groups and has been criticised for small numbers of participants BIBREF10 , lacking complementary quantitative evidence from larger samples BIBREF32 . Some quantitative evidence stems from the standardised bipolar recovery questionnaire BIBREF30 and a randomised control trial for recovery-focused cognitive-behavioural therapy BIBREF31 . Critically, previous research has taken place only in structured settings. What is more, the recovery concept emerged from research primarily conducted in English-speaking countries, mainly involving researchers and participants of Western ethnicity. This might have led to a lack of non-Western notions of wellbeing in the concept, such as those found in indigenous peoples BIBREF32 , limiting its the applicability to a general population. Indeed, the variation in BD prevalence rates from 0.1% in India to 4.4% in the US is striking. It has been shown that culture is an important factor in the diagnosis of BD BIBREF33 , as well as on the causes attributed to mental health difficulties in general and treatments considered appropriate BIBREF34 , BIBREF35 . While approaches to mental health classification from texts have long ignored the cultural dimension BIBREF36 , first studies show that online language of individuals affected by depression or related mental health difficulties differs significantly across cultures BIBREF37 , BIBREF36 .",
          "Hence, it seems timely to take into account the wealth of accounts of mental health difficulties and recovery stories from individuals of diverse ethnic and cultural backgrounds that are available in a multitude of languages on the internet. Corpus and computational linguistic methods are explicitly designed for processing large amounts of linguistic data BIBREF38 , BIBREF39 , BIBREF40 , BIBREF41 , and as discussed above, recent advances have made it feasible to apply them to noisy user-generated texts from diverse domains, including mental health BIBREF42 , BIBREF43 . Computer-aided analysis of public social media data enables us to address several shortcomings in the scientific underpinning of personal recovery in BD by overcoming the small sample sizes of lab-collected data and including accounts from a more heterogeneous population.",
          "In sum, our research questions are as follows: (1) How is personal recovery discussed online by individuals meeting criteria for BD? (2) What new insights do we get about personal recovery and factors that facilitate or hinder it? We will investigate these questions in two parts, looking at English-language data by westerners and at multilingual data by individuals of diverse ethnicities."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "Previous work in computational linguistics and clinical psychology has tended to focus on the detection of mental health issues as classification tasks BIBREF44 . Datasets have been collected for various conditions including BD using publicly available social-media data from Twitter BIBREF45 and Reddit BIBREF46 , BIBREF47 . Unfortunately, the Twitter dataset is unavailable for further research. In both Reddit datasets, mental health-related content was deliberately removed. This allows the training of classifiers that try to predict the mental health of authors from excerpts that do not explicitly address mental health, yet it renders the data useless for analyses on how mental health is talked about online. Due to this lack of appropriate existing publicly accessible datasets, we will create such resources and make them available to subsequent researchers.",
          "We plan to collect data relevant for BD in general as well as for personal recovery in BD from three sources varying in their available amount versus depth of the accounts we expect to find: 1) Twitter, 2) Reddit (focusing on mental health-related content unlike previous work), 3) blogs authored by affected individuals. Twitter and Reddit users with a BD diagnosis will be identified automatically via self-reported diagnosis statements, such as `I was diagnosed with BD-I last week'. To do so, we will extend on the diagnosis patterns and terms for BD provided by BIBREF47 . Implicit consent is assumed from users on these platforms to use their public tweets and posts. SECREF3 Relevant blogs will be manually identified, and their authors will be contacted to obtain informed consent for using their texts.",
          "Since language and culture are important factors in our research questions, we need information on the language of the texts and the country of residence of their authors, which is not provided in a structured format in the three data sources. For language identification, Twitter employs an automatic tool BIBREF48 , which can be used to filter tweets according to 60 language codes, and there are free, fairly accurate tools such as the Google Compact Language Detector, which can be applied to Reddit and blog posts. The location of Twitter users can be automatically inferred from their tweets BIBREF49 or the (albeit noisy) location field in their user profiles BIBREF50 . Only one attempt to classify the location of Reddit users has been published so far BIBREF51 showing meagre results, indicating that the development of robust location classification approaches on this platform would constitute a valuable contribution. Some companies collect mental health-related online data and make them available to researchers subject to approval of their internal review boards, e.g., OurDataHelps by Qntfy or the peer-support forum provider 7 Cups. Unlike `raw' social media data, these datasets have richer user-provided metadata and explicit consent for research usage. On the other hand, less data is available, the process to obtain access might be tedious within the short timeline of a PhD project and it might be impossible to share the used portions of the data with other researchers. Therefore, we will follow up the possibilities of obtaining access to these datasets, but in parallel also collect our own datasets to avoid dependence on external data providers."
        ]
      },
      {
        "section_name": "Methodology and Resources",
        "paragraphs": [
          "As explained in the introduction, the overarching aim of this project is to investigate in how far information conveyed in social media posts can complement more traditional research methods in clinical psychology to get insights into the recovery experience of individuals with a BD diagnosis. Therefore, we will first conduct a systematic literature review of qualitative evidence to establish a solid base of what is already known about personal recovery experiences in BD for the subsequent social media studies.",
          "Our research questions, which regard the experiences of different populations, lend themselves to several subprojects. First, we will collect and analyse English-language data from westerners. Then, we will address ethnically diverse English-speaking populations and finally multilingual accounts. This has the advantage that we can build data processing and methodological workflows along an increase in complexity of the data collection and analysis throughout the project.",
          "In each project phase, we will employ a mixed-methods approach to combine the advantages of quantitative and qualitative methods BIBREF52 , BIBREF53 , which is established in mental health research BIBREF54 , BIBREF55 , BIBREF56 , BIBREF57 and specifically recommended to investigate personal recovery BIBREF58 . Quantitative methods are suitable to study observable behaviour such as language and yield more generalisable results by taking into account large samples. However, they fall short of capturing the subjective, idiosyncratic meaning of socially constructed reality, which is important when studying individuals' recovery experience BIBREF59 , BIBREF22 , BIBREF23 , BIBREF60 . Therefore, we will apply an explanatory sequential research design BIBREF53 , starting with statistical analysis of the full dataset followed by a manual investigation of fewer examples, similar to `distant reading' BIBREF61 in digital humanities.",
          "Since previous research mainly employed (semi-)structured interviews and we do not expect to necessarily find the same aspects emphasised in unstructured settings, even less so when looking at a more diverse and non-English speaking population, we will not derive hypotheses from existing recovery models for testing on the online data. Instead, we will start off with exploratory quantitative research using comparative analysis tools such as Wmatrix BIBREF62 to uncover important linguistic features, e.g., on keywords and key concepts that occur with unexpected frequency in our collected datasets relative to reference corpora. The underlying assumption is that keywords and key concepts are indicative of certain aspects of personal recovery, such as those specified in the CHIME model BIBREF24 , other previous research BIBREF22 , BIBREF23 , BIBREF60 , or novel ones. Comparing online sources with transcripts of structured interviews or subcorpora originating from different cultural backgrounds might uncover aspects that were not prominently represented in the accounts studied in prior research.",
          "A specific challenge will be to narrow down the data to parts relevant for personal recovery, since there is no control over the discussed topics compared to structured interviews. To investigate how individuals discuss personal recovery online and what (potentially unrecorded) aspects they associate with it, without a priori narrowing down the search-space to specific known keywords seems like a chicken-and-egg problem. We propose to address this challenge by an iterative approach similar to the one taken in a corpus linguistic study of cancer metaphors BIBREF63 . Drawing on results from previous qualitative research BIBREF24 , BIBREF23 , we will compile an initial dictionary of recovery-related terms. Next, we will examine a small portion of the dataset manually, which will be partly randomly sampled and partly selected to contain recovery-related terms. Based on this, we will be able to expand the dictionary and additionally automatically annotate semantic concepts of the identified relevant text passages using a semantic tagging approach such as the UCREL Semantic Analysis System (USAS) BIBREF64 . Crucially for the multilingual aspect of the project, USAS can tag semantic categories in eight languages BIBREF8 . Then, semantic tagging will be applied to the full corpus to retrieve all text passages mentioning relevant concepts. Furthermore, distributional semantics methods BIBREF65 , BIBREF66 can be used to find terms that frequently co-occur with words from our keyword dictionary. Occurrences of the identified keywords or concepts can be quantified in the full corpus to identify the importance of the related personal recovery aspects.",
          "Linguistic Inquiry and Word Count (LIWC) BIBREF67 is a frequently used tool in social-science text analysis to analyse emotional and cognitive components of texts and derive features for classification models BIBREF47 , BIBREF46 , BIBREF68 , BIBREF69 . LIWC counts target words organised in a manually constructed hierarchical dictionary without contextual disambiguation in the texts under analysis and has been psychometrically validated and developed for English exclusively. While translations for several languages exist, e.g., Dutch BIBREF9 , and it is questionable to what extent LIWC concepts can be transferred to other languages and cultures by mere translation. We therefore aim to apply and develop methods that require less manual labour and are applicable to many languages and cultures. One option constitute unsupervised methods, such as topic modelling, which has been applied to explore cultural differences in mental-health related online data already BIBREF37 , BIBREF36 . The Differential Language Analysis ToolKit (DLATK) BIBREF70 facilitates social-scientific language analyses, including tools for preprocessing, such as emoticon-aware tokenisers, filtering according to meta data, and analysis, e.g. via robust topic modelling methods.",
          "Furthermore, emotion and sentiment analysis constitute useful tools to investigate the emotions involved in talking about recovery and identify factors that facilitate or hinder it. There are many annotated datasets to train supervised classifiers BIBREF71 , BIBREF3 for these actively researched NLP tasks. Machine learning methods were found to usually outperform rule-based approaches based on look-ups in dictionaries such as LIWC. Again, most annotated resources are English, but state of the art approaches based on multilingual embeddings allow transferring models between languages BIBREF4 ."
        ]
      },
      {
        "section_name": "Ethical considerations",
        "paragraphs": [
          "Ethical considerations are established as essential part in planning mental health research and most research projects undergo approval by an ethics committee. On the contrary, the computational linguistics community has started only recently to consider ethical questions BIBREF72 , BIBREF73 . Likely, this is because computational linguistics was traditionally concerned with publicly available, impersonal texts such as newspapers or texts published with some temporal distance, which left a distance between the text and author. Conversely, recent social media research often deals with highly personal information of living individuals, who can be directly affected by the outcomes BIBREF72 .",
          " BIBREF72 discuss issues that can arise when constructing datasets from social media and conducting analyses or developing predictive models based on these data, which we review here in relation to our project: Demographic bias in sampling the data can lead to exclusion of minority groups, resulting in overgeneralisation of models based on these data. As discussed in the introduction, personal recovery research suffers from a bias towards English-speaking Western individuals of white ethnicity. By studying multilingual accounts of ethnically diverse populations we explicitly address the demographic bias of previous research. Topic overexposure is tricky to address, where certain groups are perceived as abnormal when research repeatedly finds that their language is different or more difficult to process. Unlike previous research BIBREF45 , BIBREF47 , BIBREF46 our goal is not to reveal particularities in the language of individuals affected by mental health problems. Instead, we will compare accounts of individuals with BD from different settings (structured interviews versus informal online discourse) and of different backgrounds. While the latter bears the risk to overexpose certain minority groups, we will pay special attention to this in the dissemination of our results.",
          "Lastly, most research, even when conducted with the best intentions, suffers from the dual-use problem BIBREF74 , in that it can be misused or have consequences that affect people's life negatively. For this reason, we refrain from publishing mental health classification methods, which could be used, for example, by health insurance companies for the risk assessment of applicants based on their social media profiles.",
          "If and how informed consent needs to be obtained for research on social media data is a debated issue BIBREF75 , BIBREF76 , BIBREF77 , mainly because it is not straightforward to determine if posts are made in a public or private context. From a legal point of view, the privacy policies of Twitter and Reddit, explicitly allow analysis of the user contents by third party, but it is unclear to what extent users are aware of this when posting to these platforms BIBREF78 . However, in practice it is often infeasible to seek retrospective consent from hundreds or thousands of social media users. According to current ethical guidelines for social media research BIBREF79 , BIBREF80 and practice in comparable research projects BIBREF81 , BIBREF78 , it is regarded as acceptable to waive explicit consent if the anonymity of the users is preserved. Therefore, we will not ask the account holders of Twitter and Reddit posts included in our datasets for their consent.",
          " BIBREF79 formulate guidelines for ethical social media health research that pertain especially to data collection and sharing. In line with these, we will only share anonymised and paraphrased excerpts from the texts, as it is often possible to recover a user name via a web search for the verbatim text of a post. However, we will make the original texts available as datasets to subsequent research under a data usage agreement. Since the (automatic) annotation of demographic variables in parts of our dataset constitutes especially sensitive information on minority status in conjunction with mental health, we will only share these annotations with researchers that demonstrate a genuine need for them, i.e. to verify our results or to investigate certain research questions.",
          "Another important question is in which situations of encountering content indicative of a risk of self-harm or harm to others it would be appropriate or even required by duty of care for the research team to pass on information to authorities. Surprisingly, we could only find two mentions of this issue in social media research BIBREF81 , BIBREF82 . Acknowledging that suicidal ideation fluctuates BIBREF83 , we accord with the ethical review board's requirement in BIBREF81 to only analyse content posted at least three months ago. If the research team, which includes clinical psychologists, still perceives users at risk we will make use of the reporting facilities of Twitter and Reddit.",
          "As a central component we consider the involvement of individuals with lived experience in our project, an aspect which is missing in the discussion of ethical social media health research so far. The proposal has been presented to an advisory board of individuals with a BD diagnosis and was received positively. The advisory board will be consulted at several stages of the project to inform the research design, analysis, and publication of results. We believe that board members can help to address several of the raised ethical problems, e.g., shaping the research questions to avoid feeding into existing biases or overexposing certain groups and highlighting potentially harmful interpretations and uses of our results."
        ]
      },
      {
        "section_name": "Impact and conclusion",
        "paragraphs": [
          "The importance of the recovery concept in the design of mental health services has recently been prominently reinforced, suggesting \u2018recovery-oriented social enterprises as key component of the integrated service\u2019 BIBREF20 . We think that a recovery approach as leading principle for national or global health service strategies, should be informed by voices of individuals as diverse as those it is supposed to serve. Therefore, we expect the proposed investigations of views on recovery by previously under-researched ethnic, language, and cultural groups to yield valuable insights on the appropriateness of the recovery approach for a wider population. The datasets collected in this project can serve as useful resources for future research. More generally, our social-media data-driven approach could be applied to investigate other areas of mental health if it proves successful in leading to relevant new insights.",
          "Finally, this project is an interdisciplinary endeavour, combining clinical psychology, input from individuals with lived experience of BD, and computational linguistics. While this comes with the challenges of cross-disciplinary research, it has the potential to apply and develop state-of-the-art NLP methods in a way that is psychologically and ethically sound as well as informed and approved by affected people to increase our knowledge of severe mental illnesses such as BD."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "I would like to thank my supervisors Steven Jones, Fiona Lobban, and Paul Rayson for their guidance in this project. My heartfelt thanks go also to Chris Lodge, service user researcher at the Spectrum Centre, and the members of the advisory panel he coordinates that offer feedback on this project based on their lived experience of BD. Further, I would like to thank Masoud Rouhizadeh for his helpful comments during pre-submission mentoring and the anonymous reviewers. This project is funded by the Faculty of Health and Medicine at Lancaster University as part of a doctoral scholarship."
        ]
      }
    ],
    "qas": [
      {
        "question": "What languages were included in this multilingual population?",
        "question_id": "a926d71e6e58066d279d9f7dc3210cd43f410164",
        "nlp_background": "five",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "42a8db3f5bb659cbc61cd8d4405994cb2d4653ab",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "bb6e8f0ecd51485b8ed650cf5407db4b5ac5caa8",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "ddcb71e081eaf5a94f187d8f5ce0f7a572065836",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": []
  },
  "2003.11528": {
    "title": "Generating Major Types of Chinese Classical Poetry in a Uniformed Framework",
    "abstract": "Poetry generation is an interesting research topic in the field of text generation. As one of the most valuable literary and cultural heritages of China, Chinese classical poetry is very familiar and loved by Chinese people from generation to generation. It has many particular characteristics in its language structure, ranging from form, sound to meaning, thus is regarded as an ideal testing task for text generation. In this paper, we propose a GPT-2 based uniformed framework for generating major types of Chinese classical poems. We define a unified format for formulating all types of training samples by integrating detailed form information, then present a simple form-stressed weighting method in GPT-2 to strengthen the control to the form of the generated poems, with special emphasis on those forms with longer body length. Preliminary experimental results show this enhanced model can generate Chinese classical poems of major types with high quality in both form and content, validating the effectiveness of the proposed strategy. The model has been incorporated into Jiuge, the most influential Chinese classical poetry generation system developed by Tsinghua University (Guo et al., 2019).",
    "full_text": [
      {
        "section_name": "",
        "paragraphs": [
          "1.1em"
        ]
      },
      {
        "section_name": " ::: ",
        "paragraphs": [
          "1.1.1em"
        ]
      },
      {
        "section_name": " :::  ::: ",
        "paragraphs": [
          "1.1.1.1em",
          "Jinyi Hu, Maosong Sun$^{*}$ $*$ Corresponding author",
          "Department of Computer Science and Technology, Tsinghua University, Beijing, China",
          "Institute for Artificial Intelligence, Tsinghua University, Beijing, China",
          "State Key Lab on Intelligent Technology and Systems, Tsinghua University, Beijing, China",
          "hujy17@mails.tsinghua.edu.cn, sms@tsinghua.edu.cn",
          "Poetry generation is an interesting research topic in the field of text generation. As one of the most valuable literary and cultural heritages of China, Chinese classical poetry is very familiar and loved by Chinese people from generation to generation. It has many particular characteristics in its language structure, ranging from form, sound to meaning, thus is regarded as an ideal testing task for text generation. In this paper, we propose a GPT-2 based uniformed framework for generating major types of Chinese classical poems. We define a unified format for formulating all types of training samples by integrating detailed form information, then present a simple form-stressed weighting method in GPT-2 to strengthen the control to the form of the generated poems, with special emphasis on those forms with longer body length. Preliminary experimental results show this enhanced model can generate Chinese classical poems of major types with high quality in both form and content, validating the effectiveness of the proposed strategy. The model has been incorporated into Jiuge, the most influential Chinese classical poetry generation system developed by Tsinghua University BIBREF0."
        ]
      },
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Chinese poetry is a rich treasure in Chinese traditional culture. For thousands of years, poetry is always considered as the crystallization of human wisdom and erudition by Chinese people and deeply influences the Chinese history from the mental and cultural perspective.",
          "In general, a Chinese classical poem is a perfect combination of three aspects, i.e., form, sound, and meaning. Firstly, it must strictly obey a particular form which specifies the number of lines (i.e., sentences) in the poem and the number of characters in each line. Secondly, it must strictly obey a particular sound pattern which specifies the sound requirement for each character in every position of the poem. Lastly, it must be meaningful, i.e., with grammatical and semantic well-formedness for each line and, with thematic coherence and integrity throughout the poem. These three points form the universal principles for human poets to create Chinese classical poems.",
          "Chinese Classical poetry can be classified into two primary categories, SHI and CI. According to the statistical data from CCPC1.0, a Chinese Classical Poetry Corpus consisting of 834,902 poems in total (We believe it is almost a full collection of Chinese Classical poems). 92.87% poems in CCPC1.0 fall into the category of SHI and 7.13% fall into the category of CI. SHI and CI can be further divided into many different types in terms of their forms. We briefly introduce the related background knowledge as follows."
        ]
      },
      {
        "section_name": "Introduction ::: SHI",
        "paragraphs": [
          "The majority of SHI has a fixed number of lines and a fixed and identical number of characters for all lines. Two major forms of SHI are Jueju and Lvshi with four lines and eight lines accordingly. Jueju and Lvshi are further divided into Wuyan Jueju and Qiyan Jueju as well as Wuyan Lvshi and Qiyan Lvshi where Wuyan means five characters each line and Qiyan means seven characters. Figure 1 is a famous classical poem of Wuyan Jueju. In addition, Lvshi has a strict requirement for the two-sentence pairs composed of $<$the third line, the fourth line$>$ and $<$the fifth line, the sixth line$>$: they must satisfy the requirement of Duizhang, this is, a strict parallel matching for both part of speech and sense of every character in two lines. This obviously increases the difficulty of poem composition.",
          "According to CCPC1.0, Wuyan Jueju, Qiyan Jueju, Wuyan Lvshi, and Qiyan Lvshi constitute 67.96% of SHI, with 4.26%, 22.57%, 15.99%, and 25.14% respectively."
        ]
      },
      {
        "section_name": "Introduction ::: CI",
        "paragraphs": [
          "CI is another primary type of Chinese poetry. In contrast to SHI, CI has nearly one thousand forms. Each form of CI (it is called Cipai scholarly) is defined by a fixed number of lines for the poem and, a fixed number of characters for a particular line which usually varies for different lines. The above settings for different Cipai are very distinct, for instance, the Cipai of Busuanzi contains 8 lines and 44 characters, as shown in Figure 2, whereas the Cipai of Manjianghong contains 22 lines and 94 characters. The high diversity regarding the forms of CI further significantly increases the difficulty of poem composition.",
          "We observe the statistical distribution of all the forms (Cipai) of CI over CCPC1.0. It roughly follows Zipf\u2019s law BIBREF1. There exists a long tail in the distribution where a lot of Cipai only has a few instances which are far less enough for a computational model (algorithm) to learn its forms. So we choose the top frequent 121 forms of CI, constituting 80% of CCPC1.0, as the focus for CI in this research.",
          "As can be seen from the above analysis, the greatest challenge for machine generation of Chinese classical poems lies in how to make machine capable of following the universal principles underlying the writing of Chinese classical poems. The to-date research cannot deal with this challenge well. Most of the work so far mainly targeted at automatic generation of Jueju (including Wuyan Jueju and Qiyan Jueju), for an obvious reason that it is much easier for an algorithm to handle the requirements of form, thematic coherence and integrity in the scenario of four lines than that in the scenario of Lvshi with eight lines, let alone much more complicated scenarios, i.e., CI, are taken into account. In fact, the research on the automatic generation of CI is just at the very beginning stage.",
          "In this paper, we propose a uniformed computational framework that tries to generate major types of Chinese classical poems with two major forms of SHI, Jueju, and Lvshi, as well as 121 major forms (Cipai) of CI using a single model. Preliminary experimental results validate the effectiveness of the proposed framework. The implemented model has been incorporated into Jiuge BIBREF0, the most influential Chinese classical poetry generation system developed by Tsinghua University (refer to http://jiuge.thunlp.cn/)."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "With the development of deep learning, the mainstream of poem generation research has been shifted from traditional statistical models to neural network methods in recent years. Most existing works are based on the Encoder-Decoder architecture BIBREF2. In Chinese classical poetry generation, yan2013poet proposed a model using the Encoder-Decoder architecture and wang2016chinese further used attention-based sequence-to-sequence model.",
          "The key factor in designing the model architecture is how to treat the generated context so far in the process of generating a poem. The input to the encoder could be as short as a single poetic line or all the previously generated lines (whole history). Theoretically, considering the whole history is more appropriate for keeping the thematic coherence and integrity of the generated poem than considering the short history, at the expense that may hurt the fluency of the generated sentences due to the data sparseness problem possibly caused by the more sophisticated model.",
          "Thus we have two basic ways to figure out the history. One is to consider the whole history. zhang2014chinese first introduced the neural network method into poetry generation by proposing the so-called incremental Recurrent Neural Network, where every sentence (line) is embedded into a sentence vector by a Convolutional Sentence Model and then all are packed into a history vector. yi2018chinesea presented a working memory mechanism in LSTM, designing three kinds of memory to address the whole history. Another is to select part of history. yi2018chineseb observed that considering the full context may not lead to good performance in LSTM, and proposed salient clue mechanism where only salient characters in partial history are under consideration.",
          "The Transformer BIBREF3 architecture and other models based on this, including GPT BIBREF4, Bert BIBREF5, show much better results in various NLP tasks. Transformer utilizes the self-attention mechanism in which any pair of tokens in the sequence can attend to each other, making it possible to generate much longer SHI or CI while keeping the coherence throughout the poem.",
          "liao2019gpt applied GPT to Chinese classical poetry generation. They pre-trained the model on a Chinese news corpus with 235M sentences and then fine-tuning the model on Chinese poem corpus with 250,000 Jueju and Lvshi, 20,000 CIs, 700,000 pairs of couplets. A key point is they defined a unified format to formulate different types of training samples, as [form, identifier 1, theme, identifier 2, body], where \u201cbody\u201d accommodates the full content of an SHI, CI, or couplet in corresponding \u201cform\u201d with \u201ctheme\u201d as its title. Experiments demonstrated GPT-based poem generation gained promising performance, meanwhile still faced some limitations, for instance, only 70% of the generated CIs for the Cipai Shuidiaogetou, a sort of CI with quite long body, are correct in form.",
          "Regarding this, we think the work of liao2019gpt could be improved in the following three respects. First, there is a large improving room for better fitting the form requirement of CI in the process of generation, especially for those with relatively long body length. Second, their formulation format for training samples can be supplemented, for example, the stanza structure of CI is missing. Third, using contemporary Chinese news corpus to pre-train the model may not be necessary, owing to distinctive differences in both meaning and form between contemporary Chinese and Chinese classical poetry language.",
          "For the above considerations, we give up the pre-training on the news corpus and add a separation label to indicate the stanza structure of CI. Then we make use of GPT-2 to train the model. Furthermore, we propose a form-stressed weighting method in GPT-2 to strengthen the control in particular to the form of CI."
        ]
      },
      {
        "section_name": "Model ::: Pre-processing",
        "paragraphs": [
          "We present a unified format for formulating all types of training samples of SHI and CI by extending the format given in liao2019gpt. First, we change various punctuations between lines into the comma \u2018,\u2019, serving as a uniform separation label between two lines. Second, we utilize three separation labels, $[label_1]$ and $[label_2]$ to separate between form, title, and body of the poem respectively, and $[label_3]$ to separate two stanzas of CI if needed. Third, we enclose $[EOS]$ at the end of the body. Thus, the format for SHI is as follows:",
          "where n is the number of lines in the poem.",
          "The format of CI will be enriched with $[label_3]$ if it has two stanzas in the body:",
          "Here, $[label_1]$, $[label_2]$ and $[label_3]$ are set as \u2018$\\#$\u2019, \u2018$*$\u2019 and \u2018$\\&$\u2019.",
          "After pre-processing, all the formatted poem samples will be sent to the poetry generation model for training, as illustrated in Figure 3."
        ]
      },
      {
        "section_name": "Model ::: Basic Model",
        "paragraphs": [
          "We leverage the Transformer-based GPT-2, which is often used to train a robust language model, as the basic model of poetry generation. Compared to previous neural network-based language models such as RNN and LSTM, it is reported that GPT-2 exhibits good performance in the quality of generated texts given quite a long history BIBREF6. To weaken the so-called degeneration problem in generation and increase the diversity of generated texts, we use the top-k stochastic sampling strategy BIBREF7 (k is set as 15 in our experiment) to choose the next tokens to generate. In addition, our poetry generation model takes the Chinese character rather than the word as a basic linguistic unit, so word segmentation is not needed.",
          "With this naive GPT-2 model, we see from the experimental results that the generated poems appear pretty good in both meaning and sound(including rhyme), though if being observed carefully, there still exist some in-depth problems in sentence fluency and thematic coherence of the whole poem which are uneasy to solve. As for form, the model can perform well in generating Jueju and Lvshi of SHI whereas rather poorly in generating various Cipai of CI, with quite high form errors. Figure 4(a) is an example of a generated CI by this model, under Cipai of Busuanzi, where two characters are mistakenly missing which obviously violates the form requirement."
        ]
      },
      {
        "section_name": "Model ::: Enhanced Model",
        "paragraphs": [
          "In the basic model, the loss function for training with respect to the $i$th token in the text is conventionally defined as the cross-entropy:",
          "where $x[i]$ is the vector of $i$th token, $j$ is over all possible token types.",
          "To address the form problem, we simply add a weighting factor into the loss function with particular stress on the aforementioned three types of form-related tokens, i.e., the line separation label \u2018,\u2019, the stanza separation label \u2018$\\&$\u2019, and $[EOF]$, as in:",
          "where $weight[i]$ is set as 1 for any Chinese character, 2 for \u2018,\u2019 and \u2018$\\&$\u2019, and 3 for $[EOF]$.",
          "This simple method (we thus call it the form-stressed weighting method) enhances the model\u2019s capability to form control quite significantly. Figure 4(b) shows an example that contrasts the case in Figure 4(a)."
        ]
      },
      {
        "section_name": "Experiment ::: Experiment Setup",
        "paragraphs": [
          "We implement the GPT-2 model based on the transformers library BIBREF8. The model configuration is 8 attention heads per layer, 8 layers, 512 embedding dimensions, and 1024 feed-forward layer dimensions. We employ the OpenAIAdam optimizer and train the model with 400,000 steps in total on 4 NVIDIA 1080Ti GPUs. The characters with frequency less than 3 in CCPC1.0 are treated as UNK and a vocabulary with 11259 tokens (characters) is finally built up."
        ]
      },
      {
        "section_name": "Experiment ::: Performance Comparison of the Two Models in Form",
        "paragraphs": [
          "For Jueju and Lvshi of SHI, because of their simplicity in form, the two models hardly make form errors. We generate 500 poems for each type using the two models accordingly. All of these poems are in the right form. This demonstrates that both models are all very powerful in generating Jueju and Lvshi with almost perfect performance in form.",
          "For CI, we select 6 Cipais, with the body length varying from 33 to 114 characters and with relatively sufficient training samples in CPCC, as our observation target. We generate 300 poems with the two models accordingly. Table 1 summarizes the correct rates of the two models under these 6 Cipais (a generated poem is considered to be correct in form if and only if its form fully matches the expected form). As can be seen, a tendency is the longer the body of CI, the worse the performance of the two models in form and, the more significant the gain in the form correct rate for the enhanced model (an extreme is in the case of Qinyuanchun where the correct rate is raised from 12.0% to 55.0%)."
        ]
      },
      {
        "section_name": "Experiment ::: Effect of the Stanza Separation",
        "paragraphs": [
          "The preliminary observation on the generated poems suggests that the inclusion of the stanza separation into the unified format of training samples is beneficial in some degree for meeting the form requirement. For instance, we input the same title to the enhanced model and to a model trained under the same condition except without the stanza separation, asking them to generate a number of CIs with Cipai of Busuanzi, a task similar to that in Figure 4. We find that about 20% of CIs generated by the latter suffer from some errors in form, as illustrated in Figure 5, meanwhile all the CIs generated by the former ideally match the expected form."
        ]
      },
      {
        "section_name": "Experiment ::: Case Observation",
        "paragraphs": [
          "According to our observation, the enhanced model is likely to generate poems with both high quality and diversity. We present two examples generated by the model and give some comments on the meaning of each poem.",
          "UTF8gbsn\u4e03\u5f8b \u00b7 \u8fdc\u671b",
          "UTF8gbsn\u6c5f\u4e0a\u5fae\u832b\u4e00\u53f6\u821f\uff0c\u5929\u6daf\u82b3\u8349\u6ee1\u6c40\u6d32",
          "UTF8gbsn\u6570\u58f0\u6e14\u5531\u9694\u8239\u8fc7\uff0c\u51e0\u70b9\u4eba\u5bb6\u843d\u5e06\u6e38",
          "UTF8gbsn\u6625\u8272\u4e0d\u4ece\u83ba\u8bed\u5230\uff0c\u5915\u9633\u7a7a\u5ea6\u5ba2\u5fc3\u6101",
          "UTF8gbsn\u4f55\u65f6\u91cd\u5411\u957f\u6865\u996e\uff0c\u540c\u6cdb\u6eaa\u5149\u5171\u767d\u5934",
          "The example above is a Qiyan Lvshi. The title of this poem means \u201clook far around\u201d. In this poem, the first four lines depict a view seen from the river bank-misty and rolling waters, a drifting boat, lush vanillas, melodies from passing boats and cottages on the bank, creating a tranquil and halcyon atmosphere. However, the poet is still overcome by solitude and nostalgia because of the lonely trip, which is vividly revealed in the second four sentences. The poem adopts a typical semantic structure of Qiyan Lvshi with its first-half delineating a view and then conveying the poet\u2019s feeling in the second-half (the contrast between the view and the feeling is one of the appreciated artistic methods in Chinese classical poems). In addition, for Lvshi, the pairs of $<$the third line, the fourth line$>$ and $<$the fifth line, the sixth line$>$ must satisfy the requirement of Duizhang, a correspondence in both part-of-speech(POS) and word sense between two parallel lines. This point is perfectly reflected in the generated poem, as shown in Table 2.",
          "UTF8gbsn\u6ee1\u6c5f\u7ea2 \u00b7 \u585e\u5916",
          "UTF8gbsn\u98ce\u6025\u79cb\u7a7a\uff0c\u5929\u6b32\u66ae\uff0c\u9ec4\u4e91\u98de\u5904\u3002",
          "UTF8gbsn\u4eba\u4e0d\u89c1\uff0c\u6c99\u5824\u91ce\u620d\uff0c\u4e71\u9e26\u557c\u82e6\u3002",
          "UTF8gbsn\u4e07\u91cc\u80e1\u7b33\u5439\u96c1\u65ad\uff0c\u4e09\u66f4\u7f8c\u7b1b\u6101\u5982\u8bb8\u3002",
          "UTF8gbsn\u751a\u5173\u6cb3\u3001\u5f81\u5987\u6cea\u75d5\u591a\uff0c\u65e0\u884c\u8def\u3002",
          "UTF8gbsn\u9752\u72fc\u706b\uff0c\u8352\u70df\u6811\u3002",
          "UTF8gbsn\u767d\u9732\u8349\uff0c\u6b8b\u9633\u5ea6\u3002",
          "UTF8gbsn\u4f46\u5bd2\u5c71\u8fdc\u8fd1\uff0c\u6545\u4e61\u5343\u53e4\u3002",
          "UTF8gbsn\u4e00\u89d2\u659c\u6656\u5f52\u68a6\u7ed5\uff0c\u6ee1\u6c5f\u7ea2\u53f6\u897f\u9675\u53bb\u3002",
          "UTF8gbsn\u5f85\u660e\u5e74\uff0c\u53c8\u5230\u6c49\u5bb6\u57ce\uff0c\u91cd\u56de\u987e\u3002",
          "",
          "The example above is a CI in the form of Manjianghong and the title means \u201cbeyond the Great Wall\u201d. It vividly depicts a typical view of the Northwestern China howling wind, clouds of dust, crying crows and lugubrious sound of flutes. The poem is saturated with nostalgia, solitude and desolate feelings of life, which is not only embodied in the bleak scenery but also overtly revealed in the last three sentences. The combination of visual and audio feelings and of reality and imagination is tactfully employed in the poem and makes it even more impressive and resonating."
        ]
      },
      {
        "section_name": "Conclusion and Future Works",
        "paragraphs": [
          "In this paper, we propose a GPT-2 based uniformed framework for generating major types of Chinese classical poems, including SHI and CI. To this end, we at first define a unified format for formulating all types of training samples by integrating more detailed form information, then present a simple form-stressed weighting method in GPT-2 to strengthen the control to the form of CI. Preliminary experiments validate the effectiveness of our method. Nevertheless, we also find that enabling GPT-2 to have a strong capability in form manipulation for the generated texts remains a difficult challenge, particularly for those forms with longer body length and fewer training samples. We plan to figure out a more sophisticated way to make the model better learn the form structure and hope to enrich the general GPT-2 from this special perspective."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We would like to thank Zhipeng Guo, Xiaoyuan Yi, Xinran Gu and anonymous reviewers for their insightful comments. This work is supported by the project Text Analysis and Studies on Chinese Classical Literary Canons with Big Data Technology under grant number 18ZDA238 from the Major Program of the National Social Science Fund of China. Hu is also supported by the Initiative Scientific Research Program and Academic Training Program of the Department of Computer Science and Technology, Tsinghua University."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is the source of the training/testing data?",
        "question_id": "c2ce25878a17760c79031a426b6f38931cd854b2",
        "nlp_background": "two",
        "topic_background": "familiar",
        "paper_read": "somewhat",
        "search_query": "",
        "question_writer": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "CCPC1.0"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Chinese Classical poetry can be classified into two primary categories, SHI and CI. According to the statistical data from CCPC1.0, a Chinese Classical Poetry Corpus consisting of 834,902 poems in total (We believe it is almost a full collection of Chinese Classical poems). 92.87% poems in CCPC1.0 fall into the category of SHI and 7.13% fall into the category of CI. SHI and CI can be further divided into many different types in terms of their forms. We briefly introduce the related background knowledge as follows.",
                "We implement the GPT-2 model based on the transformers library BIBREF8. The model configuration is 8 attention heads per layer, 8 layers, 512 embedding dimensions, and 1024 feed-forward layer dimensions. We employ the OpenAIAdam optimizer and train the model with 400,000 steps in total on 4 NVIDIA 1080Ti GPUs. The characters with frequency less than 3 in CCPC1.0 are treated as UNK and a vocabulary with 11259 tokens (characters) is finally built up."
              ],
              "highlighted_evidence": [
                "Chinese Classical poetry can be classified into two primary categories, SHI and CI. According to the statistical data from CCPC1.0, a Chinese Classical Poetry Corpus consisting of 834,902 poems in total (We believe it is almost a full collection of Chinese Classical poems). 92.87% poems in CCPC1.0 fall into the category of SHI and 7.13% fall into the category of CI. SHI and CI can be further divided into many different types in terms of their forms. We briefly introduce the related background knowledge as follows.",
                "We implement the GPT-2 model based on the transformers library BIBREF8. The model configuration is 8 attention heads per layer, 8 layers, 512 embedding dimensions, and 1024 feed-forward layer dimensions. We employ the OpenAIAdam optimizer and train the model with 400,000 steps in total on 4 NVIDIA 1080Ti GPUs. The characters with frequency less than 3 in CCPC1.0 are treated as UNK and a vocabulary with 11259 tokens (characters) is finally built up."
              ]
            },
            "annotation_id": "b2cf6d3f57698251eec990df3ce42f4271b95225",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Two major forms(Jueju and Lvshi) of SHI and 121 major forms of CI from Chinese Classical Poerty Corpus (CCPC1.0)",
              "evidence": [
                "Chinese Classical poetry can be classified into two primary categories, SHI and CI. According to the statistical data from CCPC1.0, a Chinese Classical Poetry Corpus consisting of 834,902 poems in total (We believe it is almost a full collection of Chinese Classical poems). 92.87% poems in CCPC1.0 fall into the category of SHI and 7.13% fall into the category of CI. SHI and CI can be further divided into many different types in terms of their forms. We briefly introduce the related background knowledge as follows.",
                "In this paper, we propose a uniformed computational framework that tries to generate major types of Chinese classical poems with two major forms of SHI, Jueju, and Lvshi, as well as 121 major forms (Cipai) of CI using a single model. Preliminary experimental results validate the effectiveness of the proposed framework. The implemented model has been incorporated into Jiuge BIBREF0, the most influential Chinese classical poetry generation system developed by Tsinghua University (refer to http://jiuge.thunlp.cn/)."
              ],
              "highlighted_evidence": [
                "Chinese Classical poetry can be classified into two primary categories, SHI and CI. According to the statistical data from CCPC1.0, a Chinese Classical Poetry Corpus consisting of 834,902 poems in total (We believe it is almost a full collection of Chinese Classical poems).",
                "In this paper, we propose a uniformed computational framework that tries to generate major types of Chinese classical poems with two major forms of SHI, Jueju, and Lvshi, as well as 121 major forms (Cipai) of CI using a single model."
              ]
            },
            "annotation_id": "b329fcbcd2132fba8fa55b6c320ef06031b059d5",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Chinese poem corpus with 250,000 Jueju and Lvshi, 20,000 CIs, 700,000 pairs of couplets"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "liao2019gpt applied GPT to Chinese classical poetry generation. They pre-trained the model on a Chinese news corpus with 235M sentences and then fine-tuning the model on Chinese poem corpus with 250,000 Jueju and Lvshi, 20,000 CIs, 700,000 pairs of couplets. A key point is they defined a unified format to formulate different types of training samples, as [form, identifier 1, theme, identifier 2, body], where \u201cbody\u201d accommodates the full content of an SHI, CI, or couplet in corresponding \u201cform\u201d with \u201ctheme\u201d as its title. Experiments demonstrated GPT-based poem generation gained promising performance, meanwhile still faced some limitations, for instance, only 70% of the generated CIs for the Cipai Shuidiaogetou, a sort of CI with quite long body, are correct in form.",
                "Regarding this, we think the work of liao2019gpt could be improved in the following three respects. First, there is a large improving room for better fitting the form requirement of CI in the process of generation, especially for those with relatively long body length. Second, their formulation format for training samples can be supplemented, for example, the stanza structure of CI is missing. Third, using contemporary Chinese news corpus to pre-train the model may not be necessary, owing to distinctive differences in both meaning and form between contemporary Chinese and Chinese classical poetry language."
              ],
              "highlighted_evidence": [
                "They pre-trained the model on a Chinese news corpus with 235M sentences and then fine-tuning the model on Chinese poem corpus with 250,000 Jueju and Lvshi, 20,000 CIs, 700,000 pairs of couplets.",
                "Third, using contemporary Chinese news corpus to pre-train the model may not be necessary, owing to distinctive differences in both meaning and form between contemporary Chinese and Chinese classical poetry language."
              ]
            },
            "annotation_id": "db1daaf10fae01579492cc9f2ccc956126b70816",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: An example of SHI with Wuyan Jueju as its form. The array of small boxes, usually each surrounds a Chinese character, illustrates the form requirement in the number of lines and the number of characters per line for a poem. A full correspondence between character and box, no more and no less, indicates this basic form requirement is satisfied by the given poem."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: An example of CI with the form(Cipai) Busuanzi. In contrast to the case of SHI in Figure 1, the array of small boxes here shows the predefined number of characters per line of CI tends to be variable."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Format pre-processing of poem samples for training."
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Figure 4: Comparison of two generated poems by the basic model and the enhanced model."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Comparison between two models on the control to the form of CI."
      },
      {
        "file": "5-Figure5-1.png",
        "caption": "Figure 5: Two example poems generated by the model without considering the stanza separation. Both have errors in form. Refer to Figure 4(b) for comparison."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Illustration of Duizhang."
      }
    ]
  },
  "1801.03615": {
    "title": "Improved English to Russian Translation by Neural Suffix Prediction",
    "abstract": "Neural machine translation (NMT) suffers a performance deficiency when a limited vocabulary fails to cover the source or target side adequately, which happens frequently when dealing with morphologically rich languages. To address this problem, previous work focused on adjusting translation granularity or expanding the vocabulary size. However, morphological information is relatively under-considered in NMT architectures, which may further improve translation quality. We propose a novel method, which can not only reduce data sparsity but also model morphology through a simple but effective mechanism. By predicting the stem and suffix separately during decoding, our system achieves an improvement of up to 1.98 BLEU compared with previous work on English to Russian translation. Our method is orthogonal to different NMT architectures and stably gains improvements on various domains.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Neural machine translation (NMT) BIBREF0 has shown better performance compared with statistic machine translation BIBREF1 . Such methods encode a source sentence into hidden states and generate target words sequentially by calculating a probability distribution on the target-side vocabulary. Most NMT systems limit target side vocabulary to a fixed size, considering the limit of graphics memory size and high computing complexity when predicting a word over the whole target side vocabulary (e.g., 30K or 50K). In addition, a larger target-side vocabulary can also make the prediction task more difficult. Word-level NMT systems suffer the problem of out of vocabulary (OOV) words, particularly for morphologically rich languages. For example, English to Russian machine translation faces a big challenge due to rich morphology of Russian words, which leads to much more OOV words than some other languages. Typically a specific tag is used to represent all OOV words, which is then translated during a post process BIBREF2 . This can be harmful to the translation quality.",
          "There has been several methods to address this problem. Some focused on translation granularity ( BIBREF3 , BIBREF3 ; BIBREF4 , BIBREF4 ; BIBREF5 , BIBREF5 ), while others ( BIBREF6 , BIBREF6 ; BIBREF7 , BIBREF7 ) effectively expand target side vocabulary. However, though those methods can avoid OOV, none of them has explicitly modeled the target side morphology. When dealing with language pairs such as English-Russian, the number of different target side words is large due to the rich suffixes in Russian. The above methods are limited in distinguishing one suffix from another.",
          "Since the total number of different stems in a morphologically rich language is much less than the number of words, a natural perspective to make a better translation on a morphologically-rich target-side language is to model stems and suffixes separately. We design a simple method, which takes a two-step approach for the decoder. In particular, stem is first generated at each decoding step, before suffix is predicted. Two types of target side sequences are used during training, namely stem sequence and suffix sequence, which are extracted from the original target side word sequence, as shown in Figure FIGREF1 . Sparsity is relieved since the number of stem types is much smaller than word types, and suffix types can be as small as several hundreds. Another advantage of this structure is that during the prediction of suffix, the previously generated stem sequence can be considered, which can further improve the accuracy of suffix prediction.",
          "We empirically study this method and compare it with previous work on reducing OOV rates ( BIBREF3 , BIBREF3 ; BIBREF4 , BIBREF4 ). Results show that our method gives significant improvement on the English to Russian translation task on two different domains and two popular NMT architectures. We also verify our method on training data consisting of 50M bilingual sentences, which proves that this method works effectively on large-scale corpora."
        ]
      },
      {
        "section_name": "Translation Granularity",
        "paragraphs": [
          "Subword based BIBREF3 and character-based ( BIBREF4 , BIBREF4 ; BIBREF5 , BIBREF5 ) NMT are the two directions of adjusting translation granularity, which can be helpful to our problem.",
          "In BIBREF3 ( BIBREF3 )'s work, commonly appearing words remain unchanged, while others are segmented into several subword units, which are from a fixed set. Both source and target side sentences can be changed into subword sequences. More specifically, some rare words are split into and represent as some more frequent units, base on a data compression technique, namely Byte Pair Encoding (BPE). The vocabulary built on common words and these frequent subword units can successfully improve the coverage of training data. In fact, a fixed size vocabulary can cover all the training data as long as the granularity of subword units is small enough. The main limitation of this method is the absence of morphology boundary. Some subword units may not be a word suffix which can represent a morphological meaning, and the subword units are treated in the same way as complete words. Subword units and complete words are predicted during a same sequence generation procedure. This may lead to two problems:",
          "The sequence length can increase, especially on a morphologically rich language, which can lead to low NMT performance.",
          "A subword unit cannot represent a linguistic unit, and suffix is not modeled explicitly.",
          " BIBREF5 ( BIBREF5 ) proposed a hybrid architecture to deal with the OOV words in source side and any generated unknown tag in the target side. In their system, any OOV words on the source side are encoded at the character level, and if an unknown tag is predicted during decoding, another LSTM will be used to generate a sequence of target-side characters, which will be used as the replacement of the target side unknown word for the translation of a source OOV. However, their model may not work well when the target side is morphologically rich and the source side is not, because their hybrid network on the target side will only be used when an unknown tag is generated, which is always corresponding to a source unknown word. If most of the source side tokens are covered by the source vocabulary, the hybrid network may not have advantage on a morphologically rich target side language.",
          "In BIBREF4 ( BIBREF4 )'s work, source side and target side sequence are all character-based, which eliminates OOV on the source side, and can generate any target side word theoretically. Character-based NMT may potentially improve the translation accuracy of morphologically rich language on the source side, but the training and decoding latency increase linearly with the sequence length, which is several times to the original word based NMT. Another disadvantage of character-based NMT is that character embedding lost the ability to represent a linguistic unit. Long-distance dependences are more difficult to be modeled in a character-based NMT. BIBREF4 ( BIBREF4 ) use convolutional and pooling layers on the source side to make the source sequence shorter. However, the target side sequence remains much longer than the original word sequence, and suffix boundary of the target side is not specifically considered in their model. This work may more helpful if a morphologically rich language is on the source side, but it is not designed to overcome the problem brought by a morphologically rich target side language.",
          "There is another way which can effectively reduce target-side OOV. Both BIBREF6 ( BIBREF6 ) and BIBREF7 ( BIBREF7 ) use a large target-side vocabulary. To overcome the problem of GPU memory limitation and increasing computational complexity, instead of the original vocabulary, a selected subset is actually used both during the training and decoding time. Their model can generate any of the words in the large vocabulary, but data sparsity still remains, the low frequent words in the training data is not fully trained."
        ]
      },
      {
        "section_name": "Morphology and MT",
        "paragraphs": [
          "Previous work considered morphological information for both SMT and NMT. BIBREF8 ( BIBREF8 ) proposed an effective way to integrate word-level annotation in SMT, which can be morphological, syntactic, or semantic. Morphological information can be utilized not only on source side, but also the target side. Although these annotation can help to improve the translation procedure, data sparsity still exists. BIBREF9 ( BIBREF9 ) decompose the process of translating a word into two steps. Firstly a stem is produced, then a feature-rich discriminative model selects an appropriate inflection for the stem. Target-side morphological features and source-side context features are utilized in their inflection prediction model.",
          " BIBREF10 ( BIBREF10 ) use distributed representations for words and soft morphological tags in their neural inflection model, which can effectively reduce lexical sparsity, leading to less morphological ambiguity. This is the first try of modeling inflection through a neural method, integrated in a SMT architecture.",
          "For NMT, BIBREF11 ( BIBREF11 ) make use of various source side features (such as morphological features, part-of-speech tags, and syntactic dependency labels) to enhance encoding in NMT. This is the first time morphological information is leveraged in NMT architecture. Target-side morphology is not considered in their work. BIBREF12 ( BIBREF12 ) predict a sequence of interleaving morphological tags and lemmas, followed by a morphological generator. They used a external model to synthesize words given tags and lemmas. Our method is the first to explicitly consider the generation of morphological suffixes within a neural translation model. Our work is motivated by a line of work that generates morphology during text generation ( BIBREF13 , BIBREF13 ; BIBREF14 , BIBREF14 ; BIBREF10 , BIBREF10 )."
        ]
      },
      {
        "section_name": "Russian Morphology and Stemming",
        "paragraphs": [
          "Morphology Russian has rich morphology, which includes number (singular or plural), case (nominative, accusative etc.), gender (feminine, masculine or neuter) and tense mood. Figure FIGREF2 shows one example for Russian. A noun word \u201cball\u201d is always masculine, but the suffix differs when the case and number changes, resulting in 10 different forms. Some other nouns can be feminine or neuter, and their adjectives will agree with them. Both adjectives and verbs have different forms according to their case, tense mood and the form of words they modify. Such morphological changes bring a challenge to machine translation task.",
          "Stemming A Russian word can be split into two parts, namely the stem and the suffix. Suffix contains morphological information of a Russian word, including gender, number and case etc. In this paper, we use a deterministic rule-based stemmer to obtain stem and suffix for a Russian word. The process of stemming is shown in Figure FIGREF1 ."
        ]
      },
      {
        "section_name": "Neural Machine Translation Baselines",
        "paragraphs": [
          "We experiment with two different types of Neural Machine Translation (NMT) systems, one using a recurrent encoder-decoder structure BIBREF0 , the other leveraging the attention mechanism on the encoder BIBREF15 .",
          "Recurrent Neural Network Based NMT We use an encoder-decoder network proposed by BIBREF16 ( BIBREF16 ). The encoder uses a bi-directional recurrent neural network (RNN) to encode the source sentence, the decoder uses a uni-directional RNN to predict the target translation. Formally, the source sentence can be expressed as INLINEFORM0 , where INLINEFORM1 is the length of the sentence. It is encoded into a sequence of hidden states INLINEFORM2 , each INLINEFORM3 is the result of a concat operation on a forward (left-to-right) hidden state INLINEFORM4 and a backword (right-to-left) hidden state INLINEFORM5 : DISPLAYFORM0 DISPLAYFORM1 ",
          " INLINEFORM0 is a variation of LSTM BIBREF17 , namely Gated Recurrent Unit (GRU) BIBREF18 : DISPLAYFORM0 DISPLAYFORM1 ",
          "where INLINEFORM0 , INLINEFORM1 , INLINEFORM2 are weight matrices which are learned.",
          "During decoding, at each time step INLINEFORM0 , an attention probability INLINEFORM1 to the source word INLINEFORM2 is first calculated by: DISPLAYFORM0 ",
          "and DISPLAYFORM0 ",
          "is an attention model that gives a probability distribution on source words INLINEFORM0 , which indicates how much the source word INLINEFORM1 is considered during the decoding step INLINEFORM2 to generate target side word INLINEFORM3 . The attention layer INLINEFORM4 can be as simple as a feed-forward network. INLINEFORM5 is a weighted sum of the encoding hidden state at each position of input sentence: DISPLAYFORM0 ",
          " INLINEFORM0 is then fed into a feed-forward network together with previous target word embedding INLINEFORM1 and the current decoding hidden state INLINEFORM2 to generate the output intermediate state INLINEFORM3 : DISPLAYFORM0 ",
          "and DISPLAYFORM0 ",
          "where INLINEFORM0 is GRU, which is mentioned before. The output intermediate state INLINEFORM1 is then used to predict the current target word by generating a probability distribution on target side vocabulary. In our implementation, maxout BIBREF19 mechanism is used in both training and decoding. Dropout BIBREF20 is used in training time.",
          "Transformer BIBREF15 is a recently proposed model for sequence to sequence tasks. It discards the RNN structure for building the encoder and decoder blocks. Instead, only the attention mechanism is used to calculate the source and target hidden states.",
          "The encoder is composed of stacked neural layers. In particularly, for the time step INLINEFORM0 in layer INLINEFORM1 , the hidden state INLINEFORM2 is calculated as follows: First, a self-attention sub-layer is employed to encode the context. For this end, the hidden states in the previous layer are projected into a tuple of queries( INLINEFORM3 ), keys( INLINEFORM4 ) and values( INLINEFORM5 ), where INLINEFORM6 in the following function denotes a feed forward layer: DISPLAYFORM0 ",
          "Then attention weights are computed as scaled dot product between current query and all keys, normalized with a softmax function. After that, the context vector is represented as weighted sum of the values projected from hidden states in the previous layer. The hidden state in the previous layer and the context vector are then connected by residual connection, followed by a layer normalization function BIBREF21 , to produce a candidate hidden state INLINEFORM0 . Finally, another sub-layer including a feed forward layer, followed by another residual connection and layer normalization, are used to obtain the hidden state INLINEFORM1 : DISPLAYFORM0 ",
          "The decoder is also composed of stacked layers. The hidden states are calculated in a similar way, except for the following two differences: First, only those target positions before the current one are used to calculate the target side self-attention. Second, attention is applied in both target-to-target and target-to-source. The target-to-source attention sub-layer is inserted between the target self-attention sub-layer and the feed-forward sub-layer. Different from self-attention, the queries( INLINEFORM0 ) are projected from target hidden states in the previous layer, and the keys( INLINEFORM1 ) and values( INLINEFORM2 ) are projected from the source hidden states in the last layer.",
          "The rest of the calculation is exactly the same with self-attention. Compared to RNN based sequence to sequence models, transformer allows significantly more parallelization, since all the hidden states in the same layer can be calculated simultaneously, whereas the hidden states in RNN can only be calculated sequentially from left to right. In consideration of translation quality, BIBREF15 ( BIBREF15 ) use multi-head attention instead of single-head attention as mentioned above, and positional encoding is also used to compensate the missing of position information in this model."
        ]
      },
      {
        "section_name": "Target-Side Suffix Prediction",
        "paragraphs": [
          "We take a two-step approach for the decoder, yielding a stem at each time step before predicting the suffix of the stem. Since we only make use of source hidden states, target hidden states, target to source attention weights and target predicted tokens, these are universal in all sequence to sequence models, our method can be implemented into any of these models.",
          "Figure FIGREF23 shows a more detailed procedure. Decoding target stems is exactly the same as decoding target words in normal sequence to sequence model, which is predicted through a softmax layer based on the target output layer. All we need is to replace target words with target stems: DISPLAYFORM0 ",
          "where INLINEFORM0 is a weight matrix to transfer the output layer INLINEFORM1 from a dimension of hidden size to target side vocabulary size. INLINEFORM2 is target side hidden state at time step INLINEFORM3 when generating the stem. INLINEFORM4 is the output state: DISPLAYFORM0 ",
          " INLINEFORM0 is a single layer feed-forward neural network.",
          "After the prediction of INLINEFORM0 , the target suffix INLINEFORM1 on decoding step INLINEFORM2 is immediately predicted from the target suffix hidden state INLINEFORM3 : DISPLAYFORM0 ",
          " INLINEFORM0 is generated from a single layer feed-forward neural network by using the stem embedding INLINEFORM1 , stem hidden state INLINEFORM2 , and source context vector INLINEFORM3 : DISPLAYFORM0 ",
          "Since we consider that the attention degree towards each word in the source sequence is useful to the generation of suffix, the aligned source context is also used during the prediction of suffix. Note that the source context vector INLINEFORM0 is shared between the generation of stem hidden state INLINEFORM1 and suffix hidden state INLINEFORM2 .",
          "In addition, the embedding of the predicted suffix is not further fed into the hidden state of the next stem, because we think suffix information can provide little information for predicting the next stem from a linguistic perspective."
        ]
      },
      {
        "section_name": "Training",
        "paragraphs": [
          "During the training stage, the objective function INLINEFORM0 consists of two components: DISPLAYFORM0 ",
          "where: DISPLAYFORM0 ",
          "and DISPLAYFORM0 ",
          " INLINEFORM0 verifies from 0 to 1, and INLINEFORM1 can also be modeled in the whole architecture, which will be studied in our future work. In our experiments, we set INLINEFORM2 to 0.1 empirically. We use Adam BIBREF22 as our optimizing function."
        ]
      },
      {
        "section_name": "Decoding",
        "paragraphs": [
          "Beam search is adopted as our decoding algorithm. At each time step, the search space can be infeasible large if we take all the combinations of stems and suffixes into consideration. So we use cube pruning BIBREF23 to obtain n-best candidates. First, the top INLINEFORM0 stems with the highest scores are pushed to the stack. Then for each stem, we predict the top INLINEFORM1 suffixes, which will result in INLINEFORM2 complete candidates. The candidates will be inserted to a priority queue, which keeps records of the top INLINEFORM3 complete candidates. After all the stems are expanded, the final n-best candidates are obtained."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We run our experiments on English to Russian (En-RU) data under two significantly different domain, namely the news domain and the e-commerce domain. We verify our method on both RNN based NMT architecture and Transformer based NMT architecture."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "News We select 5.3M sentences from the bilingual training corpus released by WMT2017 shared task on the news translation domain as our training data. We use 3 test set, which are published by WMT2017 news translation task, namely \u201cNews2014\u201d, \u201cNews2015\u201d, \u201cNews2016\u201d.",
          "E-commerce We collect 50M bilingual sentences as our training corpus:",
          "10M sentences are crawled and automatic aligned from some international brand's English and Russian websites.",
          "20M are back translated corpus: First we crawled the Russian sentences from websites of certain Russian's Brands. Then translated them to English through a machine translation system trained on limited RU-EN corpus BIBREF24 .",
          "The last 20M bilingual sentences are crawled from the web, and are not domain specific.",
          "We typically use the following 3 types of data as test set, which are named title, description and comment, these sentences are all extracted from e-commerce websites. Title are the goods' titles showed on a listing page when some buyers type in some keywords in a searching bar under an e-commerce website. Description refers to the information in a commodities' detail page. Comment include the review or feedback from some buyers. Example sentences are shown in Table TABREF33 . For each kind of test set, we randomly select 1K English sentences and translate it by human.",
          "Pre-Processing Both the training set and the test set are lowercased, and some entity words appeared in the data are generalized into specific symbols, such as \u201c_date_\u201d, \u201c_time_\u201d, \u201c_number_\u201d. When selecting our training data, we keep the sentences which has length between 1 to 30. We use a bilingual sentence scorer to discard some low-quality bilingual sentences. The scorer is simply trained under algorithm of IBM Model 1 BIBREF25 on a very large bilingual corpus.",
          "Target Side Word Stemming We use snowball to create stems from words. Because stem created from snowball is always a substring of the original word, we can obtain suffixes by simply applying a string cut operation. By applying snowball to a target side word sequence, we split a target side sentence into a stem sequence and a suffix sequence. The stemming accuracy of snowball is 83.3% on our human labeled test set.",
          "Applying BPE to Target Side Stem Sequence We also use the Byte-pair encoding (BPE algorithm) on the target side stem sequence, which will further reduce data sparsity. Some stems will be split into \u201csub-stem\u201d units. The stem sequence is transferred to \u201csub-stem\u201d sequence at this step. Suffix sequence should also be adjusted according to the \u201csub-stem\u201d sequence simultaneously. More specifically, as shown in Figure FIGREF36 , if a stem is split into INLINEFORM0 \u201csub-stem\u201d units, then INLINEFORM1 \u201cN\u201d (refers to \u201cN\u201d in Figure FIGREF1 ) will be inserted into the suffix sequence, and these tags will be located in front of the suffix which is corresponding to the original complete stem. The sub-stem sequence and the adjusted suffix sequence are the final training corpus on target side."
        ]
      },
      {
        "section_name": "Baselines",
        "paragraphs": [
          "Our RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides, since the subword method had a stable improvement compared with word based system, especially on morphologically rich languages.",
          "Besides, we compared our system with a fully character-based baseline system, which is an implementation of BIBREF4 ( BIBREF4 )'s work, and is available on github.",
          "We limit the source and target vocabularies to the most frequent 30K tokens for both English and Russian. For news domain, about 99.7% tokens are covered by the source side vocabulary, about 97.0% target tokens are covered by the target side vocabulary."
        ]
      },
      {
        "section_name": "Our System",
        "paragraphs": [
          "For our system, the source token coverage is the same as the baselines. On the other hand, 100% target tokens are covered by the target-side vocabulary, which consists of \u201csub-stem\u201d units generated from target side stem sequence by applying BPE algorithm. There are totally 752 types of suffixes, which are calculated from the suffix sequences generated from target side sentences."
        ]
      },
      {
        "section_name": "Distributed Training",
        "paragraphs": [
          "For the experiments on the e-commerce domain, the training data is large. We use a distributed training framework for both the baseline system and our system. Training data are split into several parts, each being trained on a single worker node. A parameter server averages the model parameters from each worker node after every 100 training batchs and then synchronizes the averaged model to every worker node. Each worker continues with the training process based on the averaged model."
        ]
      },
      {
        "section_name": "Results and Analysis",
        "paragraphs": [
          "We use BLEU BIBREF26 as our evaluation metric. The performance of different systems are shown in Table TABREF34 and TABREF35 . On both the news and e-commerce domains, our system performs better than baseline systems.",
          "On news domain, the average improvement of our method is 1.75 and 0.97 BLEU score when implemented on RNN-based NMT, compared with subword BIBREF3 method and fully character-based BIBREF4 method, respectively. When implemented on Transformer BIBREF15 , average improvement is 1.47 BLEU compared with subword method. On the e-commerce domain, which use 50M sentences as training corpus, the average improvement of our method is 0.68 BLEU compared with the subword method.",
          "We evaluate stem accuracies and suffix accuracies separately. For stem, we use BLEU as evaluation metric, Table TABREF34 shows stem BLEU of different methods on \u201cNews2014\u201d test set, our method can gain significant improvement compared with baselines, since our method can reduce data sparsity better than baselines. Our method can effectively reduce suffix error, Figure FIGREF43 gives some examples both on e-commerce and news domains:",
          "For the first sample, the suffix of the translation words (tagged by 1 and 2) from two different baseline systems means a reflexive verb, whose direct object is the same as its subject. In other words, a reflexive verb has the same semantic agent and patient. It is an incorrect translation according to the source meaning, because we can infer from the source sentence that the agent is a person and the patient is an object (some goods bought by a customer). In our system, the suffix of the translation word (tagged by 3) is correct. It represents an infinitive verb which may take objects, other complements and modifiers to form a verb phrase.",
          "In the second sample, the translation word (tagged by 1) is not accurate, its suffix represents a plural form, but the correct form is singular, because the corresponding source word \u201cpositive\u201d is singular form. Character-based system can correctly translate source word \u201cstars\u201d into a Russian word with plural form. However, the translation of \u201cpositive\u201d (tagged by 2) is still with wrong form. Both the translation of \u201cpositive\u201d and \u201cstars\u201d from our system are with the correct forms.",
          "In the third sample, the translation word tagged by 3 represents past tense; However, the translation words tagged by 1 and 2 represent present tense. Our system successfully predicted the tense moods."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We proposed a simple but effective method to improve English-Russian NMT, for which a morphologically rich language is on the target side. We take a two-step approach in the decoder. At each step, a stem is first generated, then its suffix is generated. We empirically compared our method with two previous methods (namely subword and fully character-based), which can also to some extent address our problem. Our method gives an improvement on two encoder-decoder NMT architectures on two domains. To our knowledge, we are the first to explicitly model suffix for morphologically-rich target translation."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "We thank the anonymous reviewers for their detailed and constructed comments. Yue Zhang and Min Zhang are the corresponding authors. The research work is supported by the National Natural Science Foundation of China (61525205, 61432013, 61373095). Thanks for Xiaoqing Li, Heng Yu and Zhdanova Liubov for their useful discussion. "
        ]
      }
    ],
    "qas": [
      {
        "question": "what is the previous work they are comparing to?",
        "question_id": "68f1df3fb0703ff694a055d23e7ec3f6fb449b8d",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "RNN and Transformer baseline systems utilize BPE BIBREF3",
                "fully character-based baseline system, which is an implementation of BIBREF4 ( BIBREF4 )'s work"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides, since the subword method had a stable improvement compared with word based system, especially on morphologically rich languages.",
                "Besides, we compared our system with a fully character-based baseline system, which is an implementation of BIBREF4 ( BIBREF4 )'s work, and is available on github."
              ],
              "highlighted_evidence": [
                "Our RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides, since the subword method had a stable improvement compared with word based system, especially on morphologically rich languages.\n\nBesides, we compared our system with a fully character-based baseline system, which is an implementation of BIBREF4 ( BIBREF4 )'s work, and is available on github."
              ]
            },
            "annotation_id": "132f382fc3f9b9db1abc162078d50f865a62d2f8",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Subword based NMT, Character-based NMT",
              "evidence": [
                "We empirically study this method and compare it with previous work on reducing OOV rates ( BIBREF3 , BIBREF3 ; BIBREF4 , BIBREF4 ). Results show that our method gives significant improvement on the English to Russian translation task on two different domains and two popular NMT architectures. We also verify our method on training data consisting of 50M bilingual sentences, which proves that this method works effectively on large-scale corpora.",
                "Subword based BIBREF3 and character-based ( BIBREF4 , BIBREF4 ; BIBREF5 , BIBREF5 ) NMT are the two directions of adjusting translation granularity, which can be helpful to our problem."
              ],
              "highlighted_evidence": [
                "We empirically study this method and compare it with previous work on reducing OOV rates ( BIBREF3 , BIBREF3 ; BIBREF4 , BIBREF4 ). ",
                "Subword based BIBREF3 and character-based ( BIBREF4 , BIBREF4 ; BIBREF5 , BIBREF5 ) NMT are the two directions of adjusting translation granularity, which can be helpful to our problem."
              ]
            },
            "annotation_id": "85e33ebd8533d4f457f39a62a4d608ffa108890a",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides, since the subword method had a stable improvement compared with word based system, especially on morphologically rich languages."
              ],
              "highlighted_evidence": [
                "Our RNN and Transformer baseline systems utilize BPE BIBREF3 to transfer the original word sequence to subword sequence on both the source and the target sides, since the subword method had a stable improvement compared with word based system, especially on morphologically rich languages."
              ]
            },
            "annotation_id": "42ba6f4847c52b36a85a95d8b529cbd44c0e5787",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Russian word sequence to stem sequence and suffix sequence, \u201cN\u201d is a special tag used in suffix sequence, which means \u201cno suffix\u201d for corresponding stem."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: Different forms of the word \u201cball\u201d."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: Improved rnn-based NMT architecture."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Example of the e-commerce test set."
      },
      {
        "file": "5-Figure4-1.png",
        "caption": "Figure 4: Adjust the suffix sequence according to the \u201csubstem\u201d sequence."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Evaluation on the news domain: \u201cSubword\u201d refers to Sennrich, Haddow, and Birch (2015b), \u201cFully Character-based\u201d refers to Lee, Cho, and Hofmann (2016), \u201cSuffix Prediction\u201d refers to our work. Scores in brackets are BLEU of stem, which means that the output sentence and reference are both transformed into stem sequence."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Evaluation on the e-commerce domain: \u201cSubword\u201d refers to Sennrich, Haddow, and Birch (2015b), \u201cSuffix Prediction\u201d refers to our work."
      },
      {
        "file": "7-Figure5-1.png",
        "caption": "Figure 5: \u201cRNN+Subword\u201d refers to Sennrich, Haddow, and Birch (2015b), \u201cCharacter-based\u201d refers to Lee, Cho, and Hofmann (2016), \u201cRNN+Suffix\u201d refers to our work."
      }
    ]
  },
  "1910.09362": {
    "title": "Improving Word Representations: A Sub-sampled Unigram Distribution for Negative Sampling",
    "abstract": "Word2Vec is the most popular model for word representation and has been widely investigated in literature. However, its noise distribution for negative sampling is decided by empirical trials and the optimality has always been ignored. We suggest that the distribution is a sub-optimal choice, and propose to use a sub-sampled unigram distribution for better negative sampling. Our contributions include: (1) proposing the concept of semantics quantification and deriving a suitable sub-sampling rate for the proposed distribution adaptive to different training corpora; (2) demonstrating the advantages of our approach in both negative sampling and noise contrastive estimation by extensive evaluation tasks; and (3) proposing a semantics weighted model for the MSR sentence completion task, resulting in considerable improvements. Our work not only improves the quality of word vectors but also benefits current understanding of Word2Vec.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The recent decade has witnessed the great success achieved by word representation in natural language processing (NLP). It proves to be an integral part of most other NLP tasks, in which words have to be vectorized before input to the models. High quality word vectors have boosted the performance of many tasks, such as named entity recognition BIBREF0, BIBREF1, sentence completion BIBREF2, BIBREF3, part-of-speech tagging BIBREF4, BIBREF5, sentiment analysis BIBREF6, BIBREF7, and machine translation BIBREF8, BIBREF9. In a conventional way, word vectors are obtained from word-context co-occurrence matrices by either cascading the row and column vectors BIBREF10 or applying singular value decomposition (SVD) BIBREF11. However, these approaches are limited by their sub-optimal linear structure of vector space and the highly increased memory requirement when confronting huge vocabularies. Both problems have been solved by a popular model called Word2Vec BIBREF12, which utilizes two shallow neural networks, i.e., skip-gram and continuous bag-of-words, to learn word vectors from large corpora. The model is also capable of capturing interesting linear relationships between word vectors.",
          "While Word2Vec makes a breakthrough in word representation, it has not been fully understood and its theoretical exploitation is still in demand. One aspect, which has always been ignored, is the choice of noise distribution for negative sampling. Word2Vec employs a smoothed unigram distribution with a power rate of 3/4 as the noise distribution. The decision is made by empirical trials but has been widely adopted in subsequent work BIBREF13, BIBREF4, BIBREF14, BIBREF15. However, the quality of learned word vectors is sensitive to the choice of noise distribution BIBREF16, BIBREF13 when using a moderate number (5 to 15) of negative samples, which is a common strategy for the tradeoff between vector quality and computation costs.",
          "In this paper, we propose to employ a sub-sampled unigram distribution for negative sampling and demonstrate its capability of improving the linear relationships between word vectors. Our contributions include three aspects: (1) We propose the concept of semantics quantification and derive a suitable sub-sampling rate for the proposed distribution. (2) We demonstrate the advantages of our noise distribution in both negative sampling and noise contrastive estimation by extensive experiments. (3) We propose a semantics weighted model for the MSR sentence completion task, resulting in considerable improvements."
        ]
      },
      {
        "section_name": "Word2Vec ::: Architectures",
        "paragraphs": [
          "Firstly, we briefly introduce the two architectures, i.e., skip-gram (SG) and continuous bag-of-words (CBOW) in Word2Vec BIBREF12. For a corpus with a word sequence $w_{1}, w_{2}, \\cdots , w_{T}$, skip-gram predicts the context word $w_{t+j}$ given the center word $w_t$, and maximizes the average log probability,",
          "where $c$ is the size of context window, and $p(w_{t+j}|w_{t})$ is defined by the full softmax function,",
          "where $v_{w}$ and $v_{w}^{\\prime }$ are the vectors of the \u201cinput\u201d and \u201coutput\u201d words, and $|V|$ is the size of vocabulary.",
          "As for CBOW, it predicts the center word based on the context words. The input vector is usually the average of the context words' vectors, i.e., $v_{w_{I}} = \\frac{1}{2c} \\sum _{-c \\le j \\le c, j \\ne 0} v_{w_{t+j}}$."
        ]
      },
      {
        "section_name": "Word2Vec ::: Negative Sampling",
        "paragraphs": [
          "For large vocabularies, it is inefficient to compute the full softmax function in Eq. (DISPLAY_FORM3). To tackle this problem, Word2Vec utilizes negative sampling to distinguish the real output word from $k$ noise words,",
          "where $\\sigma (x) = \\frac{1}{1 + \\exp (-x)}$, and $P_n$ is the so-called noise distribution, representing the probability for a word to be sampled as a noise word. The smoothed unigram distribution used in Word2Vec is expressed as,",
          "where $f(w_i)$ is the frequency of word $w_i$."
        ]
      },
      {
        "section_name": "Word2Vec ::: Sub-sampling",
        "paragraphs": [
          "Sub-sampling is a process in Word2Vec for randomly deleting the most frequent words during training, since they are usually stop words with less information than infrequent ones. During sub-sampling, the probability that a word $w_i$ should be kept is defined as,",
          "where $\\hat{f}(w_i)$ is the normalized word frequency of $w_i$, and $t$ is called the sub-sampling rate typically between $10^{-5}$ and $10^{-3}$. The process does not delete infrequent words."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Unigram. A noise distribution is recommended to be close to the distribution of the real data in noise contrastive estimation (NCE) BIBREF16. Such guidance finds its earliest application for training language models by BIBREF17, demonstrating that the unigram distribution works better than a uniform distribution. This choice is also adopted in some other work BIBREF18, BIBREF19, BIBREF20, BIBREF21. However, the performance of models is limited due to the inadequate training of infrequent words BIBREF22, BIBREF23.",
          "Smoothed Unigram. The smoothed unigram distribution in Word2Vec BIBREF12 solves this problem because it gives more chances for infrequent words to be sampled. However, the required power rate is decided empirically, and may need adjustment for different scenarios BIBREF24, BIBREF25. BIBREF23 even propose to use a bigram distribution after studying the power rate, but it is infeasible for large corpora. Besides, the smoothed unigram distribution also changes the lexical structure of infrequent words, which could be a reason for the limited quality of word vectors."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution",
        "paragraphs": [
          "We believe a sub-sampled unigram distribution is better for negative sampling since it reduces the amount of frequent words and also maintains the lexical structure of infrequent words. To our best knowledge, we are the first to employ such a noise distribution for negative sampling. Beyond this, we propose a approach to derive the sub-sampling rate that is adaptive to different corpora (Table TABREF35)."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution ::: Critical Word",
        "paragraphs": [
          "We start our analysis by recalling the probability in Eq. (DISPLAY_FORM9) of a word to be kept during sub-sampling. Obviously, we need to choose the sub-sampling rate $t$ to decide the noise distribution. Although empirically selecting a sub-sampling rate can result in improvements (Table TABREF55), we aim to derive the sub-sampling rate adaptive to different corpora. To accomplish this, we firstly introduce a concept critical word denoted by $w_{crt}$, which is the word with $P_{keep}(w_{crt})=1$. The critical word indicates that words with frequencies lower than it will not be deleted during sub-sampling. It is uniquely decided by the sub-sampling rate. Thus, if we select the critical word with certain properties at first, we are able to obtain a suitable sub-sampling rate in return.",
          "The basic rule for us to select the critical word is to find a word with balanced semantic and syntactic information. We prefer not to delete words with relatively more semantic information. Now, the problem is how to measure these two kinds of information a word possesses."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution ::: Semantics Quantification",
        "paragraphs": [
          "In order to quantify the semantic and syntactic information of words, we consider two observations: (1) frequent words are more likely to be function words with more syntactic information; (2) infrequent words are more likely to be content words with more semantic information BIBREF26. Thus, for the $r$-th most frequent word $w$, the quantity of its semantic and syntactic information $I_{sem}^{w}$ and $I_{syn}^{w}$, can be described as,",
          "where $F_1(r)$ and $F_2(f_r)$ are monotonically increasing functions of the ranking $r$ and the frequency $f_r$, respectively. One can tell that the functions capture the properties of the observations.",
          "On the other hand, we require that the total quantity of semantic and syntactic information, denoted by $I_{tot}^{w}$ is fixed for all words, i.e.,",
          "where $\\mathrm {const}_1$ is a constant. We rewrite Eq. (DISPLAY_FORM14) into an exponential form as the following,",
          "This expression leads us to a well known power law called Zipf's law BIBREF27, which approximates the relationship between $f_r$ and $r$ as,",
          "where $\\gamma , \\beta $ are constants and $\\beta \\approx 1$. Consequently, we can decide the form of the functions $F_1(r)$ and $F_2(f_r)$ as,",
          "Obviously, the $\\log $ form functions satisfy the definition we made before. As a results, the total information becomes $\\log \\gamma $ given $\\beta \\approx 1$."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution ::: Expression of Sub-sampling Rate",
        "paragraphs": [
          "Now, given the quantified information, we are able to decide the critical word satisfying the condition",
          "Combined with Eq. (DISPLAY_FORM16), we obtain the frequency of the critical word",
          "where $r_c$ is the ranking of the critical word. Meanwhile, we know the probability of the critical word $w_{crt}$ to be kept should be exactly $P_{keep}^{t_c} (w_{crt})=1$. Thus, with Eq. (DISPLAY_FORM9) and Eq. (DISPLAY_FORM20), the sub-sampling rate for our noise distribution is expressed as",
          "Note that we use $t_c$ to distinguish from the sub-sampling rate $t$ applied for the training corpus."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution ::: Constants Estimation",
        "paragraphs": [
          "As for the estimation of constants $\\gamma $ and $\\beta $, we provide two choices:",
          "(1) wLSE-1. We use weighted least squares estimation (wLSE) to estimate the two constants. Since more data are located at higher positions in $\\log r$ axis, wLSE with a weight of $\\frac{1}{r}$ for the r-th most frequent word makes sure the trend of line can be well fit. The estimated constants are",
          "where $\\left\\langle x \\right\\rangle $ denotes the weighted average of $x$ such that $\\left\\langle x \\right\\rangle = \\sum _{r=1}^{|V|}\\frac{x}{r} / \\sum _{r=1}^{|V|}\\frac{1}{r}$.",
          "(2) wLSE-2. We use wLSE with a condition that the fitting line passes through the point $(\\log 1, \\log f_1)$. This method engages the most frequent word to further control the trend of the line. As a result, $\\hat{\\gamma }= f_1$ and",
          "Now, we can write down the expression of the sub-sampled unigram distribution",
          "where $\\alpha _i$ satisfies",
          "Note that we use $P_n^{sub}$ to distinguish from the original noise distribution $P_n$ in Word2Vec."
        ]
      },
      {
        "section_name": "Sub-sampled Unigram Distribution ::: Discussions",
        "paragraphs": [
          "In semantics quantification, the modeling of word distribution is not limited to zipf's law. We adopt it because of its popularity and conciseness. There could be other choices BIBREF28, BIBREF29, and the expression of $t_c$ needs modification accordingly. Besides, one can either use the chosen law to decide the critical word or just search through the unigram distribution to find it."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "To show the advantages of our noise distribution, we conduct experiments on three evaluation tasks. While the word analogy task BIBREF12 is our focus for testing the linear relationships between word vectors, we also evaluate the learned word vectors on the word similarity task BIBREF0 and the synonym selection task BIBREF3.",
          "In the following, we firstly describe the experimental setup including baselines, training corpora and details. Next, we report experimental results for the three NLP tasks. At last, we introduce the semantics weighted model proposed for the MSR sentence completion task BIBREF30."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Setup ::: Baselines",
        "paragraphs": [
          "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,",
          "(1) Uni$^{3/4}$. The smoothed unigram distribution proposed by BIBREF12.",
          "(2) Sub$^{L1}$. The sub-sampled uinigram distribution, of which the threshold $t_c$ is estimated by wLSE-1.",
          "(3) Sub$^{L2}$. The sub-sampled uinigram distribution, of which the threshold $t_c$ is estimated by wLSE-2."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Setup ::: Training Corpora",
        "paragraphs": [
          "Our training corpora come from four sources, described as below:",
          "(1) BWLM. The \u201cOne Billion Word Language Modeling Benchmark\u201d, which is already pre-processed and has almost 1 billion tokens.",
          "(2) Wiki10. The April 2010 snapshot of the Wikipedia corpus with a total of about 2 million articles and 1 billion tokens.",
          "(3) UMBC. The UMBC WebBase corpus from the Stanford WebBase project\u2019s February 2007 Web crawl, with over 3 billion tokens.",
          "(4) MSR. The MSR corpus containing 5 Conan Doyle Sherlock Holmes novels with about 50 million tokens.",
          "The first three large corpora are used for word similarity, synonym selection, and word analogy tasks. The MSR corpus is designated for the MSR sentence completion task. We pre-process the corpora by converting all words into lowercase and removing all the non-alphanumeric. The number of remaining tokens for each corpus is listed in the column Size of Table TABREF35. Vocabularies are built by discarding words whose occurrences are less than the threshold shown in the column Mcn. The column Vocab represents the sizes of the resulted vocabularies. The rightmost two columns are the sub-sampling rates for our noise distribution by the wLSE-1 and wLSE-2 estimations, respectively. The values are $10^6$ times of the true ones for readability."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Setup ::: Training details",
        "paragraphs": [
          "We implement the training of word vectors with the word2vec tool, in which the part of noise distribution is modified to support several choices. For SG and CBOW, we set the vector dimensionality to 100, and the size of the context window to 5. We choose 10 negative samples for each training sample in the models. The models are trained using the stochastic gradient decent (SGD) algorithm with a linear decaying learning rate with an initial value of 0.025 in SG and 0.05 in CBOW. We train the models on the three large corpora for 2 epochs, and for MSR's Holmes novels the value may vary. Results in this paper are shown in percentages and each of them is the average result of 4 repeated experiments, unless otherwise stated."
        ]
      },
      {
        "section_name": "Experiments ::: Task 1: Word Similarity Task ::: Task Description",
        "paragraphs": [
          "The task computes the correlation between the word similarity scores by human judgment and the word distances in vector space. We use Pearson correlation coefficient $\\rho _p$ as the metric, the higher of which the better the word vectors are. The expression of $\\rho _p$ is",
          "where $\\phi $ and $\\hat{\\phi }$ are random variables for the word similarity scores by human judgment and the cosine distances between word vectors, respectively. Benchmark datasets for this task include RG BIBREF31, MC BIBREF32, WS BIBREF33, MEN BIBREF34, and RW BIBREF35."
        ]
      },
      {
        "section_name": "Experiments ::: Task 1: Word Similarity Task ::: Results",
        "paragraphs": [
          "We implement the task on the mentioned 5 datasets and show the results in the column Word Similarity of Table TABREF42. At the first glance, our noise distributions Sub$^{L1}$ and Sub$^{L2}$ perform slightly better than Uni$^{3/4}$. Significant improvements can be achieved on two small datasets RG and MC, because they are more sensitive to the vector quality. Another observation is that CBOW is more affected by Sub$^{L1}$ and Sub$^{L2}$ than SG, if comparing results on RG and MC with Wiki10 corpus. These results show that our noise distributions have the potential as high as or even higher than the smoothed unigram distribution in learning good word vectors."
        ]
      },
      {
        "section_name": "Experiments ::: Task 2: Synonym Selection Task ::: Task Description",
        "paragraphs": [
          "This task attempts to select the semantically closest word, from the candidate answers, to the stem word. For example, given the stem word \u201ccostly\u201d and the candidate answers \u201cexpensive, beautiful, popular, complicated\u201d, the most similar word should be \u201cexpensive\u201d. For each candidate answer, we compute the cosine similarity score between its word vector and that of the stem word. The candidate answer with the highest score is our final answer for a question. Here we use the TOEFL dataset BIBREF36 with 80 synonym questions and the LEX dataset with 303 questions collected by ourselves."
        ]
      },
      {
        "section_name": "Experiments ::: Task 2: Synonym Selection Task ::: Results",
        "paragraphs": [
          "We report the results of this task in the Synonym Selection column of Table TABREF42. For all the noise distributions, the results are not stable on TOEFL dataset since it is quite small. Still, Sub$^{L1}$ and Sub$^{L2}$ have comparable performance with Uni$^{3/4}$. In particular, Sub$^{L1}$ makes considerable improvements with Wiki10 corpus. As for LEX dataset, Sub$^{L1}$ and Sub$^{L2}$ outperform Uni$^{3/4}$ in both SG and CBOW models with BWLM corpus. With the other two corpora, Sub$^{L2}$ performs better than Sub$^{L1}$ and Uni$^{3/4}$ using CBOW model. But again, the SG model appears to be less boosted by Sub$^{L1}$ and Sub$^{L2}$ in terms of the corresponding results. Considering the unbalanced number of questions in these two datasets, we provide the total results on TOEFL+LEX and conclude that our noise distributions are better than Uni$^{3/4}$."
        ]
      },
      {
        "section_name": "Experiments ::: Task 3: Word Analogy Task ::: Task Description",
        "paragraphs": [
          "The task comes from the idea that arithmetic operations in a word vector space can be predicted: given three words $w_a$, $w_b$, and $w_c$, the goal is to find a word $w_d$ such that the relation $w_d:w_c$ is the same as the relation $w_b:w_a$. Semantic questions are in the form of \u201cAthens:Greece is as Berlin:German\u201d and syntactic ones are like \u201cdance:dancing is as fly:flying\u201d. Here we choose the fourth word $\\hat{w}_d$ by maximizing the cosine similarity such that $\\hat{w}_d = \\operatornamewithlimits{arg\\,max}_{w\\in V} \\,\\cos \\left( v_{w_b}-v_{w_a}+v_{w_c}, v_w\\right)$ BIBREF37. We test the learned word vectors on the Google analogy dataset BIBREF12, which contains 8,869 semantic questions and 10,675 syntactic ones."
        ]
      },
      {
        "section_name": "Experiments ::: Task 3: Word Analogy Task ::: Results",
        "paragraphs": [
          "This task is our primary focus because it exposes interesting linear relationships between word vectors. Thus we conduct four sub-experiments to investigate four aspects of our noise distributions.",
          "Model Responses. The two models SG and CBOW respond differently to our noise distributions as shown in Table TABREF42. When applying CBOW model on the three corpora, our noise distributions Sub$^{L1}$ and Sub$^{L2}$ can result in significant improvements compared with Uni$^{3/4}$, especially on semantic questions. Specifically, the accuracy of semantic questions is improved by 2 to 6 points, and for syntactic questions it is 1.5 to 2 points. As for the SG model, the improvements on semantic questions by Sub$^{L1}$ and Sub$^{L2}$ are still considerable (2 to 5 points). But on syntactic questions, Uni$^{0.75}$ becomes competitive with Sub$^{L1}$ and Sub$^{L2}$ and is slightly better with BWLM and Wiki10 corpora. The reason may be that SG model is better at capturing semantic relationships between words compared with CBOW model. Still, it is safe to say that our noise distributions are better for SG in terms of the total accuracy.",
          "Number of Negative Samples. Increasing the number of negative samples does not reduce the advantages of our noise distributions necessarily. We report the results of the task using various number of negative samples in Fig. FIGREF48 (a) for CBOW and Fig. FIGREF48 (b) for SG. Note that we only train the models on Wiki10 and compare Sub$^{L2}$ with Uni$^{3/4}$. For CBOW, Sub$^{L2}$ outperforms Uni$^{3/4}$ consistently with significant margins on both semantic and syntactic questions. For SG, though the two distributions are competitive with each other on syntactic questions, Sub$^{L2}$ always performs better than Uni$^{3/4}$ on semantic ones.",
          "Optimality. Since our approach is built on assumptions and new concepts, we wonder whether the resulted $t_c$ is optimal. We select several values around $t_c$-2 and show the word analogy results in Fig. FIGREF48 (c). For CBOW, $t_c$-2 approaches the optimal point given the accuracy on semantic questions and the total dataset. For SG, the optimal point lies between $0.1\\,t_c$-2 and $t_c$-2, with negligible advantages relative to Sub$^{L2}$. Notice that the point $3.57\\,t_c$-2 corresponds to $10^{-5}$, showing much worse performance than Sub$^{L2}$. It indicates that trying a commonly used sub-sampling rate is inappropriate, and our approach is better.",
          "Scalability. We apply our noise distributions in NCE, from which negative sampling originates, to train word vectors. The implementation comes from wang2vec by BIBREF4, and we report the results of this task using CBOW. We include the unigram distribution Uni BIBREF18 and the sub-sampled unigram distribution Sub$^{1e-5}$ with a manually chosen threshold $10^{-5}$ for comparison. We draw three conclusions: (1) Uni$^{3/4}$ indeed works much better than Uni as claimed in BIBREF12; (2) Sub$^{1e-5}$ results in considerable improvements compared with Uni$^{3/4}$, especially on semantic questions; (3) Our Sub$^{L2}$ achieves the best performance consistently even with a larger vector size of 300. Note that even though Sub$^{1e-5}$ or Uni$^{3/4}$ performs better on syntactic questions with UMBC corpus, its results on semantic questions and the total dataset are much worse than Sub$^{L2}$. To this end, we believe that our approach is also scalable to the NCE related work."
        ]
      },
      {
        "section_name": "Experiments ::: Extension of Semantics Quantification ::: MSR Sentence Completion Task",
        "paragraphs": [
          "The task deals with incompletion sentences, e.g., \u201cA few faint were gleaming in a violet sky.\u201d with candidate answers \u201ctragedies, stars, rumours, noises, explanations\u201d, and aims to choose a word (e.g., \u201cstars\u201d) to best complete the sentence. Several works evaluate word vectors on this task BIBREF38, BIBREF18, BIBREF3 since it requires a combination of semantics and occasional logical reasoning. Most of them follow the same procedures of implementation described in BIBREF17. Specifically, we can calculate the probabilities that a set of words $\\mathcal {S}$ surrounding the blank to be the context of each candidate answer $w_{cd}$. Then the score of the candidate answer is the sum of these probabilities,",
          "and the highest score corresponds to the final answer for the question.",
          "Since the conventional method ignores the syntactic structure of sentences, it should be biased to semantics. Thus, we modify the method with two steps: (1) applying sub-sampling on the words in the sentences (CM$^s$); and (2) using quantified semantics as weights to form a semantics weighted model (SWM) based on (1). Then we have"
        ]
      },
      {
        "section_name": "Experiments ::: Extension of Semantics Quantification ::: Results",
        "paragraphs": [
          "The setup of models is a little different: the size of context window for SG and CBOW is 10 and 5; the number of negative samples is 20 in both models; we train SG for 5 and 10 epochs when the size of word vectors is 100 and 300, while the number of epochs is 10 and 20 in CBOW; we use all the rest words in a sentence to form $\\mathcal {S}$.",
          "Our focus here is to popularize SWM rather than to compare the noise distributions. We show the results of this task by previous word presentation models and our approach in Table TABREF60. The bottom three previous models follow the conventional method. Accordingly, we draw two conclusions: (1) sub-sampling on the words in sentences results in significant improvements to the conventional method; and (2) SWM further improves CM$^s$ and beats previous word representation models with a vector size of 300, indicating the success of semantics quantification."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "We propose to employ a sub-sampled unigram distribution for better negative sampling, and design an approach to derive the required sub-sampling rate. Experimental results show that our noise distribution captures better linear relationships between words than the baselines. It adapts to different corpora and is scalable to NCE related work. The proposed semantics weighted model also achieves a success on the MSR sentence completion task. In summary, our work not only improves the quality of word vectors, but also sheds light on the understanding of Word2Vec."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they use skip-gram word2vec?",
        "question_id": "c7f43c95db3d0c870407cd0e7becdd802463683b",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Firstly, we briefly introduce the two architectures, i.e., skip-gram (SG) and continuous bag-of-words (CBOW) in Word2Vec BIBREF12. For a corpus with a word sequence $w_{1}, w_{2}, \\cdots , w_{T}$, skip-gram predicts the context word $w_{t+j}$ given the center word $w_t$, and maximizes the average log probability,",
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,"
              ],
              "highlighted_evidence": [
                "Firstly, we briefly introduce the two architectures, i.e., skip-gram (SG) and continuous bag-of-words (CBOW) in Word2Vec BIBREF12. ",
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach"
              ]
            },
            "annotation_id": "6ed4824b13d6d27bed97ce689fcad83013171d06",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,",
                "(1) Uni$^{3/4}$. The smoothed unigram distribution proposed by BIBREF12."
              ],
              "highlighted_evidence": [
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,\n\n(1) Uni$^{3/4}$. The smoothed unigram distribution proposed by BIBREF12."
              ]
            },
            "annotation_id": "a58b94fd14b714ae45384060ad924d725048f3ed",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,"
              ],
              "highlighted_evidence": [
                "We train the two models, SG and CBOW, using the original noise distribution and other two obtained by our approach, specifically,"
              ]
            },
            "annotation_id": "d5bbaab3acb647e566d6bed937842408502ec1e9",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Illustration of the skip-gram and continuous bag-of-words (CBOW) architectures."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Illustration of a unigram distribution, the fitting line, and the sub-sampled version."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Information of the training corpora."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Results of evaluation tasks on the learned word vectors, i.e., word similarity, synonym selection, and word analogy. The sub-sampling rate for the training corpora is 10\u22124."
      },
      {
        "file": "7-Figure3-1.png",
        "caption": "Figure 3: Word analogy results (a) and (b) for number of negative samples and (c) for optimality. Smoothed and wLSE-2 represent Uni3/4 and SubL2, tc-2 means the sub-sampling rate of SubL2."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: The results of word analogy task using NCE for the training of word vectors. Each entry is the average result of 2 repeated experiments."
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: The results of MSR sentence completion task by previous word representation models and our approach."
      }
    ]
  },
  "1911.12559": {
    "title": "KPTimes: A Large-Scale Dataset for Keyphrase Generation on News Documents",
    "abstract": "Keyphrase generation is the task of predicting a set of lexical units that conveys the main content of a source text. Existing datasets for keyphrase generation are only readily available for the scholarly domain and include non-expert annotations. In this paper we present KPTimes, a large-scale dataset of news texts paired with editor-curated keyphrases. Exploring the dataset, we show how editors tag documents , and how their annotations differ from those found in existing datasets. We also train and evaluate state-of-the-art neural keyphrase generation models on KPTimes to gain insights on how well they perform on the news domain. The dataset is available online at https:// github.com/ygorg/KPTimes.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Keyphrases are single or multi-word lexical units that best summarise a document BIBREF0. As such, they are of great importance for indexing, categorising and browsing digital libraries BIBREF1. Yet, very few documents have keyphrases assigned, thus raising the need for automatic keyphrase generation systems. This task falls under the task of automatic keyphrase extraction which can also be the subtask of finding keyphrases that only appear in the input document. Generating keyphrases can be seen as a particular instantiation of text summarization, where the goal is not to produce a well-formed piece of text, but a coherent set of phrases that convey the most salient information. Those phrases may or may not appear in the document, the latter requiring some form of abstraction to be generated. State-of-the-art systems for this task rely on recurrent neural networks BIBREF2, BIBREF3, BIBREF4, and hence require large amounts of annotated training data to achieve good performance. As gold annotated data is expensive and difficult to obtain BIBREF5, previous works focused on readily available scientific abstracts and used author-assigned keyphrases as a proxy for expert annotations. However, this poses two major issues: 1) neural models for keyphrase generation do not generalize well across domains, thus limiting their use in practice; 2) author-assigned keyphrases exhibit strong consistency issues that negatively impacts the model's performance. There is therefore a great need for annotated data from different sources, that is both sufficiently large to support the training of neural-based models and that comprises gold-standard labels provided by experts. In this study, we address this need by providing KPTimes, a dataset made of 279 923 news articles that comes with editor-assigned keyphrases.",
          "Online news are particularly relevant to keyphrase generation since they are a natural fit for faceted navigation BIBREF6 or topic detection and tracking BIBREF7. Also, and not less importantly, they are available in large quantities and are sometimes accompanied by metadata containing human-assigned keyphrases initially intended for search engines. Here, we divert these annotations from their primary purpose, and use them as gold-standard labels to automatically build our dataset. More precisely, we collect data by crawling selected news websites and use heuristics to draw texts paired with gold keyphrases. We then explore the resulting dataset to better understand how editors tag documents, and how these expert annotations differ from author-assigned keyphrases found in scholarly documents. Finally, we analyse the performance of state-of-the-art keyphrase generation models and investigate their transferability to the news domain and the impact of domain shift."
        ]
      },
      {
        "section_name": "Existing datasets",
        "paragraphs": [
          "Frequently used datasets for keyphrase generation have a common characteristic that they are, by and large, made from scholarly documents (abstracts or full texts) paired with non-expert (mostly from authors) annotations. Notable examples of such datasets are SemEval-2010 BIBREF8 and KP20k BIBREF2, which respectively comprises scientific articles and paper abstracts, both about computer science and information technology. Detailed statistics are listed in Table . Only two publicly available datasets, that we are aware of, contain news documents: DUC-2001 BIBREF9 and KPCrowd BIBREF10. Originally created for the DUC evaluation campaign on text summarization BIBREF11, the former is composed of 308 news annotated by graduate students. The latter includes 500 news annotated by crowdsourcing. Both datasets are very small and contain newswire articles from various online sources labelled by non-expert annotators, in this case readers, which is not without issues.",
          "Thus, unlike author annotations, those produced by readers exhibit significantly lower missing keyphrases, that is, gold keyphrases that do not occur in the content of the document. In the DUC-2001 dataset for example, more than 96% of the gold keyphrases actually appear in the documents. This confirms previous observations that readers tend to assign keyphrases in an extractive fashion BIBREF12, which makes these datasets less suitable for the task at hand (keyphrase generation) but rather relevant for a purely extractive task (keyphrase extraction). Yet, author-assigned keyphrases commonly found in scientific paper datasets are not perfect either, as they are less constrained BIBREF13 and include seldom-used variants or misspellings that negatively impact performance. One can see there is an apparent lack of sizeable expert-annotated data that enables the development of neural keyphrase generation models in a domain other than scholarly texts. Here, we fill this gap and propose a large-scale dataset that includes news texts paired with manually curated gold standard annotations."
        ]
      },
      {
        "section_name": "Building the KPTimes dataset",
        "paragraphs": [
          "To create the KPTimes dataset, we collected over half a million newswire articles by crawling selected online news websites. We applied heuristics to identify the content (title, headline and body) of each article and regarded the keyphrases provided in the HTML metadata as the gold standard. A cherry-picked sample document is showcased in Figure , it allows to show present and absent keyphrases, as well as keyphrase variants (in this example News media and journalism).",
          "We use the New York Times as our primary source of data, since the content tagging policy that it applies is rigorous and well-documented. The news articles are annotated in a semi-automatic way, first the editors revise a set of tags proposed by an algorithm. They then provide additional tags which will be used by a taxonomy team to improve the algorithm.",
          "We first retrieved the URLs of the free-to-read articles from 2006 to 2017, and collected the corresponding archived HTML pages using the Internet Archive. Doing so allows the distribution of our dataset using a thin, URL-only list. We then extracted the HTML body content using beautifulsoup and devised heuristics to extract the main content and title of each article while excluding extraneous HTML markup and inline ads. Gold standard keyphrases are obtained from the metadata (field types news_keywords and keywords) available in the HTML page of each article. Surface form variants of gold keyphrases (e.g. \u201cAIDS; HIV\u201d, \u201cDriverless Cars; Self-Driving Cars\u201d or \u201cFatalities; Casualties\u201d), which are sometimes present in the metadata, are kept to be used for evaluation purposes.",
          "We further cleansed and filtered the dataset by removing duplicates, articles without content and those with too few (less than 2) or too many (more than 10) keyphrases. This process resulted in a set of 279 923 article-keyphrase pairs. We randomly divided this dataset into training (92.8%), development (3.6%) and test (3.6%) splits.",
          "Restricting ourselves to one source of data ensures the uniformity and consistency of annotation that is missing in the other datasets, but it may also make the trained model source-dependent and harm generalization. To monitor the model's ability to generalize, we gather a secondary source of data. We collected HTML pages from the Japan Times and processed them the same way as described above. 10K more news articles were gathered as the JPTimes dataset.",
          "Although in this study we concentrate only on the textual content of the news articles, it is worth noting that the HTML pages also provide additional information that can be helpful in generating keyphrases such as text style properties (e.g. bold, italic), links to related articles, or news categorization (e.g. politics, science, technology)."
        ]
      },
      {
        "section_name": "Data analysis",
        "paragraphs": [
          "We explored the KPTimes dataset to better understand how it stands out from the existing ones. First, we looked at how editors tag news articles. Figure illustrates the difference between the annotation behaviour of readers, authors and editors through the number of times that each unique keyphrase is used in the gold standard. We see that non-expert annotators use a larger, less controlled indexing vocabulary, in part because they lack the higher level of domain expertise that editors have. For example, we observe that frequent keyphrases in KPTimes are close to topic descriptors (e.g. \u201cBaseball\u201c, \u201cPolitics and Government\u201c) while those appearing only once are very precise (e.g. \u201cMarley's Cafe\u201c, \u201cCatherine E. Connelly\u201c). Annotations in KPTimes are arguably more uniform and consistent, through the use of tag suggestions, which, as we will soon discuss in \u00a7SECREF12, makes it easier for supervised approaches to learn a good model.",
          "Next, we further looked at the characteristics of the gold keyphrases in KPTimes. Table shows that the number of gold keyphrases per document is similar to the one observed for KP20k while the number of missing keyphrases is higher. This indicates that editors are more likely to generalize and assign keyphrases that do not occur in the document ($\\approx 55\\%$). It is therefore this ability to generalize that models should mimic in order to perform well on KPTimes. We also note that keyphrases are on average shorter in news datasets ($1.5$ words) than those in scientific paper datasets ($2.4$ words). This may be due to the abundant use of longer, more specific phrases in scholarly documents BIBREF14.",
          "Variants of keyphrases recovered from the metadata occur in 8% of the documents and represent 810 sets of variants in the KPTimes test split. These variants often refer to the same concept (e.g. \u201cMarijuana; Pot; Weed\u201c), but can sometimes be simply semantically related (e.g. \u201cBridges; Tunnels\u201c). Thereafter, keyphrase variants will be used during model evaluation for reducing the number of mismatches associated with commonly used lexical overlap metrics."
        ]
      },
      {
        "section_name": "Performance of existing models",
        "paragraphs": [
          "We train and evaluate several keyphrase generation models to understand the challenges of KPTimes and its usefulness for training models."
        ]
      },
      {
        "section_name": "Performance of existing models ::: Evaluation metrics",
        "paragraphs": [
          "We follow the common practice and evaluate the performance of each model in terms of f-measure (F$_1$) at the top $N=10$ keyphrases, and apply stemming to reduce the number of mismatches. We also report the Mean Average Precision (MAP) scores of the ranked lists of keyphrases."
        ]
      },
      {
        "section_name": "Performance of existing models ::: Models ::: Baseline: FirstPhrase",
        "paragraphs": [
          "Position is a strong feature for keyphrase extraction, simply because texts are usually written so that the most important ideas go first BIBREF15. In news summarization for example, the lead baseline \u2013that is, the first sentences from the document\u2013, while incredibly simple, is still a competitive baseline BIBREF16. Similar to the lead baseline, we compute the FirstPhrases baseline that extracts the first $N$ keyphrase candidates from a document."
        ]
      },
      {
        "section_name": "Performance of existing models ::: Models ::: Baseline, unsupervised: MultipartiteRank",
        "paragraphs": [
          "The second baseline we consider, MultipartiteRank BIBREF17, represents the state-of-the-art in unsupervised graph-based keyphrase extraction. It relies on a multipartite graph representation to enforce topical diversity while ranking keyphrase candidates. Just as FirstPhrases, this model is bound to the content of the document and cannot generate missing keyphrases. We use the implementation of MultipartiteRank available in pke BIBREF18."
        ]
      },
      {
        "section_name": "Performance of existing models ::: Models ::: State-of-the-art, supervised: CopyRNN",
        "paragraphs": [
          "The generative neural model we include in this study is CopyRNN BIBREF2, an encoder-decoder model that incorporates a copying mechanism BIBREF19 in order to be able to generate phrases that rarely occur. When properly trained, this model was shown to be very effective in extracting keyphrases from scientific abstracts. CopyRNN has been further extended by BIBREF3 to include correlation constraints among keyphrases which we do not include here as it yields comparable results.",
          "Two models were trained to bring evidence on the necessity to have datasets from multiple domains. CopySci was trained using scientific abstracts (KP20k) and CopyNews using newspaper articles (KPTimes), the two models use the same architecture."
        ]
      },
      {
        "section_name": "Performance of existing models ::: Results",
        "paragraphs": [
          "Model performances for each dataset are reported in Table . Extractive baselines show the best results for KPCrowd and DUC-2001 which is not surprising given that these datasets exhibit the lowest ratio of absent keyphrases. Neural-based models obtain the greatest performance, but only for the dataset on which they were trained. We therefore see that these models do not generalize well across domains, confirming previous preliminary findings BIBREF2 and exacerbating the need for further research on this topic. Interestingly, CopyNews outperforms the other models on JPTimes and achieves very low scores for KPCrowd and DUC-2001, although all these datasets are from the same domain. This emphasizes the differences that exist between the reader- and editor-assigned gold standard. The score difference may be explained by the ratio of absent keyphrases that differs greatly between the reader-annotated datasets and JPTimes (see Table ), and thus question the use of these rather extractive datasets for evaluating keyphrase generation.",
          "Finally, we note that the performance of CopyNews on KPTimes is significantly higher than that of CopySci on KP20k, proving that a more uniform and consistent annotation makes it easier to learn a good model."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper we presented KPTimes, a large-scale dataset of newswire articles to train and test deep learning models for keyphrase generation. The dataset and the code are available at https://github.com/ygorg/KPTimes. Large datasets have driven rapid improvement in other natural language generation tasks, such as machine translation or summarization. We hope that KPTimes will play this role and help the community in devising more robust and generalizable neural keyphrase generation models."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they report results only on English data?",
        "question_id": "bc7081aaa207de2362e0bea7bc8108d338aee36f",
        "nlp_background": "five",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "7a9f96067e761e6fb86486d2548e824f56d6d47d",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Restricting ourselves to one source of data ensures the uniformity and consistency of annotation that is missing in the other datasets, but it may also make the trained model source-dependent and harm generalization. To monitor the model's ability to generalize, we gather a secondary source of data. We collected HTML pages from the Japan Times and processed them the same way as described above. 10K more news articles were gathered as the JPTimes dataset."
              ],
              "highlighted_evidence": [
                " To monitor the model's ability to generalize, we gather a secondary source of data. We collected HTML pages from the Japan Times and processed them the same way as described above. 10K more news articles were gathered as the JPTimes dataset."
              ]
            },
            "annotation_id": "9554b4081d9bc1bd2bd8c4a40871460041a9249a",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We use the New York Times as our primary source of data, since the content tagging policy that it applies is rigorous and well-documented. The news articles are annotated in a semi-automatic way, first the editors revise a set of tags proposed by an algorithm. They then provide additional tags which will be used by a taxonomy team to improve the algorithm.",
                "We first retrieved the URLs of the free-to-read articles from 2006 to 2017, and collected the corresponding archived HTML pages using the Internet Archive. Doing so allows the distribution of our dataset using a thin, URL-only list. We then extracted the HTML body content using beautifulsoup and devised heuristics to extract the main content and title of each article while excluding extraneous HTML markup and inline ads. Gold standard keyphrases are obtained from the metadata (field types news_keywords and keywords) available in the HTML page of each article. Surface form variants of gold keyphrases (e.g. \u201cAIDS; HIV\u201d, \u201cDriverless Cars; Self-Driving Cars\u201d or \u201cFatalities; Casualties\u201d), which are sometimes present in the metadata, are kept to be used for evaluation purposes.",
                "Restricting ourselves to one source of data ensures the uniformity and consistency of annotation that is missing in the other datasets, but it may also make the trained model source-dependent and harm generalization. To monitor the model's ability to generalize, we gather a secondary source of data. We collected HTML pages from the Japan Times and processed them the same way as described above. 10K more news articles were gathered as the JPTimes dataset.",
                "Although in this study we concentrate only on the textual content of the news articles, it is worth noting that the HTML pages also provide additional information that can be helpful in generating keyphrases such as text style properties (e.g. bold, italic), links to related articles, or news categorization (e.g. politics, science, technology)."
              ],
              "highlighted_evidence": [
                "We use the New York Times as our primary source of data, since the content tagging policy that it applies is rigorous and well-documented.",
                "Gold standard keyphrases are obtained from the metadata (field types news_keywords and keywords) available in the HTML page of each article. Surface form variants of gold keyphrases (e.g. \u201cAIDS; HIV\u201d, \u201cDriverless Cars; Self-Driving Cars\u201d or \u201cFatalities; Casualties\u201d), which are sometimes present in the metadata, are kept to be used for evaluation purposes.",
                "To monitor the model's ability to generalize, we gather a secondary source of data. We collected HTML pages from the Japan Times and processed them the same way as described above. 10K more news articles were gathered as the JPTimes dataset.\n\nAlthough in this study we concentrate only on the textual content of the news articles, it is worth noting that the HTML pages also provide additional information that can be helpful in generating keyphrases such as text style properties (e.g. bold, italic), links to related articles, or news categorization (e.g. politics, science, technology)."
              ]
            },
            "annotation_id": "afc445ffbcc140a3be00b45d65b2e06da4042b3e",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Statistics of available datasets for keyphrase generation. Gold annotation is performed by authors (A), readers (R) or editors (E). The number of documents in the training (#Train), validation (dev) and testing (#Test) splits are shown. The average number of keyphrases (#kp) and words (#words) per document, the average length of keyphrases (len kp) and the ratio of keyphrases in the reference that do not appear in the document (%abs) are computed on the test set."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Distributions of gold keyphrase assignments."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Performance on benchmark datasets composed of newspaper article, full scientific article and scientific article abstract. The generation models CopySci and CopyNews were trained respectively on KP20k and KPTimes. The dataset presented in this work are written in italic."
      }
    ]
  },
  "1802.09059": {
    "title": "One Single Deep Bidirectional LSTM Network for Word Sense Disambiguation of Text Data",
    "abstract": "Due to recent technical and scientific advances, we have a wealth of information hidden in unstructured text data such as offline/online narratives, research articles, and clinical reports. To mine these data properly, attributable to their innate ambiguity, a Word Sense Disambiguation (WSD) algorithm can avoid numbers of difficulties in Natural Language Processing (NLP) pipeline. However, considering a large number of ambiguous words in one language or technical domain, we may encounter limiting constraints for proper deployment of existing WSD models. This paper attempts to address the problem of one-classifier-per-one-word WSD algorithms by proposing a single Bidirectional Long Short-Term Memory (BLSTM) network which by considering senses and context sequences works on all ambiguous words collectively. Evaluated on SensEval-3 benchmark, we show the result of our model is comparable with top-performing WSD algorithms. We also discuss how applying additional modifications alleviates the model fault and the need for more training data.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Word Sense Disambiguation (WSD) is an important problem in Natural Language Processing (NLP), both in its own right and as a stepping stone to other advanced tasks in the NLP pipeline, applications such as machine translation BIBREF0 and question answering BIBREF1 . WSD specifically deals with identifying the correct sense of a word, among a set of given candidate senses for that word, when it is presented in a brief narrative (surrounding text) which is generally referred to as context. Consider the ambiguous word `cold'. In the sentence \u201cHe started to give me a cold shoulder after that experiment\u201d, the possible senses for cold can be cold temperature (S1), a cold sensation (S2), common cold (S3), or a negative emotional reaction (S4). Therefore, the ambiguous word cold is specified along with the sense set {S1, S2, S3, S4} and our goal is to identify the correct sense S4 (as the closest meaning) for this specific occurrence of cold after considering - the semantic and the syntactic information of - its context.",
          "In this effort, we develop our supervised WSD model that leverages a Bidirectional Long Short-Term Memory (BLSTM) network. This network works with neural sense vectors (i.e. sense embeddings), which are learned during model training, and employs neural word vectors (i.e. word embeddings), which are learned through an unsupervised deep learning approach called GloVe (Global Vectors for word representation) BIBREF2 for the context words. By evaluating our one-model-fits-all WSD network over the public gold standard dataset of SensEval-3 BIBREF3 , we demonstrate that the accuracy of our model in terms of F-measure is comparable with the state-of-the-art WSD algorithms'.",
          "We outline the organization of the rest of the paper as follows. In Section 2, we briefly explore earlier efforts in WSD and discuss recent approaches that incorporate deep neural networks and word embeddings. Our main model that employs BLSTM with the sense and word embeddings is detailed in Section 3. We then present our experiments and results in Section 4 supported by a discussion on how to avoid some drawbacks of the current model in order to achieve higher accuracies and demand less number of training data which is desirable. Finally, in Section 5, we conclude with some future research directions for the construction of sense embeddings as well as applications of such model in other domains such as biomedicine."
        ]
      },
      {
        "section_name": "Background and Related Work",
        "paragraphs": [
          "Generally, there are three categories of WSD algorithms: supervised, knowledge-based, and unsupervised. Supervised algorithms consist of automatically inducing classification models or rules from labeled examples BIBREF4 . Knowledge-based WSD approaches are dependent on manually created lexical resources such as WordNet BIBREF5 and the Unified Medical Language System (UMLS) BIBREF6 . Unsupervised algorithms may employ topic modeling-based methods to disambiguate when the senses are known ahead of time BIBREF7 . For a thorough survey of WSD algorithms refer to Navigli BIBREF8 ."
        ]
      },
      {
        "section_name": "Neural Embeddings for WSD",
        "paragraphs": [
          "In the past few years, there has been an increasing interest in training neural word embeddings from large unlabeled corpora using neural networks BIBREF9 BIBREF10 . Word embeddings are typically represented as a dense real-valued low dimensional matrix INLINEFORM0 (i.e. a lookup table) of size INLINEFORM1 , where INLINEFORM2 is the predefined embedding dimension and INLINEFORM3 is the vocabulary size. Each column of the matrix is an embedding vector associated with a word in the vocabulary and each row of the matrix represents a latent feature. These vectors can subsequently be used to initialize the input layer of a neural network or some other NLP model. GloVe BIBREF2 is one of the existing unsupervised learning algorithms for obtaining these vector representations of the words in which training is performed on aggregated global word-word co-occurrence statistics from a corpus.",
          "Besides word embeddings, recently, computation of sense embeddings has gained the attention of numerous studies as well. For example, Chen et al. BIBREF11 adapted neural word embeddings to compute different sense embeddings (of the same word) and showed competitive performance on the SemEval-2007 data BIBREF12 ."
        ]
      },
      {
        "section_name": "Bidirectional LSTM",
        "paragraphs": [
          "Long Short-Term Memory (LSTM), introduced by Hochreiter and Schmidhuber (1997) BIBREF13 , is a gated recurrent neural network (RNN) architecture that has been designed to address the vanishing and exploding gradient problems of conventional RNNs. Unlike feedforward neural networks, RNNs have cyclic connections making them powerful for modeling sequences. A Bidirectional LSTM is made up of two reversed unidirectional LSTMs BIBREF14 . For WSD this means we are able to encode information of both preceding and succeeding words within context of an ambiguous word, which is necessary to correctly classify its sense."
        ]
      },
      {
        "section_name": "One Single BLSTM network for WSD",
        "paragraphs": [
          "Given a document and the position of a target word, our model computes a probability distribution over possible senses related to that word. The architecture of our model, depicted in Fig. FIGREF4 , consist of 6 layers which are a sigmoid layer (at the top), a fully-connected layer, a concatenation layer, a BLSTM layer, a cosine layer, and a sense and word embeddings layer (on the bottom).",
          "In contrast to other supervised neural WSD networks in which generally a softmax layer - with a cross entropy or hinge loss - is parameterized by the context words and selects the corresponding weight matrix and bias vector for each ambiguous word's senses BIBREF15 BIBREF16 , our network shares parameters over all words' senses. While remaining computationally efficient, this structure aims to encode statistical information across different words enabling the network to select the true sense (or even a proper word) in a blank space within a context.",
          "Due to the replacement of their softmax layers with a sigmoid layer in our network, we need to impose a modification in the input of the model. For this purpose, not only the contextual features are going to make the input of the network, but also, the sense for which we are interested to find out whether that given context makes sense or not (no pun intended) would be provided to the network. Next, the context words would be transferred to a sequence of word embeddings while the sense would be represented as a sense embedding (the shaded embeddings in Fig. FIGREF4 ). For a set of candidate senses (i.e. INLINEFORM0 ) for an ambiguous term, after computing cosine similarities of each sense embedding with the word embeddings of the context words, we expect the sequence result of similarities between the true sense and the surrounding context communicate a pattern-like information that can be encoded through our BLSTM network; for the incorrect senses this premise does not hold. Several WSD studies already incorporated the idea of sense-context cosine similarities in their models BIBREF17 BIBREF18 ."
        ]
      },
      {
        "section_name": "Model Definition",
        "paragraphs": [
          "For one instance (or one document), the input of the network consists of a sense and a list of context words (left and right) which paired together form a list of context components. For the context D which encompasses the ambiguous term INLINEFORM0 , that takes the set of predefined candidate senses INLINEFORM1 , the input for the sense INLINEFORM2 for which we are interested in to find out whether the context is a proper match will be determined by Eq. ( EQREF6 ). Then, this input is copied (next) to INLINEFORM3 positions of the context to form the first pair of the context components. DISPLAYFORM0 ",
          " Here, INLINEFORM0 is the one-hot representation of the sense corresponding to INLINEFORM1 . A one-hot representation is a vector with dimension INLINEFORM2 consisting of INLINEFORM3 zeros and a single one which index indicates the sense. The INLINEFORM4 size is equal to the number of all senses in the language (or the domain of interest). Eq. ( EQREF6 ) will have the effect of picking the column (i.e. sense embeddings) from INLINEFORM5 corresponding to that sense. The INLINEFORM6 (stored in the sense embeddings lookup table) is initialized randomly since no sense embedding is computed a priori.",
          "Regarding the context words inputs that form the second pairs of context components, at position m in the same context D the input is determined by: DISPLAYFORM0 ",
          " Here, INLINEFORM0 is the one-hot representation of the word corresponding to INLINEFORM1 . Similar to a sense one-hot representation ( INLINEFORM2 ), this one-hot representation is a vector with dimension INLINEFORM3 consisting of INLINEFORM4 zeros and a single one which index indicates the word in the context. The INLINEFORM5 size is equal to the number of words in the language (or the domain of interest). Eq. ( EQREF7 ) will choose the column (i.e. word embeddings) from INLINEFORM6 corresponding to that word. The INLINEFORM7 (stored in the word embeddings lookup table) can be initialized using pre-trained word embeddings; in this work, GloVe vectors are used.",
          "On the other hand, the output of the network that is examining sense INLINEFORM0 is DISPLAYFORM0 ",
          " where INLINEFORM0 and INLINEFORM1 are the weights and the bias of the classification layer (sigmoid), and INLINEFORM2 is the result of the merge layer (concatenation).",
          "When we train the network, for an instance with the correct sense and the given context as inputs, INLINEFORM0 is set to be 1.0, and for incorrect senses they are set to be 0.0. During testing, however, among all the senses, the output of the network for a sense that gives the highest value of INLINEFORM1 will be considered as the true sense of the ambiguous term, in other words, the correct sense would be: DISPLAYFORM0 ",
          " By applying softmax to the result of estimated classification values, INLINEFORM0 , we can show them as probabilities; this facilitates interpretation of the results.",
          "Further, the hidden layer INLINEFORM0 is computed as DISPLAYFORM0 ",
          " where INLINEFORM0 means rectified linear unit; INLINEFORM1 is the concatenated outputs of the right and left traversing LSTMs of the BLSTM when the last context components are met. INLINEFORM2 and INLINEFORM3 are the weights and bias for the hidden layer."
        ]
      },
      {
        "section_name": "Validation for Selection of Hyper-parameters",
        "paragraphs": [
          "SensEval-3 data BIBREF3 on which the network is evaluated, consist of separate training and test samples. In order to find hyper-parameters of the network 5% of the training samples were used for the validation in advance. Once the hyper-parameters are selected, the whole network is trained on all training samples prior to testing. As to the loss function employed for the network, even though is it common to use (binary) cross entropy loss function when the last unit is a sigmoidal classification, we observed that mean square error led to better results for the final argmax classification (Eq. ( EQREF9 )) that we used. Regarding parameter optimization, RMSprop BIBREF19 is employed. Also, all weights including embeddings are updated during training."
        ]
      },
      {
        "section_name": "Dropout and Dropword",
        "paragraphs": [
          "Dropout BIBREF20 is a regularization technique for neural network models where randomly selected neurons are ignored during training. This means that their contribution to the activation of downstream neurons is temporally removed on the forward pass, and any weight updates are not applied to the neuron on the backward pass. The effect is that the network becomes less sensitive to the specific weights of neurons, resulting in better generalization, and a network that is less likely to overfit the training data. In our network, dropout is applied to the embeddings as well as the outputs of the merge and fully-connected layers.",
          "Following the dropout logic, dropword BIBREF21 is the word level generalizations of it, but in word dropout the word is set to zero while in dropword it is replaced with a specific tag. The tag is subsequently treated just like one word in the vocabulary. The motivation for doing dropword and word dropout is to decrease the dependency on individual words in the training context. Since by replacing word dropout with dropword we observed no change in the results, only word dropout was applied to the sequence of context words during training."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "In SensEval-3 data (lexical sample task), the sense inventory used for nouns and adjectives is WordNet 1.7.1 BIBREF5 whereas verbs are annotated with senses from Wordsmyth. Table TABREF15 presents the number of words under each part of speech, and the average number of senses for each class.",
          "As stated, training and test data are supplied as the instances of this task; and the task consist of disambiguating one indicated word within a context."
        ]
      },
      {
        "section_name": "Experimental Settings",
        "paragraphs": [
          "The hyper-parameters that were determined during the validation is presented in Table TABREF17 . The preprocessing of the data was conducted by lower-casing all the words in the documents and removing numbers. This results in a vocabulary size of INLINEFORM0 = 29044. Words not present in the training set are considered unknown during testing. Also, in order to have fixed-size contexts around the ambiguous words, the padding and truncating are applied to them whenever needed."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Between-all-models comparisons - When SensEval-3 task was launched 47 submissions (supervised and unsupervised algorithms) were received addressing this task. Afterward, some other papers tried to work on this data and reported their results in separate articles as well. We compare the result of our model with the top-performing and low-performing algorithms (supervised). We show our single model sits among the 5 top-performing algorithms, considering that in other algorithms for each ambiguous word one separate classifier is trained (i.e. in the same number of ambiguous words in a language there have to be classifiers; which means 57 classifiers for this specific task). Table TABREF19 shows the results of the top-performing and low-performing supervised algorithms.",
          "The first two algorithms represent the state-of-the-art models of supervised WSD when evaluated on SensEval-3. Multi-classifier BLSTM BIBREF15 consists of deep neural networks which make use of pre-trained word embeddings. While the lower layers of these networks are shared, upper layers of each network are responsible to individually classify the ambiguous that word the network is associated with. IMS+adapted CW BIBREF16 is another WSD model that considers deep neural networks and also uses pre-trained word embeddings as inputs. In contrast to Multi-classifier BLSTM, this model relies on features such as POS tags, collocations, and surrounding words to achieve their result. For these two models, softmax constitutes the output layers of all networks. htsa3 BIBREF22 was the winner of the SensEval-3 lexical sample. It is a Naive Bayes system applied mainly to raw words, lemmas, and POS tags with correction of the a-priori frequencies. IRST-Kernels BIBREF23 utilizes kernel methods for pattern abstraction, paradigmatic and syntagmatic information and unsupervised term proximity on British National Corpus (BNC), in SVM classifiers. Likewise, nusels BIBREF24 makes use of SVM classifiers with a combination of knowledge sources (part-of-speech of neighboring words, words in context, local collocations, syntactic relations. The second part of the table lists the low-performing supervised algorithms BIBREF3 . Considering their ranking scores we see that there are unsupervised methods that outperform these supervised algorithms.",
          "",
          "Within-our-model comparisons - Besides several internal experiments to examine the importance of some hyper-parameters to our network, we investigated if the sequential follow of cosine similarities computed between a true sense and its preceding and succeeding context words carries a pattern-like information that can be encoded with BLSTM. Table TABREF20 presents the results of these experiments.",
          "The first row shows the best result of the network that we described above (and depicted in Fig. FIGREF4 ). Each of the other rows shows one change that we applied to the network to see the behavior of the network in terms of F-measure. In the middle part, we are specifically concerned about the importance of the presence of a BLSTM layer in our network. So, we introduced some fundamental changes in the input or in the structure of the network. Generally, it is expected that the cosine similarities of closer words (in the context) to the true sense be larger than the incorrect senses' BIBREF17 ; however, if a series of cosine similarities can be encoded through an LSTM (or BLSTM) network should be experimented. We observe if reverse the sequential follow of information into our Bidirectional LSTM, we shuffle the order of the context words, or even replace our Bidirectional LSTMs with two different fully-connected networks of the same size 50 (the size of the LSTMs outputs), the achieved results were notably less than 72.5%.",
          "In the third section of the table, we report our changes to the hyper-parameters. Specifically, we see the importance of using GloVe as pre-trained word embeddings, how word dropout improves generalization, and how context size plays an important role in the final classification result (showing one of our experiments)."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "From the results of Table TABREF19 , we notice our single WSD network, despite eliminating the problem of having a large number of WSD classifiers, still falls short when is compared with the state-of-the-art WSD algorithms. Based on our intuition and supported by some of our preliminary experiments, this deficiency stems from an important factor in our BLSTM network. Since no sense embedding is made publicly available for use, the sense embeddings are initialized randomly; yet, word embeddings are initialized by pre-trained GloVe vectors in order to benefit from the semantic and syntactic properties of the context words conveyed by these embeddings. That is to say, the separate spaces that the sense embeddings and the (context) word embeddings come from enforces some delay for the alignment of these spaces which in turn demands more training data. Furthermore, this early misalignment does not allow the BLSTM fully take advantage of larger context sizes which can be helpful. Our first attempt to deal with such problem was to pre-train the sense embeddings by some techniques - such as taking the average of the GloVe embeddings of the (informative) definition content words of senses, or taking the average of the GloVe embeddings of the (informative) context words in their training samples - did not give us a better result than our random initialization. Our preliminary experiments though in which we replaced all GloVe embeddings in the network with sense embeddings (using a method proposed by Chen et al. BIBREF11 ), showed considerable improvements in the results of some ambiguous words. That means both senses and context words (while they can be ambiguous by themselves) come from one vector space. In other words, the context would also be represented by the possible senses that its words can take. This idea not only can help to improve the results of the current model, it can also avoid the need for a large amount of training data since senses can be seen in both places, center and context, to be trained."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In contrast to common one-classifier-per-each-word supervised WSD algorithms, we developed our single network of BLSTM that is able to effectively exploit word orders and achieve comparable results with the best-performing supervised algorithms. This single WSD BLSTM network is language and domain independent and can be applied to resource-poor languages (or domains) as well. As an ongoing project, we also provided a direction which can lead us to the improvement of the results of the current network using pre-trained sense embeddings.",
          "For future work, besides following the discussed direction in order to resolve the inadequacy of the network regarding having two non-overlapping vector spaces of the embeddings, we plan to examine the network on technical domains such as biomedicine as well. In this case, our model will be evaluated on MSH WSD dataset prepared by National Library of Medicine (NLM). Also, construction of sense embeddings using (extended) definitions of senses BIBREF25 BIBREF26 can be tested. Moreover, considering that for many senses we have at least one (lexically) unambiguous word representing that sense, we also aim to experiment with unsupervised (pre-)training of our network which benefits form quarry management by which more training data will be automatically collected from the web."
        ]
      }
    ],
    "qas": [
      {
        "question": "How long is their dataset?",
        "question_id": "b1d255f181b18f7cf8eb3dd2369a082a2a398b7b",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "13a6f0b3e659250e1116dfba4ee9bb5eea5c94f0",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "2ce0fa85b0401b3197e81f18376a0e1a6abb1d50",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "b54b5ec8e3c5c8af5f6b32ab51557eeab43f3838",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "7-Table1-1.png",
        "caption": "Table 1: Summary of senses in SensEval-3"
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Hyper-parameter used for the experiments and the ranges that were searched during tuning. \u2018-\u2019 indicates no tuning was performed on that parameter."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: F-measure results for SensEval-3 (English lexical samples)"
      },
      {
        "file": "9-Table4-1.png",
        "caption": "Table 4: WSD single-classifier BLSTM with other pieces or hyper-parameters"
      }
    ]
  },
  "1909.06708": {
    "title": "Hint-Based Training for Non-Autoregressive Machine Translation",
    "abstract": "Due to the unparallelizable nature of the autoregressive factorization, AutoRegressive Translation (ART) models have to generate tokens sequentially during decoding and thus suffer from high inference latency. Non-AutoRegressive Translation (NART) models were proposed to reduce the inference time, but could only achieve inferior translation accuracy. In this paper, we proposed a novel approach to leveraging the hints from hidden states and word alignments to help the training of NART models. The results achieve significant improvement over previous NART models for the WMT14 En-De and De-En datasets and are even comparable to a strong LSTM-based ART baseline but one order of magnitude faster in inference.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Neural machine translation has attracted much attention in recent years BIBREF0, BIBREF1, BIBREF2, BIBREF3. Given a sentence $x=(x_1, \\dots ,x_{T_x})$ from the source language, the straight-forward way for translation is to generate the target words $y=(y_1, \\dots , y_{T_y})$ one by one from left to right. This is also known as the AutoRegressive Translation (ART) models, in which the joint probability is decomposed into a chain of conditional probabilities:",
          "While the ART models have achieved great success in terms of translation quality, the time consumption during inference is still far away from satisfactory. During training, the predictions at different positions can be estimated in parallel since the ground truth pair $(x,y)$ is exposed to the model. However, during inference, the model has to generate tokens sequentially as $y_{<t}$ must be inferred on the fly. Such autoregressive behavior becomes the bottleneck of the computational time BIBREF4.",
          "In order to speed up the inference process, a line of works begin to develop non-autoregressive translation models. These models break the autoregressive dependency by decomposing the joint probability with",
          "The lost of autoregressive dependency largely hurt the consistency of the output sentences, increase the difficulty in the learning process and thus lead to a low quality translation. Previous works mainly focus on adding different components into the NART model to improve the expressiveness of the network structure to overcome the loss of autoregressive dependency BIBREF5, BIBREF6, BIBREF7. However, the computational overhead of new components will hurt the inference speed, contradicting with the goal of the NART models: to parallelize and speed up neural machine translation models.",
          "To tackle this, we proposed a novel hint-based method for NART model training. We first investigate the causes of the poor performance of the NART model. Comparing with the ART model, we find that: (1) the positions where the NART model outputs incoherent tokens will have very high hidden states similarity; (2) the attention distributions of the NART model are more ambiguous than those of ART model. Therefore, we design two kinds of hints from the hidden states and attention distributions of the ART model to help the training of the NART model. The experimental results show that our model achieves significant improvement over the NART baseline models and is even comparable to a strong ART baseline in BIBREF4."
        ]
      },
      {
        "section_name": "Approach",
        "paragraphs": [
          "In this section, we first describe the observations on the ART and NART models, and then discuss what kinds of information can be used as hints to help the training of the NART model. We follow the network structure in BIBREF8, use a copy of the source sentence as decoder input, remove the attention masks in decoder self-attention layers and add a positional attention layer as suggested in BIBREF5. We provide a visualization of ART and NART models we used in Figure FIGREF11 and a detailed description of the model structure in Appendix."
        ]
      },
      {
        "section_name": "Approach ::: Observation: Illed States and Attentions",
        "paragraphs": [
          "According to the case study in BIBREF5, the translations of the NART models contain incoherent phrases (e.g. repetitive words) and miss meaningful tokens on the source side, while these patterns do not commonly appear in ART models. After some empirical study, we find two non-obvious facts that lead to this phenomenon.",
          "First, we visualize the cosine similarities between decoder hidden states of a certain layer in both ART and NART models for sampled cases. Mathematically, for a set of hidden states $r_1, \\ldots , r_T$, the pairwise cosine similarity can be derived by $\\cos _{ij} = {\\left<r_i, r_j\\right>}/{(\\Vert r_i\\Vert \\cdot \\Vert r_j\\Vert )}.$ We then plot the heatmap of the resulting matrix $\\cos $. A typical example is shown in Figure FIGREF4, where the cosine similarities in the NART model are larger than those of the ART model, indicating that the hidden states across positions in the NART model are \u201csimilar\u201d. Positions with highly-correlated hidden states tend to generate the same word and make the NART model output repetitive tokens, e.g., the yellow area on the top-left of Figure FIGREF4(b), while this does not happen in the ART model (Figure FIGREF4(a)). According to our statistics, 70% of the cosine similarities between hidden states in the ART model are less than 0.25, and 95% are less than 0.5.",
          "Second, we visualize the encoder-decoder attentions for sampled cases, shown in Figure FIGREF6. Good attentions between the source and target sentences are usually considered to lead to accurate translation while poor ones may cause wrong output tokens BIBREF0. In Figure FIGREF6(b), the attentions of the ART model almost covers all source tokens, while the attentions of the NART model do not cover \u201cfarm\u201d but with two \u201cmorning\u201d. This directly makes the translation result worse in the NART model. These phenomena inspire us to use the intermediate hidden information in the ART model to guide the learning process of the NART model."
        ]
      },
      {
        "section_name": "Approach ::: Hints from the ART teacher Model",
        "paragraphs": [
          "Our study motivates us to leverage the intermediate hidden information from an ART model to improve the NART model. We focus on how to define hints from a well-trained ART teacher model and use it to guide the training process of a NART student model. We study layer-to-layer hints and assume both the teacher and student models have an $M$-layer encoder and an $N$-layer decoder, despite the difference in stacked components.",
          "Without the loss of generality, we discuss our method on a given paired sentence $(x,y)$. In real experiments, losses are averaged over all training data. For the teacher model, we use $a_{t,l,h}^\\mathit {tr}$ as the encoder-to-decoder attention distribution of $h$-th head in the $l$-th decoder layer at position $t$, and use $r_{t,l}^\\mathit {tr}$ as the output of the $l$-th decoder layer after feed forward network at position $t$. Correspondingly, $a_{t,l,h}^\\mathit {st}$ and $r_{t,l}^\\mathit {st}$ are used for the student model. We propose a hint-based training framework that contains two kinds of hints:"
        ]
      },
      {
        "section_name": "Approach ::: Hints from the ART teacher Model ::: Hints from hidden states",
        "paragraphs": [
          "The discrepancy of hidden states motivates us to use hidden states of the ART model as a hint for the learning process of the NART model. One straight-forward method is to regularize the $L_1$ or $L_2$ distance between each pair of hidden states in ART and NART models. However, since the network components are quite different in ART and NART models, applying the straight-forward regression on hidden states hurts the learning process and fails. Therefore, we design a more implicit loss to help the student refrain from the incoherent translation results by acting towards the teacher in the hidden-state level:",
          "where $d_\\mathit {st} = \\cos (r_{s, l}^\\mathit {st},r_{t, l}^\\mathit {st})$, $d_\\mathit {tr} = \\cos (r_{s, l}^\\mathit {tr},r_{t, l}^\\mathit {tr})$, and $\\phi $ is a penalty function. In particular, we let",
          "where $-1\\le \\gamma _\\mathit {st}, \\gamma _\\mathit {tr}\\le 1$ are two thresholds controlling whether to penalize or not. We design this loss since we only want to penalize hidden states that are highly similar in the NART model, but not similar in the ART model. We have tested several choices of $-\\log (1-d_\\mathit {st})$, e.g., $\\exp (d_\\mathit {st})$, from which we find similar experimental results."
        ]
      },
      {
        "section_name": "Approach ::: Hints from the ART teacher Model ::: Hints from word alignments",
        "paragraphs": [
          "We observe that meaningful words in the source sentence are sometimes untranslated by the NART model, and the corresponding positions often suffer from ambiguous attention distributions. Therefore, we use the word alignment information from the ART model to help the training of the NART model.",
          "In particular, we minimize KL-divergence between the per-head encoder-to-decoder attention distributions of the teacher and the student to encourage the student to have similar word alignments to the teacher model, i.e.",
          "Our final training loss $\\mathcal {L}$ is a weighted sum of two parts stated above and the negative log-likelihood loss $\\mathcal {L}_\\mathit {nll}$ defined on bilingual sentence pair $(x, y)$, i.e.",
          "where $\\lambda $ and $\\mu $ are hyperparameters controlling the weight of different loss terms."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Settings",
        "paragraphs": [
          "The evaluation is on two widely used public machine translation datasets: IWSLT14 German-to-English (De-En) BIBREF9, BIBREF1 and WMT14 English-to-German (En-De) dataset BIBREF4, BIBREF10. To compare with previous works, we also reverse WMT14 English-to-German dataset and obtain WMT14 German-to-English dataset.",
          "We pretrain Transformer BIBREF8 as the teacher model on each dataset, which achieves 33.26/27.30/31.29 in terms of BLEU BIBREF11 in IWSLT14 De-En, WMT14 En-De and De-En test sets. The student model shares the same number of layers in encoder/decoder, size of hidden states/embeddings and number of heads as the teacher models (Figure FIGREF11). Following BIBREF5, BIBREF12, we replace the target sentences by the decoded output of the teacher models.",
          "Hyperparameters ($\\gamma _\\mathit {st}, \\gamma _\\mathit {tr}, \\lambda , \\mu $) for hint-based learning are determined to make the scales of three loss components similar after initialization. We also employ label smoothing of value $\\epsilon _\\mathit {ls}=0.1$ BIBREF13 in all experiments. We use Adam optimizer and follow the setting in BIBREF8. Models for WMT14/IWSLT14 tasks are trained on 8/1 NVIDIA M40 GPUs respectively. The model is based on the open-sourced tensor2tensor BIBREF14. More settings can be found in Appendix."
        ]
      },
      {
        "section_name": "Experiments ::: Inference",
        "paragraphs": [
          "During training, $T_y$ does not need to be predicted as the target sentence is given. During testing, we have to predict the length of the target sentence for each source sentence. In many languages, the length of the target sentence can be roughly estimated from the length of the source sentence. We choose a simple method to avoid the computational overhead, which uses input length to determine target sentence length: $T_y = T_x + C$, where $C$ is a constant bias determined by the average length differences between the source and target training sentences. We can also predict the target length ranging from $[(T_x+C)-B, (T_x+C)+B]$, where $B$ is the halfwidth. By doing this, we can obtain multiple translation results with different lengths. Note that we choose this method only to show the effectiveness of our proposed method and a more advanced length estimation method can be used to further improve the performance.",
          "Once we have multiple translation results, we additionally use our ART teacher model to evaluate each result and select the one that achieves the highest probability. As the evaluation is fully parallelizable (since it is identical to the parallel training of the ART model), this rescoring operation will not hurt the non-autoregressive property of the NART model."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Results",
        "paragraphs": [
          "We compare our model with several baselines, including three ART models, the fertility based (FT) NART model BIBREF5, the deterministic iterative refinement based (IR) NART model BIBREF6, and the Latent Transformer BIBREF7 which is not fully non-autoregressive by incorporating an autoregressive sub-module in the NART model architecture.",
          "The results are shown in the Table TABREF15. Across different datasets, our method achieves significant improvements over previous non-autoregressive models. Specifically, our method outperforms fertility based NART model with 6.54/7.11 BLEU score improvements on WMT En-De and De-En tasks in similar settings and achieves comparable results with state-of-the-art LSTM-based model on WMT En-De task. Furthermore, our model achieves a speedup of 30.2 (output a single sentence) or 17.8 (teacher rescoring) times over the ART counterparts. Note that our speedups significantly outperform all previous works, because of our lighter design of the NART model: without any computationally expensive module trying to improve the expressiveness.",
          "We also visualize the hidden state cosine similarities and attention distributions for the NART model with hint-based training, as shown in Figure FIGREF4(c) and FIGREF6(c). With hints from hidden states, the hidden states similarities of the NART model decrease in general, and especially for the positions where the original NART model outputs incoherent phrases. The attention distribution of the NART model after hint-based training is more similar to the ART teacher model and less ambiguous comparing to the NART model without hints.",
          "According to our empirical analysis, the percentage of repetitive words drops from 8.3% to 6.5% by our proposed methods on the IWSLT14 De-En test set, which is a 20%+ reduction. This shows that our proposed method effectively improve the quality of the translation outputs. We also provide several case studies in Appendix.",
          "Finally, we conduct an ablation study on IWSLT14 De-En task. As shown in Table TABREF18, the hints from word alignments provide an improvement of about 1.6 BLEU points, and the hints from hidden states improve the results by about 0.8 BLEU points. We also test these models on a subsampled set whose source sentence lengths are at least 40. Our model outperforms the baseline model by more than 3 BLEU points (20.63 v.s. 17.48)."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we proposed to use hints from a well-trained ART model to enhance the training of NART models. Our results on WMT14 En-De and De-En significantly outperform previous NART baselines, with one order of magnitude faster in inference than ART models. In the future, we will focus on designing new architectures and training methods for NART models to achieve comparable accuracy as ART models."
        ]
      },
      {
        "section_name": "Acknowledgment",
        "paragraphs": [
          "This work is supported by National Key R&D Program of China (2018YFB1402600), NSFC (61573026) and BJNSF (L172037) and a grant from Microsoft Research Asia. We would like to thank the anonymous reviewers for their valuable comments on our paper."
        ]
      }
    ],
    "qas": [
      {
        "question": "How do you know the word alignments are correct?",
        "question_id": "2711ae6dd532d136295c95253dbf202e37ecd3e7",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2a18a3656984d04249f100633e4c1003417a2255",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "we use the word alignment information from the ART model"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We observe that meaningful words in the source sentence are sometimes untranslated by the NART model, and the corresponding positions often suffer from ambiguous attention distributions. Therefore, we use the word alignment information from the ART model to help the training of the NART model."
              ],
              "highlighted_evidence": [
                "Therefore, we use the word alignment information from the ART model to help the training of the NART model."
              ]
            },
            "annotation_id": "1b4b98e0c5559a6db1334a6e37b8dd1214849e3d",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "In particular, we minimize KL-divergence between the per-head encoder-to-decoder attention distributions of the teacher and the student to encourage the student to have similar word alignments to the teacher model,"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We observe that meaningful words in the source sentence are sometimes untranslated by the NART model, and the corresponding positions often suffer from ambiguous attention distributions. Therefore, we use the word alignment information from the ART model to help the training of the NART model.",
                "In particular, we minimize KL-divergence between the per-head encoder-to-decoder attention distributions of the teacher and the student to encourage the student to have similar word alignments to the teacher model, i.e."
              ],
              "highlighted_evidence": [
                "We observe that meaningful words in the source sentence are sometimes untranslated by the NART model, and the corresponding positions often suffer from ambiguous attention distributions. Therefore, we use the word alignment information from the ART model to help the training of the NART model.",
                "In particular, we minimize KL-divergence between the per-head encoder-to-decoder attention distributions of the teacher and the student to encourage the student to have similar word alignments to the teacher model, i.e."
              ]
            },
            "annotation_id": "2ebb533776b993a4723f989522a5037c8c88b5c3",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "we conduct an ablation study on IWSLT14 De-En task. As shown in Table TABREF18, the hints from word alignments provide an improvement of about 1.6 BLEU points, and the hints from hidden states improve the results by about 0.8 BLEU points. We also test these models on a subsampled set whose source sentence lengths are at least 40. Our model outperforms the baseline model by more than 3 BLEU points (20.63 v.s. 17.48)."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Finally, we conduct an ablation study on IWSLT14 De-En task. As shown in Table TABREF18, the hints from word alignments provide an improvement of about 1.6 BLEU points, and the hints from hidden states improve the results by about 0.8 BLEU points. We also test these models on a subsampled set whose source sentence lengths are at least 40. Our model outperforms the baseline model by more than 3 BLEU points (20.63 v.s. 17.48)."
              ],
              "highlighted_evidence": [
                "we conduct an ablation study on IWSLT14 De-En task. As shown in Table TABREF18, the hints from word alignments provide an improvement of about 1.6 BLEU points, and the hints from hidden states improve the results by about 0.8 BLEU points. We also test these models on a subsampled set whose source sentence lengths are at least 40. Our model outperforms the baseline model by more than 3 BLEU points (20.63 v.s. 17.48)."
              ]
            },
            "annotation_id": "faa6ecc535db10c99c57a9276dde81218babf75d",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Case study: the above three figures visualize the hidden state cosine similarities of different models. The axes correspond to the generated target tokens. Each pixel shows the cosine similarities cosij between the last layer hidden states of the i-th and j-th generated tokens, where the diagonal pixel will always be 1.0."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Case study: the above three figures visualize the encoder-decoder attention weights of different models. The x-axis and y-axis correspond to the source and generated target tokens respectively. The attention distribution is from a single head of the third layer encoder-decoder attention, which is the most informative one according to our observation. Each pixel shows attention weights \u03b1ij between the i-th source token and j-th target token."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: Hint-based training from ART model to NART model."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Performance on WMT14 En-De, De-En and IWSLT14 De-En tasks. \u201c/\u201d means non-reportable."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Ablation studies on IWSLT14 De-En. Results are BLEU scores without teacher rescoring."
      },
      {
        "file": "9-Table3-1.png",
        "caption": "Table 3: Cases on IWSLT14 De-En."
      }
    ]
  },
  "1706.08568": {
    "title": "Neural Question Answering at BioASQ 5B",
    "abstract": "This paper describes our submission to the 2017 BioASQ challenge. We participated in Task B, Phase B which is concerned with biomedical question answering (QA). We focus on factoid and list question, using an extractive QA model, that is, we restrict our system to output substrings of the provided text snippets. At the core of our system, we use FastQA, a state-of-the-art neural QA system. We extended it with biomedical word embeddings and changed its answer layer to be able to answer list questions in addition to factoid questions. We pre-trained the model on a large-scale open-domain QA dataset, SQuAD, and then fine-tuned the parameters on the BioASQ training set. With our approach, we achieve state-of-the-art results on factoid questions and competitive results on list questions.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "BioASQ is a semantic indexing, question answering (QA) and information extraction challenge BIBREF0 . We participated in Task B of the challenge which is concerned with biomedical QA. More specifically, our system participated in Task B, Phase B: Given a question and gold-standard snippets (i.e., pieces of text that contain the answer(s) to the question), the system is asked to return a list of answer candidates.",
          "The fifth BioASQ challenge is taking place at the time of writing. Five batches of 100 questions each were released every two weeks. Participating systems have 24 hours to submit their results. At the time of writing, all batches had been released.",
          "The questions are categorized into different question types: factoid, list, summary and yes/no. Our work concentrates on answering factoid and list questions. For factoid questions, the system's responses are interpreted as a ranked list of answer candidates. They are evaluated using mean-reciprocal rank (MRR). For list questions, the system's responses are interpreted as a set of answers to the list question. Precision and recall are computed by comparing the given answers to the gold-standard answers. F1 score, i.e., the harmonic mean of precision and recall, is used as the official evaluation measure .",
          "Most existing biomedical QA systems employ a traditional QA pipeline, similar in structure to the baseline system by weissenborn2013answering. They consist of several discrete steps, e.g., named-entity recognition, question classification, and candidate answer scoring. These systems require a large amount of resources and feature engineering that is specific to the biomedical domain. For example, OAQA BIBREF1 , which has been very successful in last year's challenge, uses a biomedical parser, entity tagger and a thesaurus to retrieve synonyms.",
          "Our system, on the other hand, is based on a neural network QA architecture that is trained end-to-end on the target task. We build upon FastQA BIBREF2 , an extractive factoid QA system which achieves state-of-the-art results on QA benchmarks that provide large amounts of training data. For example, SQuAD BIBREF3 provides a dataset of $\\approx 100,000$ questions on Wikipedia articles. Our approach is to train FastQA (with some extensions) on the SQuAD dataset and then fine-tune the model parameters on the BioASQ training set.",
          "Note that by using an extractive QA network as our central component, we restrict our system's responses to substrings in the provided snippets. This also implies that the network will not be able to answer yes/no questions. We do, however, generalize the FastQA output layer in order to be able to answer list questions in addition to factoid questions."
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "Our system is a neural network which takes as input a question and a context (i.e., the snippets) and outputs start and end pointers to tokens in the context. At its core, we use FastQA BIBREF2 , a state-of-the-art neural QA system. In the following, we describe our changes to the architecture and how the network is trained."
        ]
      },
      {
        "section_name": "Network architecture",
        "paragraphs": [
          "In the input layer, the context and question tokens are mapped to high-dimensional word vectors. Our word vectors consists of three components, which are concatenated to form a single vector:",
          "GloVe embedding: We use 300-dimensional GloVe embeddings BIBREF4 which have been trained on a large collection of web documents.",
          "Character embedding: This embedding is computed by a 1-dimensional convolutional neural network from the characters of the words, as introduced by seo2016bidirectional.",
          "Biomedical Word2Vec embeddings: We use the biomedical word embeddings provided by biomedicalword2vec. These are 200-dimensional Word2Vec embeddings BIBREF5 which were trained on $\\approx 10$ million PubMed abstracts.",
          "To the embedding vectors, we concatenate a one-hot encoding of the question type (list or factoid). Note that these features are identical for all tokens.",
          "Following our embedding layer, we invoke FastQA in order to compute start and end scores for all context tokens. Because end scores are conditioned on the chosen start, there are $O(n^2)$ end scores where $n$ is the number of context tokens. We denote the start index by $i \\in [1, n]$ , the end index by $j \\in [i, n]$ , the start scores by $y_{start}^{i}$ , and end scores by $y_{end}^{i, j}$ .",
          "In our output layer, the start, end, and span probabilities are computed as: ",
          "$$p_{start}^i = \\sigma (y_{start}^i)$$   (Eq. 8) ",
          "$$p_{end}^{i, \\cdot } = softmax(y_{end}^{i, \\cdot })$$   (Eq. 9) ",
          "where $\\sigma $ denotes the sigmoid function. By computing the start probability via the sigmoid rather than softmax function (as used in FastQA), we enable the model to output multiple spans as likely answer spans. This generalizes the factoid QA network to list questions."
        ]
      },
      {
        "section_name": "Training & decoding",
        "paragraphs": [
          "We define our loss as the cross-entropy of the correct start and end indices. In the case of multiple occurrences of the same answer, we only minimize the span of the lowest loss.",
          "We train the network in two steps: First, the network is trained on SQuAD, following the procedure by weissenborn2017fastqa (pre-training phase). Second, we fine-tune the network parameters on BioASQ (fine-tuning phase). For both phases, we use the Adam optimizer BIBREF6 with an exponentially decaying learning rate. We start with learning rates of $10^{-3}$ and $10^{-4}$ for the pre-training and fine-tuning phases, respectively.",
          "During fine-tuning, we extract answer spans from the BioASQ training data by looking for occurrences of the gold standard answer in the provided snippets. Note that this approach is not perfect as it can produce false positives (e.g., the answer is mentioned in a sentence which does not answer the question) and false negatives (e.g., a sentence answers the question, but the exact string used is not in the synonym list).",
          "Because BioASQ usually contains multiple snippets for a given question, we process all snippets independently and then aggregate the answer spans, sorting globally according to their probability $p_{span}^{i, j}$ .",
          "During the inference phase, we retrieve the top 20 answers span via beam search with beam size 20. From this sorted list of answer strings, we remove all duplicate strings. For factoid questions, we output the top five answer strings as our ranked list of answer candidates. For list questions, we use a probability cutoff threshold $t$ , such that $\\lbrace (i, j)|p_{span}^{i, j} \\ge t\\rbrace $ is the set of answers. We set $t$ to be the threshold for which the list F1 score on the development set is optimized.",
          "In order to further tweak the performance of our systems, we built a model ensemble. For this, we trained five single models using 5-fold cross-validation on the entire training set. These models are combined by averaging their start and end scores before computing the span probabilities (Equations 8 - 10 ). As a result, we submit two systems to the challenge: The best single model (according to its development set) and the model ensemble.",
          "We implemented our system using TensorFlow BIBREF7 . It was trained on an NVidia GForce Titan X GPU."
        ]
      },
      {
        "section_name": "Results & discussion",
        "paragraphs": [
          "We report the results for all five test batches of BioASQ 5 (Task 5b, Phase B) in Table 1 . Note that the performance numbers are not final, as the provided synonyms in the gold-standard answers will be updated as a manual step, in order to reflect valid responses by the participating systems. This has not been done by the time of writing. Note also that \u2013 in contrast to previous BioASQ challenges \u2013 systems are no longer allowed to provide an own list of synonyms in this year's challenge.",
          "In general, the single and ensemble system are performing very similar relative to the rest of field: Their ranks are almost always right next to each other. Between the two, the ensemble model performed slightly better on average.",
          "On factoid questions, our system has been very successful, winning three out of five batches. On list questions, however, the relative performance varies significantly. We expect our system to perform better on factoid questions than list questions, because our pre-training dataset (SQuAD) does not contain any list questions.",
          "Starting with batch 3, we also submitted responses to yes/no questions by always answering yes. Because of a very skewed class distribution in the BioASQ dataset, this is a strong baseline. Because this is done merely to have baseline performance for this question type and because of the naivety of the method, we do not list or discuss the results here."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we summarized the system design of our BioASQ 5B submission for factoid and list questions. We use a neural architecture which is trained end-to-end on the QA task. This approach has not been applied to BioASQ questions in previous challenges. Our results show that our approach achieves state-of-the art results on factoid questions and competitive results on list questions."
        ]
      }
    ],
    "qas": [
      {
        "question": "Are answers in this dataset guaranteed to be substrings of the text? If not, what is the coverage of answers being substrings?",
        "question_id": "a526c63fc8dc1b79702b481b77e3922d7002d973",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "question",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "BioASQ is a semantic indexing, question answering (QA) and information extraction challenge BIBREF0 . We participated in Task B of the challenge which is concerned with biomedical QA. More specifically, our system participated in Task B, Phase B: Given a question and gold-standard snippets (i.e., pieces of text that contain the answer(s) to the question), the system is asked to return a list of answer candidates."
              ],
              "highlighted_evidence": [
                "More specifically, our system participated in Task B, Phase B: Given a question and gold-standard snippets (i.e., pieces of text that contain the answer(s) to the question), the system is asked to return a list of answer candidates."
              ]
            },
            "annotation_id": "2ca29ac18fdb31592cbd37a3c51357c4498713ec",
            "worker_id": "ca2a4695129d0180768a955fb5910d639f79aa34"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "The questions are categorized into different question types: factoid, list, summary and yes/no. Our work concentrates on answering factoid and list questions. For factoid questions, the system's responses are interpreted as a ranked list of answer candidates. They are evaluated using mean-reciprocal rank (MRR). For list questions, the system's responses are interpreted as a set of answers to the list question. Precision and recall are computed by comparing the given answers to the gold-standard answers. F1 score, i.e., the harmonic mean of precision and recall, is used as the official evaluation measure ."
              ],
              "highlighted_evidence": [
                "The questions are categorized into different question types: factoid, list, summary and yes/no."
              ],
              "yes_no": null,
              "free_form_answer": "No, the answers can also be summaries or yes/no.",
              "extractive_spans": []
            },
            "annotation_id": "b82c3c516f21a6b8592f8adff34baf590b1282b6",
            "worker_id": "4857c606a55a83454e8d81ffe17e05cf8bc4b75f"
          },
          {
            "answer": {
              "unanswerable": true,
              "evidence": [],
              "highlighted_evidence": [],
              "yes_no": null,
              "free_form_answer": "",
              "extractive_spans": []
            },
            "annotation_id": "beca733a2ae3c9397cd187e03dc43d5b68aedbb9",
            "worker_id": "c7d4a630661cd719ea504dba56393f78278b296b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Neural architecture of our system. Question and context (i.e., the snippets) are mapped directly to start and end probabilities for each context token. We use FastQA (Weissenborn et al., 2017) with modified input vectors and an output layer that supports list answers in addition to factoid answers."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Preliminary results for factoid and list questions for all five batches and for our single and ensemble systems. We report MRR and F1 scores for factoid and list questions, respectively. In parentheses, we report the rank of the respective systems relative to all other systems in the challenge. The last row averages the performance numbers of the respective system and question type across the five batches."
      }
    ]
  },
  "1909.05190": {
    "title": "Event Representation Learning Enhanced with External Commonsense Knowledge",
    "abstract": "Prior work has proposed effective methods to learn event representations that can capture syntactic and semantic information over text corpus, demonstrating their effectiveness for downstream tasks such as script event prediction. On the other hand, events extracted from raw texts lacks of commonsense knowledge, such as the intents and emotions of the event participants, which are useful for distinguishing event pairs when there are only subtle differences in their surface realizations. To address this issue, this paper proposes to leverage external commonsense knowledge about the intent and sentiment of the event. Experiments on three event-related tasks, i.e., event similarity, script event prediction and stock market prediction, show that our model obtains much better event embeddings for the tasks, achieving 78% improvements on hard similarity task, yielding more precise inferences on subsequent events under given contexts, and better accuracies in predicting the volatilities of the stock market.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Events are a kind of important objective information of the world. Structuralizing and representing such information as machine-readable knowledge are crucial to artificial intelligence BIBREF0, BIBREF1. The main idea is to learn distributed representations for structured events (i.e. event embeddings) from text, and use them as the basis to induce textual features for downstream applications, such as script event prediction and stock market prediction.",
          "Parameterized additive models are among the most widely used for learning distributed event representations in prior work BIBREF2, BIBREF3, which passes the concatenation or addition of event arguments' word embeddings to a parameterized function. The function maps the summed vectors into an event embedding space. Furthermore, BIBREF4 ding2015deep and BIBREF5 weber2018event propose using neural tensor networks to perform semantic composition of event arguments, which can better capture the interactions between event arguments.",
          "This line of work only captures shallow event semantics, which is not capable of distinguishing events with subtle differences. On the one hand, the obtained event embeddings cannot capture the relationship between events that are syntactically or semantically similar, if they do not share similar word vectors. For example, as shown in Figure FIGREF2 (a), \u201cPersonX threw bomb\u201d and \u201cPersonZ attacked embassy\u201d. On the other hand, two events with similar word embeddings may have similar embeddings despite that they are quite unrelated, for example, as shown in Figure FIGREF2 (b), \u201cPersonX broke record\u201d and \u201cPersonY broke vase\u201d. Note that in this paper, similar events generally refer to events with strong semantic relationships rather than just the same events.",
          "One important reason for the problem is the lack of the external commonsense knowledge about the mental state of event participants when learning the objective event representations. In Figure FIGREF2 (a), two event participants \u201cPersonY\u201d and \u201cPersonZ\u201d may carry out a terrorist attack, and hence, they have the same intent: \u201cto bloodshed\u201d, which can help representation learning model maps two events into the neighbor vector space. In Figure FIGREF2 (b), a change to a single argument leads to a large semantic shift in the event representations, as the change of an argument can result in different emotions of event participants. Who \u201cbroke the record\u201d is likely to be happy, while, who \u201cbroke a vase\u201d may be sad. Hence, intent and sentiment can be used to learn more fine-grained semantic features for event embeddings.",
          "Such commonsense knowledge is not explicitly expressed but can be found in a knowledge base such as Event2Mind BIBREF6 and ATOMIC BIBREF7. Thus, we aim to incorporate the external commonsense knowledge, i.e., intent and sentiment, into the learning process to generate better event representations. Specifically, we propose a simple and effective model to jointly embed events, intents and emotions into the same vector space. A neural tensor network is used to learn baseline event embeddings, and we define a corresponding loss function to incorporate intent and sentiment information.",
          "Extensive experiments show that incorporating external commonsense knowledge brings promising improvements to event embeddings, achieving 78% and 200% improvements on hard similarity small and big dataset, respectively. With better embeddings, we can achieve superior performances on script event prediction and stock market prediction compared to state-of-the-art baseline methods."
        ]
      },
      {
        "section_name": "Commonsense Knowledge Enhanced Event Representations",
        "paragraphs": [
          "The joint embedding framework is shown in Figure FIGREF3. We begin by introducing the baseline event embedding learning model, which serves as the basis of the proposed framework. Then, we show how to model intent and sentiment information. Subsequently, we describe the proposed joint model by integrating intent and sentiment into the original objective function to help learn high-quality event representations, and introduce the training details."
        ]
      },
      {
        "section_name": "Commonsense Knowledge Enhanced Event Representations ::: Low-Rank Tensors for Event Embedding",
        "paragraphs": [
          "The goal of event embedding is to learn low-dimension dense vector representations for event tuples $E=(A, P, O)$, where $P$ is the action or predicate, $A$ is the actor or subject and $O$ is the object on which the action is performed. Event embedding models compound vector representations over its predicate and arguments representations. The challenge is that the composition models should be effective for learning the interactions between the predicate and the argument. Simple additive transformations are incompetent.",
          "We follow BIBREF4 (BIBREF4) modelling such informative interactions through tensor composition. The architecture of neural tensor network (NTN) for learning event embeddings is shown in Figure FIGREF5, where the bilinear tensors are used to explicitly model the relationship between the actor and the action, and that between the object and the action.",
          "The inputs of NTN are the word embeddings of $A$, $P$ and $O$, and the outputs are event embeddings. We initialized our word representations using publicly available $d$-dimensional ($d=100$) GloVe vectors BIBREF8. As most event arguments consist of several words, we represent the actor, action and object as the average of their word embeddings, respectively.",
          "From Figure FIGREF5, $S_1 \\in \\mathbb {R}^d$ is computed by:",
          "where $T^{[1:k]}_1 \\in \\mathbb {R}^{d\\times d\\times k}$ is a tensor, which is a set of $k$ matrices, each with $d\\times d$ dimensions. The bilinear tensor product $A^TT_1^{[1:k]}P$ is a vector $r \\in \\mathbb {R}^k$, where each entry is computed by one slice of the tensor ($r_i=A^TT_1^{[i]}P, i = 1, \\cdots , k$). The other parameters are a standard feed-forward neural network, where $W \\in \\mathbb {R}^{k \\times \\it 2d}$ is the weight matrix, $b \\in \\mathbb {R}^k$ is the bias vector, $U \\in \\mathbb {R}^k$ is a hyper-parameter and $f=\\it tanh$ is a standard nonlinearity applied element-wise. $S_2$ and $C$ in Figure FIGREF5 are computed in the same way as $S_1$.",
          "One problem with tensors is curse of dimensionality, which limits the wide application of tensors in many areas. It is therefore essential to approximate tensors of higher order in a compressed scheme, for example, a low-rank tensor decomposition. To decrease the number of parameters in standard neural tensor network, we make low-rank approximation that represents each matrix by two low-rank matrices plus diagonal, as illustrated in Figure FIGREF7. Formally, the parameter of the $i$-th slice is $T_{appr}^{[i]}=T^{[i_1]}\\times T^{[i_2]}+diag(t^{[i]})$, where $T^{[i_1]}\\in \\mathbb {R}^{d\\times n}$, $T^{[i_2]}\\in \\mathbb {R}^{n\\times d}$, $t^{[i]}\\in \\mathbb {R}^d$, $n$ is a hyper-parameter, which is used for adjusting the degree of tensor decomposition. The output of neural tensor layer is formalized as follows.",
          "where $[T_{appr}]_1^{[1:k]}$ is the low-rank tensor that defines multiple low-rank bilinear layers. $k$ is the slice number of neural tensor network which is also equal to the output length of $S_1$.",
          "We assume that event tuples in the training data should be scored higher than corrupted tuples, in which one of the event arguments is replaced with a random argument. Formally, the corrupted event tuple is $E^r=(A^r, P, O)$, which is derived by replacing each word in $A$ with a random word $w^r$ in our dictionary $\\mathcal {D}$ (which contains all the words in the training data) to obtain a corrupted counterpart $A^r$. We calculate the margin loss of the two event tuples as:",
          "where $\\mathit {\\Phi }=(T_1, T_2, T_3, W, b)$ is the set of model parameters. The standard $L_2$ regularization is used, for which the weight $\\lambda $ is set as 0.0001. The algorithm goes over the training set for multiple iterations. For each training instance, if the loss $loss(E,E^r)=\\max (0,1-g(E)+g(E^r))$ is equal to zero, the online training algorithm continues to process the next event tuple. Otherwise, the parameters are updated to minimize the loss using back-propagation BIBREF9."
        ]
      },
      {
        "section_name": "Commonsense Knowledge Enhanced Event Representations ::: Intent Embedding",
        "paragraphs": [
          "Intent embedding refers to encoding the event participants' intents into event vectors, which is mainly used to explain why the actor performed the action. For example, given two events \u201cPersonX threw basketball\u201d and \u201cPersonX threw bomb\u201d, there are only subtle differences in their surface realizations, however, the intents are totally different. \u201cPersonX threw basketball\u201d is just for fun, while \u201cPersonX threw bomb\u201d could be a terrorist attack. With the intents, we can easily distinguish these superficial similar events.",
          "One challenge for incorporating intents into event embeddings is that we should have a large-scale labeled dataset, which annotated the event and its actor's intents. Recently, BIBREF6 P18-1043 and BIBREF7 sap2018atomic released such valuable commonsense knowledge dataset (ATOMIC), which consists of 25,000 event phrases covering a diverse range of daily-life events and situations. For example, given an event \u201cPersonX drinks coffee in the morning\u201d, the dataset labels PersonX's likely intent is \u201cPersonX wants to stay awake\u201d.",
          "We notice that the intents labeled in ATOMIC is a sentence. Hence, intent embedding is actually a sentence representation learning task. Among various neural networks for encoding sentences, bi-directional LSTMs (BiLSTM) BIBREF10 have been a dominant method, giving state-of-the-art results in language modelling BIBREF11 and syntactic parsing BIBREF12.",
          "We use BiLSTM model to learn intent representations. BiLSTM consists of two LSTM components, which process the input in the forward left-to-right and the backward right-to-left directions, respectively. In each direction, the reading of input words is modelled as a recurrent process with a single hidden state. Given an initial value, the state changes its value recurrently, each time consuming an incoming word.",
          "Take the forward LSTM component for example. Denoting the initial state as $\\overrightarrow{\\mathbf {h}}^0$, which is a model parameter, it reads the input word representations $\\mathbf {x}_0,\\mathbf {x}_1,\\dots ,\\mathbf {x}_n$, and the recurrent state transition step for calculating $\\overrightarrow{\\mathbf {h}}^1,\\dots ,\\overrightarrow{\\mathbf {h}}^{n+1}$ is defined as BIBREF13 (BIBREF13).",
          "The backward LSTM component follows the same recurrent state transition process as the forward LSTM component. Starting from an initial state $\\overleftarrow{\\mathbf {h}}^{n+1}$, which is a model parameter, it reads the input $\\mathbf {x}_n,\\mathbf {x}_{n-1},\\dots ,\\mathbf {x}_0$, changing its value to $\\overleftarrow{\\mathbf {h}}^n,\\overleftarrow{\\mathbf {h}}^{n-1},\\dots ,\\overleftarrow{\\mathbf {h}}^0$, respectively. The BiLSTM model uses the concatenated value of $\\overrightarrow{\\mathbf {h}}^t$ and $\\overleftarrow{\\mathbf {h}}^t$ as the hidden vector for $w_t$:",
          "A single hidden vector representation $\\mathbf {v}_i$ of the input intent can be obtained by concatenating the last hidden states of the two LSTMs:",
          "In the training process, we calculate the similarity between a given event vector $\\mathbf {v}_e$ and its related intent vector $\\mathbf {v}_i$. For effectively training the model, we devise a ranking type loss function as follows:",
          "where $\\mathbf {v}^{\\prime }_i$ is the incorrect intent for $\\mathbf {v}_e$, which is randomly selected from the annotated dataset."
        ]
      },
      {
        "section_name": "Commonsense Knowledge Enhanced Event Representations ::: Sentiment Embedding",
        "paragraphs": [
          "Sentiment embedding refers to encoding the event participants' emotions into event vectors, which is mainly used to explain how does the actor feel after the event. For example, given two events \u201cPersonX broke record\u201d and \u201cPersonX broke vase\u201d, there are only subtle differences in their surface realizations, however, the emotions of PersonX are totally different. After \u201cPersonX broke record\u201d, PersonX may be feel happy, while after \u201cPersonX broke vase\u201d, PersonX could be feel sad. With the emotions, we can also effectively distinguish these superficial similar events.",
          "We also use ATOMIC BIBREF7 as the event sentiment labeled dataset. In this dataset, the sentiment of the event is labeled as words. For example, the sentiment of \u201cPersonX broke vase\u201d is labeled as \u201c(sad, be regretful, feel sorry, afraid)\u201d. We use SenticNet BIBREF14 to normalize these emotion words ($W=\\lbrace w_1, w_2, \\dots , w_n\\rbrace $) as the positive (labeled as 1) or the negative (labeled as -1) sentiment. The sentiment polarity of the event $P_e$ is dependent on the polarity of the labeled emotion words $P_W$: $P_e=1$, if $\\sum _i P_{w_i}>0$, or $P_e=-1$, if $\\sum _i P_{w_i}<0$. We use the softmax binary classifier to learn sentiment enhanced event embeddings. The input of the classifier is event embeddings, and the output is its sentiment polarity (positive or negative). The model is trained in a supervised manner by minimizing the cross entropy error of the sentiment classification, whose loss function is given below.",
          "where $C$ means all training instances, $L$ is the collection of sentiment categories, $x_e$ means an event vector, $p_l(x_e)$ is the probability of predicting $x_e$ as class $l$, $p^g_l(x_e)$ indicates whether class $l$ is the correct sentiment category, whose value is 1 or -1."
        ]
      },
      {
        "section_name": "Commonsense Knowledge Enhanced Event Representations ::: Joint Event, Intent and Sentiment Embedding",
        "paragraphs": [
          "Given a training event corpus with annotated intents and emotions, our model jointly minimizes a linear combination of the loss functions on events, intents and sentiment:",
          "where $\\alpha , \\beta , \\gamma \\in [0,1]$ are model parameters to weight the three loss functions.",
          "We use the New York Times Gigaword Corpus (LDC2007T07) for pre-training event embeddings. Event triples are extracted based on the Open Information Extraction technology BIBREF15. We initialize the word embedding layer with 100 dimensional pre-trained GloVe vectors BIBREF8, and fine-tune initialized word vectors during our model training. We use Adagrad BIBREF16 for optimizing the parameters with initial learning rate 0.001 and batch size 128."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We compare the performance of intent and sentiment powered event embedding model with state-of-the-art baselines on three tasks: event similarity, script event prediction and stock prediction."
        ]
      },
      {
        "section_name": "Experiments ::: Baselines",
        "paragraphs": [
          "We compare the performance of our approach against a variety of event embedding models developed in recent years. These models can be categorized into three groups:",
          "Averaging Baseline (Avg) This represents each event as the average of the constituent word vectors using pre-trained GloVe embeddings BIBREF8.",
          "Compositional Neural Network (Comp. NN) The event representation in this model is computed by feeding the concatenation of the subject, predicate, and object embedding into a two layer neural network BIBREF17, BIBREF3, BIBREF2.",
          "Element-wise Multiplicative Composition (EM Comp.) This method simply concatenates the element-wise multiplications between the verb and its subject/object.",
          "Neural Tensor Network This line of work use tensors to learn the interactions between the predicate and its subject/object BIBREF4, BIBREF5. According to the different usage of tensors, we have three baseline methods: Role Factor Tensor BIBREF5 which represents the predicate as a tensor, Predicate Tensor BIBREF5 which uses two tensors learning the interactions between the predicate and its subject, and the predicate and its object, respectively, NTN BIBREF4, which we used as the baseline event embedding model in this paper, and KGEB BIBREF18, which incorporates knowledge graph information in NTN."
        ]
      },
      {
        "section_name": "Experiments ::: Event Similarity Evaluation ::: Hard Similarity Task",
        "paragraphs": [
          "We first follow BIBREF5 (BIBREF5) evaluating our proposed approach on the hard similarity task. The goal of this task is that similar events should be close to each other in the same vector space, while dissimilar events should be far away with each other. To this end, BIBREF5 (BIBREF5) created two types of event pairs, one with events that should be close to each other but have very little lexical overlap (e.g., police catch robber / authorities apprehend suspect), and another with events that should be farther apart but have high overlap (e.g., police catch robber / police catch disease).",
          "The labeled dataset contains 230 event pairs (115 pairs each of similar and dissimilar types). Three different annotators were asked to give the similarity/dissimilarity rankings, of which only those the annotators agreed upon completely were kept. For each event representation learning method, we obtain the cosine similarity score of the pairs, and report the fraction of cases where the similar pair receives a higher cosine value than the dissimilar pair (we use Accuracy $\\in [0,1]$ denoting it). To evaluate the robustness of our approach, we extend this dataset to 1,000 event pairs (similar and dissimilar events each account for 50%), and we will release this dataset to the public."
        ]
      },
      {
        "section_name": "Experiments ::: Event Similarity Evaluation ::: Transitive Sentence Similarity",
        "paragraphs": [
          "Except for the hard similarity task, we also evaluate our approach on the transitive sentence similarity dataset BIBREF19, which contains 108 pairs of transitive sentences: short phrases containing a single subject, object and verb (e.g., agent sell property). It also has another dataset which consists of 200 sentence pairs. In this dataset, the sentences to be compared are constructed using the same subject and object and semantically correlated verbs, such as `spell\u2019 and `write\u2019; for example, `pupils write letters\u2019 is compared with `pupils spell letters\u2019. As this dataset is not suitable for our task, we only evaluate our approach and baselines on 108 sentence pairs.",
          "Every pair is annotated by a human with a similarity score from 1 to 7. For example, pairs such as (design, reduce, amount) and (company, cut, cost) are annotated with a high similarity score, while pairs such as (wife, pour, tea) and (worker, join, party) are given low similarity scores. Since each pair has several annotations, we use the average annotator score as the gold score. To evaluate the cosine similarity given by each model and the annotated similarity score, we use the Spearman\u2019s correlation ($\\rho \\in [-1,1]$)."
        ]
      },
      {
        "section_name": "Experiments ::: Event Similarity Evaluation ::: Results",
        "paragraphs": [
          "Experimental results of hard similarity and transitive sentence similarity are shown in Table TABREF23. We find that:",
          "(1) Simple averaging achieved competitive performance in the task of transitive sentence similarity, while performed very badly in the task of hard similarity. This is mainly because hard similarity dataset is specially created for evaluating the event pairs that should be close to each other but have little lexical overlap and that should be farther apart but have high lexical overlap. Obviously, on such dataset, simply averaging word vectors which is incapable of capturing the semantic interactions between event arguments, cannot achieve a sound performance.",
          "(2) Tensor-based compositional methods (NTN, KGEB, Role Factor Tensor and Predicate Tensor) outperformed parameterized additive models (Comp. NN and EM Comp.), which shows that tensor is capable of learning the semantic composition of event arguments.",
          "(3) Our commonsense knowledge enhanced event representation learning approach outperformed all baseline methods across all datasets (achieving 78% and 200% improvements on hard similarity small and big dataset, respectively, compared to previous SOTA method), which indicates that commonsense knowledge is useful for distinguishing distinct events."
        ]
      },
      {
        "section_name": "Experiments ::: Event Similarity Evaluation ::: Case Study",
        "paragraphs": [
          "To further analyse the effects of intents and emotions on the event representation learning, we present case studies in Table TABREF29, which directly shows the changes of similarity scores before and after incorporating intent and sentiment. For example, the original similarity score of two events \u201cchef cooked pasta\u201d and \u201cchef cooked books\u201d is very high (0.89) as they have high lexical overlap. However, their intents differ greatly. The intent of \u201cchef cooked pasta\u201d is \u201cto hope his customer enjoying the delicious food\u201d, while the intent of \u201cchef cooked books\u201d is \u201cto falsify their financial statements\u201d. Enhanced with the intents, the similarity score of the above two events dramatically drops to 0.45. For another example, as the event pair \u201cman clears test\u201d and \u201che passed exam\u201d share the same sentiment polarity, their similarity score is boosted from -0.08 to 0.40."
        ]
      },
      {
        "section_name": "Experiments ::: Script Event Prediction",
        "paragraphs": [
          "Event is a kind of important real-world knowledge. Learning effective event representations can be benefit for numerous applications. Script event prediction BIBREF20 is a challenging event-based commonsense reasoning task, which is defined as giving an existing event context, one needs to choose the most reasonable subsequent event from a candidate list.",
          "Following BIBREF21 (BIBREF21), we evaluate on the standard multiple choice narrative cloze (MCNC) dataset BIBREF2. As SGNN proposed by BIBREF21 (BIBREF21) achieved state-of-the-art performances for this task, we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings.",
          "BIBREF22 (BIBREF22) and BIBREF21 (BIBREF21) showed that script event prediction is a challenging problem, and even 1% of accuracy improvement is very difficult. Experimental results shown in Table TABREF31 demonstrate that we can achieve more than 1.5% improvements in single model comparison and more than 1.4% improvements in multi-model integration comparison, just by replacing the input embeddings, which confirms that better event understanding can lead to better inference results. An interesting result is that the event embeddings only incorporated with intents achieved the best result against other baselines. This confirms that capturing people's intents is helpful to infer their next plan. In addition, we notice that the event embeddings only incorporated with sentiment also achieve better performance than SGNN. This is mainly because the emotional consistency does also contribute to predicate the subsequent event."
        ]
      },
      {
        "section_name": "Experiments ::: Stock Market Prediction",
        "paragraphs": [
          "It has been shown that news events influence the trends of stock price movements BIBREF23. As news events affect human decisions and the volatility of stock prices is influenced by human trading, it is reasonable to say that events can influence the stock market.",
          "In this section, we compare with several event-driven stock market prediction baseline methods: (1) Word, BIBREF23 luss2012predicting use bag-of-words represent news events for stock prediction; (2) Event, BIBREF24 ding-EtAl:2014:EMNLP2014 represent events by subject-predicate-object triples for stock prediction; (3) NTN, BIBREF4 ding2015deep learn continues event vectors for stock prediction; (4) KGEB, BIBREF18 ding2016knowledge incorporate knowledge graph into event vectors for stock prediction.",
          "Experimental results are shown in Figure FIGREF33. We find that knowledge-driven event embedding is a competitive baseline method, which incorporates world knowledge to improve the performances of event embeddings on the stock prediction. Sentiment is often discussed in predicting stock market, as positive or negative news can affect people's trading decision, which in turn influences the movement of stock market. In this study, we empirically show that event emotions are effective for improving the performance of stock prediction (+2.4%)."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Recent advances in computing power and NLP technology enables more accurate models of events with structures. Using open information extraction to obtain structured events representations, we find that the actor and object of events can be better captured BIBREF24. For example, a structured representation of the event above can be (Actor = Microsoft, Action = sues, Object = Barnes & Noble). They report improvements on stock market prediction using their structured representation instead of words as features.",
          "One disadvantage of structured representations of events is that they lead to increased sparsity, which potentially limits the predictive power. BIBREF4 ding2015deep propose to address this issue by representing structured events using event embeddings, which are dense vectors. The goal of event representation learning is that similar events should be embedded close to each other in the same vector space, and distinct events should be farther from each other.",
          "Previous work investigated compositional models for event embeddings. BIBREF2 granroth2016happens concatenate predicate and argument embeddings and feed them to a neural network to generate an event embedding. Event embeddings are further concatenated and fed through another neural network to predict the coherence between the events. Modi modi2016event encodes a set of events in a similar way and use that to incrementally predict the next event \u2013 first the argument, then the predicate and then next argument. BIBREF25 pichotta2016learning treat event prediction as a sequence to sequence problem and use RNN based models conditioned on event sequences in order to predict the next event. These three works all model narrative chains, that is, event sequences in which a single entity (the protagonist) participates in every event. BIBREF26 hu2017happens also apply an RNN approach, applying a new hierarchical LSTM model in order to predict events by generating descriptive word sequences. This line of work combines the words in these phrases by the passing the concatenation or addition of their word embeddings to a parameterized function that maps the summed vector into event embedding space. The additive nature of these models makes it difficult to model subtle differences in an event\u2019s surface form.",
          "To address this issue, BIBREF4 ding2015deep, and BIBREF5 weber2018event propose tensor-based composition models, which combine the subject, predicate and object to produce the final event representation. The models capture multiplicative interactions between these elements and are thus able to make large shifts in event semantics with only small changes to the arguments.",
          "However, previous work mainly focuses on the nature of the event and lose sight of external commonsense knowledge, such as the intent and sentiment of event participants. This paper proposes to encode intent and sentiment into event embeddings, such that we can obtain a kind of more powerful event representations."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Understanding events requires effective representations that contain commonsense knowledge. High-quality event representations are valuable for many NLP downstream applications. This paper proposed a simple and effective framework to incorporate commonsense knowledge into the learning process of event embeddings. Experimental results on event similarity, script event prediction and stock prediction showed that commonsense knowledge enhanced event embeddings can improve the quality of event representations and benefit the downstream applications."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "We thank the anonymous reviewers for their constructive comments, and gratefully acknowledge the support of the National Key Research and Development Program of China (SQ2018AAA010010), the National Key Research and Development Program of China (2018YFB1005103), the National Natural Science Foundation of China (NSFC) via Grant 61702137."
        ]
      }
    ],
    "qas": [
      {
        "question": "How is the event prediction task evaluated?",
        "question_id": "ec62df859ad901bf0848f0a8b91eedc78dba5657",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "stock market",
        "question_writer": "486a870694ba60f1a1e7e4ec13e328164cd4b43c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "accuracy"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "BIBREF22 (BIBREF22) and BIBREF21 (BIBREF21) showed that script event prediction is a challenging problem, and even 1% of accuracy improvement is very difficult. Experimental results shown in Table TABREF31 demonstrate that we can achieve more than 1.5% improvements in single model comparison and more than 1.4% improvements in multi-model integration comparison, just by replacing the input embeddings, which confirms that better event understanding can lead to better inference results. An interesting result is that the event embeddings only incorporated with intents achieved the best result against other baselines. This confirms that capturing people's intents is helpful to infer their next plan. In addition, we notice that the event embeddings only incorporated with sentiment also achieve better performance than SGNN. This is mainly because the emotional consistency does also contribute to predicate the subsequent event."
              ],
              "highlighted_evidence": [
                "BIBREF22 (BIBREF22) and BIBREF21 (BIBREF21) showed that script event prediction is a challenging problem, and even 1% of accuracy improvement is very difficult."
              ]
            },
            "annotation_id": "1e32cb1b434ea6bc5892f2a60c7775b864e85381",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "replacing the event embeddings on SGNN and running it on the MCNC dataset",
              "evidence": [
                "Following BIBREF21 (BIBREF21), we evaluate on the standard multiple choice narrative cloze (MCNC) dataset BIBREF2. As SGNN proposed by BIBREF21 (BIBREF21) achieved state-of-the-art performances for this task, we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings."
              ],
              "highlighted_evidence": [
                "Following BIBREF21 (BIBREF21), we evaluate on the standard multiple choice narrative cloze (MCNC) dataset BIBREF2.",
                "As SGNN proposed by BIBREF21 (BIBREF21) achieved state-of-the-art performances for this task, we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings."
              ]
            },
            "annotation_id": "50a38bf2879562d9ae5ed550ac28a301e6a3aa26",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Following BIBREF21 (BIBREF21), we evaluate on the standard multiple choice narrative cloze (MCNC) dataset BIBREF2. As SGNN proposed by BIBREF21 (BIBREF21) achieved state-of-the-art performances for this task, we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings."
              ],
              "highlighted_evidence": [
                " As SGNN proposed by BIBREF21 (BIBREF21) achieved state-of-the-art performances for this task, we use the framework of SGNN, and only replace their input event embeddings with our intent and sentiment-enhanced event embeddings."
              ]
            },
            "annotation_id": "861962918e878b9b620e9755fca08f0ecc2ddc7d",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Intent and sentiment enhanced event embeddings can distinguish distinct events even with high lexical overlap, and find similar events even with low lexical overlap."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: Architecture of the joint embedding model. eventneg refers to the corrupted event tuple, which is derived by replacing each word of the event object with a random word in our dictionary. intentneg is the incorrect intent for the given event, which is randomly selected from the annotated dataset."
      },
      {
        "file": "3-Figure4-1.png",
        "caption": "Figure 4: An illustration of low-rank neural tensor network for learning event embeddings."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Baseline event-embedding model."
      },
      {
        "file": "6-Table1-1.png",
        "caption": "Table 1: Experimental results on hard similarity dataset and transitive sentence similarity dataset. The small dataset (230 event pairs) of hard similarity task from Weber et al. (2018), and the big dataset (2,000 event pairs) is annotated by us. The best results are in bold."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Case study of the cosine similarity score changes with incorporating the intent and sentiment. oScore is the original cosine similarity score without intent and sentiment, and mScore is the modified cosine similarity score with intent and sentiment."
      },
      {
        "file": "7-Table3-1.png",
        "caption": "Table 3: Results of script event prediction on the test set. The improvement is significant at p < 0.05. Acc is short for Accuracy."
      },
      {
        "file": "7-Figure5-1.png",
        "caption": "Figure 5: Experimental results on S&P 500 index prediction. \u201c+Int\u201d means that we encode the intent information into the original event embeddings."
      }
    ]
  },
  "1606.02601": {
    "title": "A Joint Model for Word Embedding and Word Morphology",
    "abstract": "This paper presents a joint model for performing unsupervised morphological analysis on words, and learning a character-level composition function from morphemes to word embeddings. Our model splits individual words into segments, and weights each segment according to its ability to predict context words. Our morphological analysis is comparable to dedicated morphological analyzers at the task of morpheme boundary recovery, and also performs better than word-based embedding models at the task of syntactic analogy answering. Finally, we show that incorporating morphology explicitly into character-level models help them produce embeddings for unseen words which correlate better with human judgments.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Word embedding models associate each word in a corpus with a vector in a semantic space. These vectors can either be learnt to optimize performance in a downstream task BIBREF0 , BIBREF1 or learnt via the distributional hypothesis: words with similar contexts have similar meanings BIBREF2 , BIBREF3 . Current word embedding models treat words as atomic. However, words follow a power law distribution BIBREF4 , and word embedding models suffer from the problem of sparsity: a word like `unbelievableness' does not appear at all in the first 17 million words of Wikipedia, even though it is derived from common morphemes. This leads to three problems:",
          "One approach to smooth word distributions is to operate on the smallest meaningful semantic unit, the morpheme BIBREF6 , BIBREF7 . However, previous work on the morpheme level has all used external morphological analyzers. These require a separate pre-processing step, and cannot be adapted to suit the problem at hand.",
          "Another is to operate on the smallest orthographic unit, the character BIBREF8 , BIBREF9 . However, the link between shape and meaning is often complicated BIBREF10 , as alphabetic characters carry no inherent semantic meaning. To account for this, the model has to learn complicated dependencies between strings of characters to accurately capture word meaning. We hypothesize that explicitly introducing morphology into character-level models can help them learn morphological features, and hence word meaning.",
          "In this paper, we introduce a word embedding model that jointly learns word morphology and word embeddings. To the best of our knowledge, this is the first word embedding model that learns morphology as part of the model. Our guiding intuition is that the words with the same stem have similar contexts. Thus, when considering word segments in terms of context-predictive power, the segment corresponding to the stem will have the most weight.",
          "Our model `reads' the word and outputs a sequence of word segments. We weight each segment, and then combine the segments to obtain the final word representation. These representations are trained to predict context words, as this has been shown to give word representations which capture word semantics well BIBREF11 . As the root morpheme has the most context-predictive power, we expect our model to assign high weight to this segment, thereby learning to separate root+affix structures.",
          "One exciting feature of character-level models is their ability to represent open-vocabulary words. After training, they can predict a vector for any word, not just words that they have seen before. Our model has an advantage in that it can split unknown words into known and unknown components. Hence, it can potentially generalise better over seen morphemes and words and apply existing knowledge to new cases.",
          "To evaluate our model, we evaluate its use as a morphological analyzer (\u00a7 \"Morphological awareness\" ), test how well it learns word semantics, including for unseen words (\u00a7 \"Capturing semantic similarity\" ), and examine the structure of the embedding space (\u00a7 \"Capturing syntactic and semantic regularity\" )."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "While words are often treated as the fundamental unit of language, they are in fact themselves compositional. The smallest unit of semantics is the morpheme, while the smallest unit of orthography is the grapheme, or character. Both have been used as a method to go beyond word-level models."
        ]
      },
      {
        "section_name": "Morphemic analysis and semantics",
        "paragraphs": [
          "As word semantics is compositional, one might ask whether it is possible to learn morpheme representations, and compose them to obtain good word representations. Lazaridou et al. lazaridou demonstrated precisely this: one can derive good representations of morphemes distributionally, and apply tools from compositional distributional semantics to obtain good word representations. Luong et al. luong also trained a morphological composition model based on recursive neural networks. Botha and Blunsom Botha2014 built a language model incorporating morphemes, and demonstrated improvements in language modelling and in machine translation. All of these approaches incorporated external morphological knowledge, either in the form of gold standard morphological analyses such as CELEX BIBREF12 or an external morphological analyzer such as Morfessor BIBREF13 .",
          "Unsupervised morphology induction aims to decide whether two words are morphologically related or to generate a morphological analysis for a word BIBREF14 , BIBREF15 . While they may use semantic insights to perform the morphological analysis BIBREF16 , they typically are not concerned with obtaining a semantic representation for morphemes, nor of the resulting word."
        ]
      },
      {
        "section_name": "Character-level models",
        "paragraphs": [
          "Another approach to go beyond words is based on on character-level neural network models. Both recurrent and convolutional architectures for deriving word representations from characters have been used, and results in downstream tasks such as language modelling and POS tagging have been promising, with reductions in word perplexity for language modelling and state-of-the-art English POS tagging accuracy BIBREF8 , BIBREF9 . Ballesteros et al. ballesteros train a character-level model for parsing. Zhang et al. zhang do away with words completely, and train a convolutional neural network to do text classification directly from characters.",
          "Excitingly, character-level models seem to capture morphological effects. Examining nearest neighbours of morphologically complex words in character-aware models often shows other words with the same morphology BIBREF8 , BIBREF9 . Furthermore, morphosyntactic features such as capitalization and suffix information have long been used in tasks such as POS tagging BIBREF17 , BIBREF18 . By explicitly modelling these features, one might expect good performance gains in many NLP tasks.",
          "What is less clear is how well these models learn word semantics. Classical word embedding models seem to capture word semantics, and the nearest neighbours of a given word are typically semantically related words BIBREF3 , BIBREF19 . In addition, the correlation between model word similarity scores and human similarity judgments is typically high BIBREF20 . However, no previous work (to our knowledge) evaluates the similarity judgments of character-level models against human annotators."
        ]
      },
      {
        "section_name": "The Char2Vec model",
        "paragraphs": [
          "We hypothesize that by incorporating morphological knowledge directly into a character-level model, one can improve the ability of character-level models to learn compositional word semantics. In addition, we hypothesize that incorporating morphological knowledge helps structure the embedding space in such a way that affixation corresponds to a regular shift in the embedding space. We test both hypotheses directly in \u00a7 \"Capturing semantic similarity\" and \u00a7 \"Capturing syntactic and semantic regularity\" respectively.",
          "The starting point for our model is the skip-gram with negative sampling (SGNS) objective of Mikolov et al. word2vec2. For a vocabulary $V$ of size $|V|$ and embedding size $N$ , SGNS learns two embedding tables $W, C \\in \\mathbb {R}^{N \\times |V|}$ , the target and context vectors. Every time a word $w$ is seen in the corpus with a context word $c$ , the tables are updated to maximize ",
          "$$\\log \\sigma (w \\cdot c) + \\sum _{i = 1}^{k} \\mathbb {E}_{\\tilde{c}_i \\sim P(w)} [\\log \\sigma (-w \\cdot \\tilde{c}_i)]$$   (Eq. 7) ",
          "where $P(w)$ is a noise distribution from which we draw $k$ negative samples. In the end, the target vector for a word $w$ should have high inner product with context vectors for words with which it is typically seen, and low inner products with context vectors for words it is not typically seen with. Figure 1 illustrates this for a particular example. In Mikolov et al. word2vec2, the noise distribution $P(w)$ is proportional to the unigram probability of a word raised to the 3/4th power BIBREF11 .",
          "Our innovation is to replace $W$ with a trainable function $f$ that accepts a sequence of characters and returns a vector of length $N$ (i.e. $f: A^{<\\omega } \\rightarrow \\mathbb {R}^N$ , where $A$ is the alphabet we are considering and $A^{<\\omega }$ denotes the finite length strings over the alphabet $A$ ). We still keep the table of context embeddings $C$ , and our model objective is still to minimize ",
          "$$\\log \\sigma (f(w) \\cdot c) + \\sum _{i = 1}^{k} \\mathbb {E}_{\\tilde{c}_i \\sim P(w)} [\\log \\sigma (-f(w) \\cdot \\tilde{c}_i)]$$   (Eq. 8) ",
          "where we now treat $w$ as a sequence of characters. After training, $f$ can be used to produce an embedding for any sequence of characters, even if it was not previously seen in training.",
          "The process of calculating $f$ on a word is illustrated in Figure 2 . We first pad the word with beginning and end of word tokens, and then pass the characters of the word into a character lookup table. As the link between characters and morphemes is non-compositional and requires essentially memorizing a sequence of characters, we use LSTMs BIBREF21 to encode the letters in the word, as they have been shown to capture non-local and non-linear dependencies. We run a forward and a backward LSTM over the character embeddings. The forward LSTM reads the beginning of word symbol, but not the end of word symbol, and the backward LSTM reads the end of word symbol but not the beginning of word symbol. This is necessary to align the resulting embeddings, so that the LSTM hidden states taken together correspond to a partition of the word into two without overlap.",
          "The LSTMs output two sequences of vectors $h_0^{f}, \\dots , h_n^f$ and $h_n^{b}, \\dots , h_0^b$ . We then concatenate the resulting vectors, and pass them through a shared feed-forward layer to obtain a final sequence of vectors $h_i$ . Each vector corresponds to two half-words: one half read by the forward LSTM, and the other by the backward LSTM.",
          "We then learn an attention model over these hidden states: given a hidden state $h_i$ , we calculate a weight $\\alpha _i = a(h_i)$ such that $\\sum \\alpha _i = 1$ , and then calculate the resulting vector for the word $w$ as $f(w) = \\sum \\alpha _i h_i$ . Following Bahdanau et al. bahdanau, we calculate $a$ as ",
          "$$a(h_i) = \\frac{\\exp (v^{T} \\tanh (Wh_i))}{\\sum _j \\exp (v^{T} \\tanh (Wh_j))}$$   (Eq. 10) ",
          "i.e. a softmax over the hidden states."
        ]
      },
      {
        "section_name": "Capturing morphology via attention",
        "paragraphs": [
          "Previous work on bidirectional LSTM character-level models used both LSTMs to read the entire word BIBREF8 , BIBREF22 . This can lead to redundancy, as both LSTMs are used to capture the full word. In contrast, our model is capable of splitting the words and optimizing the two LSTMs for modelling different halves. This means one of the LSTMs can specialize on word prefixes and roots, while the other memorizes possible suffixes. In addition, when dealing with an unknown word, it can be split into known and unknown components. The model can then use the semantic knowledge it has learnt for a known component to predict a representation for the unknown word as a whole.",
          "We hypothesize that the natural place to split words is on morpheme boundaries, as morphemes are the smallest unit of language which carry semantic meaning. We test the splitting capabilities of our model in \u00a7 \"Morphological awareness\" ."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We evaluate our model on three tasks: morphological analysis (\u00a7 \"Morphological awareness\" ), semantic similarity (\u00a7 \"Capturing semantic similarity\" ), and analogy retrieval (\u00a7 \"Capturing syntactic and semantic regularity\" ). We trained all of the models once, and then use the same trained model for all three tasks \u2013 we do not perform hyperparameter tuning to optimize performance on each task.",
          "We trained our Char2Vec model on the Text8 corpus, consisting of the first 100MB of a 2006 cleaned-up dump of Wikipedia. We only trained on words which appeared more than 5 times in our corpus. We used a context window size of 3 words either side of the target word, and took 11 negative samples per positive sample, using the same smoothed unigram distribution as word2vec. The model was trained for 3 epochs using the Adam optimizer BIBREF23 . All experiments were carried out using Keras BIBREF24 and Theano BIBREF25 , BIBREF26 . We initialized the context lookup table using word2vec, and kept it fixed during training. In all character-level models, the character embeddings have dimension $d_C = 64$ , while the forward and backward LSTMs have dimension $d_{LSTM} = 256$ . The concatenation of both therefore has dimensionality $d = 512$ . The concatenated LSTM hidden states are then compressed down to $d_{word} = 256$ by a feed-forward layer.",
          "As baselines, we trained a SGNS model on the same dataset with the same parameters. To test how much the attention model helps the character-level model to generalize, we also trained the Char2Vec model without the attention layer, but with the same parameters. In this model, the word embeddings are just the concatenation of the final forward and backward states, passed through a feedforward layer. We refer to this model as C2V-NO-ATT. We also constructed count-based vectors using SVD on PPMI-weighted co-occurence counts, with a window size of 3. We kept the top 256 principal components in the SVD decomposition, to obtain embeddings with the same size as our other models."
        ]
      },
      {
        "section_name": "Morphological awareness",
        "paragraphs": [
          "The main innovation of our Char2Vec model compared to existing recurrent character-level models is the capability to split words and model each half independently. Here we test whether our model segmentations correspond to gold-standard morphological analyses.",
          "We obtained morphological analyses for all the words in our training vocabulary which were in the English Lexicon Project BIBREF27 . We then converted these into surface-level segmentations using heuristic affix-matching, and used this as a gold-standard morphemic analysis. We ended up with 14682 words, of which 7867 have at least two morphemes and 1138 have at least three.",
          "Evaluating morphological segmentation is a long-debated issue BIBREF28 . Traditional hard morphological analyzers are normally evaluated on border $F_1$ \u2013 that is, how many morpheme borders are recovered. However, our model does not actually posit any hard morpheme borders. Instead, it just associates each character boundary with a weight. Therefore, we treat the problem of recovering intra-word morpheme boundaries as a ranking problem. We rank each inter-character boundary of a word according to our model weights, and then evaluate whether our model ranks morpheme boundaries above non-morpheme boundaries.",
          "We use mean average precision (MAP) as our evaluation metric. We first calculate precision at $N$ for each word, until all the gold standard morpheme boundaries have been recovered. Then, we average over $N$ to obtain the average precision (AP) for that word. We then calculate the mean of the APs across all words to obtain the MAP for the model.",
          "We report results of a random baseline as a point of comparison, which randomly places morpheme boundaries inside the word. We also report the results of the Porter stemmer, where we place a morpheme boundary at the end of the stem, then randomly thereafter.",
          "Finally, we trained Morfessor 2.0 BIBREF13 on our corpus, using an initial random split value of 0.9, and stopping training when the difference in loss between successive epochs is less than 0.1% of the total loss. We then used our trained Morfessor model to predict morpheme boundaries, and randomly permuted the morpheme boundaries and ranked them ahead of randomly permuted non-morpheme boundaries to calculate MAP.",
          "As the test set is dominated by words with simple morphology, we also extracted all the morphologically rich words with 3 or more morphemes, and created a separate evaluation on this subsection. We report the results in Table 1 .",
          "As the results show, our model performs the best out of all the methods at analysing morphologically rich words with multiple morphemes. On these words, our model even outperforms Morfessor, which is explicitly designed as a morphological analyzer. This shows that our model learns splits which correspond well to human morphological analysis, even though we build no morphological knowledge into our model. However, when evaluating on all words, the Porter stemmer has a great advantage, as it is rule-based and able to give just the stem of words with great precision, which is effectively giving a canonical segmentation for words with just 2 morphemes.",
          "We show some model analyses against the gold standard in Table 2 ."
        ]
      },
      {
        "section_name": "Capturing semantic similarity",
        "paragraphs": [
          "Next, we tested our model similarity scores against human similarity judgments. For these datasets, human annotators are asked to judge how similar two words are on a fixed scale. Model word vectors are evaluated based on ranking the word pairs according to their cosine similarity, and then measuring the correlation (using Spearman's $\\rho $ ) between model judgments and human judgments BIBREF20 .",
          "We use the WordSim353 dataset BIBREF29 , the test split of the MEN dataset BIBREF30 , and the Rare Word (RW) dataset BIBREF31 . The word pairs in the WordSim353 and MEN datasets are typically simple, commonly occurring words denoting basic concepts, whereas the RW dataset contains many morphologically derived words which have low corpus frequencies. This is reflected by how many of the test pairs in each dataset contain out of vocabulary (OOV) items: 3/353 and 6/1000 of the word pairs in WordSim353 and MEN, compared with 1083/2034 for the RW dataset.",
          "We report results for in-corpus word pairs in Table 3 , and for all word pairs for those models able to predict vectors for unseen words in Table 4 .",
          "Overall, word-based embedding models learn vectors that correlate better with human judgments, particularly for morphologically simple words. However, character-based models are competitive with word-based models on the RW dataset. While the words in this dataset appear rarely in our corpus (of the in-corpus words, over half appear fewer than 100 times), each morpheme may be common, and the character-level models can use this information. We note that on the entire RW dataset (of which over half contain an OOV word), the character-based models still perform reasonably. We also note that on word pairs in the RW test containing at least one OOV word, the full Char2Vec model outperforms the C2V model without morphology. This suggests that character-based embedding models are learning to morphologically analyse complex word forms, even on unseen words, and that giving the model the capability to learn word segments independently helps this process.",
          "We also present some word nearest neighbours for our Char2Vec model in Table 5 , both on the whole vocabulary and then filtering the nearest neighbours to only include words which appear 100 times or more in our corpus. This corresponds to keeping the top 10k words, which is common among language models BIBREF8 , BIBREF9 . We note that nearest neighbour predictions include words that are orthographically distant but semantically similar, showing that our model has the capability to learn to compose characters into word meanings.",
          "We also note that word nearest neighbours seem to be more semantically coherent when rarely-observed words are filtered out of the vocabulary, and more based on orthographic overlap when the entire vocabulary is included. This suggests that for rarely-observed words, the model is basing its predictions on orthographic analysis, whereas for more commonly observed words it can `memorize' the mapping between the orthography and word semantics."
        ]
      },
      {
        "section_name": "Capturing syntactic and semantic regularity",
        "paragraphs": [
          "Finally, we evaluate the structure of the embedding space of our various models. In particular, we test whether affixation corresponds to regular linear shifts in the embedding space.",
          "To do this, we use the Google analogy dataset BIBREF3 . This consists of 19544 questions of the form \u201cA is to B as C is to X\u201d. We split this collection into semantic and syntactic sections, based on whether the analogies between the words are driven by morphological changes or deeper semantic shifts. Example semantic questions are on capital-country relationships (\u201cParis is to France as Berlin is to X) and currency-country relationships. Example syntactic questions are adjective-adverb relationships (\u201camazing is to amazingly as apparent is to X\u201d) and opposites formed by prefixing a negation particle (\u201cacceptable is to unacceptable as aware is to X\u201d). This results in 5537 semantic analogies and 10411 syntactic analogies.",
          "We use the method of Mikolov et al. word2vec1 to answer these questions. We first $\\ell _2$ -normalize all of our word vectors. Then, to answer a question of the form \u201cA is to B as C is to X\u201d, we find the word $w$ which satisfies ",
          "$$w = \\operatornamewithlimits{argmax}_{w \\in V - \\lbrace a, b, c\\rbrace } \\cos (w, b - a + c)$$   (Eq. 28) ",
          "where $a,\\, b,\\, c$ are the word vectors for the words A, B and C respectively.",
          "We report the results in Table 6 . The most intriguing result is that character-level models are competitive with word-level models for syntactic analogy, with our Char2Vec model holding the best result for syntactic analogy answering. This suggests that incorporating morphological knowledge explicitly rather than latently helps the model learn morphological features. However, on the semantic analogies, the character-based models do much worse than the word-based models. This is perhaps unsurprising in light of the previous section, where we demonstrate that character-based models do worse at the semantic similarity task than word-level models."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "We only report results for English. However, English is a morphologically impoverished language, with little inflection and relatively few productive patterns of derivation. Our morphology test set reflects this, with over half the words consisting of a simple morpheme, and over 90% having at most 2 morphemes.",
          "This is unfortunate for our model, as it performs better on words with richer morphology. It gives consistently more accurate morphological analyses for these words compared to standard baselines, and matches word-level models for semantic similarity on rare words with rich morphology. In addition, it seems to learn morphosyntactic features to help solve the syntactic analogy task. Most of all, it is language-agnostic, and easy to port across different languages. We thus expect our model to perform even better for languages with a richer morphology than English, such as Turkish and German."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we present a model which learns morphology and word embeddings jointly. Given a word, it splits the word in to segments and ranks the segments based on their context-predictive power. Our model can segment words into morphemes, and also embed the word into a representation space.",
          "We show that our model is competitive at the task of morpheme boundary recovery compared to a dedicated morphological analyzer, beating dedicated analyzers on words with a rich morphology. We also show that in the representation space word affixation corresponds to linear shifts, demonstrating that our model can learn morphological features.",
          "Finally, we show that character-level models, while outperformed by word-level models generally at the task of semantic similarity, are competitive at representing rare morphologically rich words. In addition, the character-level models can predict good quality representations for unseen words, with the morphologically aware character-level model doing slightly better."
        ]
      }
    ],
    "qas": [
      {
        "question": "Is there a difference between the model's performance for morphologically impoverished and morphologically complex languages?",
        "question_id": "2b75df325c98b761faf2fecf6e71ac7366eb15ea",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "somewhat",
        "search_query": "morphology",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "They did not report results for English but expect that morphologically complex languages will perform better.",
              "evidence": [
                "We only report results for English. However, English is a morphologically impoverished language, with little inflection and relatively few productive patterns of derivation. Our morphology test set reflects this, with over half the words consisting of a simple morpheme, and over 90% having at most 2 morphemes.",
                "This is unfortunate for our model, as it performs better on words with richer morphology. It gives consistently more accurate morphological analyses for these words compared to standard baselines, and matches word-level models for semantic similarity on rare words with rich morphology. In addition, it seems to learn morphosyntactic features to help solve the syntactic analogy task. Most of all, it is language-agnostic, and easy to port across different languages. We thus expect our model to perform even better for languages with a richer morphology than English, such as Turkish and German."
              ],
              "highlighted_evidence": [
                "We only report results for English.",
                "We only report results for English. However, English is a morphologically impoverished language, with little inflection and relatively few productive patterns of derivation.",
                "This is unfortunate for our model, as it performs better on words with richer morphology. It gives consistently more accurate morphological analyses for these words compared to standard baselines, and matches word-level models for semantic similarity on rare words with rich morphology.",
                "We thus expect our model to perform even better for languages with a richer morphology than English, such as Turkish and German."
              ]
            },
            "annotation_id": "17d6e12f71e32614d5e4857d2e5e302a114b362b",
            "worker_id": "0bef3d73d87da2395d3e86b22aef3d3bc5a05057"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "661dc949661c6d352bce6540b8eca10a5270ac76",
            "worker_id": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "This is unfortunate for our model, as it performs better on words with richer morphology. It gives consistently more accurate morphological analyses for these words compared to standard baselines, and matches word-level models for semantic similarity on rare words with rich morphology. In addition, it seems to learn morphosyntactic features to help solve the syntactic analogy task. Most of all, it is language-agnostic, and easy to port across different languages. We thus expect our model to perform even better for languages with a richer morphology than English, such as Turkish and German."
              ],
              "highlighted_evidence": [
                "This is unfortunate for our model, as it performs better on words with richer morphology. It gives consistently more accurate morphological analyses for these words compared to standard baselines, and matches word-level models for semantic similarity on rare words with rich morphology."
              ],
              "yes_no": true,
              "free_form_answer": "",
              "extractive_spans": []
            },
            "annotation_id": "db425b513e03139fbf9fa4ec6ecfc49497e024d2",
            "worker_id": "8bbf73085923ab9804349bd5ec1c51469b3928bd"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: A graphical illustration of SGNS. The target vector for \u2018dog\u2019 is learned to have high inner product with the context vectors for words seen in the context of \u2018dog\u2019 (no shading), while having low inner product with random negatively sampled words (shaded)"
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: An illustration of Char2Vec. A bidirectional LSTM reads the word (start and end of word symbols represented by \u02c6 and $ respectively), outputting a sequence of hidden states. These are then passed through a feed-forward layer (not shown), weighted by an attention model (the square box in the diagram) and summed to obtain the final word representation."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: An illustration of the attention model (start and end of word symbols omitted). The root morpheme contributes the most to predicting the context, and is upweighted. In contrast, another potential split is inaccurate, and predicts the wrong context words. This is downweighted."
      },
      {
        "file": "6-Table1-1.png",
        "caption": "Table 1: Results at retrieving intra-word morpheme boundaries."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Similarity correlations of in-vocabulary word pairs between the models and human annotators."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Morphological analyses for sample words from the corpus. We take the top N model predictions as the split points, where N is the number of gold-standard morphemes in the word."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Similarity correlations of all word pairs between the character-level models and human annotators. RW OOV indicates results specifically on pairs in the RW dataset with at least one word not seen in the training corpus."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: Filtered and unfiltered model nearest neighbours for some in-vocabulary and out-of-vocabulary words"
      },
      {
        "file": "7-Table6-1.png",
        "caption": "Table 6: Results on the Google analogy task"
      }
    ]
  },
  "1602.04341": {
    "title": "Attention-Based Convolutional Neural Network for Machine Comprehension",
    "abstract": "Understanding open-domain text is one of the primary challenges in natural language processing (NLP). Machine comprehension benchmarks evaluate the system's ability to understand text based on the text content only. In this work, we investigate machine comprehension on MCTest, a question answering (QA) benchmark. Prior work is mainly based on feature engineering approaches. We come up with a neural network framework, named hierarchical attention-based convolutional neural network (HABCNN), to address this task without any manually designed features. Specifically, we explore HABCNN for this task by two routes, one is through traditional joint modeling of passage, question and answer, one is through textual entailment. HABCNN employs an attention mechanism to detect key phrases, key sentences and key snippets that are relevant to answering the question. Experiments show that HABCNN outperforms prior deep learning approaches by a big margin.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Endowing machines with the ability to understand natural language is a long-standing goal in NLP and holds the promise of revolutionizing the way in which people interact with machines and retrieve information. Richardson et al. richardson2013mctest proposed the task of machine comprehension, along with MCTest, a question answering dataset for evaluation. The ability of the machine to understand text is evaluated by posing a series of questions, where the answer to each question can be found only in the associated text. Solutions typically focus on some semantic interpretation of the text, possibly with some form of probabilistic or logic inference, to answer the question. Despite intensive recent work BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 , the problem is far from solved.",
          "Machine comprehension is an open-domain question-answering problem which contains factoid questions, but the answers can be derived by extraction or induction of key clues. Figure FIGREF1 shows one example in MCTest. Each example consists of one document, four associated questions; each question is followed by four answer candidates in which only one is correct. Questions in MCTest have two categories: \u201cone\u201d and \u201cmultiple\u201d. The label means one or multiple sentences from the document are required to answer this question. To correctly answer the first question in the example, the two blue sentences are required; for the second question instead, only the red sentence can help. The following observations hold for the whole MCTest. (i) Most of the sentences in the document are irrelavent for a given question. It hints that we need to pay attention to just some key regions. (ii) The answer candidates can be flexible text in length and abstraction level, and probably do not appear in the document. For example, candidate B for the second question is \u201coutside\u201d, which is one word and does not exist in the document, while the answer candidates for the first question are longer texts with some auxiliary words like \u201cBecause\u201d in the text. This requires our system to handle flexible texts via extraction as well as abstraction. (iii) Some questions require multiple sentences to infer the answer, and those vital sentences mostly appear close to each other (we call them snippet). Hence, our system should be able to make a choice or compromise between potential single-sentence clue and snippet clue.",
          "Prior work on this task is mostly based on feature engineering. This work, instead, takes the lead in presenting a deep neural network based approach without any linguistic features involved.",
          "Concretely, we propose HABCNN, a hierarchical attention-based convolutional neural network, to address this task in two roadmaps. In the first one, we project the document in two different ways, one based on question-attention, one based on answer-attention and then compare the two projected document representations to determine whether the answer matches the question. In the second one, every question-answer pair is reformatted into a statement, then the whole task is treated through textual entailment.",
          "In both roadmaps, convolutional neural network (CNN) is explored to model all types of text. As human beings usually do for such a QA task, our model is expected to be able to detect the key snippets, key sentences, and key words or phrases in the document. In order to detect those informative parts required by questions, we explore an attention mechanism to model the document so that its representation contains required information intensively. In practice, instead of imitating human beings in QA task top-down, our system models the document bottom-up, through accumulating the most relevant information from word level to snippet level.",
          "Our approach is novel in three aspects. (i) A document is modeled by a hierarchical CNN for different granularity, from word to sentence level, then from sentence to snippet level. The reason of choosing a CNN rather than other sequence models like recurrent neural network BIBREF4 , long short-term memory unit (LSTM BIBREF5 ), gated recurrent unit (GRU BIBREF6 ) etc, is that we argue CNNs are more suitable to detect the key sentences within documents and key phrases within sentences. Considering again the second question in Figure FIGREF1 , the original sentence \u201cThey sat by the fire and talked about he insects\u201d has more information than required, i.e, we do not need to know \u201cthey talked about the insects\u201d. Sequence modeling neural networks usually model the sentence meaning by accumulating the whole sequence. CNNs, with convolution-pooling steps, are supposed to detect some prominent features no matter where the features come from. (ii) In the example in Figure FIGREF1 , apparently not all sentences are required given a question, and usually different snippets are required by different questions. Hence, the same document should have different representations based on what the question is. To this end, attentions are incorporated into the hierarchical CNN to guide the learning of dynamic document representations which closely match the information requirements by questions. (iii) Document representations at sentence and snippet levels both are informative for the question, a highway network is developed to combine them, enabling our system to make a flexible tradeoff.",
          "Overall, we make three contributions. (i) We present a hierarchical attention-based CNN system \u201cHABCNN\u201d. It is, to our knowledge, the first deep learning based system for this MCTest task. (ii) Prior document modeling systems based on deep neural networks mostly generate generic representation, this work is the first to incorporate attention so that document representation is biased towards the question requirement. (iii) Our HABCNN systems outperform other deep learning competitors by big margins."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Existing systems for MCTest task are mostly based on manually engineered features. Representative work includes BIBREF7 , BIBREF3 , BIBREF8 , BIBREF9 . In these works, a common route is first to define a regularized loss function based on assumed feature vectors, then the effort focuses on designing effective features based on various rules. Even though these researches are groundbreaking for this task, their flexibility and their capacity for generalization are limited.",
          "Deep learning based approaches appeal to increasing interest in analogous tasks. Weston et al., weston2014memory introduce memory networks for factoid QA. Memory network framework is extended in BIBREF1 , BIBREF10 for Facebook bAbI dataset. Peng et al. PengLLW15's Neural Reasoner infers over multiple supporting facts to generate an entity answer for a given question and it is also tested on bAbI. All of these works deal with some short texts with simple-grammar, aiming to generate an answer which is restricted to be one word denoting a location, a person etc.",
          "Some works also tried over other kinds of QA tasks. For example, Iyyer et al., iyyer2014neural present QANTA, a recursive neural network, to infer an entity based on its description text. This task is basically a matching between description and entity, no explicit question exist. Another difference with us lies in that all the sentences in the entity description actually contain partial information about the entity, hence a description is supposed to have only one representation. However in our task, the modeling of document should be dynamically changed according to the question analysis. Hermann et al., hermann2015teaching incorporate attention mechanism into LSTM for a QA task over news text. Still, their work does not handle some complex question types like \u201cWhy...\u201d, they merely aim to find the entity from the document to fill the slot in the query so that the completed query is true based on the document. Nevertheless, it inspires us to treat our task as a textual entailment problem by first reformatting question-answer pairs into statements.",
          "Some other deep learning systems are developed for answer selection task BIBREF11 , BIBREF12 , BIBREF13 , BIBREF14 , BIBREF15 . Differently, this kind of question answering task does not involve document comprehension. They only try to match the question and answer candidate without any background information. Instead, we treat machine comprehension in this work as a question-answer matching problem under background guidance.",
          "Overall, for open-domain MCTest machine comprehension task, this work is the first to resort to deep neural networks."
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "We investigate this task by three approaches, illustrated in Figure FIGREF2 . (i) We can compute two different document (D) representations in a common space, one based on question (Q) attention, one based on answer (A) attention, and compare them. This architecture we name HABCNN-QAP. (ii) We compute a representation of D based on Q attention (as before), but now we compare it directly with a representation of A. We name this architecture HABCNN-QP. (iii) We treat this QA task as textual entailment (TE), first reformatting Q-A pair into a statement (S), then matching S and D directly. This architecture we name HABCNN-TE. All three approaches are implemented in the common framework HABCNN."
        ]
      },
      {
        "section_name": "HABCNN",
        "paragraphs": [
          "Recall that we use the abbreviations A (answer), Q (question), S (statement), D (document). HABCNN performs representation learning for triple (Q, A, D) in HABCNN-QP and HABCNN-QAP, for tuple (S, D) in HABCNN-TE. For convenience, we use \u201cquery\u201d to refer to Q, A, or S uniformly. HABCNN, depicted in Figure FIGREF3 , has the following phases.",
          "Input Layer. The input is (query,D). Query is two individual sentences (for Q, A) or one single sentence (for S), D is a sequence of sentences. Words are initialized by INLINEFORM0 -dimensional pre-trained word embeddings. As a result, each sentence is represented as a feature map with dimensionality of INLINEFORM1 ( INLINEFORM2 is sentence length). In Figure FIGREF3 , each sentence in the input layer is depicted by a rectangle with multiple columns.",
          "Sentence-CNN. Sentence-CNN is used for sentence representation learning from word level. Given a sentence of length INLINEFORM0 with a word sequence: INLINEFORM1 , let vector INLINEFORM2 be the concatenated embeddings of INLINEFORM3 words INLINEFORM4 where INLINEFORM5 is the filter width, INLINEFORM6 is the dimensionality of word representations and INLINEFORM7 . Embeddings for words INLINEFORM8 , INLINEFORM9 and INLINEFORM10 , are zero padding. We then generate the representation INLINEFORM11 for the phrase INLINEFORM12 using the convolution weights INLINEFORM13 : DISPLAYFORM0 ",
          "where bias INLINEFORM0 . INLINEFORM1 is called \u201ckernel size\u201d in CNN.",
          "Note that the sentence-CNNs for query and all document sentences share the same weights, so that the resulting sentence representations are comparable.",
          "Sentence-Level Representation. The sentence-CNN generates a new feature map (omitted in Figure FIGREF3 ) for each input sentence, one column in the feature map denotes a phrase representation (i.e., INLINEFORM0 in Equation (1)).",
          "For the query and each sentence of D, we do element-wise 1-max-pooling (\u201cmax-pooling\u201d for short) BIBREF16 over phrase representations to form their representations at this level.",
          "We now treat D as a set of \u201cvital\u201d sentences and \u201cnoise\u201d sentences. We propose attention-pooling to learn the sentence-level representation of D as follows: first identify vital sentences by computing attention for each D's sentence as the cosine similarity between the its representation and the query representation, then select the INLINEFORM0 highest-attention sentences to do max-pooling over them. Taking Figure FIGREF3 as an example, based on the output of sentence-CNN layer, INLINEFORM1 important sentences with blue color are combined by max-pooling as the sentence-level representation INLINEFORM2 of D; the other \u2013 white-color \u2013 sentence representations are neglected as they have low attentions. (If INLINEFORM3 , attention-pooling returns to the common max-pooling in BIBREF16 .) When the query is (Q,A), this step will be repeated, once for Q, once for A, to compute representations of D at the sentence level that are biased with respect to Q and A, respectively.",
          "Snippet-CNN. As the example in Figure FIGREF1 shows, to answer the first question \u201cwhy did Grandpa answer the door?\u201d, it does not suffice to compare this question only to the sentence \u201cGrandpa answered the door with a smile and welcomed Jimmy inside\u201d; instead, the snippet \u201cFinally, Jimmy arrived at Grandpa's house and knocked. Grandpa answered the door with a smile and welcomed Jimmy inside\u201d should be used to compare. To this end, it is necessary to stack another CNN layer, snippet-CNN, to learn representations of snippets, i.e., units of one or more sentences. Thus, the basic units input to snippet-CNN (resp. sentence-CNN) are sentences (resp. words) and the output is representations of snippets (resp. sentences).",
          "Concretely, snippet-CNN puts all sentence representations in column sequence as a feature map and conducts another convolution operation over it. With filter width INLINEFORM0 , this step generates representation of snippet with INLINEFORM1 consecutive sentences. Similarly, we use the same CNN to learn higher-abstraction query representations (just treating query as a document with only one sentence, so that the higher-abstraction query representation is in the same space with corresponding snippet representations).",
          "Snippet-Level Representation. For the output of snippet-CNN, each representation is more abstract and denotes bigger granularity. We apply the same attention-pooling process to snippet level representations: attention values are computed as cosine similarities between query and snippets and the snippets with the INLINEFORM0 largest attentions are retained. Max-pooling over the INLINEFORM1 selected snippet representations then creates the snippet-level representation INLINEFORM2 of D. Two selected snippets are shown as red in Figure FIGREF3 .",
          "Overall Representation. Based on convolution layers at two different granularity, we have derived query-biased representations of D at sentence level (i.e., INLINEFORM0 ) as well as snippet level (i.e., INLINEFORM1 ). In order to create a flexible choice for open Q/A, we develop a highway network BIBREF17 to combine the two levels of representations as an overall representation INLINEFORM2 of D: DISPLAYFORM0 ",
          "where highway network weights INLINEFORM0 are learned by DISPLAYFORM0 ",
          "where INLINEFORM0 . With the same highway network, we can generate the overall query representation, INLINEFORM1 in Figure FIGREF3 , by combining the two representations of the query at sentence and snippet levels."
        ]
      },
      {
        "section_name": "HABCNN-QP & HABCNN-QAP",
        "paragraphs": [
          "HABCNN-QP/QAP computes the representation of D as a projection of D, either based on attention from Q or based on attention from A. We hope that these two projections of the document are close for a correct A and less close for an incorrect A. As we said in related work, machine comprehension can be viewed as an answer selection task using the document D as critical background information. Here, HABCNN-QP/QAP do not compare Q and A directly, but they use Q and A to filter the document differently, extracting what is critical for the Q/A match by attention-pooling. Then they match the two document representations in the new space.",
          "For ease of exposition, we have used the symbol INLINEFORM0 so far, but in HABCNN-QP/QAP we compute two different document representations: INLINEFORM1 , for which attention is computed with respect to Q; and INLINEFORM2 for which attention is computed with respect to A. INLINEFORM3 also has two versions, one for Q: INLINEFORM4 , one for A: INLINEFORM5 .",
          "HABCNN-QP and HABCNN-QAP make different use of INLINEFORM0 . HABCNN-QP compares INLINEFORM1 with answer representation INLINEFORM2 . HABCNN-QAP compares INLINEFORM3 with INLINEFORM4 . HABCNN-QAP projects D twice, once based on attention from Q, once based on attention from A and compares the two projected representations, shown in Figure FIGREF2 (top). HABCNN-QP only utilizes the Q-based projection of D and then compares the projected document with the answer representation, shown in Figure FIGREF2 (middle)."
        ]
      },
      {
        "section_name": "HABCNN-TE",
        "paragraphs": [
          "HABCNN-TE treats machine comprehension as textual entailment. We use the statements that are provided as part of MCTest. Each statement corresponds to a question-answer pair; e.g., the Q/A pair \u201cWhy did Grandpa answer the door?\u201d / \u201cBecause he saw the insects\u201d (Figure FIGREF1 ) is reformatted into the statement \u201cGrandpa answered the door because he saw the insects\u201d. The question answering task is then cast as: \u201cdoes the document entail the statement?\u201d",
          "For HABCNN-TE, shown in Figure FIGREF2 (bottom), the input for Figure FIGREF3 is the pair (S,D). HABCNN-TE tries to match the S's representation INLINEFORM0 with the D's representation INLINEFORM1 ."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "MCTest has two subsets. MCTest-160 is a set of 160 items, each consisting of a document, four questions followed by one correct anwer and three incorrect answers (split into 70 train, 30 dev and 60 test) and MCTest-500 a set of 500 items (split into 300 train, 50 dev and 150 test)."
        ]
      },
      {
        "section_name": "Training Setup and Tricks",
        "paragraphs": [
          "Our training objective is to minimize the following ranking loss function: DISPLAYFORM0 ",
          "where INLINEFORM0 is a matching score between two representation vectors. Cosine similarity is used throughout. INLINEFORM1 is a constant.",
          "For this common ranking loss, we also have two styles to utilize the data in view of each positive answer is accompanied with three negative answers. One is treating ( INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 , INLINEFORM4 ) as a training example, then our loss function can have three \u201cmax()\u201d terms, each for a positive-negative pair; the other one is treating ( INLINEFORM5 , INLINEFORM6 , INLINEFORM7 ) as an individual training example. In practice, we find the second way works better. We conjecture that the second way has more training examples, and positive answers are repeatedly used to balance the amounts of positive and negative answers.",
          "Multitask learning: Question typing is commonly used and proved to be very helpful in QA tasks BIBREF3 . Inspired, we stack a logistic regression layer over question representation INLINEFORM0 , with the purpose that this subtask can favor the parameter tuning of the whole system, and finally the question is better recognized and is able to find the answer more accurately.",
          "To be specific, we classify questions into 12 classes: \u201chow\u201d, \u201chow much\u201d, \u201chow many\u201d, \u201cwhat\u201d, \u201cwho\u201d, \u201cwhere\u201d, \u201cwhich\u201d, \u201cwhen\u201d, \u201cwhose\u201d, \u201cwhy\u201d, \u201cwill\u201d and \u201cother\u201d. The question label is created by querying for the label keyword in the question. If more than one keyword appears in a question, we adopt the one appearing earlier and the more specific one (e.g., \u201chow much\u201d, not \u201chow\u201d). In case there is no match, the class \u201cother\u201d is assigned.",
          "We train with AdaGrad BIBREF18 and use 50-dimensional GloVe BIBREF19 to initialize word representations, kept fixed during training. Table TABREF15 gives hyperparameter values, tuned on dev.",
          "We consider two evaluation metrics: accuracy (proportion of questions correctly answered) and NDCG INLINEFORM0 BIBREF20 . Unlike accuracy which evaluates if the question is correctly answered or not, NDCG INLINEFORM1 , being a measure of ranking quality, evaluates the position of the correct answer in our predicted ranking."
        ]
      },
      {
        "section_name": "Baseline Systems",
        "paragraphs": [
          "This work focuses on the comparison with systems about distributed representation learning and deep learning:",
          "Addition. Directly compare question and answers without considering the D. Sentence representations are computed by element-wise addition over word representations.",
          "Addition-proj. First compute sentence representations for Q, A and all D sentences as the same way as Addition, then match the two sentences in D which have highest similarity with Q and A respectively.",
          "NR. The Neural Reasoner BIBREF21 has an encoding layer, multiple reasoning layers and a final answer layer. The input for the encoding layer is a question and the sentences of the document (called facts); each sentence is encoded by a GRU into a vector. In each reasoning layer, NR lets the question representation interact with each fact representation as reasoning process. Finally, all temporary reasoning clues are pooled as answer representation.",
          "AR. The Attentive Reader BIBREF2 is implemented by modeling the whole D as a word sequence \u2013 without specific sentence / snippet representations \u2013 using an LSTM. Attention mechanism is implemented at word representation level.",
          "Overall, baselines Addition and Addition-proj do not involve complex composition and inference. NR and AR represent the top-performing deep neural networks in QA tasks."
        ]
      },
      {
        "section_name": "HABCNN Variants",
        "paragraphs": [
          "In addition to the main architectures described above, we also explore two variants of ABCHNN, inspired by BIBREF21 and BIBREF2 , respectively.",
          "Variant-I: As RNNs are widely recognized as a competitor of CNNs in sentence modeling, similar with BIBREF21 , we replace the sentence-CNN in Figure FIGREF3 by a GRU while keeping other parts unchanged.",
          "Variant-II: How to model attention at the granularity of words was shown in BIBREF2 ; see their paper for details. We develop their attention idea and model attention at the granularity of sentence and snippet. Our attention gives different weights to sentences/snippets (not words), then computes the document representation as a weighted average of all sentence/snippet representations."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Table TABREF16 lists the performance of baselines, HABCNN-TE variants, HABCNN systems in the first, second and last block, respectively (we only report variants for top-performing HABCNN-TE). Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500. This demonstrates the promise of our architecture in this task.",
          "As said before, both AR and NR systems aim to generate answers in entity form. Their designs might not suit this machine comprehension task, in which the answers are openly-formed based on summarizing or abstracting the clues. To be more specific, AR models D always at word level, attentions are also paid to corresponding word representations, which is applicable for entity-style answers, but is less suitable for comprehension at sentence level or even snippet level. NR contrarily models D in sentence level always, neglecting the discovering of key phrases which however compose most of answers. In addition, the attention of AR system and the question-fact interaction in NR system both bring large numbers of parameters, this potentially constrains their power in a dataset of limited size.",
          "For Variant-I and Variant-II (second block of Table TABREF16 ), we can see that both modifications do harm to the original HABCNN-TE performance. The first variant, i.e, replacing the sentence-CNN in Figure FIGREF3 as GRU module is not helpful for this task. We suspect that this lies in the fundamental function of CNN and GRU. The CNN models a sentence without caring about the global word order information, and max-pooling is supposed to extract the features of key phrases in the sentence no matter where the phrases are located. This property should be useful for answer detection, as answers are usually formed by discovering some key phrases, not all words in a sentence should be considered. However, a GRU models a sentence by reading the words sequentially, the importance of phrases is less determined by the question requirement. The second variant, using a more complicated attention scheme to model biased D representations than simple cosine similarity based attention used in our model, is less effective to detect truly informative sentences or snippet. We doubt such kind of attention scheme when used in sentence sequences of large size. In training, the attention weights after softmax normalization have actually small difference across sentences, this means the system can not distinguish key sentences from noise sentences effectively. Our cosine similarity based attention-pooling, though pretty simple, is able to filter noise sentences more effectively, as we only pick top- INLINEFORM0 pivotal sentences to form D representation finally. This trick makes the system simple while effective."
        ]
      },
      {
        "section_name": "Case Study and Error Analysis",
        "paragraphs": [
          "In Figure FIGREF17 , we visualize the attention distribution at sentence level as well as snippet level for the statement \u201c Grandpa answered the door because Jimmy knocked\u201d whose corresponding question requires multiple sentences to answer. From its left part, we can see that \u201cGrandpa answered the door with a smile and welcomed Jimmy inside\u201d has the highest attention weight. This meets the intuition that this sentence has semantic overlap with the statement. And yet this sentence does not contain the answer. Look further the right part, in which the CNN layer over sentence-level representations is supposed to extract high-level features of snippets. In this level, the highest attention weight is cast to the best snippet \u201cFinally, Jimmy arrived...knocked. Grandpa answered the door...\u201d. And the neighboring snippets also get relatively higher attentions than other regions. Recall that our system chooses the one sentence with top attention at left part and choose top-3 snippets at right part (referring to INLINEFORM0 value in Table TABREF15 ) to form D representations at different granularity, then uses a highway network to combine both representations as an overall D representation. This visualization hints that our architecture provides a good way for a question to compromise key information from different granularity.",
          "We also do some preliminary error analysis. One big obstacle for our systems is the \u201chow many\u201d questions. For example, for question \u201chow many rooms did I say I checked?\u201d and the answer candidates are four digits \u201c5,4,3,2\u201d which never appear in the D, but require the counting of some locations. However, these digital answers can not be modeled well by distributed representations so far. In addition, digital answers also appear for \u201cwhat\u201d questions, like \u201cwhat time did...\u201d. Another big limitation lies in \u201cwhy\u201d questions. This question type requires complex inference and long-distance dependencies. We observed that all deep lerning systems, including the two baselines, suffered somewhat from it."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This work takes the lead in presenting a CNN based neural network system for open-domain machine comprehension task. Our systems tried to solve this task in a document projection way as well as a textual entailment way. The latter one demonstrates slightly better performance. Overall, our architecture, modeling dynamic document representation by attention scheme from sentence level to snippet level, shows promising results in this task. In the future, more fine-grained representation learning approaches are expected to model complex answer types and question types."
        ]
      }
    ],
    "qas": [
      {
        "question": "what was the margin their system outperformed previous ones?",
        "question_id": "041529e15b70b21986adb781fd9b94b595e451ed",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Concretely, we propose HABCNN, a hierarchical attention-based convolutional neural network, to address this task in two roadmaps. In the first one, we project the document in two different ways, one based on question-attention, one based on answer-attention and then compare the two projected document representations to determine whether the answer matches the question. In the second one, every question-answer pair is reformatted into a statement, then the whole task is treated through textual entailment.",
                "We consider two evaluation metrics: accuracy (proportion of questions correctly answered) and NDCG INLINEFORM0 BIBREF20 . Unlike accuracy which evaluates if the question is correctly answered or not, NDCG INLINEFORM1 , being a measure of ranking quality, evaluates the position of the correct answer in our predicted ranking.",
                "Baseline Systems",
                "This work focuses on the comparison with systems about distributed representation learning and deep learning:",
                "NR. The Neural Reasoner BIBREF21 has an encoding layer, multiple reasoning layers and a final answer layer. The input for the encoding layer is a question and the sentences of the document (called facts); each sentence is encoded by a GRU into a vector. In each reasoning layer, NR lets the question representation interact with each fact representation as reasoning process. Finally, all temporary reasoning clues are pooled as answer representation.",
                "AR. The Attentive Reader BIBREF2 is implemented by modeling the whole D as a word sequence \u2013 without specific sentence / snippet representations \u2013 using an LSTM. Attention mechanism is implemented at word representation level.",
                "Overall, baselines Addition and Addition-proj do not involve complex composition and inference. NR and AR represent the top-performing deep neural networks in QA tasks.",
                "Table TABREF16 lists the performance of baselines, HABCNN-TE variants, HABCNN systems in the first, second and last block, respectively (we only report variants for top-performing HABCNN-TE). Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500. This demonstrates the promise of our architecture in this task.",
                "Dataset",
                "MCTest has two subsets. MCTest-160 is a set of 160 items, each consisting of a document, four questions followed by one correct anwer and three incorrect answers (split into 70 train, 30 dev and 60 test) and MCTest-500 a set of 500 items (split into 300 train, 50 dev and 150 test)."
              ],
              "highlighted_evidence": [
                "Concretely, we propose HABCNN, a hierarchical attention-based convolutional neural network, to address this task in two roadmaps. ",
                "We consider two evaluation metrics: accuracy (proportion of questions correctly answered) and NDCG INLINEFORM0 BIBREF20 . ",
                "Baseline Systems\nThis work focuses on the comparison with systems about distributed representation learning and deep learning:",
                "NR. The Neural Reasoner BIBREF21 has an encoding layer, multiple reasoning layers and a final answer layer.",
                "AR. The Attentive Reader BIBREF2 is implemented by modeling the whole D as a word sequence \u2013 without specific sentence / snippet representations \u2013 using an LSTM. ",
                "NR and AR represent the top-performing deep neural networks in QA tasks.",
                "Table TABREF16 lists the performance of baselines, HABCNN-TE variants, HABCNN systems in the first, second and last block, respectively (we only report variants for top-performing HABCNN-TE). Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500. This demonstrates the promise of our architecture in this task.",
                "Dataset\nMCTest has two subsets. MCTest-160 is a set of 160 items, each consisting of a document, four questions followed by one correct anwer and three incorrect answers (split into 70 train, 30 dev and 60 test) and MCTest-500 a set of 500 items (split into 300 train, 50 dev and 150 test)."
              ]
            },
            "annotation_id": "37c28c13e3a2bc003122c3d361e15967bc16f1c8",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "15.6 and 16.5 for accuracy and NDCG on MCTest-150, 7.3 and 4.6 on MCTest-500.",
              "evidence": [
                "Table TABREF16 lists the performance of baselines, HABCNN-TE variants, HABCNN systems in the first, second and last block, respectively (we only report variants for top-performing HABCNN-TE). Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500. This demonstrates the promise of our architecture in this task."
              ],
              "highlighted_evidence": [
                "The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500."
              ]
            },
            "annotation_id": "6f01f33691bbe009bca62f6a5aab6d6db896e3a5",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Table TABREF16 lists the performance of baselines, HABCNN-TE variants, HABCNN systems in the first, second and last block, respectively (we only report variants for top-performing HABCNN-TE). Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500. This demonstrates the promise of our architecture in this task."
              ],
              "highlighted_evidence": [
                "Consistently, our HABCNN systems outperform all baselines, especially surpass the two competitive deep learning based systems AR and NR. The margin between our best-performing ABHCNN-TE and NR is 15.6/16.5 (accuracy/NDCG) on MCTest-150 and 7.3/4.6 on MCTest-500."
              ]
            },
            "annotation_id": "e0297e2c15df9c2da46828d6ff7149734a4844bc",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: Illustrations of HABCNN-QAP (top), HABCHHQP (middle) and HABCNN-TE (bottom). Q, A, S: question, answer, statement; D: document"
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: HABCNN. Feature maps for phrase representations pi and the max pooling steps that create sentence representations out of phrase representations are omitted for simplification. Each snippet covers three sentences in snippet-CNN. Symbols \u25e6 mean cosine similarity calculation."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Experimental results for one-sentence (one), multiple-sentence (mul) and all cases."
      }
    ]
  },
  "1908.02284": {
    "title": "Two-stage Training for Chinese Dialect Recognition",
    "abstract": "In this paper, we present a two-stage language identification (LID) system based on a shallow ResNet14 followed by a simple 2-layer recurrent neural network (RNN) architecture, which was used for Xunfei (iFlyTek) Chinese Dialect Recognition Challenge and won the first place among 110 teams. The system trains an acoustic model (AM) firstly with connectionist temporal classification (CTC) to recognize the given phonetic sequence annotation and then train another RNN to classify dialect category by utilizing the intermediate features as inputs from the AM. Compared with a three-stage system we further explore, our results show that the two-stage system can achieve high accuracy for Chinese dialects recognition under both short utterance and long utterance conditions with less training time.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The aim of language identification (LID) is to determine the language of an utterance and can be defined as a variable-length sequence classification task on the utterance-level. The task introduced in this paper is more challenging than general LID tasks cause we use a dialect database which contains 10 dialects in China. The dialects' regions are close to each other and they all belong to Chinese, so they have the same characters and similar pronunciations.",
          "Recently, the use of deep neural network (DNN) has been explored in LID tasks. The DNN is trained to discriminate individual physical states of a tied-state triphone and then extract the bottleneck features to a back-end system for classification BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 . End-to-end frameworks based on DNN later are trained for LID BIBREF4 . Other network architectures are successfully applied to LID task, example for convolutional neural network (CNN) BIBREF5 , BIBREF6 , time delay neural network (TDNN) BIBREF7 , RNN BIBREF8 , BIBREF9 , BIBREF10 , and BIBREF11 has a CNN followed by an RNN structure, which is similar to ours. They predict the final category of an utterance directly by the last fully connected layer, or derive the results by averaging the the frame-level posteriors. These frameworks just trained end-to-end to recognize languages, but they do not consider the phonetic information concretely.",
          "On the other hand, in many utterance analyzing tasks such as acoustic speech recognition (ASR), speaker verification (SV) and our LID, only a simple task or a specific aim is focused on. However, an utterance always has multi-dimensional information such as content, emotion, speaker and language and there are some certain correlations between them. Although the LID task is text-independent, which means the content of each utterance is totally different, different languages may have its own pronunciations or tones. Thus acoustic and language are two components in the LID task, BIBREF12 , BIBREF13 , BIBREF14 , BIBREF15 use the bottleneck features from an ASR system and feed to another neural network for recognition. Nevertheless, these ASR DNNs constituted by fully connected layers adds significant computational complexity and also require labels of physical states of a tied-state triphone.",
          "Inspired by all this, we assume that the high-dim features extracted from the network will contain information of pronunciation and language category, so we combine the ASR method with our LID task and here are our main contributions:",
          "The remainder of the paper is organized as follows. Section 2 introduces some related works about ASR and section 3 introduces the ResNet14 structure and gives processing of the two multi-stage systems. We present details of the database and initialization methods of the network in Section 4. The results of experiments and analysis are shown in Section 5. Lastly we give the conclusion and some future work in Section 6."
        ]
      },
      {
        "section_name": "Related works",
        "paragraphs": [
          "ASR BIBREF17 task enables the recognition and translation of spoken language into text. Traditionally, we can train an AM based on frame-wise cross-entropy loss to recognize phoneme, which requires tedious label alignment procedure such as Hidden Markov Model and Gaussian Mixture Model (HMM-GMM) paradigm. Then we can use a pronunciation model and a language model to transfer into text.",
          "In the latter case, CTC is used in training end-to-end ASR network BIBREF18 , BIBREF19 , BIBREF20 , which means that we do not have to align the phoneme label before training. CNN followed by RNN architectures have shown strong ability in dealing sequence-related problems such as sense text recognition BIBREF21 and ASR BIBREF22 . These make the ASR network easy to train and perform better with fewer parameters. BIBREF23 , BIBREF24 further add residual links to the CNN and RNN respectively and both make significant progress."
        ]
      },
      {
        "section_name": "Network structure",
        "paragraphs": [
          "The major network structure we use in the two-stage system can be divided to the CNN part and the RNN part, as described in Table TABREF7 . Given the input data of shape INLINEFORM0 , where INLINEFORM1 is the frame length of an utterance, we finally get 512-dimensional frame-level representation and INLINEFORM2 is the number of phonemes or dialect categories.",
          "Compared with other DNN based systems, we design the CNN part based on ResNet-18 BIBREF25 structure, named ResNet14, as the main part, which decreases the parameters a lot. The first conv layer is with kernel size INLINEFORM0 and stride size INLINEFORM1 , followed by a maxpool layer with stride size INLINEFORM2 for downsampling. Then the residual blocks extract high-dim features from the input sequences and keep the low-rank information. There are 6 res-blocks in all for decreasing parameters, the kernel size of each block is INLINEFORM3 and the features are downsampled while adding channels.",
          "We use 2-layer bidirectional long-short term memory (BLSTM) BIBREF26 as the RNN part following ResNet14. BLSTM extends original LSTM by introducing a backward direction layer so it considers the future context. The output of the network will be linked to different loss functions and different labels in different stages."
        ]
      },
      {
        "section_name": "Loss function",
        "paragraphs": [
          "CTC is an objective function that allows an RNN to be trained for sequence transcription tasks without requiring any prior alignment between the input and target sequences. The label sequence INLINEFORM0 can be mapped to its corresponding CTC paths. We denote the set of CTC paths for INLINEFORM1 as INLINEFORM2 . Thus the likelihood of INLINEFORM3 can be evaluated as a sum of the probabilities of its CTC paths: DISPLAYFORM0 ",
          "where INLINEFORM0 is the utterance and INLINEFORM1 is a CTC path. Then the network can be trained to optimize the CTC function INLINEFORM2 by the given sequence labeling. For the LID task, we use the multi-class cross-entropy loss for classification: DISPLAYFORM0 ",
          "where INLINEFORM0 is the ground truth label and INLINEFORM1 is the output probability distribution."
        ]
      },
      {
        "section_name": "Two-stage system",
        "paragraphs": [
          "Figure FIGREF12 shows the architecture of the two-stage system. The input is the sound feature of each utterance. We firstly train the AM with the ResNet14 followed by an RNN architecture, then the intermediate results computed by res-blocks are feed to the second stage as the input. The framework does not need to compress the feature sequence so it keeps all the information from the ResNet14 part. The network of second stage is 2-layer BLSTM. The final pooling strategy is average pooling on time-dimension so we can get the utterance-level category results from frame-level, and the output is the prediction of dialect category. We use CTC loss to train the AM so the network outputs can align with the phoneme sequences automatically and use cross-entropy loss to discriminate between dialects.",
          "Compared with multi-task training BIBREF27 , BIBREF28 in SV tasks, it should be emphasized that these stages should be trained step by step instead of multi-task learning with shared layers, that is to say we backpropagate the whole network while training AM, and only backpropagate the RNN part in the second stage, or the network will be degenerated and lost the information of acoustic knowledge."
        ]
      },
      {
        "section_name": "Three-stage system",
        "paragraphs": [
          "The three-stage system, as shown in Figure FIGREF14 , has a more complex architecture. Firstly, we still train an AM whose architecture is the same as the first-stage in the two-stage system. This AM is used to generate temporal locations of each phoneme through CTC loss, so that we can train an another AM by using cross-entropy loss as the second-stage to predict the corresponding phonetic labels of the input frames, in which we only use ResNet14 without an RNN because we have the precise locations of each phoneme from the first stage. The third stage is similar, we use the intermediate features from the second stage to train an RNN network for LID task, also the loss in this stage is cross-entropy loss."
        ]
      },
      {
        "section_name": "Data description",
        "paragraphs": [
          "We use a database covering 10 most widespread Chinese dialects, the dialects are Ningxia, Hefei, Sichuan, Shanxi, Changsha, Hebei, Nanchang, Shanghai, Kekka and Fujian. Each dialect has 6-hour audio data. For the training set, there will be 6000 audio files in each dialect with variable length (Figure FIGREF16 ), we can see that most files are longer than 3 seconds. The test set has 500 audio files in each dialect and the set is divided into two categories according to the duration of the audio file ( INLINEFORM0 3s for the first task and INLINEFORM1 3s for the second task).",
          "The phonetic sequence annotation of the corresponding text to each speech is also provided in the training set. There are 27 initials and 39 finals with 148 tones in the whole database."
        ]
      },
      {
        "section_name": "Experimental setup",
        "paragraphs": [
          "We convert the raw audio to 40-dimensional log Mel-filterbank coefficients with a frame-length of 25 ms, mean-normalized over the whole utterance. Then we stack all the log-mel filterbank features and feed it into the neural network, which is implemented in PyTorch. No voice activity detection (VAD) or other data augmentation approaches are applied. During the training process, we use Adam as the optimization method and set different learning rates and weight decay in different stages. We do not set dropout while training AM but set the dropout value=0.5 while training the LID network (the last stage).",
          "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category. In the process of evaluation, we compute the accuracy of the two sub-tasks and the whole test set to evaluate the performance of each system."
        ]
      },
      {
        "section_name": "Comparison of different stage systems",
        "paragraphs": [
          "First of all, we compare the two-stage system and the three-stage system trained with phonetic sequence annotation and dialect category label with the baseline trained only with dialect category label. The two multi-stage system have the same ResNet14 architecture and use 2-layer BLSTM as the RNN part with 256 nodes. From the results in the Table TABREF20 , we can see that the relative accuracy (ACC) of the two multi-stage systems increases by 10% on every task relative to the baseline and the two-stage system performs best. We also observe that both two multi-stage systems perform excellently in long duration ( INLINEFORM0 3s) task and the two-stage system illustrates its advantageous and robustness in short duration ( INLINEFORM1 3s) task.",
          "By analyzing the confusing matrices (Figure FIGREF19 ) of predicted results, we can find that the accuracy is high in several dialects' recognition, such as Shanghai (98.8%) and Hefei (99.8%), but the systems have some trouble while recognizing Minnan and Kekka, Hebei and Shanxi. The results accord with regional distribution of the dialects. For example, Minnan and Kekka are both in Fujian Province and have lots of cognate words, so it is hard to recognize them in reality."
        ]
      },
      {
        "section_name": "Comparison of different RNN structures",
        "paragraphs": [
          "We further explore the impact of different RNN structures with bidirectional gated recurrent unit (BGRU) and BLSTM. For the two-stage system (Table TABREF22 ), adding the nodes of BLSTM does not work, but adding another layer makes sense in short-duration task. Moreover, with the same layers and nodes, BLSTM outperforms BGRU in the two sub-tasks. We believe that sound related tasks do not need a very deep network as image related tasks, that is also the reason why we use a shallow ResNet14 as the CNN part.",
          "We evaluate the three-stage system with the same experiments, and the results (Table TABREF23 ) demonstrate that the three-stage system can achieve high accuracy in long duration task by larger BLSTM layers and the BGRU structure outperforms BLSTM on the whole. But adding the third RNN layer also does not work in these experiments.",
          "As Table TABREF24 shows, training networks in the first stage (with CTC loss) needs more time for convergence than training networks in the second or third stage (with cross-entropy loss). We can observe that the two-stage system spends less time while having a slightly higher accuracy compared to the three-stage system.",
          "These two multi-stage systems both much outperform the baseline system. They learn acoustic and language knowledge successively, indicating that language and phoneme are features of different levels, so we have to train step by step to avoid the networks \u201cforget\" some knowledge. Through the process, we can find the rules of multi-task and multi-stage training, if the labels are in different levels then multi-stage training should be used such as the situation in our paper, otherwise multi-task training should be used for parallel learning a wide range of knowledge."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this work, we propose an acoustic model based on ResNet14 followed by an RNN to recognize phoneme sequence directly with CTC loss and train a simple RNN lastly to get posteriors for recognizing dialect category, forming a two-stage LID system. The system links the different stages by using intermediate features extracted by a shallow ResNet14 architecture. Compared with a simple network or the three-stage system, the two-stage system achieves the state-of-the-art in the Chinese dialect recognition task. We believe this idea of two-stage training can provide inspirations for learning different classes knowledge and can extend to other fields."
        ]
      }
    ],
    "qas": [
      {
        "question": "what are the baselines?",
        "question_id": "eb653a5c59851eda313ece0bcd8c589b6155d73e",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "one-stage RNN system containing 2-layer BLSTM",
              "evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category. In the process of evaluation, we compute the accuracy of the two sub-tasks and the whole test set to evaluate the performance of each system."
              ],
              "highlighted_evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category."
              ]
            },
            "annotation_id": "1c751eea2e248956c8be45d687dc14176948bf20",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "one-stage RNN system"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category. In the process of evaluation, we compute the accuracy of the two sub-tasks and the whole test set to evaluate the performance of each system."
              ],
              "highlighted_evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category."
              ]
            },
            "annotation_id": "f3cbe10b07421b055d22d96c483a8f78c6446a79",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "a one-stage RNN system"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category. In the process of evaluation, we compute the accuracy of the two sub-tasks and the whole test set to evaluate the performance of each system."
              ],
              "highlighted_evidence": [
                "The baseline we use for comparison is a one-stage RNN system, the RNN structure is the same as the last stage containing 2-layer BLSTM and directly trained to recognize dialect category. "
              ]
            },
            "annotation_id": "f9883b10bd7efdb51cb337f2ac605b5e627adeea",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Training architecture of two-stage system"
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Our ResNet14 structure, which has only 5.36 million parameters compared to the standard ResNet-18 (11.26 million)"
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Data distribution of time"
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Training architecture of three-stage system"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: System Performance of different multi-stage systems"
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Figure 4: Comparison of confusion matrices produced by the two-stage system (left) and the three-stage system (right)"
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Epochs to converge of different multi-stage systems"
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Comparison of two-stage system with different RNN structures"
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Comparison of three-stage system with different RNN structures"
      }
    ]
  },
  "1907.00168": {
    "title": "The CUED's Grammatical Error Correction Systems for BEA-2019",
    "abstract": "We describe two entries from the Cambridge University Engineering Department to the BEA 2019 Shared Task on grammatical error correction. Our submission to the low-resource track is based on prior work on using finite state transducers together with strong neural language models. Our system for the restricted track is a purely neural system consisting of neural language models and neural machine translation models trained with back-translation and a combination of checkpoint averaging and fine-tuning -- without the help of any additional tools like spell checkers. The latter system has been used inside a separate system combination entry in cooperation with the Cambridge University Computer Lab.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The automatic correction of errors in text [In a such situaction INLINEFORM0 In such a situation] is receiving more and more attention from the natural language processing community. A series of competitions has been devoted to grammatical error correction (GEC): the CoNLL-2013 shared task BIBREF0 , the CoNLL-2014 shared task BIBREF1 , and finally the BEA 2019 shared task BIBREF2 . This paper presents the contributions from the Cambridge University Engineering Department to the latest GEC competition at the BEA 2019 workshop.",
          "We submitted systems to two different tracks. The low-resource track did not permit the use of parallel training data except a small development set with around 4K sentence pairs. For our low-resource system we extended our prior work on finite state transducer based GEC BIBREF3 to handle new error types such as punctuation errors as well as insertions and deletions of a small number of frequent words. For the restricted track, the organizers provided 1.2M pairs (560K without identity mappings) of corrected and uncorrected sentences. Our goal on the restricted track was to explore the potential of purely neural models for grammatical error correction. We confirm the results of BIBREF4 and report substantial gains by applying back-translation BIBREF5 to GEC \u2013 a data augmentation technique common in machine translation. Furthermore, we noticed that large parts of the training data do not match the target domain. We mitigated the domain gap by over-sampling the in-domain training corpus, and by fine-tuning through continued training. Our final model is an ensemble of four neural machine translation (NMT) models and two neural language models (LMs) with Transformer architecture BIBREF6 . Our purely neural system was also part of the joint submission with the Cambridge University Computer Lab described by BIBREF7 ."
        ]
      },
      {
        "section_name": "FST-based Grammatical Error Correction",
        "paragraphs": [
          " BIBREF3 investigated the use of finite state transducers (FSTs) for neural grammatical error correction. They proposed a cascade of FST compositions to construct a hypothesis space which is then rescored with a neural language model. We will outline this approach and explain our modifications in this section. For more details we refer to BIBREF3 .",
          "In a first step, the source sentence is converted to an FST INLINEFORM0 (Fig. FIGREF3 ). This initial FST is augmented by composition (denoted with the INLINEFORM1 -operator) with various other FSTs to cover different error types. Composition is a widely used standard operation on FSTs and supported efficiently by FST toolkits such as OpenFST BIBREF8 . We construct the hypothesis space as follows:",
          "We compose the input INLINEFORM0 with the deletion transducer INLINEFORM1 in Fig. FIGREF5 . INLINEFORM2 allows to delete tokens on the short list shown in Tab. TABREF6 at a cost INLINEFORM3 . We selected INLINEFORM4 by looking up all tokens which have been deleted in the dev set more than five times and manually filtered that list slightly. We did not use the full list of dev set deletions to avoid under-estimating INLINEFORM5 in tuning.",
          "In a next step, we compose the transducer from step 1 with the edit transducer INLINEFORM0 in Fig. FIGREF7 . This step addresses substitution errors such as spelling or morphology errors. Like BIBREF3 , we use the confusion sets of BIBREF9 based on CyHunspell for spell checking BIBREF10 , the AGID morphology database for morphology errors BIBREF11 , and manually defined corrections for determiner and preposition errors to construct INLINEFORM1 . Additionally, we extracted all substitution errors from the BEA-2019 dev set which occurred more than five times, and added a small number of manually defined rules that fix tokenization around punctuation symbols.",
          "We found it challenging to allow insertions in LM-based GEC because the LM often prefers inserting words with high unigram probability such as articles and prepositions before less predictable words like proper names. We therefore restrict insertions to the three tokens \u201c,\u201d, \u201c-\u201d, and \u201c's\u201d and allow only one insertion per sentence. We achieve this by adding the transducer INLINEFORM0 in Fig. FIGREF8 to our composition cascade.",
          "Finally, we map the word-level FSTs to the subword-level by composition with a mapping transducer INLINEFORM0 that applies byte pair encoding BIBREF12 to the full words. Word-to-BPE mapping transducers have been used in prior work to combine word-level models with subword-level neural sequence models BIBREF3 , BIBREF13 , BIBREF14 , BIBREF15 .",
          "In a more condensed form, we can describe the final transducer as: DISPLAYFORM0 ",
          "with INLINEFORM0 for deletions, INLINEFORM1 for substitutions, INLINEFORM2 for insertions, and INLINEFORM3 for converting words to BPE tokens. Path scores in the FST in Eq. EQREF14 are the accumulated penalties INLINEFORM4 , INLINEFORM5 , and INLINEFORM6 . The INLINEFORM7 -parameters are tuned on the dev set using a variant of Powell search BIBREF16 . We apply standard FST operations like output projection, INLINEFORM8 -removal, determinization, minimization, and weight pushing BIBREF17 , BIBREF18 to help downstream decoding. Following BIBREF3 we then use the resulting transducer to constrain a neural LM beam decoder."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "Our LMs are Transformer BIBREF6 decoders (transformer_big) trained using the Tensor2Tensor library BIBREF19 . We delay SGD updates BIBREF20 , BIBREF21 with factor 2 to simulate 500K training steps with 8 GPUs on 4 physical GPUs. Training batches contain about 4K source and target tokens. Our LM training set comprises the monolingual news2015-news2018 English training sets from the WMT evaluation campaigns BIBREF22 after language detection BIBREF23 (138M sentences) and subword segmentation using byte pair encoding BIBREF12 with 32K merge operations. For decoding, we use our SGNMT tool BIBREF13 , BIBREF14 with OpenFST backend BIBREF8 .",
          "We use neural LMs and neural machine translation (NMT) models in our restricted track entry. Our neural LM is as described in Sec. SECREF15 . Our LMs and NMT models share the same subword segmentation. We perform exploratory NMT experiments with the Base setup, but switch to the Big setup for our final models. Tab. TABREF21 shows the differences between both setups. Tab. TABREF22 lists some corpus statistics for the BEA-2019 training sets. In our experiments without fine-tuning we decode with the average of the 20 most recent checkpoints BIBREF26 . We use the SGNMT decoder BIBREF13 , BIBREF14 in all our experiments.",
          "The BEA-2019 training corpora (Tab. TABREF22 ) differ significantly not only in size but also their closeness to the target domain. The W&I+LOCNESS corpus is most similar to the BEA-2019 dev and test sets in terms of domains and the distribution over English language proficiency, but only consists of 34K sentence pairs. To increase the importance of in-domain training samples we over-sampled the W&I+LOCNESS corpus with different rates. Tab. TABREF24 shows that over-sampling by factor 4 (i.e. adding the W&I+LOCNESS corpus four times to the training set) improves the ERRAMT INLINEFORM0 -score by 2.2 points on the BEA-2019 dev set and does not lead to substantial losses on the CoNLL-2014 test set. We will over-sample the W&I+LOCNESS corpus by four in all subsequent experiments.",
          "Previous works often suggested to remove unchanged sentences (i.e. source and target sentences are equal) from the training corpora BIBREF3 , BIBREF27 , BIBREF28 . We note that removing these identity mappings can be seen as measure to control the balance between precision and recall. As shown in Tab. TABREF26 , removing identities encourages the model to make more corrections and thus leads to higher recall but lower precision. It depends on the test set whether this results in an improvement in INLINEFORM0 score. For the subsequent experiments we found that removing identities in the parallel training corpora but not in the back-translated synthetic data works well in practice.",
          "Back-translation BIBREF5 has become the most widely used technique to use monolingual data in neural machine translation. Back-translation extends the existing parallel training set by additional training samples with real English target sentences but synthetic source sentences. Different methods have been proposed to synthesize the source sentence such as using dummy tokens BIBREF5 , copying the target sentence BIBREF29 , or sampling from or decoding with a reverse sequence-to-sequence model BIBREF5 , BIBREF30 , BIBREF4 . The most popular approach is to generate the synthetic source sentences with a reverse model that is trained to transform target to source sentences using beam search. In GEC, this means that the reverse model learns to introduce errors into a correct English sentence. Back-translation has been applied successfully to GEC by BIBREF4 . We confirm the effectiveness of back-translation in GEC and discuss some of the differences between applying this technique to grammatical error correction and machine translation.",
          "Our experiments with back-translation are summarized in Tab. TABREF28 . Adding 1M synthetic sentences to the training data already yields very substantial gains on both test sets. We achieve our best results with 5M synthetic sentences (+8.44 on BEA-2019 Dev). In machine translation, it is important to maintain a balance between authentic and synthetic data BIBREF5 , BIBREF31 , BIBREF32 . Over-sampling the real data is a common practice to rectify that ratio if large amounts of synthetic data are available. Interestingly, over-sampling real data in GEC hurts performance (row 3 vs. 5 in Tab. TABREF28 ), and it is possible to mix real and synthetic sentences at a ratio of 1:7.9 (last three rows in Tab. TABREF28 ). We will proceed with the 5M setup for the remainder of this paper.",
          "As explained previously, we over-sample the W&I+LOCNESS corpus by factor 4 to mitigate the domain gap between the training set and the BEA-2019 dev and test sets. To further adapt our system to the target domain, we fine-tune the NMT models on W&I+LOCNESS after convergence on the full training set. We do that by continuing training on W&I+LOCNESS from the last checkpoint of the first training pass. Fig. FIGREF30 plots the INLINEFORM0 score on the BEA-2019 dev set for two different setups. For the red curve, we average all checkpoints BIBREF26 (including the last unadapted checkpoint) up to a certain training iteration. Checkpoints are dumped every 500 steps. The green curve does not use any checkpoint averaging. Checkpoint averaging helps to smooth out fluctuations in INLINEFORM1 score, and also generalizes better to CoNLL-2014 (Tab. TABREF31 ).",
          "Tab. TABREF33 contains our experiments with the Big configuration. In addition to W&I+LOCNESS over-sampling, back-translation with 5M sentences, and fine-tuning with checkpoint averaging, we report further gains by adding the language models from our low-resource system (Sec. SECREF15 ) and ensembling. Our best system (4 NMT models, 2 language models) achieves 58.9 M2 on CoNLL-2014, which is slightly (2.25 points) worse than the best published result on that test set BIBREF27 . However, we note that we have tailored our system towards the BEA-2019 dev set and not the CoNLL-2013 or CoNLL-2014 test sets. As we argued in Sec. SECREF18 , our results throughout this work suggest strongly that the optimal system parameters for these test sets are very different from each other, and that our final system settings are not optimal for CoNLL-2014. We also note that unlike the system of BIBREF27 , our system for the restricted track does not use spell checkers or other NLP tools but relies solely on neural sequence models."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "We report M2 BIBREF24 scores on the CoNLL-2014 test set BIBREF1 and span-based ERRANT scores BIBREF25 on the BEA-2019 dev set BIBREF2 . On CoNLL-2014 we compare with the best published results with comparable amount of parallel training data. We refer to BIBREF2 for a full comparison of BEA-2019 systems. We tune our systems on BEA-2019 and only report the performance on CoNLL-2014 for comparison to prior work.",
          "Tab. TABREF9 summarizes our low-resource experiments. Our substitution-only system already outperforms the prior work of BIBREF3 . Allowing for deletions and insertions improves the ERRANT score on BEA-2019 Dev by 2.57 points. We report further gains on both test sets by ensembling two language models and increasing the beam size."
        ]
      },
      {
        "section_name": "Differences Between CoNLL-2014 and BEA-2019 Dev",
        "paragraphs": [
          "Our results in Tab. TABREF9 differ significantly between the CoNLL-2014 test set and the BEA-2019 dev set. Allowing insertions is beneficial on BEA-2019 Dev but decreases the M2 score on CoNLL-2014. Increasing the beam size improves our system by 3.28 points on CoNLL-2014 while the impact on BEA-2019 Dev is smaller (+0.85 points). These differences can be partially explained by comparing the error type frequencies in the reference annotations in both test sets (Tab. TABREF19 ). Samples in CoNLL-2014 generally need more corrections per sentence than in BEA-2019 Dev. More importantly, the CoNLL-2014 test set contains fewer missing words, but much more unnecessary words than BEA-2019 Dev. This mismatch tempers with tuning as we explicitly tune insertion and deletion penalties."
        ]
      },
      {
        "section_name": "Restricted Track Submission",
        "paragraphs": [
          "In contrast to our low-resource submission, our restricted system entirely relies on neural models and does not use any external NLP tools, spell checkers, or hand-crafted confusion sets. For simplicity, we also chose to use standard implementations BIBREF19 of standard Transformer BIBREF6 models with standard hyper-parameters. This makes our final system easy to deploy as it is a simple ensemble of standard neural models with minimal preprocessing (subword segmentation). Our contributions on this track focus on NMT training techniques such as over-sampling, back-translation, and fine-tuning. We show that over-sampling effectively reduces domain mismatch. We found back-translation BIBREF5 to be a very effective technique to utilize unannotated training data. However, while over-sampling is commonly used in machine translation to balance the number of real and back-translated training sentences, we report that using over-sampling this way for GEC hurts performance. Finally, we propose a combination of checkpoint averaging BIBREF26 and continued training to adapt our NMT models to the target domain."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We participated in the BEA 2019 Shared Task on grammatical error correction with submissions to the low-resource and the restricted track. Our low-resource system is an extension of prior work on FST-based GEC BIBREF3 to allow insertions and deletions. Our restricted track submission is a purely neural system based on standard NMT and LM architectures. We pointed out the similarity between GEC and machine translation, and demonstrated that several techniques which originate from MT research such as over-sampling, back-translation, and fine-tuning, are also useful for GEC. Our models have been used in a joint submission with the Cambridge University Computer Lab BIBREF7 ."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This work was supported by the U.K. Engineering and Physical Sciences Research Council (EPSRC) grant EP/L027623/1 and has been performed using resources provided by the Cambridge Tier-2 system operated by the University of Cambridge Research Computing Service funded by EPSRC Tier-2 capital grant EP/P020259/1."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which neural machine translation model was used?",
        "question_id": "94d794df4a3109522c2ea09dad5d40e55d35df51",
        "nlp_background": "five",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SGNMT tool BIBREF13 , BIBREF14 with OpenFST backend BIBREF8"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our LMs are Transformer BIBREF6 decoders (transformer_big) trained using the Tensor2Tensor library BIBREF19 . We delay SGD updates BIBREF20 , BIBREF21 with factor 2 to simulate 500K training steps with 8 GPUs on 4 physical GPUs. Training batches contain about 4K source and target tokens. Our LM training set comprises the monolingual news2015-news2018 English training sets from the WMT evaluation campaigns BIBREF22 after language detection BIBREF23 (138M sentences) and subword segmentation using byte pair encoding BIBREF12 with 32K merge operations. For decoding, we use our SGNMT tool BIBREF13 , BIBREF14 with OpenFST backend BIBREF8 ."
              ],
              "highlighted_evidence": [
                "For decoding, we use our SGNMT tool BIBREF13 , BIBREF14 with OpenFST backend BIBREF8 ."
              ]
            },
            "annotation_id": "1af80fde5dd33e327dceb6602c0dae07dc58f269",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "3840533eaee030fee8755ce0ed216041332ce55a",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "SGNMT"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We use neural LMs and neural machine translation (NMT) models in our restricted track entry. Our neural LM is as described in Sec. SECREF15 . Our LMs and NMT models share the same subword segmentation. We perform exploratory NMT experiments with the Base setup, but switch to the Big setup for our final models. Tab. TABREF21 shows the differences between both setups. Tab. TABREF22 lists some corpus statistics for the BEA-2019 training sets. In our experiments without fine-tuning we decode with the average of the 20 most recent checkpoints BIBREF26 . We use the SGNMT decoder BIBREF13 , BIBREF14 in all our experiments."
              ],
              "highlighted_evidence": [
                "We use the SGNMT decoder BIBREF13 , BIBREF14 in all our experiments."
              ]
            },
            "annotation_id": "64a3cc01aed4489002d40533030ecb3221865c4b",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure3-1.png",
        "caption": "Figure 3: Edit FSTE which allows substitutions with a cost of \u03bbsub. The \u03c3-label matches any symbol and maps it to itself at no cost."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: List of tokens R that can be deleted by the deletion transducer D in Fig. 2."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Results on the low-resource track. The \u03bb-parameters are tuned on the BEA-2019 dev set."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Number of correction types in CoNLL-2014 and BEA-2019 Dev references."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: NMT setups BASE and BIG used in our experiments for the restricted track."
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: BEA-2019 parallel training data with and without removing pairs where source and target sentences are the same."
      },
      {
        "file": "5-Table6-1.png",
        "caption": "Table 6: Over-sampling the BEA-2019 in-domain corpus W&I+LOCNESS under BASE models. The second column contains the ratio of W&I+LOCNESS samples to training samples from the other corpora."
      },
      {
        "file": "5-Table7-1.png",
        "caption": "Table 7: Impact of identity removal on BASE models."
      },
      {
        "file": "5-Table8-1.png",
        "caption": "Table 8: Using back-translation for GEC (BASE models). The third column contains the ratio between real and synthetic sentence pairs."
      },
      {
        "file": "6-Table9-1.png",
        "caption": "Table 9: Fine-tuning through continued training on W&I+LOCNESS and checkpoint averaging with a BASE model with 5M back-translated sentences."
      },
      {
        "file": "6-Figure5-1.png",
        "caption": "Figure 5: Span-based ERRANT F0.5 scores on the BEA-2019 dev set over the number of fine-tuning training iterations (single GPU, SGD delay factor (Saunders et al., 2018) of 16)."
      },
      {
        "file": "6-Table10-1.png",
        "caption": "Table 10: Final results on the restricted track with BIG models and back-translation."
      }
    ]
  },
  "1911.09709": {
    "title": "Automatically Neutralizing Subjective Bias in Text",
    "abstract": "Texts like news, encyclopedias, and some social media strive for objectivity. Yet bias in the form of inappropriate subjectivity - introducing attitudes via framing, presupposing truth, and casting doubt - remains ubiquitous. This kind of bias erodes our collective trust and fuels social conflict. To address this issue, we introduce a novel testbed for natural language generation: automatically bringing inappropriately subjective text into a neutral point of view (\"neutralizing\" biased text). We also offer the first parallel corpus of biased language. The corpus contains 180,000 sentence pairs and originates from Wikipedia edits that removed various framings, presuppositions, and attitudes from biased sentences. Last, we propose two strong encoder-decoder baselines for the task. A straightforward yet opaque CONCURRENT system uses a BERT encoder to identify subjective words as part of the generation process. An interpretable and controllable MODULAR algorithm separates these steps, using (1) a BERT-based classifier to identify problematic words and (2) a novel join embedding through which the classifier can edit the hidden states of the encoder. Large-scale human evaluation across four domains (encyclopedias, news headlines, books, and political speeches) suggests that these algorithms are a first step towards the automatic identification and reduction of bias.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Writers and editors of texts like encyclopedias, news, and textbooks strive to avoid biased language. Yet bias remains ubiquitous. 62% of Americans believe their news is biased BIBREF0 and bias is the single largest source of distrust in the media BIBREF1.",
          "This work presents data and algorithms for automatically reducing bias in text. We focus on a particular kind of bias: inappropriate subjectivity (\u201csubjective bias\u201d). Subjective bias occurs when language that should be neutral and fair is skewed by feeling, opinion, or taste (whether consciously or unconsciously). In practice, we identify subjective bias via the method of BIBREF2: using Wikipedia's neutral point of view (NPOV) policy. This policy is a set of principles which includes \u201cavoiding stating opinions as facts\u201d and \u201cpreferring nonjudgemental language\u201d.",
          "For example a news headline like \u201cJohn McCain exposed as an unprincipled politician\" (Figure FIGREF1) is biased because the verb expose is a factive verb that presupposes the truth of its complement; a non-biased sentence would use a verb like describe so as not to presuppose something that is the subjective opinion of the writer. \u201cPilfered\u201d in \u201cthe gameplay is pilfered from DDR\u201d (Table TABREF3) subjectively frames the shared gameplay as a kind of theft. \u201cHis\u201d in \u201ca lead programmer usually spends his career\u201d again introduces a biased and subjective viewpoint (that all programmers are men) through presupposition.",
          "We aim to debias text by suggesting edits that would make it more neutral. This contrasts with prior research which has debiased representations of text by removing dimensions of prejudice from word embeddings BIBREF3, BIBREF4 and the hidden states of predictive models BIBREF5, BIBREF6. To avoid overloading the definition of \u201cdebias,\u201d we refer to our kind of text debiasing as neutralizing that text. Figure FIGREF1 gives an example.",
          "We introduce the Wiki Neutrality Corpus (WNC). This is a new parallel corpus of 180,000 biased and neutralized sentence pairs along with contextual sentences and metadata. The corpus was harvested from Wikipedia edits that were designed to ensure texts had a neutral point of view. WNC is the first parallel corpus targeting biased and neutralized language. We also define the task of neutralizing subjectively biased text. This task shares many properties with tasks like detecting framing or epistemological bias BIBREF2, or veridicality assessment/factuality prediction BIBREF7, BIBREF8, BIBREF9, BIBREF10. Our new task extends these detection/classification problems into a generation task: generating more neutral text with otherwise similar meaning.",
          "Finally, we propose a pair of novel sequence-to-sequence algorithms for this neutralization task. Both methods leverage denoising autoencoders and a token-weighted loss function. An interpretable and controllable modular algorithm breaks the problem into (1) detection and (2) editing, using (1) a BERT-based detector to explicitly identify problematic words, and (2) a novel join embedding through which the detector can modify an editors' hidden states. This paradigm advances an important human-in-the-loop approach to bias understanding and generative language modeling. Second, an easy to train and use but more opaque concurrent system uses a BERT encoder to identify subjectivity as part of the generation process.",
          "Large-scale human evaluation suggests that while not without flaws, our algorithms can identify and reduce bias in encyclopedias, news, books, and political speeches, and do so better than state-of-the-art style transfer and machine translation systems. This work represents an important first step towards automatically managing bias in the real world. We release data and code to the public."
        ]
      },
      {
        "section_name": "Wiki Neutrality Corpus (WNC)",
        "paragraphs": [
          "The Wiki Neutrality Corpus consists of aligned sentences pre and post-neutralization by English Wikipedia editors (Table TABREF3). We used regular expressions to crawl 423,823 Wikipedia revisions between 2004 and 2019 where editors provided NPOV-related justification BIBREF11, BIBREF2, BIBREF12. To maximize the precision of bias-related changes, we ignored revisions where",
          "[noitemsep]",
          "More than a single sentence was changed.",
          "Minimal edits (character Levenshtein distance $<$ 4).",
          "Maximal edits (more than half of the words changed).",
          "Edits where more than half of the words were proper nouns.",
          "Edits that fixed spelling or grammatical errors.",
          "Edits that added references or hyperlinks.",
          "Edits that changed non-literary elements like tables or punctuation.",
          "We align sentences in the pre and post text by computing a sliding window (of size $k = 5$) of pairwise BLEU BIBREF13 between sentences and matching sentences with the biggest score BIBREF14, BIBREF15. Last, we discarded pairs whose length ratios were beyond the 95th percentile BIBREF16.",
          "Corpus statistics are given in Table TABREF12. The final data are (1) a parallel corpus of 180k biased sentences and their neutral counterparts, and (2) 385k neutral sentences that were adjacent to a revised sentence at the time of editing but were not changed by the editor. Note that following BIBREF2, the neutralizing experiments in Section SECREF4 focus on the subset of WNC where the editor modified or deleted a single word in the source text (\u201cBiased-word\u201d in Table TABREF12).",
          "Table TABREF12 also gives a categorization of these sample pairs using a slight extension of the typology of BIBREF2. They defined framing bias as using subjective words or phrases linked with a particular point of view (like using words like best or deepest or using pilfered from instead of based on, and epistemological bias as linguistic features that subtly (often via presupposition) focus on the believability of a proposition. We add to their two a third kind of subjectivity bias that also occurs in our data, which we call demographic bias, text with presuppositions about particular genders or races or other demographic categories (like presupposing that all programmers are male).",
          "The dataset does not include labels for these categories, but we hand-labeled a random sample of 500 examples to estimate the distribution of the 3 types. Table TABREF13 shows that while framing bias is most common, all types of bias are represented in the data, including instances of demographic bias."
        ]
      },
      {
        "section_name": "Wiki Neutrality Corpus (WNC) ::: Dataset Properties",
        "paragraphs": [
          "We take a closer look at WNC to identify characteristics of subjective bias on Wikipedia.",
          "Topic. We use the Wikimedia Foundation's categorization models BIBREF17 to bucket articles from WNC and the aforementioned random sample into a 44-category ontology, then compare the proportions of NPOV-driven edits across categories. Subjectively biased edits are most prevalent in history, politics, philosophy, sports, and language categories. They are least prevalent in the meteorology, science, landforms, broadcasting, and arts categories. This suggests that there is a relationship between a text's topic and the realization of bias. We use this observation to guide our model design in Section SECREF19.",
          "Tenure. We group editors into \u201cnewcomers\u201d (less than a month of experience) and \u201cexperienced\u201d (more than a month). We find that newcomers are less likely to perform neutralizing edits (15% in WNC) compared to other edits (34% in a random sample of 685k edits). This difference is significant ($\\tilde{\\chi }^2$ p $=$ 0.001), suggesting the complexity of neutralizing text is typically reserved for more senior editors, which helps explain the performance of human evaluators in Section SECREF53."
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text",
        "paragraphs": [
          "We propose the task of neutralizing text, in which the algorithm is given an input sentence and must produce an output sentence whose meaning is as similar as possible to the input but with the subjective bias removed.",
          "We propose two algorithms for this task, each with its own benefits. A modular algorithm enables human control and interpretability. A concurrent algorithm is simple to train and operate.",
          "We adopt the following notation:",
          "",
          "$\\mathbf {s} = [w^s_1, ..., w^s_n]$ is a source sequence of subjectively biased text.",
          "",
          "$\\mathbf {t} = [w^t_1, ..., w^t_m]$ is a target sequence and the neutralized version of $\\mathbf {s}$."
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text ::: MODULAR",
        "paragraphs": [
          "The first algorithm we are proposing has two stages: BERT-based detection and LSTM-based editing. We pretrain a model for each stage and then combine them into a joint system for end-to-end fine tuning on the overall neutralizing task. We proceed to describe each module."
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text ::: MODULAR ::: Detection Module",
        "paragraphs": [
          "The detection module is a neural sequence tagger that estimates $p_i$, the probability that each input word $w^s_i$ is subjectively biased (Figure FIGREF26).",
          "Module description. Each $p_i$ is calculated according to",
          "$\\mathbf {b}_i \\in \\mathcal {R}^{b}$ represents $w^s_i$'s semantic meaning. It is a contextualized word vector produced by BERT, a transformer encoder that has been pre-trained as a masked language model BIBREF18. To leverage the bias-topic relationship uncovered in Section SECREF14, we prepend a token indicating an article's topic category (<arts>, <sports>, etc) to $\\mathbf {s}$. The word vectors for these tokens are learned from scratch.",
          "$\\mathbf {e}_i$ represents expert features of bias proposed by BIBREF2:",
          "",
          "$\\mathbf {W}^{in} \\in \\mathcal {R}^{f \\times h}$ is a matrix of learned parameters, and $\\mathbf {f}_i$ is a vector of discrete features.",
          "$\\mathbf {W}^{b} \\in \\mathcal {R}^{b}$, $\\mathbf {W}^{e} \\in \\mathcal {R}^{h}$, and $b \\in \\mathcal {R}$ are learnable parameters.",
          "Module pre-training. We train this module using diffs between the source and target text. A label $p^*_i$ is 1 if $w^s_i$ was deleted or modified as part of the neutralizing process. A label is 0 if it occurs in both the source and target text. The loss is calculated as the average negative log likelihood of the labels:"
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text ::: MODULAR ::: Editing Module",
        "paragraphs": [
          "The editing module takes a subjective source sentence $\\mathbf {s}$ and is trained to edit it into a more neutral compliment $\\mathbf {t}$.",
          "Module description. This module is based on a sequence-to-sequence neural machine translation model BIBREF19. A bi-LSTM BIBREF20 encoder turns $\\mathbf {s}$ into a sequence of hidden states $\\mathbf {H} = (\\mathbf {h}_1, ..., \\mathbf {h}_n)$. Next, an LSTM decoder generates text one token at a time by repeatedly attending to $\\mathbf {H}$ and producing probability distributions over the vocabulary. We also add two mechanisms from the summarization literature BIBREF21. The first is a copy mechanism, where the model's final output for timestep $i$ becomes a weighted combination of the predicted vocabulary distribution and attentional distribution from that timestep. The second is a coverage mechanism which incorporates the sum of previous attention distributions into the final loss function to discourage the model from re-attending to a word and repeating itself.",
          "Module pre-training. We pre-train the decoder as a language model of neutral text using the neutral portion of WNC (Section SECREF2). Doing so expresses a data-driven prior about how target sentences should read. We accomplish this with a denoising autoencoder objective BIBREF22 and maximizing the conditional log probability $\\log p(\\mathbf {x} \\vert \\widetilde{\\mathbf {x}})$ of reconstructing a sequence $\\mathbf {x}$ from a corrupted version of itself $\\widetilde{\\mathbf {x}} = C(\\mathbf {x})$ using noise model $C$.",
          "Our $C$ is similar to BIBREF23. We slightly shuffle $\\mathbf {x}$ such that $x_i$'s index in $\\widetilde{\\mathbf {x}}$ is randomly selected from $[i - k, i + k]$. We then drop words with probability $p$. For our experiments, we set $k = 3$ and $p = 0.25$."
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text ::: MODULAR ::: Final System",
        "paragraphs": [
          "Once the detection and editing modules have been pre-trained, we join them and fine-tune together as an end to end system for translating $\\mathbf {s}$ into $\\mathbf {t}$.",
          "This is done with a novel join embedding mechanism that lets the detector control the editor (Figure FIGREF29). The join embedding is a vector $\\mathbf {v} \\in \\mathcal {R}^h$ that we add to each encoder hidden state in the editing module. This operation is gated by the detector's output probabilities $\\mathbf {p} = (p_1, ..., p_n)$. Note that the same $\\mathbf {v}$ is applied across all timesteps.",
          "",
          "We proceed to condition the decoder on the new hidden states $\\mathbf {H}^{\\prime } = (\\mathbf {h^{\\prime }}_1, ..., \\mathbf {h}^{\\prime }_n)$. Intuitively, $\\mathbf {v}$ is enriching the hidden states of words that the detector identified as subjective. This tells the decoder what language should be changed and what is safe to be be copied during the neutralization process. Error signals are allowed to flow backwards into both the encoder and detector, creating an end-to-end system from the two modules.",
          "To fine-tune the parameters of the joint system, we use a token-weighted loss function that scales the loss on neutralized words (i.e. words unique to $\\mathbf {t}$) by a factor of $\\alpha $:",
          "",
          "Note that $c$ is a term from the coverage mechanism (Section SECREF28). We use $\\alpha = 1.3$ in our experiments. Intuitively, this loss function incorporates an inductive bias of the neutralizing process: the source and target have a high degree of lexical similarity but the goal is to learn the structure of their differences, not simply copying words into the output (something a pre-trained autoencoder should already have knowledge of). This loss function is related to previous work on grammar correction BIBREF24, and cost-sensitive learning BIBREF25."
        ]
      },
      {
        "section_name": "Methods for Neutralizing Text ::: CONCURRENT",
        "paragraphs": [
          "Our second algorithm takes the problematic source $\\textbf {s}$ and directly generates a neutralized $\\mathbf {\\hat{t}}$. While this renders the system easier to train and operate, it limits interpretability and controllability.",
          "Model description. The concurrent system is an encoder-decoder neural network. The encoder is BERT. The decoder is the same as that of Section SECREF28: an attentional LSTM with copy and coverage mechanisms. The decoder's inputs are set to:",
          "Hidden states $\\mathbf {H} = \\mathbf {W}^H\\ \\mathbf {B}$, where $\\mathbf {B} = (\\mathbf {b}_1, ..., \\mathbf {b}_{n}) \\in \\mathcal {R}^{b \\times n}$ is the BERT-embedded source and $\\mathbf {W}^H \\in \\mathcal {R}^{h \\times b}$ is a matrix of learned parameters.",
          "Initial states $\\mathbf {c}_0 = \\mathbf {W}^{c0}\\ \\sum \\mathbf {b}_i / n$ and $\\mathbf {h_0} = \\mathbf {W}^{h0}\\ \\sum \\mathbf {b}_i / n$. $\\mathbf {W}^{c0} \\in \\mathcal {R}^{h \\times b}$ and $\\mathbf {W}^{h0} \\in \\mathcal {R}^{h \\times b}$ are learned matrices.",
          "Model training. The concurrent model is pre-trained with the same autoencoding procedure described in Section SECREF28. It is then fine-tuned as a subjective-to-neutral translation system with the same loss function described in Section SECREF30."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Protocol",
        "paragraphs": [
          "Implementation. We implemented nonlinear models with Pytorch BIBREF29 and optimized using Adam BIBREF30 as configured in BIBREF18 with a learning rate of 5e-5. We used a batch size of 16. All vectors were of length $h = 512$ unless otherwise specified. We use gradient clipping with a maximum gradient norm of 3 and a dropout probability of 0.2 on the inputs of each LSTM cell BIBREF31. We initialize the BERT component of the tagging module with the publicly-released bert-base-uncased parameters. All other parameters were uniformly initialized in the range $[-0.1,\\ 0.1]$.",
          "Procedure. Following BIBREF2, we train and evaluate our system on the subset of WNC where the editor changed or deleted a single word in the source text. This yielded 53,803 training pairs (about a quarter of the WNC), from which we sampled 700 development and 1,000 test pairs. For fair comparison, we gave our baselines additional access to the 385,639 neutral examples when possible. We pretrained the tagging module for 4 epochs. We pretrained the editing module on the neutral portion of our WNC for 4 epochs. The joint system was trained on the same data as the tagger for 25,000 steps (about 7 epochs). We perform interference using beam search and a beam width of 4. All computations were performed on a single NVIDIA TITAN X GPU; training the full system took approximately 10 hours. We report statistical significance with bootstrap resampling and a 95% confidence level BIBREF32, BIBREF33.",
          "Evaluation. We evaluate our models according to five metrics. BLEU BIBREF13 and accuracy (the proportion of decodings that exactly matched the editors changes) are quantitative. We also hired fluent English-speaking crowdworkers on Amazon Mechanical Turk. Workers were shown the BIBREF2 and Wikipedia definition of a \u201cbiased statement\u201d and six example sentences, then subjected to a five-question qualification test where they had to identify subjectivity bias. Approximately half of the 30,000 workers who took the qualification test passed. Those who passed were asked to compare pairs of original and edited sentences (not knowing which was the original) along three criteria: fluency, meaning preservation, and bias. Fluency and bias were evaluated on a Semantic Differential scale from -2 to 2. Here, a semantic differential scale can better evaluate attitude oriented questions with two polarized options (e.g., \u201cis text A or B more fluent?\u201d). Meaning was evaluated on a Likert scale from 0 to 4, ranging from \u201ctotally different\u201d to \u201cidentical\u201d. Inter-rater agreement was fair to substantial (Krippendorff's alpha of 0.65 for fluency, 0.33 for meaning, and 0.51 for bias). We report statistical significance with a t-test and 95% confidence interval."
        ]
      },
      {
        "section_name": "Experiments ::: Wikipedia (WNC)",
        "paragraphs": [
          "Results on WNC are presented in Table TABREF35. In addition to methods from the literature we include (1) a BERT-based system which simply predicts and deletes subjective words, and (2) a system which predicts replacements (including deletion) for subjective words directly from their BERT embeddings. All methods appear to successfully reduce bias according to the human evaluators. However, many methods appear to lack fluency. Adding a token-weighted loss function and pretraining the decoder help the model's coherence according to BLEU and accuracy. Adding the detector (modular) or a BERT encoder (concurrent) provide additional benefits. The proposed models retain the strong effects of systems from the literature while also producing target-level fluency on average. Our results suggest there is no clear winner between our two proposed systems. modular is better at reducing bias and has higher accuracy, while concurrent produces more fluent responses, preserves meaning better, and has higher BLEU.",
          "Table TABREF39 indicates that BLEU is more correlated with fluency but accuracy is more correlated with subjective bias reduction. The weak association between BLEU and human evaluation scores is corroborated by other research BIBREF35, BIBREF36. We conclude that neither automatic metric is a true substitute for human judgment."
        ]
      },
      {
        "section_name": "Experiments ::: Real-world Media",
        "paragraphs": [
          "To demonstrate the efficacy of the proposed methods on subjective bias in the wild, we perform inference on three out-of-domain datasets (Table TABREF45). We prepared each dataset according to the same procedure as WNC (Section SECREF2). After inference, we enlisted 1800 raters to assess the quality of 200 randomly sampled datapoints. Note that for partisan datasets we sample an equal number of examples from \u201cconservative\u201d and \u201cliberal\u201d sources. These data are:",
          "",
          "The Ideological Books Corpus (IBC) consisting of partisan books and magazine articles BIBREF37, BIBREF38.",
          "",
          "Headlines of partisan news articles identified as biased according to mediabiasfactcheck.com.",
          "",
          "Sentences from the campaign speeches of a prominent politician (United States President Donald Trump). We filtered out dialog-specific artifacts (interjections, phatics, etc) by removing all sentences with less than 4 tokens before sampling a test set.",
          "Overall, while modular does a better job at reducing bias, concurrent appears to better preserve the meaning and fluency of the original text. We conclude that the proposed methods, while imperfect, are capable of providing useful suggestions for how subjective bias in real-world news or political text can be reduced."
        ]
      },
      {
        "section_name": "Error Analysis",
        "paragraphs": [
          "To better understand the limits of our models and the proposed task of bias neutralization, we randomly sample 50 errors produced by our models on the Wikipedia test set and bin them into the following categories:",
          "No change. The model failed to remove or change the source sentence.",
          "Bad change. The model modified the source but introduced an edit which failed to match the ground-truth target (i.e. the Wikipedia editor's change).",
          "Disfluency. Errors in language modeling and text generation.",
          "Noise. The datapoint is noisy and the target text is not a neutralized version of the source.",
          "The distribution of errors is given in Table TABREF50. Most errors are due to the subtlety and complexity of language understanding required for bias neutralization, rather than the generation of fluent text. These challenges are particularly pronounced for neutralizing edits that involve the replacement of factive and assertive verbs. As column 2 shows, a large proportion of the errors, though disagreeing with the edit written by the Wikipedia editors, nonetheless successfully neutralize bias in the source.",
          "Examples of each error type are given in Table TABREF52 (two pages away). As the examples show, our models have have a tendency to simply remove words instead of finding a good replacement."
        ]
      },
      {
        "section_name": "Algorithmic Analysis",
        "paragraphs": [
          "We proceed to analyze our algorithm's ability to detect and categorize bias as well as the efficacy of the proposed join embedding."
        ]
      },
      {
        "section_name": "Algorithmic Analysis ::: Detecting Subjectivity",
        "paragraphs": [
          "Identifying subjectivity in a sentence (explicitly or implicitly) is prerequisite to neutralizing it. We accordingly evaluate our model's (and 3,000 crowdworker's) ability to detect subjectivity using the procedure of BIBREF2 and the same 50k training examples as Section SECREF4 (Table TABREF51). For each sentence, we select the word with the highest predicted probability and test whether that word was in fact changed by the editor. The proportion of correctly selected words is the system's \u201caccuracy\u201d. Results are given in Table TABREF51.",
          "Note that concurrent lacks an interpretive window into its detection behavior, so we estimate an upper bound on the model's detection abilities by (1) feeding the encoder's hidden states into a fully connected + softmax layer that predicts the probability of a token being subjectively biased, and (2) training this layer as a sequence tagger according to the procedure of Section SECREF19.",
          "The low human performance can be attributed to the difficulty of identifying bias. Issues of bias are typically reserved for senior Wikipedia editors (Section SECREF14) and untrained workers performed worse (37.39%) on the same task in BIBREF2 (and can struggle on other tasks requiring linguistic knowledge BIBREF39). concurrent's encoder, which is architecturally identical to BERT, had similar performance to a stand-alone BERT system. The linguistic and category-related features in the modular detector gave it slight leverage over the plain BERT-based models."
        ]
      },
      {
        "section_name": "Algorithmic Analysis ::: Join Embedding",
        "paragraphs": [
          "We continue by analyzing the abilities of the proposed join embedding mechanism."
        ]
      },
      {
        "section_name": "Algorithmic Analysis ::: Join Embedding ::: Join Embedding Ablation",
        "paragraphs": [
          "The join embedding combines two separately pretrained models through a gated embedding instead of the more traditional practice of stripping off any final classification layers and concatenating the exposed hidden states BIBREF40. We accordingly ablated the join embedding mechanism by training a new model where the pre-trained detector is frozen and its pre-output hidden states $\\mathbf {b}_i$ are concatenated to the encoder's hidden states before decoding. Doing so reduced performance to 90.78 BLEU and 37.57 Accuracy (from the 93.52/46.8 with the join embedding). This suggests learned embeddings can be a high-performance and end-to-end conduit between sub-modules of machine learning systems."
        ]
      },
      {
        "section_name": "Algorithmic Analysis ::: Join Embedding ::: Join Embedding Control",
        "paragraphs": [
          "We proceed to demonstrate how the join embedding creates controllability in the neutralization process. Recall that modular relies on a probability distribution $\\mathbf {p}$ to determine which words require editing (Equation DISPLAY_FORM31). Typically, this distribution comes from the detection module (Section SECREF19), but we can also feed in user-specified distributions that force the model to target particular words. This can let human advisors correct errors or push the model's behavior towards some desired outcome. We find that the model is indeed capable of being controlled, letting users target specific words for rewording in case they disagree with the model's output or seek recommendations on specific language. However, doing so can also introduce errors into downstream language generation (Table TABREF52)."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Subjectivity Bias. The study of subjectivity in NLP was pioneered by the late Janyce Wiebe and colleagues BIBREF41, BIBREF42. Several studies develop methods for highlighting subjective or persuasive frames in a text BIBREF43, BIBREF44, or detecting biased sentences BIBREF45, BIBREF46, BIBREF12, BIBREF47 of which the most similar to ours is BIBREF2, whose early, smaller version of WNC and logistic regression-based bias detector inspired our study.",
          "Debiasing. Many scholars have worked on removing demographic prejudice from meaning representations BIBREF48, BIBREF49, BIBREF5, BIBREF50, BIBREF51. Such studies begin with identifying a direction or subspace that capture the bias and then removing such bias component to make these representations fair across attributes like gender and age BIBREF3, BIBREF48. For instance, BIBREF50 introduced a regularization term for the language model to penalize the projection of the word embeddings onto that gender subspace, while BIBREF51 used adversarial training to remove directions of bias from hidden states.",
          "Neural Language Generation. Several studies propose stepwise procedures for text generation, including sampling from a corpus BIBREF52 and identifying language ripe for modification BIBREF53. Most similar to us is BIBREF26 who localize a text's style to a fraction of its words. Our modular detection module performs a similar localization in a soft manner, and our steps are joined by a smooth conduit (the join embedding) instead of discrete logic. There is also work related to our concurrent model. The closest is BIBREF54, where a decoder was attached to BERT for question answering, or BIBREF23, where machine translation systems are initialized to LSTM and Transformer-based language models of the source text."
        ]
      },
      {
        "section_name": "Conclusion and Future Work",
        "paragraphs": [
          "The growing presence of bias has marred the credibility of our news, educational systems, and social media platforms. Automatically reducing bias is thus an important new challenge for the Natural Language Processing and Artificial Intelligence community. By learning models to automatically detect and correct subjective bias in text, this work is a first step in this important direction. Nonetheless our scope was limited to single-word edits, which only constitute a quarter of the edits in our data, and are probably among the simplest instances of bias. We therefore encourage future work to tackle broader instances of multi-word, multi-lingual, and cross-sentence bias. Another important direction is integrating aspects of fact-checking BIBREF55, since a more sophisticated system would be able to know when a presupposition is in fact true and hence not subjective. Finally, our new join embedding mechanism can be applied to other modular neural network architectures."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We thank the Japan-United States Educational Commission (Fulbright Japan) for their generous support. We thank Chris Potts, Hirokazu Kiyomaru, Abigail See, Kevin Clark, the Stanford NLP Group, and our anonymous reviewers for their thoughtful comments and suggestions. We gratefully acknowledge support of the DARPA Communicating with Computers (CwC) program under ARO prime contract no. W911NF15-1-0462 and the NSF via grant IIS-1514268. Diyi Yang is supported by a grant from Google."
        ]
      }
    ],
    "qas": [
      {
        "question": "Were the Wikipedia edits that removed framings, presuppositions and attitudes from biased sentences a Wiki community effort, or were annotators trained to do it?",
        "question_id": "5422a3f2a083395416d6f99c57d28335eb2e44e1",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "bias",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Wiki community effort",
              "evidence": [
                "The Wiki Neutrality Corpus consists of aligned sentences pre and post-neutralization by English Wikipedia editors (Table TABREF3). We used regular expressions to crawl 423,823 Wikipedia revisions between 2004 and 2019 where editors provided NPOV-related justification BIBREF11, BIBREF2, BIBREF12. To maximize the precision of bias-related changes, we ignored revisions where"
              ],
              "highlighted_evidence": [
                "The Wiki Neutrality Corpus consists of aligned sentences pre and post-neutralization by English Wikipedia editors (Table TABREF3)."
              ]
            },
            "annotation_id": "34f24f19a759cf951159814142bd4a269577f126",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Wikipedia editors"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The Wiki Neutrality Corpus consists of aligned sentences pre and post-neutralization by English Wikipedia editors (Table TABREF3). We used regular expressions to crawl 423,823 Wikipedia revisions between 2004 and 2019 where editors provided NPOV-related justification BIBREF11, BIBREF2, BIBREF12. To maximize the precision of bias-related changes, we ignored revisions where"
              ],
              "highlighted_evidence": [
                "The Wiki Neutrality Corpus consists of aligned sentences pre and post-neutralization by English Wikipedia editors (Table TABREF3)."
              ]
            },
            "annotation_id": "4d006969cec6e8ccf5adb162c79b6f17ddd14895",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " Wikipedia edits"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We introduce the Wiki Neutrality Corpus (WNC). This is a new parallel corpus of 180,000 biased and neutralized sentence pairs along with contextual sentences and metadata. The corpus was harvested from Wikipedia edits that were designed to ensure texts had a neutral point of view. WNC is the first parallel corpus targeting biased and neutralized language. We also define the task of neutralizing subjectively biased text. This task shares many properties with tasks like detecting framing or epistemological bias BIBREF2, or veridicality assessment/factuality prediction BIBREF7, BIBREF8, BIBREF9, BIBREF10. Our new task extends these detection/classification problems into a generation task: generating more neutral text with otherwise similar meaning."
              ],
              "highlighted_evidence": [
                "The corpus was harvested from Wikipedia edits that were designed to ensure texts had a neutral point of view. "
              ]
            },
            "annotation_id": "82d1e21bc64d87ad82ee0678d1b4bb9b9cf953df",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Example output from our MODULAR algorithm. \u201cExposed\u201d is a factive verb that presupposes the truth of its complement (that McCain is unprincipled). Replacing \u201cexposed\u201d with \u201cdescribed\u201d neutralizes the headline because it conveys a similar main clause proposition (someone is asserting McCain is unprincipled), but no longer introduces the authors subjective bias via presupposition."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Samples from our new corpus. 500 sentence pairs are annotated with \u201csubcategory\u201d information (Column 3)."
      },
      {
        "file": "2-Table2-1.png",
        "caption": "Table 2: Corpus statistics."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: The detection module uses discrete features fi and BERT embedding bi to calculate logit yi."
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Proportion of bias subcategories in Biased-full."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: The MODULAR system uses join embedding v to reconcile the detector\u2019s predictions with an encoder-decoder architecture. The greater a word\u2019s probability, the more of v is mixed into that word\u2019s hidden state."
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Bias neutralization performance. ST indicates a style transfer system. MT indicates a machine translation system. For quantitative metrics, rows with asterisks are significantly different than the preceding row. For qualitative metrics, rows with asterisks are significantly different from zero. Higher is preferable for fluency, while lower is preferable for bias and meaning."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: Spearman correlation (R2) between quantitative and qualitative metrics."
      },
      {
        "file": "6-Table6-1.png",
        "caption": "Table 6: Performance on out-of-domain datasets. Higher is preferable for fluency, while lower is preferable for bias and meaning. Rows with asterisks are significantly different from zero"
      },
      {
        "file": "6-Table7-1.png",
        "caption": "Table 7: Distribution of model errors on the Wikipedia test set. We also give the percent of errors that were valid neutralizations of the source despite failing to match the target sentence."
      },
      {
        "file": "7-Table8-1.png",
        "caption": "Table 8: Performance of various bias detectors. Rows with asterisks are statistically different than the preceding row."
      },
      {
        "file": "8-Table9-1.png",
        "caption": "Table 9: Top: examples of model errors from each error category. Middle: the model treats words differently based on their context; in this case, \u201cdominant\u201d is ignored when it accurately describes an individual\u2019s winning performance, but deleted when it describes a group of people in arbitrary comparison. Bottom: the MODULAR model can sometimes be controlled, for example by selecting words to change, to correct errors or otherwise change the model\u2019s behavior."
      }
    ]
  },
  "1909.04251": {
    "title": "A Benchmark Dataset for Learning to Intervene in Online Hate Speech",
    "abstract": "Countering online hate speech is a critical yet challenging task, but one which can be aided by the use of Natural Language Processing (NLP) techniques. Previous research has primarily focused on the development of NLP methods to automatically and effectively detect online hate speech while disregarding further action needed to calm and discourage individuals from using hate speech in the future. In addition, most existing hate speech datasets treat each post as an isolated instance, ignoring the conversational context. In this paper, we propose a novel task of generative hate speech intervention, where the goal is to automatically generate responses to intervene during online conversations that contain hate speech. As a part of this work, we introduce two fully-labeled large-scale hate speech intervention datasets collected from Gab and Reddit. These datasets provide conversation segments, hate speech labels, as well as intervention responses written by Mechanical Turk Workers. In this paper, we also analyze the datasets to understand the common intervention strategies and explore the performance of common automatic response generation methods on these new datasets to provide a benchmark for future research.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The growing popularity of online interactions through social media has been shown to have both positive and negative impacts. While social media improves information sharing, it also facilitates the propagation of online harassment, including hate speech. These negative experiences can have a measurable negative impact on users. Recently, the Pew Research Center BIBREF0 reported that \u201croughly four-in-ten Americans have personally experienced online harassment, and 63% consider it a major problem.\u201d",
          "To address the growing problem of online hate, an extensive body of work has focused on developing automatic hate speech detection models and datasets BIBREF1, BIBREF2, BIBREF3, BIBREF4, BIBREF5, BIBREF6, BIBREF7, BIBREF8. However, simply detecting and blocking hate speech or suspicious users often has limited ability to prevent these users from simply turning to other social media platforms to continue to engage in hate speech as can be seen in the large move of individuals blocked from Twitter to Gab BIBREF9. What's more, such a strategy is often at odds with the concept of free speech. As reported by the Pew Research Center BIBREF0, \u201cDespite this broad concern over online harassment, 45% of Americans say it is more important to let people speak their minds freely online; a slightly larger share (53%) feels that it is more important for people to feel welcome and safe online.\u201d The special rapporteurs representing the Office of the United Nations High Commissioner for Human Rights (OHCHR) have recommended that \u201cThe strategic response to hate speech is more speech.\u201d BIBREF10 They encourage to change what people think instead of merely changing what they do, so they advocate more speech that educates about cultural differences, diversity, and minorities as a better strategy to counter hate speech.",
          "Therefore, in order to encourage strategies of countering online hate speech, we propose a novel task of generative hate speech intervention and introduce two new datasets for this task. Figure FIGREF5 illustrates the task. Our datasets consist of 5K conversations retrieved from Reddit and 12k conversations retrieved from Gab. Distinct from existing hate speech datasets, our datasets retain their conversational context and introduce human-written intervention responses. The conversational context and intervention responses are critical in order to build generative models to automatically mitigate the spread of these types of conversations.",
          "To summarize, our contributions are three-fold:",
          "We introduce the generative hate speech intervention task and provide two fully-labeled hate speech datasets with human-written intervention responses.",
          "Our data is collected in the form of conversations, providing better context.",
          "The two data sources, Gab and Reddit, are not well studied for hate speech. Our datasets fill this gap.",
          "Due to our data collecting strategy, all the posts in our datasets are manually labeled as hate or non-hate speech by Mechanical Turk workers, so they can also be used for the hate speech detection task. The performance of commonly-used classifiers on our datasets is shown in Section SECREF6."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "In recent years, a few datasets for hate speech detection have been built and released by researchers. Most are collected from Twitter and are labeled using a combination of expert and non-expert hand labeling, or through machine learning assistance using a list of common negative words. It is widely accepted that labels can vary in their accuracy overall, though this can be mitigated by relying on a consensus rule to rectify disagreements in labels. A synopsis of these datasets can be found in Table TABREF10.",
          "BIBREF2 collect 17k tweets based on hate-related slurs and users. The tweets are manually annotated with three categories: sexist (20.0%), racist (11.7%), and normal (68.3%). Because the authors identified a number of prolific users during the initial manual search, the resulting dataset has a small number of users (1,236 users) involved, causing a potential selection bias. This problem is most prevalent on the 1,972 racist tweets, which are sent by only 9 Twitter users. To avoid this problem, we did not identify suspicious user accounts or utilize user information when collecting our data.",
          "BIBREF3 use a similar strategy, which combines the utilization of hate keywords and suspicious user accounts to build a dataset from Twitter. But different from BIBREF2, this dataset consists of 25k tweets randomly sampled from the 85.4 million posts of a large number of users (33,458 users). This dataset is proposed mainly to distinguish hateful and offensive language, which tend to be conflated by many studies.",
          "BIBREF11 focus on online harassment on Twitter and propose a fine-grained labeled dataset with 6 categories. BIBREF14 introduce a large Twitter dataset with 100k tweets. Despite the large size of this dataset, the ratio of the hateful tweets are relatively low (5%). Thus the size of the hateful tweets is around 5k in this dataset, which is not significantly larger than that of the previous datasets.",
          "The dataset introduced by BIBREF12 is different from the other datasets as it investigates the behavior of hate-related users on Twitter, instead of evaluating hate-related tweets. The large majority of the 1.5k users are labeled as spammers (31.8%) or normal (60.3%). Only a small fraction of the users are labeled as bullies (4.5%) or aggressors (3.4%). While most datasets are from single sources, BIBREF13 introduce a dataset with a combination of Twitter (58.9%), Reddit, and The Guardian. In total 20,432 unique comments were obtained with 4,136 labeled as harassment (20.2%) and 16,296 as non-harassment (79.8%).",
          "Since most of the publicly available hate speech datasets are collected from Twitter, previous research of hate speech mainly focus on Twitter posts or users BIBREF2, BIBREF17, BIBREF18, BIBREF19, BIBREF3. While there are several studies on the other sources, such as Instagram BIBREF20, Yahoo! BIBREF1, BIBREF15, and Ask.fm BIBREF16, the hate speech on Reddit and Gab is not widely studied. What's more, all the previous hate speech datasets are built for the classification or detection of hate speech from a single post or user on social media, ignoring the context of the post and intervention methods needed to effectively calm down the users and diffuse negative online conversations."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Ethics",
        "paragraphs": [
          "Our study got approval from our Internal Review Board. Workers were warned about the offensive content before they read the data and they were informed by our instructions to feel free to quit the task at any time if they are uncomfortable with the content. Additionally, all personally identifiable information such as user names is masked in the datasets."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Data Filtering",
        "paragraphs": [
          "Reddit: To retrieve high-quality conversational data that would likely include hate speech, we referenced the list of the whiniest most low-key toxic subreddits. Skipping the three subreddits that have been removed, we collect data from ten subreddits: r/DankMemes, r/Imgoingtohellforthis, r/KotakuInAction, r/MensRights, r/MetaCanada, r/MGTOW, r/PussyPass, r/PussyPassDenied, r/The_Donald, and r/TumblrInAction. For each of these subreddits, we retrieve the top 200 hottest submissions using Reddit's API. To further focus on conversations with hate speech in each submission, we use hate keywords BIBREF6 to identify potentially hateful comments and then reconstructed the conversational context of each comment. This context consists of all comments preceding and following a potentially hateful comment. Thus for each potentially hateful comment, we rebuild the conversation where the comment appears. Figure FIGREF14 shows an example of the collected conversation, where the second comment contains a hate keyword and is considered as potentially hateful. Because a conversation may contain more than one comments with hate keywords, we removed any duplicated conversations.",
          "Gab: We collect data from all the Gab posts in October 2018. Similar to Reddit, we use hate keywords BIBREF6 to identify potentially hateful posts, rebuild the conversation context and clean duplicate conversations."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Crowd-Sourcing",
        "paragraphs": [
          "After we collected the conversations from both Reddit and Gab, we presented this data to Mechanical Turk workers to label and create intervention suggestions. In order not to over-burden the workers, we filtered out conversations consisting of more than 20 comments. Each assignment consists of 5 conversations. For Reddit, we also present the title and content of the corresponding submission in order to give workers more information about the topic and context. For each conversation, a worker is asked to answer two questions:",
          "",
          "Q1: Which posts or comments in this conversation are hate speech?",
          "Q2: If there exists hate speech in the conversation, how would you respond to intervene? Write down a response that can probably hold it back (word limit: 140 characters).",
          "If the worker thinks no hate speech exists in the conversation, then the answers to both questions are \u201cn/a\u201d. To provide context, the definition of hate speech from Facebook: \u201cWe define hate speech as a direct attack on people based on what we call protected characteristics \u2014 race, ethnicity, national origin, religious affiliation, sexual orientation, caste, sex, gender, gender identity, and serious disease or disability.\u201d is presented to the workers. Also, to prevent workers from using hate speech in the response or writing responses that are too general, such as \u201cPlease do not say that\u201d, we provide additional instructions and rejected examples."
        ]
      },
      {
        "section_name": "Dataset Collection ::: Data Quality",
        "paragraphs": [
          "Each conversation is assigned to three different workers. To ensure data quality, we restrict the workers to be in an English speaking country including Australia, Canada, Ireland, New Zealand, the United Kingdom, and the United States, with a HIT approval rate higher than 95%. Excluding the rejected answers, the collected data involves 926 different workers. The final hate speech labels (answers to Q1) are aggregated according to the majority of the workers' answers. A comment is considered hate speech only when at least two out of the three workers label it as hate speech. The responses (answers to Q2) are aggregated according to the aggregated result of Q1. If the worker's label to Q1 agrees with the aggregated result, then their answer to Q2 is included as a candidate response to the corresponding conversation but is otherwise disregarded. See Figure FIGREF14 for an example of the aggregated data."
        ]
      },
      {
        "section_name": "Dataset Analysis ::: Statistics",
        "paragraphs": [
          "From Reddit, we collected 5,020 conversations, including 22,324 comments. On average, each conversation consists of 4.45 comments and the length of each comment is 58.0 tokens. 5,257 of the comments are labeled as hate speech and 17,067 are labeled as non-hate speech. A majority of the conversations, 3,847 (76.6%), contain hate speech. Each conversation with hate speech has 2.66 responses on average, for a total of 10,243 intervention responses. The average length of the intervention responses is 17.96 tokens.",
          "From Gab, we collected 11,825 conversations, consisting of 33,776 posts. On average, each conversation consists of 2.86 posts and the average length of each post is 35.6 tokens. 14,614 of the posts are labeled as hate speech and 19,162 are labeled as non-hate speech. Nearly all the conversations, 11,169 (94.5%), contain hate speech. 31,487 intervention responses were originally collected for conversations with hate speech, or 2.82 responses per conversation on average. The average length of the intervention responses is 17.27 tokens.",
          "Compared with the Gab dataset, there are fewer conversations and comments in the Reddit dataset, comments and conversations are longer, and the distribution of hate and non-hate speech labels is more imbalanced. Figure FIGREF20 illustrates the distributions of the top 10 keywords in the hate speech collected from Reddit and Gab separately. The Gab dataset and the Reddit dataset have similar popular hate keywords, but the distributions are very different. All the statistics shown above indicate that the characteristics of the data collected from these two sources are very different, thus the challenges of doing detection or generative intervention tasks on the dataset from these sources will also be different."
        ]
      },
      {
        "section_name": "Dataset Analysis ::: Intervention Strategies",
        "paragraphs": [
          "Removing duplicates, there are 21,747 unique intervention responses in the aggregated Gab dataset and 7,641 in the aggregated Reddit dataset. Despite the large diversity of the collected responses for intervention, we find workers tend to have certain strategies for intervention.",
          "",
          "Identify Hate Keywords: One of the most common strategies is to identify the inappropriate terms in the post and then urge the user to stop using that work. For example, \u201cThe C word and language attacking gender is unacceptable. Please refrain from future use.\u201d This strategy is often used when the hatred in the post is mainly conveyed by specific hate keywords.",
          "",
          "Categorize Hate Speech: This is another common strategy used by the workers. The workers classify hate speech into different categories, such as racist, sexist, homophobic, etc. This strategy is often combined with identifying hate keywords or targets of hatred. For example, \u201cThe term \"\"fa**ot\"\" comprises homophobic hate, and as such is not permitted here.\u201d",
          "",
          "Positive Tone Followed by Transitions: This is a strategy where the response consists of two parts combined with a transitional word, such as \u201cbut\u201d and \u201ceven though\u201d. The first part starts with affirmative terms, such as \u201cI understand\u201d, \u201cYou have the right to\u201d, and \u201cYou are free to express\u201d, showing kindness and understanding, while the second part is to alert the users that their post is inappropriate. For example, \u201cI understand your frustration, but the term you have used is offensive towards the disabled community. Please be more aware of your words.\u201d. Intuitively, compared with the response that directly warns, this strategy is likely more acceptable for the users and be more likely to clam down a quarrel full of hate speech.",
          "",
          "Suggest Proper Actions: Besides warning and discouraging the users from continuing hate speech, workers also suggest the actions that the user should take. This strategy can either be combined with other strategies mentioned above or be used alone. In the latter case, a negative tone can be greatly alleviated. For example, \u201cI think that you should do more research on how resources are allocated in this country.\u201d"
        ]
      },
      {
        "section_name": "Generative Intervention",
        "paragraphs": [
          "Our datasets can be used for various hate speech tasks. In this paper, we focus on generative hate speech intervention.",
          "The goal of this task is to generate a response to hate speech that can mitigate its use during a conversation. The objective can be formulated as the following equation:",
          "where $c$ is the conversation, $r$ is the corresponding intervention response, and $D$ is the dataset. This task is closely related to the response generation and dialog generation, though several differences exist including dialog length, language cadence, and word imbalances. As a baseline, we chose the most common methods of these two tasks, such as Seq2Seq and VAE, to determine the initial feasibility of automatically generate intervention responses. More recent Reinforcement Learning method for dialog generation BIBREF21 can also be applied to this task with slight modification. Future work will explore more complex, and unique models.",
          "Similar to BIBREF21, a generative model is considered as an agent. However, different from dialog generation, generative intervention does not have multiple turns of utterance, so the action of the agent is to select a token in the response. The state of the agent is given by the input posts and the previously generated tokens. Another result due to this difference is that the rewards with regard to ease of answering or information flow do not apply to this case, but the reward for semantic coherence does. Therefore, the reward of the agent is:",
          "where $rw(c,r)$ is the reward with regard to the conversation $c$ and its reference response $r$ in the dataset. $p(r|c)$ denotes the probability of generating response $r$ given the conversation $c$, and $p_{back}(c|r)$ denotes the backward probability of generating the conversation based on the response, which is parameterized by another generation network. The reward is a weighted combination of these two parts, which are observed after the agent finishing generating the response. We refer the readers to BIBREF21 for details."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We evaluate the commonly-used detection and generation methods with our dataset. Due to the different characteristics of the data collected from the two sources (Section SECREF4), we treat them as two independent datasets."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Settings",
        "paragraphs": [
          "For binary hate speech detection, we experimented the following four different methods.",
          "",
          "Logistic Regression (LR): We evaluate the Logistic Regression model with L2 regularization. The penalty parameter C is set to 1. The input features are the Term Frequency Inverse Document Frequency (TF-IDF) values of up to 2-grams.",
          "",
          "Support Vector Machine (SVM): We evaluate the SVM model with linear kernels. We use L2 regularization and the coefficient is 1. The features are the same as in LR.",
          "",
          "Convolutional Neural Network (CNN): We use the CNN model for sentence classification proposed by BIBREF22 with default hyperparameters. The word embeddings are randomly initialized (CNN in Table TABREF27) or initialized with pretrained Word2Vec BIBREF23 embeddings on Google News (CNN$^\\ast $ in Table TABREF27).",
          "",
          "Recurrent Neural Network (RNN): The model we evaluated consists of 2-layer bidirectional Gated Recurrent Unit (GRU) BIBREF24 followed by a linear layer. Same as for CNN, we report the performance of RNN with two different settings of the word embeddings.",
          "The methods are evaluated on testing data randomly selected from the dataset with the ratio of 20%. The input data is not manipulated to manually balance the classes for any of the above methods. Therefore, the training and testing data retain the same distribution as the collected results (Section SECREF4). The methods are evaluated using F-1 score, Precision-Recall (PR) AUC, and Receiver-Operating-Characteristic (ROC) AUC.",
          "For generative hate speech intervention, we evaluated the following three methods.",
          "",
          "Seq2Seq BIBREF25, BIBREF24: The encoder consists of 2 bidirectional GRU layers. The decoder consists of 2 GRU layers followed by a 3-layer MLP (Multi-Layer Perceptron).",
          "",
          "Variational Auto-Encoder (VAE) BIBREF26: The structure of the VAE model is similar to that of the Seq2Seq model, except that it has two independent linear layers followed by the encoder to calculate the mean and variance of the distribution of the latent variable separately. We assume the latent variable follows a multivariate Gaussian Distribution. KL annealing BIBREF27 is applied during training.",
          "",
          "Reinforcement Learning (RL): We also implement the Reinforcement Learning method described in Section SECREF5. The backbone of this model is the Seq2Seq model, which follows the same Seq2Seq network structure described above. This network is used to parameterize the probability of a response given the conversation. Besides this backbone Seq2Seq model, another Seq2Seq model is used to generate the backward probability. This network is trained in a similar way as the backbone Seq2Seq model, but with a response as input and the corresponding conversation as the target. In our implementation, the function of the first part of the reward ($\\log p(r|c)$) is conveyed by the MLE loss. A curriculum learning strategy is adopted for the reward of $\\log p_{back}(c|r)$ as in BIBREF28. Same as in BIBREF21 and BIBREF28, a baseline strategy is employed to estimate the average reward. We parameterize it as a 3-layer MLP.",
          "The Seq2Seq model and VAE model are evaluated under two different settings. In one setting, the input for the generative model is the complete conversation, while in the other setting, the input is the filtered conversation, which only includes the posts labeled as hate speech. The filtered conversation was necessary to test the Reinforcement Learning model, as it is too challenging for the backward model to reconstruct the complete conversation based only on the intervention response.",
          "In our experiments on the generative hate speech intervention task, we do not consider conversations without hate speech. The testing dataset is then randomly selected from the resulting dataset with the ratio of 20%. Since each conversation can have multiple reference responses, we dis-aggregate the responses and construct a pair (conversation, reference response) for each of the corresponding references during training. Teacher forcing is used for each of the three methods. The automatic evaluation metrics include BLEU BIBREF29, ROUGE-L BIBREF30, and METEOR BIBREF31.",
          "In order to validate and compare the quality of the generated results from each model, we also conducted human evaluations as previous research has shown that automatic evaluation metrics often do not correlate with human preference BIBREF32. We randomly sampled 450 conversations from the testing dataset. We then generated responses using each of the above models trained with the filtered conversation setting. In each assignment, a Mechanical Turk worker is presented 10 conversations, along with corresponding responses generated by the three models. For each conversation, the worker is asked to evaluate the effectiveness of the generated intervention by selecting a response that can best mitigate hate speech. 9 of the 10 questions are filled with the sampled testing data and the generated results, while the other is artificially constructed to monitor response quality. After selecting the 10 best mitigation measures, the worker is asked to select which of the three methods has the best diversity of responses over all the 10 conversations. Ties are permitted for answers. Assignments failed on the quality check are rejected."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Results and Discussion",
        "paragraphs": [
          "The experimental results of the detection task and the generative intervention task are shown in Table TABREF27 and Table TABREF29 separately. The results of the human evaluation are shown in Table TABREF30. Figure FIGREF25 shows examples of the generated responses.",
          "As shown in Table TABREF27 and TABREF29, all the classification and generative models perform better on the Gab dataset than on the Reddit dataset. We think this stems from the datasets' characteristics. First, the Gab dataset is larger and has a more balanced category distribution than the Reddit dataset. Therefore, it is inherently more challenging to train a classifier on the Reddit dataset. Further, the average lengths of the Reddit posts and conversations are much larger than those of Gab, potentially making the Reddit input nosier than the Gab input for both tasks. On both the Gab and Reddit datasets, the SVM classifier and the LR classifier achieved better performance than the CNN and RNN model with randomly initialized word embeddings. A possible reason is that without pretrained word embeddings, the neural network models tend to overfit on the dataset.",
          "For the generative intervention task, three models perform similarly on all three automatic evaluation metrics. As expected, the Seq2Seq model achieves higher scores with filtered conversation as input. However, this is not the case for the VAE model. This indicates that the two models may have different capabilities to capture important information in conversations.",
          "As shown in Table TABREF29, applying Reinforcement Learning does not lead to higher scores on the three automatic metrics. However, human evaluation (Table TABREF30) shows that the RL model creates responses that are potentially better at mitigating hate speech and are more diverse, which is consistent with BIBREF21. There is a larger performance difference with the Gab dataset, while the effectiveness and the diversity of the responses generated by the Seq2Seq model and the RL model are quite similar on the Reddit dataset. One possible reason is that the size of the training data from Reddit (around 8k) is only 30% the size of the training data from Gab. The inconsistency between the human evaluation results and the automatic ones indicates the automatic evaluation metrics listed in Table TABREF29 can hardly reflect the quality of the generated responses. As mentioned in Section SECREF4, annotators tend to have strategies for intervention. Therefore, generating the common parts of the most popular strategies for all the testing input can lead to high scores of these automatic evaluation metrics. For example, generating \u201cPlease do not use derogatory language.\u201d for all the testing Gab data can achieve 4.2 on BLEU, 20.4 on ROUGE, and 18.2 on METEOR. However, this response is not considered as high-quality because it is almost a universal response to all the hate speech, regardless of the context and topic.",
          "Surprisingly, the responses generated by the VAE model have much worse diversity than the other two methods according to human evaluation. As indicated in Figure FIGREF25, the responses generated by VAE tend to repeat the responses related to some popular hate keyword. For example, \u201cUse of the r-word is unacceptable in our discourse as it demeans and insults people with mental disabilities.\u201d and \u201cPlease do not use derogatory language for intellectual disabilities.\u201d are the generated responses for a large part of the Gab testing data. According to Figure FIGREF20, insults towards disabilities are the largest portion in the dataset, so we suspect that the performance of the VAE model is affected by the imbalanced keyword distribution.",
          "The sampled results in Figure FIGREF25 show that the Seq2Seq and the RL model can generate reasonable responses for intervention. However, as is to be expected with machine-generated text, in the other human evaluation we conducted, where Mechanical Turk workers were also presented with sampled human-written responses alongside the machine generated responses, the human-written responses were chosen as the most effective and diverse option a majority of the time (70% or more) for both datasets. This indicates that there is significant room for improvement while generating automated intervention responses.",
          "In our experiments, we only utilized the text of the posts, but more information is available and can be utilized, such as the user information and the title of a Reddit submission."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "Towards the end goal of mitigating the problem of online hate speech, we propose the task of generative hate speech intervention and introduce two fully-labeled datasets collected from Reddit and Gab, with crowd-sourced intervention responses. The performance of the three generative models: Seq2Seq, VAE, and RL, suggests ample opportunity for improvement. We intend to make our dataset freely available to facilitate further exploration of hate speech intervention and better models for generative intervention."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This research was supported by the Intel AI Faculty Research Grant. The authors are solely responsible for the contents of the paper and the opinions expressed in this publication do not reflect those of the funding agencies."
        ]
      }
    ],
    "qas": [
      {
        "question": "What types of hate speech are considered?",
        "question_id": "8330242b56b63708a23c6a92db4d4bcf927a4576",
        "nlp_background": "five",
        "topic_background": "research",
        "paper_read": "somewhat",
        "search_query": "Hate speech",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "8bfee0fc62a3848d4bb43b3fab920c981dd7837c",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": " Potentially hateful comments are identified using hate keywords.",
              "evidence": [
                "Reddit: To retrieve high-quality conversational data that would likely include hate speech, we referenced the list of the whiniest most low-key toxic subreddits. Skipping the three subreddits that have been removed, we collect data from ten subreddits: r/DankMemes, r/Imgoingtohellforthis, r/KotakuInAction, r/MensRights, r/MetaCanada, r/MGTOW, r/PussyPass, r/PussyPassDenied, r/The_Donald, and r/TumblrInAction. For each of these subreddits, we retrieve the top 200 hottest submissions using Reddit's API. To further focus on conversations with hate speech in each submission, we use hate keywords BIBREF6 to identify potentially hateful comments and then reconstructed the conversational context of each comment. This context consists of all comments preceding and following a potentially hateful comment. Thus for each potentially hateful comment, we rebuild the conversation where the comment appears. Figure FIGREF14 shows an example of the collected conversation, where the second comment contains a hate keyword and is considered as potentially hateful. Because a conversation may contain more than one comments with hate keywords, we removed any duplicated conversations."
              ],
              "highlighted_evidence": [
                "To further focus on conversations with hate speech in each submission, we use hate keywords BIBREF6 to identify potentially hateful comments and then reconstructed the conversational context of each comment. This context consists of all comments preceding and following a potentially hateful comment. Thus for each potentially hateful comment, we rebuild the conversation where the comment appears."
              ]
            },
            "annotation_id": "ca0eea35f5e2b649e48bbe955fd6d998d0750d6f",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "race, ethnicity, national origin, religious affiliation, sexual orientation, caste, sex, gender, gender identity, and serious disease or disability."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "If the worker thinks no hate speech exists in the conversation, then the answers to both questions are \u201cn/a\u201d. To provide context, the definition of hate speech from Facebook: \u201cWe define hate speech as a direct attack on people based on what we call protected characteristics \u2014 race, ethnicity, national origin, religious affiliation, sexual orientation, caste, sex, gender, gender identity, and serious disease or disability.\u201d is presented to the workers. Also, to prevent workers from using hate speech in the response or writing responses that are too general, such as \u201cPlease do not say that\u201d, we provide additional instructions and rejected examples."
              ],
              "highlighted_evidence": [
                "To provide context, the definition of hate speech from Facebook: \u201cWe define hate speech as a direct attack on people based on what we call protected characteristics \u2014 race, ethnicity, national origin, religious affiliation, sexual orientation, caste, sex, gender, gender identity, and serious disease or disability.\u201d"
              ]
            },
            "annotation_id": "ca90e894dcaf148bb2adba0136499378410d35e8",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: An illustration of hate speech conversation between User 1 and User 2 and the interventions collected for our datasets. The check and the cross icons on the right indicate a normal post and a hateful post. The utterance following the human icon is a humanwritten intervention, while the utterance following the computer icon is machine-generated."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Comparison of our datasets with previous hate speech datasets. Conv.: Conversation. Interv.: Intervention."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: An example of the aggregated data. The first column is the conversation text. Indexes are added to each post. Indentations before each post indicate the structure of replies. The second column is the indexes of the human-labeled hateful post. Each bullet point in the third column is a human-written response."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: The distributions of the top 10 keywords in the hate speech collected from Reddit and Gab. Hate keywords are masked."
      },
      {
        "file": "7-Figure4-1.png",
        "caption": "Figure 4: Examples of the generated intervention responses. The hateful terms in the conversation are masked."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Experimental results for the detection task. PR is Precision-Recall AUC and ROC is ROC AUC. The models marked with \u2217 use pretrained Word2Vec embeddings. The best results are in bold."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: Experimental results for generative intervention task. Inp. Set.: Input Setting (Section 6.1). B: BLEU. R: ROUGE-L. M: METEOR. Best results are in bold."
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4: Human evaluation results. Table values are the percentage of the answers. Eff.: Effectiveness, evaluates how well the generated responses can mitigate hate speech. Div: Diversity, evaluates how many different responses are generated. Best results are in bold."
      }
    ]
  },
  "1912.11980": {
    "title": "Explicit Sentence Compression for Neural Machine Translation",
    "abstract": "State-of-the-art Transformer-based neural machine translation (NMT) systems still follow a standard encoder-decoder framework, in which source sentence representation can be well done by an encoder with self-attention mechanism. Though Transformer-based encoder may effectively capture general information in its resulting source sentence representation, the backbone information, which stands for the gist of a sentence, is not specifically focused on. In this paper, we propose an explicit sentence compression method to enhance the source sentence representation for NMT. In practice, an explicit sentence compression goal used to learn the backbone information in a sentence. We propose three ways, including backbone source-side fusion, target-side fusion, and both-side fusion, to integrate the compressed sentence into NMT. Our empirical tests on the WMT English-to-French and English-to-German translation tasks show that the proposed sentence compression method significantly improves the translation performances over strong baselines.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Neural machine translation (NMT) is popularly implemented as an encoder-decoder framework BIBREF0, in which the encoder is right in charge of source sentence representation. Typically, the input sentence is implicitly represented as a contextualized source representation through deep learning networks. By further feeding the decoder, the source representation is used to learn dependent time-step context vectors for predicting target translation BIBREF1.",
          "In state-of-the-art Transformer-based encoder, self-attention mechanisms are good at capturing the general information in a sentence BIBREF2, BIBREF3, BIBREF4. However, it is difficult to distinguish which kind of information lying deeply under the language is really salient for learning source representation. Intuitively, when a person reads a source sentence, he/she often selectively focuses on the basic sentence meaning, and re-reads the entire sentence to understand its meaning completely. Take the English sentence in Table TABREF2 as an example. We manually annotate its basic meaning as a shorter sequence of words than in the original sentence, called backbone information. Obviously, these words with the basic meaning contain more important information for human understanding than the remaining words in the sentence. We argue that such backbone information is also helpful for learning source representation, and is not explicitly considered by the existing NMT system to enrich the source sentence representation.",
          "In this paper, we propose a novel explicit sentence compression approach to enhance the source representation for NMT. To this end, we first design three sentence compression models to accommodate the needs of various languages and scenarios, including supervised, unsupervised, and semi-supervised ways, to learn a backbone information words sequence (as shown in Table TABREF2) from the source sentence. We then propose three translation models, including backbone source-side fusion based NMT (BSFNMT), backbone target-side fusion (BTFNMT), and both-side fusion based NMT (BBFNMT), to introduce this backbone knowledge into the existing Transformer NMT system for improving translation predictions. Empirical results on the WMT14 English-to-German and English-to-French translation tasks show that the proposed approach significantly improves the translation performance over the strong even state-of-the-art NMT baselines."
        ]
      },
      {
        "section_name": "Explicit Sentence Compression",
        "paragraphs": [
          "Generally, sentence compression is a typical sequence generation task which aims to maximize the absorption and long-term retention of large amounts of data over a relatively short sequence for text understanding BIBREF5, BIBREF6. To distinguish the importance of words in the sentence and, more importantly, to dig out the most salient part in the sentence representation, we utilize the sentence compression method to explicitly distill the key knowledge that can retain the key meaning of the sentence, termed explicit sentence compression (ESC) in this paper. Depending on whether or not the sentence compression is trained using human annotated data, the proposed method can be implemented in three ways: supervised ESC, unsupervised ESC, and semi-supervised ESC."
        ]
      },
      {
        "section_name": "Explicit Sentence Compression ::: Supervised ESC",
        "paragraphs": [
          "Sentence compression usually relies on large-scale raw data together with their human-labeled data, which can be viewed as supervision, to train a sentence compression model BIBREF7, BIBREF8, BIBREF9, BIBREF10, BIBREF11, BIBREF12. For example, BIBREF11 proposed an attentive encoder-decoder recurrent neural network (RNN) to model abstractive text summarization. BIBREF13 furture proposed MAsked Sequence to Sequence pre-training (MASS) for the encoder-decoder sentence compression framework which reported state-of-the-art performance on both the Gigaword Corpus and DUC Corpus.",
          "Sentence compression can be conducted by a typical sequence-to-sequence model. The encoder represents the input sentence $S$ as a sequence of annotation vectors, and the decoder depends on the attention mechanism to learn the context vector for generating a compressed version $S^{^{\\prime }}$ with the key meaning of the input sentence. Recently, the new Transformer architecture proposed by BIBREF0, which fully relies on self-attention networks, has exhibited state-of-the-art translation performance for several language pairs. We follow this practice and attempt to apply the Transformer architecture to such a compression task."
        ]
      },
      {
        "section_name": "Explicit Sentence Compression ::: Unsupervised ESC",
        "paragraphs": [
          "A major challenge in supervised sentence compression is the scarce high quality human annotated parallel data. In practice, due to the lack of parallel annotated data, the supervised sentence compression model cannot be trained or the annotated data domain is different, resulting in the sentence compression model trained on the in-domain performing poorly on the out-of-domain.",
          "Supervised sentence compression models have achieved impressive performances based on large corpora containing pairs of verbose and compressed sentences with human annotation BIBREF11, BIBREF13. However, the effectiveness relies heavily on the availability of large amounts of parallel original and human-annotated compressed sentences. This hinders the sentence compression approach from further improvements for many low-resource scenarios. Recently, motivated by recent progress in unsupervised cross-lingual embeddings, the unsupervised NMT BIBREF14, BIBREF15, BIBREF16 opened the door to solving the problem of sequence-to-sequence learning without any parallel sentence pairs. It takes advantage of the lossless (ideal situation) nature of machine translation between languages; i.e., it can translate language $L_1$ to language $L_2$ and back translate $L_2$ to language $L_1$. However, sentence compression does not have this feature. It is lossy from sentence $S$ to sentence $S^{^{\\prime }}$, which makes it difficult to restore from the compressed sentence $S^{^{\\prime }}$ to the original sentence $S$.",
          "BIBREF17 added noises to extend the original sentences and trained a denoising auto-encoder to recover the original, constructing an end-to-end training network without any examples of compressed sentences in sequence to sequence framework. In doing so, the model has to exclude and reorder the noisy sentence input, and hence learns to output more semantic important, shorter but grammatically correct sentences. There are two types of noise used in the model: Additive Sampling Noise and Shuffle Noise.",
          "Additive Sampling Noise: To extend the original sentence, we sample additional sentence from the training dataset randomly, and then sub-sample a subset of words from each without replacement. The newly sampled words are appended to the original sentence.",
          "Shuffle Noise: In order for the model to learn to rephrase the input sentence to make the output shorter, we shuffle the resultant additive noisy sentence.",
          "To gain a better quality for the compressed sentences, we transfer the method of BIBREF17 into the Transformer architecture instead of their suggested RNN architecture, which makes it conducive to deeper network training and a larger corpus."
        ]
      },
      {
        "section_name": "Explicit Sentence Compression ::: Semi-supervised ESC",
        "paragraphs": [
          "As pointed out in BIBREF13, sequence to sequence framework has attracted much attention recently due to the advances of deep learning by using large-scale data. Many language generation tasks have only a small scale of pair data which can't support to train a deep model with good generalization ability. In comparison, there is a lot of unpaired data which is earier to obtain.",
          "We observe a performance degradation caused by different domains in the supervised ESC. According to the experimental results of BIBREF17, the accuracy of the unsupervised ESC is currently lower than the supervised one. Therefore, we have further adopted the semi-supervised explicit sentence compression model to alleviate this problem. Specifically, the unsupervised training (often referred to as pre-training) is performed on the unpaired data first and fine-tuning with the small scale paired data (supervised training) to obtain the ESC model with good performance and generalization ability."
        ]
      },
      {
        "section_name": "Explicit Sentence Compression ::: Compression Rate Control",
        "paragraphs": [
          "Explicit compression rate (length) control is a common method which has been used in previous sentence compression works. BIBREF18 examined several methods of introducing target output length information, and found that they were effective without negatively impacting summarization quality. BIBREF19 introduced a length marker token that induces the model to target an output of a desired length, coarsely divided into discrete bins. BIBREF17 augmented the decoder with an additional length countdown input which is a single scalar that ticks down to 0 when the generation reached the desired length.",
          "Different with the length marker or length countdown input, to induce our model to output the compression sequence with desired length, we use beam search during generation to find the sequence $S^{^{\\prime }}$ that maximizes a score function $s(S^{^{\\prime }}, S)$ given a trained ESC model. The length normalization is introduced to account for the fact that we have to compare hypotheses of different length. Without some form of length-normalization regular $ln$, beam search will favor shorter sequences over longer ones on average since a negative log-probability is added at each step, yielding lower (more negative) scores for longer sentences. Moreover, a coverage penalty $cp$ is also added to favor the sequence that cover the source sentence meaning as much as possible according to the attention weights BIBREF20.",
          "where $p_{i,j}$ is the attention probability of the $j$-th target word on the $i$-th source word. Parameters $\\alpha $ and $\\beta $ control the strength of the length normalization and the coverage penalty. Although $\\alpha $ can be used to control the compression ratio softly, we use the compression ratio $\\gamma $ to control the maximum length of decoding generation by hard requirements. When the decoding length $|S^{^{\\prime }}|$ is greater than $\\gamma |S|$, the decoding stops."
        ]
      },
      {
        "section_name": "NMT with ESC",
        "paragraphs": [
          "In this section, we first introduce the Transformer networks for machine translation. Then based on the fusion position of the backbone knowledge sequence, we propose three novel translation models: the backbone source-side fusion based NMT model (as shown in Figure FIGREF11), the backbone target-side based NMT model (as shown in Figure FIGREF12), and the backbone both-side based NMT. All of these models can make use of the source backbone knowledge generated by our sentence compression models."
        ]
      },
      {
        "section_name": "NMT with ESC ::: Transformer Networks",
        "paragraphs": [
          "A Transformer NMT model consists of an encoder and a decoder, which fully rely on self-attention networks (SANs), to translate a sentence in one language into another language with equivalent meaning. Formally, one input sentence $x$=$\\lbrace x_1, \\cdots , x_J\\rbrace $ of length $J$ is first mapped into a sequence of word vectors. Then the sequence and its position embeddings add up to form the input representation $v_x=\\lbrace v^x_1, \\cdots , v^x_J\\rbrace $. The sequence $\\lbrace v^x_1, \\cdots , v^x_J\\rbrace $ is then packed into a query matrix $\\textbf {Q}_x$, a key matrix $\\textbf {K}_x$, and a value matrix $\\textbf {V}_x$. For the SAN-based encoder, the self-attention sub-layer is first performed over $\\textbf {Q}$, $\\textbf {K}$, and $\\textbf {V}$ to the matrix of outputs as:",
          "where $d_{model}$ represents the dimensions of the model. Similarly, the translated target words are used to generate the decoder hidden state $\\textbf {s}_i$ at the current time-step $i$. Generally, the self-attention function is further refined as multi-head self-attention to jointly consider information from different representation subspaces at different positions:",
          "where the projections are parameter matrices $\\textbf {W}_{h}^{Q}$$\\in $$\\mathbb {R}^{d_{model}\\times d_k}$, $\\textbf {W}_{h}^{K}$$\\in $$\\mathbb {R}^{d_{model}\\times d_k}$, $\\textbf {W}_{h}^{V}$$\\in $$ \\mathbb {R}^{d_{model}\\times d_v}$, and $\\textbf {W}^{O}$$\\in $$\\mathbb {R}^{hd_{v}\\times d_{model}}$. For example, there are $H$=8 heads, $d_{model}$ is 512, and $d_k$=$d_v$=512/8=64. A position-wise feed-forward network (FFN) layer is applied over the output of multi-head self-attention, and then is added with the matrix $\\textbf {V}$ to generate the final source representation $H_{x}$=$\\lbrace H^{x}_1, \\cdots , H^{x}_J\\rbrace $:",
          "The SAN of decoder then uses both $H_x$ and target context hidden state $H_{tgt}$ to learn the context vector $o_i$ by \u201cencoder-decoder attention\":",
          "Finally, the context vector $o_{i}$ is used to compute translation probabilities of the next target word $\\textit {y}_i$ by a linear, potentially multi-layered function:",
          "where $\\textbf {L}_{o}$ and $\\textbf {L}_{w}$ are projection matrices."
        ]
      },
      {
        "section_name": "NMT with ESC ::: Backbone Source-side Fusion based NMT",
        "paragraphs": [
          "In the backbone source-side fusion based NMT (BSFNMT) model, given an input sentence $x$=$\\lbrace x_1, \\cdots , x_J\\rbrace $, there is an additional compressed sequence $x_c$=$\\lbrace x^c_1, \\cdots , x^c_K\\rbrace $ of length $K$ generated by the proposed sentence compression model. This compressed sequence is also input to the SAN shared with the original encoder with word vectors $v_c = \\lbrace v^c_i, \\cdots , v^c_K\\rbrace $ in shared vocabulary to learn its final representation $H_{c}$=$\\lbrace H^{c}_1, \\cdots , H^{c}_K\\rbrace $. In the proposed SFNMT model, we introduce an additional multi-head attention layer to fuse the compressed sentence and the original input sentence for learning a more effective source representation.",
          "Specifically, for the multi-head attention-fusion layer, a compressed sentence-specific context representation $H_x^c$ is computed by the multi-head attention on the original sentence representation $H_x$ and the compressed sentence representation $H_c$:",
          "$H_x^c$ and $H_x$ are added to form a fusion source representation $H_{x}^{^{\\prime }}$:",
          "Finally, the $H_{x}^{^{\\prime }}$ instead of $H_{x}$ is input to the Eq. (DISPLAY_FORM17) in turn for predicting the target translations word by word."
        ]
      },
      {
        "section_name": "NMT with ESC ::: Backbone Target-side Fusion based NMT",
        "paragraphs": [
          "In the backbone target-side fusion based NMT (BTFNMT) model, both the original sentence and its compressed version are also represented as $H_x$ and $H_c$ respectively by the shared SANs. We then use a tuple ($H_x,H_c$) instead of the source-side fusion representation $H_x^{^{\\prime }}$ as the input to the decoder. Specifically, we introduce an additional \u201cencoder-decoder attention\" module into the decoder to learn the compressed sequence context $b_i$ at the current time-step $i$:",
          "Since we are here to treat the original sentence and the compressed sentence as two independent source contexts when encoding at the source side, we use a context gate $g_c$ for integrating two independent contexts of the source: original context $c_i$ and compressed context $b_i$. The gate $g_i$ is calculated by:",
          "Therefore, the final target fusion context $c_i^{\\prime }$ is:",
          "where $\\sigma $ is the logistic sigmoid function, $\\otimes $ is the point-wise multiplication, and $[\\cdot ]$ represent the concatenation operation.",
          "The context $c_i^{\\prime }$ is input to replace the $c_i$ the Eq. (DISPLAY_FORM18) to compute the probabilities of next target word."
        ]
      },
      {
        "section_name": "NMT with ESC ::: Backbone Both-side Fusion based NMT",
        "paragraphs": [
          "In the backbone both-side fusion based NMT (BBFNMT) model, we combine BSFNMT and BTFNMT. Both the original representation $H_x$ and its compressed enhanced representation $H_x^{^{\\prime }}$ are as the input to the decoder. Similarly, we introduce an additional \u201cencoder-decoder attention\" module into the decoder to learn the compressed sequence enhanced context $b_i^{^{\\prime }}$ at the current time-step $i$:",
          "Then, the context gate $g_i$ consistent with BTFNMT is applied to combine the two context information $c_i$ and $b_i^{^{\\prime }}$."
        ]
      },
      {
        "section_name": "Experiments ::: Setup ::: Sentence Compression",
        "paragraphs": [
          "To evaluate the quality of our sentence compression model, we used the Annotated Gigaword corpus BIBREF21 as the benchmark BIBREF22. The data includes approximately 3.8 M training samples, 400 K validation samples, and 2 K test samples. The byte pair encoding (BPE) algorithm BIBREF23 was adopted for subword segmentation, and the vocabulary size was set at 40 K for our supervised, unsupervised and semi-supervised settings BIBREF24.",
          "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output. The $F_1$ score of ROUGE-1 (R-1), ROUGE-2 (R-2), and ROUGE-L (R-L) was used to evaluate this task BIBREF26. We use beam search with a beam size of 5, the length length normalization of 0.5, and the coverage penalty of 0.2.",
          "For the semi-supervised setting, in order to make the results comparable to BIBREF13, we used the same 190M English monolingual unpaired data from WMT News Crawl datasets for pre-training (unsupervised training). We included the other pretraining methods: masked language modeling (MLM, BERT) BIBREF27, denoising auto-encoder (DAE) BIBREF28, and masked sequence to sequence (MASS) BIBREF13 to compare with our unsupervised pretraining method in the semi-supervised setting."
        ]
      },
      {
        "section_name": "Experiments ::: Setup ::: Machine Translation",
        "paragraphs": [
          "The proposed NMT model was evaluated on the WMT14 English-to-German (EN-DE) and English-to-French (EN-FR) tasks, which are both standard large-scale corpora for NMT evaluation. For the EN-DE translation task, 4.43 M bilingual sentence pairs from the WMT14 dataset were used as training data, including Common Crawl, News Commentary, and Europarl v7. The newstest2013 and newstest2014 datasets were used as the dev set and test set, respectively. For the EN-FR translation task, 36 M bilingual sentence pairs from the WMT14 dataset were were used as training data. Newstest12 and newstest13 were combined for validation and the newstest14 was the test set, following the setting of BIBREF29. The BPE algorithm BIBREF23 was also adopted, and the joint vocabulary size was set at 40 K. For the hyper-parameters of our Transformer (base/large) models, we followed the settings used in BIBREF0's work.",
          "In addition, we also reported the state-of-the-art results in recent literatures, including modelling local dependencies (Localness) BIBREF30, fusing multiple-layer representations in SANs (Context-Aware) BIBREF31, and fusing all global context representations in SANs (global-deep context) BIBREF32. MultiBLEU was used to evaluate the translation task."
        ]
      },
      {
        "section_name": "Experiments ::: Main Results ::: Sentence Compression",
        "paragraphs": [
          "To evaluate the quality of our sentence compression model, we conducted a horizontal comparison between the proposed sentence compression model and other sentence compression models in different settings. Table TABREF34 shows the comparison results. We observed that the proposed unsupervised ESC model performed substantially better than Fevry and BIBREF17's unsupervised method. The proposed supervised ESC model also substantially outperformed the RNN-based Seq2seq and BIBREF11's baseline method. That is, our supervised model gave +2.0 improvements on R-1, R-2, and R-L scores over the RNN-based Seq2seq. This means that the proposed Transformer-based approaches can generate compressed sentences of high quality.",
          "We further compared our semi-supervised model with the semi-supervised pretraining methods of MLM BIBREF27, DAE BIBREF28, and MASS BIBREF13. Our unsupervised pretrainining method outperformed the other unsupervised pretrainining ones on the sentence compression task consistently."
        ]
      },
      {
        "section_name": "Experiments ::: Main Results ::: Machine Translation",
        "paragraphs": [
          "According to the results in Table TABREF34, we chose the semi-supervised ESC model (which performed the best) to generate compressed sentences for the machine translation task. The main results on the WMT14 EN-DE and EN-FR translation tasks are shown in Table TABREF35. In the EN-DE task, we made the following observations:",
          "1) The baseline Transformer (base) in this work achieved a performance comparable to the original Transformer (base) BIBREF0. This indicates that it is a strong baseline NMT system.",
          "2) All BSFNMT, BTFNMT, and BBFNMT significantly outperformed the baseline Transformer (base/big) and only introduces a very small amount of extra parameters. This indicates that the learned compressed backbone information was beneficial for the Transformer translation system.",
          "3) Among the proposed three methods, BTFNMT performed better than BSFNMT. This indicates that the backbone fusion at the target-side is better than at the source-side. In addition, BBFNMT (base/big) outperformed the comparison systems +Localness and +Context-Aware SANs. This indicates that the compression knowledge as an additional context can enhance NMT better.",
          "4) BBFNMT (based) is comparable to the +global-deep context, the best comparison system, while BBFNMT (big) slightly outperformed +global-deep context by $0.16$ BLEU scores. In particular, the parameters of BBFNMT (base/big) model, which just increased $12.1/7.9$M over the Transformer (base/big), were only 70% of the +global-deep context model. This denotes that the BBFNMT model is more efficient than the +global-deep context model. In addition, the training speed of the proposed models slightly decreased ($8\\%$), compared to the corresponding baselines.",
          "5) The proposed BBFNMT (base) slightly outperformed the Transformer (big) which contains much more parameters than BBFNMT (base). This indicates that our improvement is not likely to be due to the increased number of parameters.",
          "For the EN-FR translation task, the proposed models gave similar improvements over the baseline systems and comparing methods (except that the Transformer (big) performed much more better than Transformer (base)). These results show that our method is robust for improving the translation of other language pairs."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Study ::: Evaluating Sentence Compression",
        "paragraphs": [
          "To demonstrate the effectiveness of sentence compression, we compared the compressed sentences ($\\gamma = 0.6$) generated in the Transformer translation system (BBFNMT) under different settings: AllText, F8W, RandSample (random sampling), supervised ESC, Unsupervised ESC and semi-supervised ESC. Table TABREF39 shows the results on newstest2014 for the EN-DE translation task.",
          "We made the following observations: 1) Simply introducing AllText and F8W achieved few improvement, and RandSample is lower than the baseline. In comparison, all the +supervised ESC, +unsupervised ESC, and +semi-supervised ESC models substantially improved the performance over the baseline Transformer (base). This means that our ESC method provides a richer source information for machine translation tasks.",
          "2) +Unsupervised ESC can gain better improvements over the +supervised ESC although supervised ESC model can achieve higher quality than the unsupervised ESC model in the benchmark test dataset. This may be due to that the annotated sentence compression training data is in different domain with the WMT EN-DE traing data. Meanwhile, +Semi-supervised ESC with annotated data fine-tuning outperformed both +Unsupervised and +supervised ESC."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Study ::: Effect of Encoder Parameters",
        "paragraphs": [
          "In our model, representations of the original sentence and its compressed version were learned by a shared encoder. To explore the effect of the encoder parameters, we also designed a BBFNMT with two independent encoders to learn representations of the original sentence and its compressed version, respectively. Table TABREF41 shows results on the newstest2014 test set for the WMT14 EN-DE translation task.",
          "The BBFNMT (w/ independent params) slightly outperformed the proposed shared encoder model by a BLEU score of 0.15, but its parameters increased by approximately 30%. In contrast, the parameters in our model are comparable to the baseline Transformer (base). Considering the parameter scale, we took a shared encoder to learn source representation, which makes it easy to verify the effectiveness of the additional translation knowledge, such as our backbone knowledge."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation Study ::: Evaluating Compression Ratio",
        "paragraphs": [
          "In order to verify the impact of different compression ratios on translation quality, we conducted experiments on EN-DE translation task with semi-supervised sentence compression in BBFNMT model.",
          "We controled the compression ratio $\\gamma $ from 0 to 1.0. Consider two boundary conditions, when the compression ratio $\\gamma = 0$, it means no compression sequence generated, which is the same as the vanilla Transformer. When the compression ratio $\\gamma = 1.0$, it is equivalent to re-paraphrasing the source sentence using the sentence compression model (maintaining the same length) as the additional input for BBFNMT.",
          "The experimental results are shown in Fig. FIGREF43. As can be seen from the results, in our experiments, sentence compression (re-paraphrasing) can bring performance improvement, even when the compression ratio $\\gamma =1.0$ and the sentence length is not shortened, re-paraphrasing can still bring slight improvement of translation quality. On the wmt14 EN-DE translation task, the compression ratio $\\gamma $ was set to 0.6 to get the best results."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "To let the translation have more focus over the source sentence information, efforts have been initiated on exploiting sentence segmentation, sentence simplification, and sentence compression for machine translation. BIBREF33 presented a approach to integrating the sentence skeleton information into a phrase-based statistic machine translation system. BIBREF34 proposed an approach to modeling syntactically-motivated skeletal structure of source sentence for statistic machine translation. BIBREF35 describe an early approach to skeleton-based translation, which decomposes input sentences into syntactically meaningful chunks. The central part of the sentence is identified and remains unaltered while other parts of the sentence are simplified. This process produces a set of partial, potentially overlapping translations which are recombined to form the final translation. BIBREF36 describe a \u201cdivide and translate\u201d approach to dealing with complex input sentences. They parse the input sentences, replace subclauses with placeholders and later substitute them with separately translated clauses. Their method requires training translation models on clause-level aligned parallel data with placeholders in order for the translation model to deal with the placeholders correctly. BIBREF37 experimented with automatically segmenting the source sentence to overcome problems with overly long sentences. BIBREF38 showed that the spaces of original and simplified translations can be effectively combined using translation lattices and compare two decoding approaches to process both inputs at different levels of integration.",
          "Different from these work, our proposed sentence compression model does not rely on any known linguistics motivated (such as syntax) skeleton simplification, but directly trains a computation motivated sentence compression model to learn to compress sentences and re-paraphrase them directly in seq2seq model. Though with a pure computation source, our sentence compression model can surprisingly generate more grammatically correct and refined sentences, and the words in the compressed sentence do not have to be the same as the original sentence. In the meantime, our sentence compression model can stably give source backbone representation exempt from unstable performance of a syntactic parser which is essential for syntactic skeleton simplification. Our sentence compression model can perform unsupervised training on large-scale data sets, and then use the supervised data for finetune, which is more promising from the results."
        ]
      },
      {
        "section_name": "Conclusion and Future work",
        "paragraphs": [
          "To give a more focused source representation, this paper makes the first attempt to propose an explicit sentence compression method to enhance state-of-the-art Transformer-based NMT. To demonstrate that the proposed sentence compression enhancement is indeed helpful for the neural machine translation, We evaluate the impact of the proposed model on the large-scale WMT14 English-to-German and English-to-French translation tasks. The experimental results on WMT14 EN-DE and EN-FR translation tasks show that our proposed NMT model can yield significantly improved results over strong baseline translation systems. In the future work, we will release a pre-trained language model that uses unsupervised sentence compression as the pre-training objective to demonstrate the performance of unsupervised sentence compression in representation learning."
        ]
      },
      {
        "section_name": "Acknowledgment",
        "paragraphs": [
          "The corresponding authors are Rui wang and Hai Zhao. Zuchao Li and Zhuosheng Zhang were internship research fellows at NICT when conducting this work. Hai Zhao was partially supported by National Key Research and Development Program of China (No. 2017YFB0304100) and Key Projects of National Natural Science Foundation of China (No. U1836222 and No. 61733011). Rui Wang was partially supported by JSPS grantin-aid for early-career scientists (19K20354): \u201cUnsupervised Neural Machine Translation in Universal Scenarios\u201d and NICT tenure-track researcher startup fund \u201cToward Intelligent Machine Translation\u201d."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which baselines to they compare to?",
        "question_id": "a4cf0cf372f62b2dbc7f31c600c6c66246263328",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "AllText",
                "F8W"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To evaluate the quality of our sentence compression model, we used the Annotated Gigaword corpus BIBREF21 as the benchmark BIBREF22. The data includes approximately 3.8 M training samples, 400 K validation samples, and 2 K test samples. The byte pair encoding (BPE) algorithm BIBREF23 was adopted for subword segmentation, and the vocabulary size was set at 40 K for our supervised, unsupervised and semi-supervised settings BIBREF24.",
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output. The $F_1$ score of ROUGE-1 (R-1), ROUGE-2 (R-2), and ROUGE-L (R-L) was used to evaluate this task BIBREF26. We use beam search with a beam size of 5, the length length normalization of 0.5, and the coverage penalty of 0.2."
              ],
              "highlighted_evidence": [
                "To evaluate the quality of our sentence compression model, we used the Annotated Gigaword corpus BIBREF21 as the benchmark BIBREF22.",
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output. "
              ]
            },
            "annotation_id": "1e6fc9e8699f40743a45f5018168b825b8a3c313",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "AllText",
                "F8W"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output. The $F_1$ score of ROUGE-1 (R-1), ROUGE-2 (R-2), and ROUGE-L (R-L) was used to evaluate this task BIBREF26. We use beam search with a beam size of 5, the length length normalization of 0.5, and the coverage penalty of 0.2."
              ],
              "highlighted_evidence": [
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output."
              ]
            },
            "annotation_id": "253d69a6a69e4b20dbdafd6aa474949c961726c3",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "AllText",
                "F8W"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25. F8W is simply the first 8 words of the input, and AllText uses the whole text as the compression output. The $F_1$ score of ROUGE-1 (R-1), ROUGE-2 (R-2), and ROUGE-L (R-L) was used to evaluate this task BIBREF26. We use beam search with a beam size of 5, the length length normalization of 0.5, and the coverage penalty of 0.2."
              ],
              "highlighted_evidence": [
                "Baseline systems include AllText and F8W BIBREF22, BIBREF25."
              ]
            },
            "annotation_id": "66dd246c3f63608bfb8c34c54d76a173ba54db29",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "TABLE 1 An example of sentence compression."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Fig. 2. The architecture of proposed BSFNMT model."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Fig. 3. The architecture of proposed BTFNMT model."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "TABLE 2 Performance on the sentence compression task"
      },
      {
        "file": "6-Table3-1.png",
        "caption": "TABLE 3 Comparison with existing NMT systems on WMT14 EN-DE and EN-FR Translation Tasks. \u201c++/+\u201d after the BLEU score indicate that the proposed method was significantly better than the corresponding baseline Transformer (base or big) at significance level p<0.01/0.05. \u201c#Speed\u201d denotes the decoding speed measured in target tokens per second."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "TABLE 5 The effect of encoder parameters."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "TABLE 4 The effect of our ESC methods."
      },
      {
        "file": "7-Figure3-1.png",
        "caption": "Fig. 3. Performances on EN-DE newstest2014 with different sentence compression ratios."
      }
    ]
  },
  "2004.04060": {
    "title": "Self-Attention Gazetteer Embeddings for Named-Entity Recognition",
    "abstract": "Recent attempts to ingest external knowledge into neural models for named-entity recognition (NER) have exhibited mixed results. In this work, we present GazSelfAttn, a novel gazetteer embedding approach that uses self-attention and match span encoding to build enhanced gazetteer embeddings. In addition, we demonstrate how to build gazetteer resources from the open source Wikidata knowledge base. Evaluations on CoNLL-03 and Ontonotes 5 datasets, show F1 improvements over baseline model from 92.34 to 92.86 and 89.11 to 89.32 respectively, achieving performance comparable to large state-of-the-art models.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Named-entity recognition (NER) is the task of tagging relevant entities such as person, location and organization in unstructured text. Modern NER has been dominated by neural models BIBREF0, BIBREF1 combined with contextual embeddings from language models (LMs) BIBREF2, BIBREF3, BIBREF4. The LMs are pre-trained on large amounts of unlabeled text which allows the NER model to use the syntactic and semantic information captured by the LM embeddings. On the popular benchmark datasets CoNLL-03 BIBREF5 and Ontonotes 5 BIBREF6, neural models with LMs achieved state-of-the-art results without gazetteers features, unlike earlier approaches that heavily relied on them BIBREF7. Gazetteers are lists that contain entities such as cities, countries, and person names. The gazetteers are matched against unstructured text to provide additional features to the model. Data for building gazetteers is available for multiple language from structured data resources such as Wikipedia, DBpedia BIBREF8 and Wikidata BIBREF9.",
          "In this paper, we propose GazSelfAttn, a novel gazetteer embedding approach that uses self-attention and match span encoding to build enhanced gazetteer representation. GazSelfAttn embeddings are concatenated with the input to a LSTM BIBREF10 or CNN BIBREF11 sequence layer and are trained end-to-end with the model. In addition, we show how to extract general gazetteers from the Wikidata, a structured knowledge-base which is part of the Wikipedia project.",
          "Our contributions are the following:",
          "[topsep=1pt, leftmargin=15pt, itemsep=-1pt]",
          "We propose novel gazetteer embeddings that use self-attention combined with match span encoding.",
          "We enhance gazetteer matching with multi-token and single-token matches in the same representation.",
          "We demonstrate how to use Wikidata with entity popularity filtering as a resource for building gazetteers.",
          "GazSelfAttn evaluations on CoNLL-03 and Ontonotes 5 datasets show F$_1$ score improvement over baseline model from 92.34 to 92.86 and from 89.11 to 89.32 respectively. Moreover, we perform ablation experiments to study the contribution of the different model components."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Recently, researchers added gazetteers to neural sequence models. BIBREF12 demonstrated small improvements on large datasets and bigger improvements on small datasets. BIBREF13 proposed to train a gazetteer attentive network to learn name regularities and spans of NER entities. BIBREF14 demonstrated that trained gazetteers scoring models combined with hybrid semi-Markov conditional random field (HSCRF) layer improve overall performance. The HSCRF layer predicts a set of candidate spans that are rescored using a gazetteer classifier model. The HSCRF approach differs from the common approach of including gazetteers as an embedding in the model. Unlike the work of BIBREF14, our GazSelfAttn does not require training a separate gazetteer classifier and the HSCRF layer, thus our approach works with any standard output layer such as conditional random field (CRF) BIBREF15.",
          "BIBREF16 proposed an auto-encoding loss with hand-crafted features, including gazetteers, to improve accuracy. However, they did not find that gazetteer features significantly improve accuracy.",
          "Extracting gazetteers from structure knowledge sources was investigated by BIBREF17 and BIBREF18. They used Wikipedia's instance of relationship as a resource for building gazetteers with classical machine learning models. Compared to Wikidata, the data extracted from Wikipedia is smaller and noisier.",
          "Similar to this paper, BIBREF19 used Wikidata as a gazetteer resource. However, they did not use entity popularity to filter ambiguous entities and their gazetteer model features use simple one-hot encoding."
        ]
      },
      {
        "section_name": "Approach ::: Model Architecture",
        "paragraphs": [
          "We add GazSelfAttn embeddings to the popular Neural CRF model architecture with ELMo LM embeddings from BIBREF2. Figure FIGREF5 depicts the model, which consists of Glove word embeddings BIBREF20, Char-CNN BIBREF21, BIBREF1, ELMo embeddings, Bi-LSTM, and output CRF layer with BILOU (Beginning Inside Last Outside Unit) labels encoding BIBREF22. Note that, we concatenate the gazetteer embeddings to the Bi-LSTM input."
        ]
      },
      {
        "section_name": "Approach ::: Gazetteers",
        "paragraphs": [
          "In this section, we address the issue of building a high-quality gazetteer dictionary $M$ that maps entities to types, e.g., $M$[Andy Murray] $\\rightarrow $ Person. In this work, we use Wikidata, an open source structured knowledge-base, as the source of gazetteers. Although, Wikidata and DBpedia are similar knowledge bases, we choose Wikidata because, as of 2019, it provides data on around 45 million entities compared to around 5 million in DBpedia.",
          "Wikidata is organized as entities and properties. Entities can be concrete (Boston, NATO, Michael Jordan) and abstract (City, Organization, Person). Properties describe an entity relations. For example, Boston instance_of City and Boston part_of Massachusetts; both instance_of and part_of are properties. Also, each entity is associated with sitelink count which tacks mentions of the entity on Wikimedia website and can be used as proxy for popularity.",
          "To extract gazetteers from Wikidata, we process the official dumps into tuples of entity and type based only on the left and right part of the instance_of triplet, example resulting tuples are Boston $\\rightarrow $ City and Massachusetts $\\rightarrow $ State. Each entity is associated with a set of aliases, we keep only the aliases that are less than seven tokens long. Example aliases for Boston are \u201cBeantown\u201d and \u201cThe Cradle of Liberty\u201d. If there are multiple types per alias, we use the sitelink count to keep the six most popular types. The sitelink filtering is important to reduce the infrequent meanings of an entity in the gazetteer data.",
          "The Wikidata types that we obtain after processing the Wikidata dumps are fine-grained. However, certain NER tasks require coarse-grained types. For instance, CoNLL-03 task has a single Location label that consists of cities, states, countries, and other geographic location. To move from fine-grained to coarse-grained types, we use the Wikidata hierarchical structure induced by the subclass_of property. Examples of subclass_of hierarchies in Wikidata are: City $\\rightarrow $ Human Settlement $\\rightarrow $ Geographic Location, and Artist $\\rightarrow $ Creator $\\rightarrow $ Person. We change the types granularity depending on the NER task by traversing up, from fine-grained types to the target coarse-grained types. For instance, we merge the Artist and Painter types to Person, and the River and Mountain types to Location."
        ]
      },
      {
        "section_name": "Approach ::: Gazetteer Matching",
        "paragraphs": [
          "Gazetteer matching is the process of assigning gazetteer features to sentence tokens. Formally, given a gazetteer dictionary $M$ that maps entities to types, and a sentence $S = (t_1, t_2, ..., t_n)$ with tokens $t_i$, we have to find the $m$ gazetteer types $\\lbrace g^1_i, g^2_i,..,g^m_i\\rbrace $ and spans $\\lbrace s^1_i, s^2_i,..,s^m_i\\rbrace $ for every token $t_i$. The set notation $\\lbrace $} indicates that multiple $m$ matches are allowed per token. The match span $\\lbrace s^j_i\\rbrace $ represents positional information which encodes multi-token matches. The match spans are encoded using a BILU (Beginning Inside Last Unit) tags, similar to the BILOU tags that we use to encode the NER labels.",
          "In general, there are two methods for gazetteer matching: multi-token and single-token. Multi-token matching is searching for the longest segments of the sentence that are in $M$. For instance, given $M$[New York] $\\rightarrow $ State, $M$[New York City] $\\rightarrow $ City and the sentence \u201cYesterday in New York City\u201d, the multi-token matcher assigns the City gazetteer type to the longest segment \u201cNew York City\u201d. Single-token matching is searching to match any vocabulary word from a gazetteer type. In the earlier example, each word from the sentence is individually matched to the tokens in $M$, thus \u201cNew\u201d and \u201cYork\u201d are individually matched to both City and State, and \u201cCity\u201d is matched only to City.",
          "BIBREF12 research shows that both multi-token and single-token matching perform better on certain datasets. We propose to combine both methods: we tag the multi-token matches with BILU tags, and the single-token matches with a Single (S) tag. The single-token matches are used only if multi-token matches are not present. We consider that the single-token matches are high-recall low-precision, and multi-token matches are low-recall and high-precision. Thus, a combination of both works better than individually. Example sentences are: \u201cYesterday in New(City-B) York(City-I) City(City-L)\u201d, and \u201cYesterday in York(City-S) City(City-S)\u201d York City is marked with singles tag since $M$ does not have entities for \u201cYork City\u201d, \u201cYork\u201d, and \u201cCity\u201d.",
          "Note that gazetteer matching is unsupervised, i.e., we do not have a ground truth of correctly matched sentences for $M$. Furthermore, it is a hard task because of the many variations in writing and ambiguity of entities."
        ]
      },
      {
        "section_name": "Approach ::: Gazetteer Embeddings",
        "paragraphs": [
          "px",
          "Equations DISPLAY_FORM11- shows the gazetteer embedding $\\mathbf {g}_i$ computation for a token $t_i$. To compute $\\mathbf {g}_i$, given a set of $m$ gazetteer types $\\lbrace g^m_i\\rbrace $ and spans $\\lbrace s^m_i\\rbrace $, we execute the following procedure:",
          "[topsep=1pt, leftmargin=15pt, itemsep=-1pt]",
          "Equation DISPLAY_FORM11. We embed the sets $\\lbrace g^m_i\\rbrace $ and $\\lbrace s^m_i\\rbrace $ using the embedding matrices $\\mathbf {G}$ and $\\mathbf {S}$. Then, we do an element-wise addition, denoted $\\oplus $, of the corresponding types and spans embeddings to get a matrix $\\mathbf {E}_i$.",
          "Equation . We compute $\\mathbf {A}_i$ using scaled dot-product self-attention BIBREF23, where $d$ is the dimensionality of the gazetteer embeddings. The attention contextualizes the embeddings with multiple gazetteer matches per token $t_i$.",
          "Equation . To add model flexibility, we compute $\\mathbf {H}_i$ with a position-wise feed-forward layer and GELU activation BIBREF24.",
          "Equation . Finally, we perform max pooling across the embeddings $\\mathbf {H}_i$ to obtain the final gazetteer embedding $\\mathbf {g}_i$."
        ]
      },
      {
        "section_name": "Approach ::: Gazetteer Dropout",
        "paragraphs": [
          "To prevent the neural NER model from overfitting on the gazetteers, we use gazetteers dropout BIBREF25. We randomly set to zero gazetteer embeddings $\\mathbf {g}_i$, so the gazetteer vectors that are input to the LSTM become zero. We tune the gazetteer dropout hyperparameter on the validation set."
        ]
      },
      {
        "section_name": "Experiments ::: Setup",
        "paragraphs": [
          "Datasets. We evaluate on the English language versions of CoNLL-03 dataset BIBREF5 and the human annotated portion of the Ontonotes 5 BIBREF6 dataset. CoNLL-03 labels cover 4 entity types: person, location, organization, and miscellaneous. The Onotonotes 5 dataset is larger and its labels cover 18 types: person, NORP, facility, organization, GPE, location, product, event, work of art, law, language, date, time, percent, money, quantity, ordinal, cardinal.",
          "px",
          "Gazetteers. We use the Wikidata gazetteers with types merged to the granularity of the CoNLL-03 and Ononotes 5 datasets. We filter non-relevant types (e.g., genome names, disease) and get a total of one million records. For CoNLL-03 and Ontonotes 5, the percentage of entities covered by gazetteers are 96% and 78% respectively, and percentage of gazetteers wrongly assigned to non-entity tokens are 41% and 41.5% respectively.",
          "Evaluation. We use the standard CoNLL evaluation script which reports entity F1 scores. The F1 scores are averages over 5 runs.",
          "Configuration. We use the Bi-LSTM-CNN-CRF model architecture with ELMo language model embeddings from BIBREF2, which consist of 50 dim pre-trained Glove word embeddings BIBREF20, 128 dim Char-CNN BIBREF21, BIBREF1 embeddings with filter size of 3 and randomly initialized 16 dim char embeddings, 1024 pre-trained ELMo pre-trained embeddings, two layer 200 dim Bi-LSTM, and output CRF layer with BILOU (Beginning Inside Last Outside Unit) spans BIBREF22.",
          "For the gazetteer embeddings, we use 128 dim for the embedding matrices $\\mathbf {G}$ and $\\mathbf {S}$, 128 dim output for $\\mathbf {W}$, which yields a gazetteer embedding $\\mathbf {g}_i$ with 128 dim. The parameters are randomly initialized and trained. We apply gazetteer dropout of 0.1 which we tuned on the development set; we tried values form 0.05 to 0.6.",
          "All parameters except the ELMo embeddings are trained. We train using the Adam BIBREF26 optimizer with learning rate of 0.001 for 100 epochs. We use early stopping with patience 25 on the development set. Batch size of 64, dropout rate of 0.5 and L2 regularization of 0.1."
        ]
      },
      {
        "section_name": "Experiments ::: Results",
        "paragraphs": [
          "The experimental results for NER are summarized in Table TABREF20. The top part of the table shows recently published results. BIBREF14's work is using gazetteers with HSCRF and BIBREF4's work is using the Flair language model which is much larger than ELMo. BIBREF27 is the current state-of-the-art language model that uses cloze-driven pretraining. The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings. Including ELMo embeddings the CoNLL-03 and Ontonotes 5, F$_1$ score improves from 92.34 to 92.86 and 89.11 to 89.32 respectively. Without ELMo embeddings the F$_1$ score improves from 90.42 to 91.12 and 86.63 to 87 respectively. We observe that GazSelfAttn relative improvements are similar with and without ELMo embeddings. We obtain slightly better CoNLL-03 F$_1$ score compared to BIBREF14 work that uses the HSCRF model, and we match the Ononotes 5 F$_1$ scores of BIBREF4 that uses a much bigger model. BIBREF14 Ononotes 5 results use subset of the dataset labels and are not comparable. Note that because of computation constrains, we did not perform extensive hyperparameter tuning except for the gazetteer dropout rate."
        ]
      },
      {
        "section_name": "Experiments ::: Ablation study",
        "paragraphs": [
          "Table TABREF22 shows ablation experiments. We remove components of the gazetteer embedding model from the Neural CRF model. In each experiment, we removed only the specified component. Ablations show decreased F$_1$ score on the development and test set if any of the components is removed. The highest degradation is when single matches are removed which underscores the importance of the combining the gazetteer matching techniques for NER. We observe that match span encoding is more important for the CoNLL-02 compared to Ononotes 5 because the former has more entities with multiple tokens. Removing the self-attention shows that self-attention is effective at combining information form multiple gazetteers.",
          "In addition, we tried moving the gazetteer embeddings to the CRF layer and using the LSTM token embeddings as attention keys but the F$_1$ degraded significantly. We experimented with adding auto-encoding loss similar to BIBREF16 and multi-head self-attention. However, we did not observe F$_1$ score improvements and sometimes small degradations."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We presented GazSelfAttn, a novel approach for gazetteer embeddings that uses self-attention and match span positions. Evaluation results of GazSelfAttn show improvement compared to competitive baselines and state-of-the-art models on multiple datasets.",
          "For future work we would like to evaluate GazSelfAttn on non-English language datasets and improve the multi-token gazetteer matching with fuzzy string matching. Also, we would like to explore transfer learning of gazetteer embeddings from high-resource to low-resource setting."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is used as a baseline model?",
        "question_id": "2803709fba74e6098aae145abcbf0e9a3f4c35e5",
        "nlp_background": "zero",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "258ee4069f740c400c0049a2580945a1cc7f044c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Neural CRF model with and without ELMo embeddings"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The experimental results for NER are summarized in Table TABREF20. The top part of the table shows recently published results. BIBREF14's work is using gazetteers with HSCRF and BIBREF4's work is using the Flair language model which is much larger than ELMo. BIBREF27 is the current state-of-the-art language model that uses cloze-driven pretraining. The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings. Including ELMo embeddings the CoNLL-03 and Ontonotes 5, F$_1$ score improves from 92.34 to 92.86 and 89.11 to 89.32 respectively. Without ELMo embeddings the F$_1$ score improves from 90.42 to 91.12 and 86.63 to 87 respectively. We observe that GazSelfAttn relative improvements are similar with and without ELMo embeddings. We obtain slightly better CoNLL-03 F$_1$ score compared to BIBREF14 work that uses the HSCRF model, and we match the Ononotes 5 F$_1$ scores of BIBREF4 that uses a much bigger model. BIBREF14 Ononotes 5 results use subset of the dataset labels and are not comparable. Note that because of computation constrains, we did not perform extensive hyperparameter tuning except for the gazetteer dropout rate."
              ],
              "highlighted_evidence": [
                " We experiment with the Neural CRF model with and without ELMo embeddings. "
              ]
            },
            "annotation_id": "6be704c4e6911d751181a05d2da7b0ff2435abb9",
            "worker_id": "9cf96ca8b584b5de948019dc75e305c9e7707b92"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Neural CRF model with and without ELMo embeddings"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The experimental results for NER are summarized in Table TABREF20. The top part of the table shows recently published results. BIBREF14's work is using gazetteers with HSCRF and BIBREF4's work is using the Flair language model which is much larger than ELMo. BIBREF27 is the current state-of-the-art language model that uses cloze-driven pretraining. The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings. Including ELMo embeddings the CoNLL-03 and Ontonotes 5, F$_1$ score improves from 92.34 to 92.86 and 89.11 to 89.32 respectively. Without ELMo embeddings the F$_1$ score improves from 90.42 to 91.12 and 86.63 to 87 respectively. We observe that GazSelfAttn relative improvements are similar with and without ELMo embeddings. We obtain slightly better CoNLL-03 F$_1$ score compared to BIBREF14 work that uses the HSCRF model, and we match the Ononotes 5 F$_1$ scores of BIBREF4 that uses a much bigger model. BIBREF14 Ononotes 5 results use subset of the dataset labels and are not comparable. Note that because of computation constrains, we did not perform extensive hyperparameter tuning except for the gazetteer dropout rate.",
                "FLOAT SELECTED: Table 2: Results on CoNLL-03 and OntoNotes 5."
              ],
              "highlighted_evidence": [
                "The experimental results for NER are summarized in Table TABREF20. ",
                "The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings. Including ELMo embeddings the CoNLL-03 and Ontonotes 5, F$_1$ score improves from 92.34 to 92.86 and 89.11 to 89.32 respectively. Without ELMo embeddings the F$_1$ score improves from 90.42 to 91.12 and 86.63 to 87 respectively. ",
                "FLOAT SELECTED: Table 2: Results on CoNLL-03 and OntoNotes 5."
              ]
            },
            "annotation_id": "8eb59241621542c33f0f7b1f56a599d02fb294eb",
            "worker_id": "a0b403873302db7cada39008f04d01155ef68f4f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Neural CRF model with and without ELMo embeddings"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The experimental results for NER are summarized in Table TABREF20. The top part of the table shows recently published results. BIBREF14's work is using gazetteers with HSCRF and BIBREF4's work is using the Flair language model which is much larger than ELMo. BIBREF27 is the current state-of-the-art language model that uses cloze-driven pretraining. The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings. Including ELMo embeddings the CoNLL-03 and Ontonotes 5, F$_1$ score improves from 92.34 to 92.86 and 89.11 to 89.32 respectively. Without ELMo embeddings the F$_1$ score improves from 90.42 to 91.12 and 86.63 to 87 respectively. We observe that GazSelfAttn relative improvements are similar with and without ELMo embeddings. We obtain slightly better CoNLL-03 F$_1$ score compared to BIBREF14 work that uses the HSCRF model, and we match the Ononotes 5 F$_1$ scores of BIBREF4 that uses a much bigger model. BIBREF14 Ononotes 5 results use subset of the dataset labels and are not comparable. Note that because of computation constrains, we did not perform extensive hyperparameter tuning except for the gazetteer dropout rate."
              ],
              "highlighted_evidence": [
                "The bottom part of the table is shows our baseline models and results with included gazetteers. We experiment with the Neural CRF model with and without ELMo embeddings."
              ]
            },
            "annotation_id": "8f5ffc990e9d323886e7fad2ab9b161c7db8b075",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Model architecture with gazetteer embeddings."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Dataset sizes in number of sentences."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Results on CoNLL-03 and OntoNotes 5."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Ablation study results on CoNLL-03 and OntoNotes 5. \u201c- span encoding\u201d removes the BILU match span encoding leaving only the gazetteer types. \u201c- self attention\u201d removes the self-attention. \u201c- uncased matches\u201d removes the uncased matches."
      }
    ]
  },
  "1807.08089": {
    "title": "Phonetic-and-Semantic Embedding of Spoken Words with Applications in Spoken Content Retrieval",
    "abstract": "Word embedding or Word2Vec has been successful in offering semantics for text words learned from the context of words. Audio Word2Vec was shown to offer phonetic structures for spoken words (signal segments for words) learned from signals within spoken words. This paper proposes a two-stage framework to perform phonetic-and-semantic embedding on spoken words considering the context of the spoken words. Stage 1 performs phonetic embedding with speaker characteristics disentangled. Stage 2 then performs semantic embedding in addition. We further propose to evaluate the phonetic-and-semantic nature of the audio embeddings obtained in Stage 2 by parallelizing with text embeddings. In general, phonetic structure and semantics inevitably disturb each other. For example the words\"brother\"and\"sister\"are close in semantics but very different in phonetic structure, while the words\"brother\"and\"bother\"are in the other way around. But phonetic-and-semantic embedding is attractive, as shown in the initial experiments on spoken document retrieval. Not only spoken documents including the spoken query can be retrieved based on the phonetic structures, but spoken documents semantically related to the query but not including the query can also be retrieved based on the semantics.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Word embedding or Word2Vec BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 has been widely used in the area of natural language processing BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 , BIBREF8 , BIBREF9 , BIBREF10 , in which text words are transformed into vector representations of fixed dimensionality BIBREF11 , BIBREF12 , BIBREF13 . This is because these vector representations carry plenty of semantic information learned from the context of the considered words in the text training corpus. Similarly, audio Word2Vec has also been proposed in the area of speech signal processing, in which spoken words (signal segments for words without knowing the underlying word it represents) are transformed into vector representations of fixed dimensionality BIBREF14 , BIBREF15 , BIBREF16 , BIBREF17 , BIBREF18 , BIBREF19 , BIBREF20 , BIBREF21 , BIBREF22 , BIBREF23 , BIBREF24 . These vector representations carry the phonetic structures of the spoken words learned from the signals within the spoken words, and have been shown to be useful in spoken term detection, in which the spoken terms are detected simply based on the phonetic structures. Such Audio Word2Vec representations do not carry semantics, because they are learned from individual spoken words only without considering the context.",
          "Audio Word2Vec was recently extended to Segmental Audio Word2Vec BIBREF25 , in which an utterance can be automatically segmented into a sequence of spoken words BIBREF26 , BIBREF27 , BIBREF28 , BIBREF29 and then transformed into a sequence of vectors of fixed dimensionality by Audio Word2Vec, and the spoken word segmentation and Audio Word2Vec can be jointly trained from an audio corpus. In this way the Audio Word2Vec was upgraded from word-level to utterance-level. This offers the opportunity for Audio Word2Vec to include semantic information in addition to phonetic structures, since the context among spoken words in utterances bring semantic information. This is the goal of this work, and this paper reports the first set of results towards such a goal.",
          "In principle, the semantics and phonetic structures in words inevitably disturb each other. For example, the words \u201cbrother\" and \u201csister\" are close in semantics but very different in phonetic structure, while the words \u201cbrother\" and \u201cbother\" are close in phonetic structure but very different in semantics. This implies the goal of embedding both phonetic structures and semantics for spoken words is naturally very challenging. Text words can be trained and embedded as vectors carrying plenty of semantics because the phonetic structures are not considered at all. On the other hand, because spoken words are just a different version of representations for text words, it is also natural to believe they do carry some semantic information, except disturbed by phonetic structures plus some other acoustic factors such as speaker characteristics and background noise BIBREF30 , BIBREF31 , BIBREF32 , BIBREF33 , BIBREF34 , BIBREF35 . So the goal of embedding spoken words to carry both phonetic structures and semantics is possible, although definitely hard.",
          "But a nice feature of such embeddings is that they may include both phonetic structures and semantics BIBREF36 , BIBREF37 . A direct application for such phonetic-and-semantic embedding of spoken words is spoken document retrieval BIBREF38 , BIBREF39 , BIBREF40 , BIBREF41 , BIBREF42 . This task is slightly different from spoken term detection, in the latter case spoken terms are simply detected based on the phonetic structures. Here the goal of the task is to retrieve all spoken documents (sets of consecutive utterances) relevant to the spoken query, which may or may not include the query. For example, for the spoken query of \u201cPresident Donald Trump\", not only those documents including the spoken query should be retrieved based on the phonetic structures, but those documents including semantically related words such as \u201cWhite House\" and \u201ctrade policy\", but not necessarily \u201cPresident Donald Trump\", should also be retrieved. This is usually referred to as \u201csemantic retrieval\", which can be achieved by the phonetic-and-semantic embedding discussed here.",
          "This paper proposes a two-stage framework of phonetic-and-semantic embedding for spoken words. Stage 1 performs phonetic embedding but with speaker characteristics disentangled using separate phonetic and speaker encoders and a speaker discriminator. Stage 2 then performs semantic embedding in addition. We further propose to evaluate the phonetic-and-semantic nature of the audio embeddings obtained in Stage 2 by parallelizing with text embeddings BIBREF43 , BIBREF44 . Very encouraging results including those for an application task of spoken document retrieval were obtained in the initial experiments."
        ]
      },
      {
        "section_name": "Proposed Approach",
        "paragraphs": [
          "The proposed framework of phonetic-and-semantic embedding of spoken words consists of two stages:",
          "Stage 1 - Phonetic embedding with speaker characteristics disentangled.",
          "Stage 2 - Semantic embedding over phonetic embeddings obtained in Stage 1.",
          "In addition, we propose an approach for parallelizing the audio and text embeddings to be used for evaluating the phonetic and semantic information carried by the audio embeddings. These are described in Subsections SECREF2 , SECREF11 and SECREF14 respectively."
        ]
      },
      {
        "section_name": "Stage 1 - Phonetic Embedding with Speaker Characteristics Disentangled",
        "paragraphs": [
          "A text word with a given phonetic structure corresponds to infinite number of audio signals with varying acoustic factors such as speaker characteristics, microphone characteristics, background noise, etc. All the latter acoustic factors are jointly referred to as speaker characteristics here for simplicity, which obviously disturbs the goal of phonetic-and-semantic embedding. So Stage 1 is to obtain phonetic embeddings only with speaker characteristics disentangled.",
          "Also, because the training of phonetic-and-semantic embedding is challenging, in the initial effort we slightly simplify the task by assuming all training utterances have been properly segmented into spoken words. Because there exist many approaches for segmenting utterances automatically BIBREF25 , and automatic segmentation plus phonetic embedding of spoken words has been successfully trained and reported before BIBREF25 , such an assumption is reasonable here.",
          "We denote the audio corpus as INLINEFORM0 , which consists of INLINEFORM1 spoken words, each represented as INLINEFORM2 , where INLINEFORM3 is the acoustic feature vector for the tth frame and INLINEFORM4 is the total number of frames in the spoken word. The goal of Stage 1 is to disentangle the phonetic structure and speaker characteristics in acoustic features, and extract a vector representation for the phonetic structure only.",
          "As shown in the middle of Figure FIGREF3 , a sequence of acoustic features INLINEFORM0 is entered to a phonetic encoder INLINEFORM1 and a speaker encoder INLINEFORM2 to obtain a phonetic vector INLINEFORM3 in orange and a speaker vector INLINEFORM4 in green. Then the phonetic and speaker vectors INLINEFORM5 , INLINEFORM6 are used by the decoder INLINEFORM7 to reconstruct the acoustic features INLINEFORM8 . This phonetic vector INLINEFORM9 will be used in the next stage as the phonetic embedding. The two encoders INLINEFORM10 , INLINEFORM11 and the decoder INLINEFORM12 are jointly learned by minimizing the reconstruction loss below: DISPLAYFORM0 ",
          "It will be clear below how to make INLINEFORM0 and INLINEFORM1 separately encode the phonetic structure and speaker characteristics.",
          "The speaker encoder training requires speaker information for the spoken words. Assume the spoken word INLINEFORM0 is uttered by speaker INLINEFORM1 . When the speaker information is not available, we can simply assume that the spoken words in the same utterance are produced by the same speaker. As shown in the lower part of Figure FIGREF3 , INLINEFORM2 is learned to minimize the following loss: DISPLAYFORM0 ",
          "In other words, if INLINEFORM0 and INLINEFORM1 are uttered by the same speaker ( INLINEFORM2 ), we want their speaker embeddings INLINEFORM3 and INLINEFORM4 to be as close as possible. But if INLINEFORM5 , we want the distance between INLINEFORM6 and INLINEFORM7 larger than a threshold INLINEFORM8 .",
          "As shown in the upper right corner of Figure FIGREF3 , a speaker discriminator INLINEFORM0 takes two phonetic vectors INLINEFORM1 and INLINEFORM2 as input and tries to tell if the two vectors come from the same speaker. The learning target of the phonetic encoder INLINEFORM3 is to \"fool\" this speaker discriminator INLINEFORM4 , keeping it from discriminating the speaker identity correctly. In this way, only the phonetic structure information is learned in the phonetic vector INLINEFORM5 , while only the speaker characteristics is encoded in the speaker vector INLINEFORM6 . The speaker discriminator INLINEFORM7 learns to maximize INLINEFORM8 in ( EQREF9 ), while the phonetic encoder INLINEFORM9 learns to minimize INLINEFORM10 , DISPLAYFORM0 ",
          "where INLINEFORM0 is a real number.",
          "The optimization procedure of Stage 1 consists of four parts: (1) training INLINEFORM0 , INLINEFORM1 and INLINEFORM2 by minimizing INLINEFORM3 , (2) training INLINEFORM4 by minimizing INLINEFORM5 , (3) training INLINEFORM6 by minimizing INLINEFORM7 , and (4) training INLINEFORM8 by maximizing INLINEFORM9 . Parts (1)(2)(3) are jointly trained together, while iteratively trained with part (4) BIBREF45 ."
        ]
      },
      {
        "section_name": "Stage 2 - Semantic Embedding over Phonetic Embeddings Obtained in Stage 1",
        "paragraphs": [
          "As shown in Figure FIGREF12 , similar to the Word2Vec skip-gram model BIBREF0 , we use two encoders: semantic encoder INLINEFORM0 and context encoder INLINEFORM1 to embed the semantics over phonetic embeddings INLINEFORM2 obtained in Stage 1. On the one hand, given a spoken word INLINEFORM3 , we feed its phonetic vector INLINEFORM4 obtained from Stage 1 into INLINEFORM5 as in the middle of Figure FIGREF12 , producing the semantic embedding (in yellow) of the spoken word INLINEFORM6 . On the other hand, given the context window size INLINEFORM7 , which is a hyperparameter, if a spoken word INLINEFORM8 is in the context window of INLINEFORM9 , then its phonetic vector INLINEFORM10 is a context vector of INLINEFORM11 . For each context vector INLINEFORM12 of INLINEFORM13 , we feed it into the context encoder INLINEFORM14 in the upper part of Figure FIGREF12 , and the output is the context embedding INLINEFORM15 .",
          "Given a pair of phonetic vectors INLINEFORM0 , the training criteria for INLINEFORM1 and INLINEFORM2 is to maximize the similarity between INLINEFORM3 and INLINEFORM4 if INLINEFORM5 and INLINEFORM6 are contextual, while minimizing the similarity otherwise. The basic idea is parallel to that of text Word2Vec. Two different spoken words having similar context should have similar semantics. Thus if two different phonetic embeddings corresponding to two different spoken words have very similar context, they should be close to each other after projected by the semantic encoder INLINEFORM7 . The semantic and context encoders INLINEFORM8 and INLINEFORM9 learn to minimize the semantic loss INLINEFORM10 as follows: DISPLAYFORM0 ",
          "The sigmoid of dot product of INLINEFORM0 and INLINEFORM1 is used to evaluate the similarity. With ( EQREF13 ), if INLINEFORM2 and INLINEFORM3 are in the same context window, we want INLINEFORM4 and INLINEFORM5 to be as similar as possible. We also use the negative sampling technique, in which only some pairs INLINEFORM6 are randomly sampled as negative examples instead of enumerating all possible negative pairs."
        ]
      },
      {
        "section_name": "Parallelizing Audio and Text Embeddings for Evaluation Purposes",
        "paragraphs": [
          "In this paper we further propose an approach of parallelizing a set of audio embeddings (for spoken words) with a set of text embeddings (for text words) which will be useful in evaluating the phonetic and semantic information carried by these embeddings.",
          "Assume we have the audio embeddings for a set of spoken words INLINEFORM0 INLINEFORM1 , where INLINEFORM2 is the embedding obtained for a spoken word INLINEFORM3 and INLINEFORM4 is the total number of distinct spoken words in the audio corpus. On the other hand, assume we have the text embeddings INLINEFORM5 INLINEFORM6 , where INLINEFORM7 is the embedding of the INLINEFORM8 -th text word for the INLINEFORM9 distinct text words. Although the distributions of INLINEFORM10 and INLINEFORM11 in their respective spaces are not parallel, that is, a specific dimension in the space for INLINEFORM12 does not necessarily correspond to a specific dimension in the space for INLINEFORM13 , there should exist some consistent relationship between the two distributions. For example, the relationships among the words {France, Paris, Germany} learned from context should be consistent in some way, regardless of whether they are in text or spoken form. So we try to learn a mapping relation between the two spaces. It will be clear below such a mapping relation can be used to evaluate the phonetic and semantic information carried by the audio embeddings.",
          "Mini-Batch Cycle Iterative Closest Point (MBC-ICP) BIBREF44 previously proposed as described below is used here. Given two sets of embeddings as mentioned above, INLINEFORM0 and INLINEFORM1 , they are first projected to their respective top INLINEFORM2 principal components by PCA. Let the projected sets of vectors of INLINEFORM3 and INLINEFORM4 be INLINEFORM5 and INLINEFORM6 respectively. If INLINEFORM7 can be mapped to the space of INLINEFORM8 by an affine transformation, the distributions of INLINEFORM9 and INLINEFORM10 would be similar after PCA BIBREF44 .",
          "Then a pair of transformation matrices, INLINEFORM0 and INLINEFORM1 , is learned, where INLINEFORM2 transforms a vector INLINEFORM3 in INLINEFORM4 to the space of INLINEFORM5 , that is, INLINEFORM6 , while INLINEFORM7 maps a vector INLINEFORM8 in INLINEFORM9 to the space of INLINEFORM10 . INLINEFORM11 and INLINEFORM12 are learned iteratively by the algorithm proposed previously BIBREF44 .",
          "In our evaluation as mentioned below, labeled pairs of the audio and text embeddings of each word is available, that is, we know INLINEFORM0 and INLINEFORM1 for each word INLINEFORM2 . So we can train the transformation matrices INLINEFORM3 and INLINEFORM4 using the gradient descent method to minimize the following objective function: DISPLAYFORM0 ",
          "where the last two terms in ( EQREF15 ) are cycle-constraints to ensure that both INLINEFORM0 and INLINEFORM1 are almost unchanged after transformed to the other space and back. In this way we say the two sets of embeddings are parallelized."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. This corpus contains 1000 hours of speech sampled at 16 kHz uttered by 2484 speakers. We used the \u201cclean\" and \u201cothers\" sets with a total of 960 hours, and extracted 39-dim MFCCs as the acoustic features."
        ]
      },
      {
        "section_name": "Model Implementation",
        "paragraphs": [
          "In Stage 1, The phonetic encoder INLINEFORM0 , speaker encoder INLINEFORM1 and decoder INLINEFORM2 were all 2-layer GRUs with hidden layer size 128, 128 and 256, respectively. The speaker discriminator INLINEFORM3 is a fully-connected feedforward network with 2 hidden layers with size 128. The value of INLINEFORM4 we used in INLINEFORM5 in ( EQREF7 ) was set to 0.01.",
          "In Stage 2, the two encoders INLINEFORM0 and INLINEFORM1 were both 2-hidden-layer fully-connected feedforward networks with size 256. The size of embedding vectors was set to be 128. The context window size was 5, and the negative sampling number was 5.",
          "For parallelizing the text and audio embeddings in Subsection SECREF14 , we projected the embeddings to the top 100 principle components, so the affine transformation matrices were INLINEFORM0 . The mini-batch size was 200, and INLINEFORM1 in ( EQREF15 ) was set to 0.5."
        ]
      },
      {
        "section_name": "Evaluation by Parallelizing Audio and Text Embeddings",
        "paragraphs": [
          "Each text word corresponds to many audio realizations in spoken form. So we first took the average of the audio embeddings for all those realizations to be the audio embedding for the spoken word considered. In this way, each word has a unique representation in either audio or text form.",
          "We applied three different versions of audio embedding (AUD) on the top 1000, 3000 and 5000 words with the highest frequencies in LibriSpeech: (i) phonetic embedding only obtained in Stage 1 in Subsection SECREF2 (AUD-ph); (ii) phonetic-and-semantic embedding obtained by Stages 1 and 2 in Subsections SECREF2 , SECREF11 , except the speaker characteristics not disentangled (AUD-(ph-+se)), or INLINEFORM0 , INLINEFORM1 in ( EQREF7 ), ( EQREF9 ) not considered; (iii) complete phonetic-and-semantic embedding as proposed in this paper including Stages 1 and 2 (AUD-(ph+se)). So this is for ablation study.",
          "On the other hand, we also obtained three different types of text embedding (TXT) on the same set of top 1000, 3000 and 5000 words. Type (a) Phonetic Text embedding (TXT-ph) considered precise phonetic structure but not context or semantics at all. This was achieved by a well-trained sequence-to-sequence autoencoder encoding the precise phoneme sequence of a word into a latent embedding. Type (b) Semantic Text embedding considered only context or semantics but not phonetic structure at all, and was obtained by a standard skip-gram model using one-hot representations as the input (TXT-(se,1h)). Type (c) Semantic and Phonetic Text embedding (TXT-(se,ph)) considered context or semantics as well as the precise phonetic structure, obtained by a standard skip-gram model but using the Type (a) Phonetic Text embedding (TXT-ph) as the input. So these three types of text embeddings provided the reference embeddings obtained from text and/or phoneme sequences, not disturbed by audio signals at all.",
          "Now we can perform the transformation from the above three versions of audio embeddings (AUD-ph, AUD-(ph-+se), AUD-(ph+se)) to the above three types of text embeddings (TXT-ph, TXT-(se,1h), TXT-(se,ph)) by parallelizing the embeddings as described in Subsection SECREF14 . The evaluation metric used for this parallelizing test is the top-k nearest accuracy. If the audio embedding representation INLINEFORM0 of a word INLINEFORM1 is transformed to the text embedding INLINEFORM2 by INLINEFORM3 , and INLINEFORM4 is among the top-k nearest neighbors of the text embedding representation INLINEFORM5 of the same word, this transformation for word INLINEFORM6 is top-k-accurate. The top-k nearest accuracy is then the percentage of the words considered which are top-k-accurate.",
          "The results of top-k nearest accuracies for k=1 and 10 are respectively listed in Tables TABREF18 and TABREF19 , each for 1000, 3000 and 5000 pairs of spoken and text words.",
          "First look at the top part of Table TABREF18 for top-1 nearest accuracies for 1000 pairs of audio and text embeddings. Since column (a) (TXT-ph) considered precise phonetic structures but not semantics at all, the relatively high accuracies in column (a) for all three versions of audio embedding (i)(ii)(iii) implied the three versions of audio embedding were all rich of phonetic information. But when the semantics were embedded in (ii)(iii) (AUD-(ph-+se), AUD-(ph+se)), the phonetic structures were inevitably disturbed (0.519, 0.598 vs 0.637). On the other hand, column (b) (TXT-(se,1h)) considered only semantics but not phonetic structure at all, the relatively lower accuracies implied the three versions of audio embedding did bring some good extent of semantics, except (i) AUD-ph, but obviously weaker than the phonetic information in column (a). Also, the Stage 2 training in rows (ii)(iii) (AUD-(ph-+se), AUD-(ph+se)) gave higher accuracies than row (i) (AUD-ph) (0.339, 0.332 vs 0.124 in column (b)), which implied the Stage 2 training was successful. However, column (c) (TXT-(se,ph)) is for the text embedding considering both the semantic and phonetic information, so the two versions of phonetic-and-semantic audio embedding for rows (ii)(iii) had very close distributions (0.750, 0.800 in column (c)), or carried good extent of both semantics and phonetic structure. The above are made clearer by the numbers in bold which are the highest for each row, and the numbers in red which are the highest for each column. It is also clear that the speaker characteristics disentanglement is helpful, since row (iii) for AUD-(ph+se) was always better than row (ii) for AUD-(ph-+se).",
          "Similar trends can be observed in the other parts of Table TABREF18 for 3000 and 5000 pairs, except the accuracies were lower, probably because for more pairs the parallelizing transformation became more difficult and less accurate. The only difference is that in these parts column (a) for TXT-ph had the highest accuracies, probably because the goal of semantic embedding for rows (ii)(iii) (AUD-(ph-+se), AUD-(ph+se)) was really difficult, and disturbed or even dominated by phonetic structures. Similar trends can be observed in Table TABREF19 for top-10 accuracies, obviously with higher numbers for top-10 as compared to those for top-1 in Table TABREF18 .",
          "In Table TABREF20 , we list some examples of top-10 nearest neighbors in AUD-(ph+se) (proposed), AUD-ph (with phonetic structure) and TXT-(se,1h) (with semantics). The words in red are the common words for AUD-(ph+se) and AUD-ph, and the words in bold are the common words of AUD-(ph+se) and TXT-(se,1h). For example, the word \u201cowned\" has two common semantically related words \u201clearned\" and \u201cknown\" in the top-10 nearest neighbors of AUD-(ph+se) and TXT-(se,1h). The word \u201cowned\" also has three common phonetically similar words \u201carmed\", \u201cown\" and \u201conly\" in the top-10 nearest neighbors of AUD-(ph+se) and AUD-ph. This is even clearer for the function word \u201cdidn't\". These clearly illustrate the phonetic-and-semantic nature of AUD-(ph+se)."
        ]
      },
      {
        "section_name": "Results of Spoken Document Retrieval",
        "paragraphs": [
          "The goal here is to retrieve not only those spoken documents including the spoken query (e.g. \u201cPresident Donald Trump\") based on the phonetic structures, but those including words semantically related to the query word (e.g. \u201cWhite House\"). Below we show the effectiveness of the phonetic-and-semantc embedding proposed here in this application.",
          "We used the 960 hours of \u201cclean\" and \u201cother\" parts of LibriSpeech dataset as the target archive for retrieval, which consisted of 1478 audio books with 5466 chapters. Each chapter included 1 to 204 utterances or 5 to 6529 spoken words. In our experiments, the queries were the keywords in the book titles, and the spoken documents were the chapters. We chose 100 queries out of 100 randomly selected book titles, and our goal was to retrieve query-relevant documents. For each query INLINEFORM0 , we defined two sets of query-relevant documents: The first set INLINEFORM1 consisted of chapters which included the query INLINEFORM2 . The second set INLINEFORM3 consisted of chapters whose content didn't contain INLINEFORM4 , but these chapters belonged to books whose titles contain INLINEFORM5 (so we assume these chapters are semantically related to INLINEFORM6 ). Obviously INLINEFORM7 and INLINEFORM8 were mutually exclusive, and INLINEFORM9 were the target for semantic retrieval, but couldn't be retrieved based on the phonetic structures only.",
          "For each query INLINEFORM0 and each document INLINEFORM1 , the relevance score of INLINEFORM2 with respect to INLINEFORM3 , INLINEFORM4 , is defined as follows: DISPLAYFORM0 ",
          "where INLINEFORM0 is the audio embedding of a word INLINEFORM1 in INLINEFORM2 . So ( EQREF25 ) indicates the documents INLINEFORM3 were ranked by the minimum distance between a word INLINEFORM4 in INLINEFORM5 and the query INLINEFORM6 . We used mean average precision (MAP) as the evaluation metric for the spoken document retrieval test.",
          "We compared the retrieval results with two versions of audio embedding: AUD-(ph+se) and AUD-ph. The results are listed in Table TABREF21 for two definitions of groundtruth for the query-relevant documents: the union of INLINEFORM0 and INLINEFORM1 and INLINEFORM2 alone. As can be found from this table, AUD-(ph+se) offered better retrieval performance than AUD-ph in both rows. Note that those chapters in INLINEFORM3 in the second row of the table did not include the query INLINEFORM4 , so couldn't be well retrieved using phonetic embedding alone. That is why the phonetic-and-semantic embedding proposed here can help.",
          "In Table TABREF22 , we list some chapters in INLINEFORM0 retrieved using AUD-(ph+se) embeddings to illustrate the advantage of the phonetic-and-semantic embeddings. In this table, column (a) is the query INLINEFORM1 , column (b) is the title of a book INLINEFORM2 which had chapters in INLINEFORM3 , column (c) is a certain chapter INLINEFORM4 in INLINEFORM5 , column (d) is the rank of INLINEFORM6 out of all chapters whose content didn't contain INLINEFORM7 , and column (e) is a part of the content in INLINEFORM8 where the word in red is the word in INLINEFORM9 with the highest similarity to INLINEFORM10 . For example, in the first row for the query \u201cnations\", the chapter \u201cPrometheus the Friend of Man\" of the book titled \u201cMyths and Legends of All Nations\" is in INLINEFORM11 . The word \u201cnations\" is not in the content of this chapter. However, because the word \u201cking\" semantically related to \u201cnations\" is in the content, this chapter was ranked the 13th among all chapters whose content didn't contain the word \u201cnations\". This clearly verified why the semantics in the phonetic-and-semantic embeddings can remarkably improve the performance of spoken content retrieval."
        ]
      },
      {
        "section_name": "Conclusions and Future Work",
        "paragraphs": [
          "In this paper we propose a framework to embed spoken words into vector representations carrying both the phonetic structure and semantics of the word. This is intrinsically challenging because the phonetic structure and the semantics of spoken words inevitably disturbs each other. But this phonetic-and-semantic embedding nature is desired and attractive, for example in the application task of spoken document retrieval. A parallelizing transformation between the audio and text embeddings is also proposed to evaluate whether such a goal is achieved."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is the dataset that is used to train the embeddings?",
        "question_id": "ac87dd34d28c3edd9419fa0145f3d38c87d696aa",
        "nlp_background": "",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " LibriSpeech BIBREF46"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. This corpus contains 1000 hours of speech sampled at 16 kHz uttered by 2484 speakers. We used the \u201cclean\" and \u201cothers\" sets with a total of 960 hours, and extracted 39-dim MFCCs as the acoustic features."
              ],
              "highlighted_evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. This corpus contains 1000 hours of speech sampled at 16 kHz uttered by 2484 speakers. We used the \u201cclean\" and \u201cothers\" sets with a total of 960 hours, and extracted 39-dim MFCCs as the acoustic features."
              ]
            },
            "annotation_id": "e17831b46d7f8c925fd3add460383c597453d15a",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "LibriSpeech"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. This corpus contains 1000 hours of speech sampled at 16 kHz uttered by 2484 speakers. We used the \u201cclean\" and \u201cothers\" sets with a total of 960 hours, and extracted 39-dim MFCCs as the acoustic features."
              ],
              "highlighted_evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. "
              ]
            },
            "annotation_id": "f4c50da528085095b9bf946f337fba60a58aa09d",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "LibriSpeech"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. This corpus contains 1000 hours of speech sampled at 16 kHz uttered by 2484 speakers. We used the \u201cclean\" and \u201cothers\" sets with a total of 960 hours, and extracted 39-dim MFCCs as the acoustic features.",
                "We applied three different versions of audio embedding (AUD) on the top 1000, 3000 and 5000 words with the highest frequencies in LibriSpeech: (i) phonetic embedding only obtained in Stage 1 in Subsection SECREF2 (AUD-ph); (ii) phonetic-and-semantic embedding obtained by Stages 1 and 2 in Subsections SECREF2 , SECREF11 , except the speaker characteristics not disentangled (AUD-(ph-+se)), or INLINEFORM0 , INLINEFORM1 in ( EQREF7 ), ( EQREF9 ) not considered; (iii) complete phonetic-and-semantic embedding as proposed in this paper including Stages 1 and 2 (AUD-(ph+se)). So this is for ablation study."
              ],
              "highlighted_evidence": [
                "We used LibriSpeech BIBREF46 as the audio corpus in the experiments, which is a corpus of read speech in English derived from audiobooks. ",
                "We applied three different versions of audio embedding (AUD) on the top 1000, 3000 and 5000 words with the highest frequencies in LibriSpeech: (i) phonetic embedding only obtained in Stage 1 in Subsection SECREF2 (AUD-ph); (ii) phonetic-and-semantic embedding obtained by Stages 1 and 2 in Subsections SECREF2 , SECREF11 , except the speaker characteristics not disentangled (AUD-(ph-+se)), or INLINEFORM0 , INLINEFORM1 in ( EQREF7 ), ( EQREF9 ) not considered; (iii) complete phonetic-and-semantic embedding as proposed in this paper including Stages 1 and 2 (AUD-(ph+se))."
              ]
            },
            "annotation_id": "fdced2315a003e9d2e7888f7a27244d89a7de336",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Fig. 1. Phonetic embedding with speaker characteristics disentangled."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Fig. 2. Semantic embedding over phonetic embeddings obtained in Stage 1."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1. Top-1 nearest accuracies when parallelizing the different versions of audio and text embeddings for different numbers of pairs of spoken and text words."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2. Top-10 nearest accuracies when parallelizing the different versions of audio and text embeddings for different numbers of pairs of spoken and text words."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3. Some examples of top-10 nearest neighbors in AUD-(ph+se) (proposed), AUD-ph (with phonetic structure) and TXT(se,1h) (with semantics). The words in red are the common words of AUD-(ph+se) and AUD-ph, and the words in bold are the common words of AUD-(ph+se) and TXT-(se,1h)."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5. Some retrieval examples of chapters in D2 using AUD-(ph+se) show the advantage of semantics information in phonetic-and-semantic embeddings. The word in red in each row indicates the word with the highest similarity to the query in the chapter."
      }
    ]
  },
  "1703.05320": {
    "title": "Legal Question Answering using Ranking SVM and Deep Convolutional Neural Network",
    "abstract": "This paper presents a study of employing Ranking SVM and Convolutional Neural Network for two missions: legal information retrieval and question answering in the Competition on Legal Information Extraction/Entailment. For the first task, our proposed model used a triple of features (LSI, Manhattan, Jaccard), and is based on paragraph level instead of article level as in previous studies. In fact, each single-paragraph article corresponds to a particular paragraph in a huge multiple-paragraph article. For the legal question answering task, additional statistical features from information retrieval task integrated into Convolutional Neural Network contribute to higher accuracy.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Legal text, along with other natural language text data, e.g. scientific literature, news articles or social media, has seen an exponential growth on the Internet and in specialized systems. Unlike other textual data, legal texts contain strict logical connections of law-specific words, phrases, issues, concepts and factors between sentences or various articles. Those are for helping people to make a correct argumentation and avoid ambiguity when using them in a particular case. Unfortunately, this also makes information retrieval and question answering on legal domain become more complicated than others.",
          "There are two primary approaches to information retrieval (IR) in the legal domain BIBREF0 : manual knowledge engineering (KE) and natural language processing (NLP). In the KE approach, an effort is put into translating the way legal experts remember and classify cases into data structures and algorithms, which will be used for information retrieval. Although this approach often yields a good result, it is hard to be applied in practice because of time and financial cost when building the knowledge base. In contrast, NLP-based IR systems are more practical as they are designed to quickly process terabytes of data by utilizing NLP techniques. However, several challenges are presented when designing such system. For example, factors and concepts in legal language are applied in a different way from common usage BIBREF1 . Hence, in order to effectively answer a legal question, it must compare the semantic connections between the question and sentences in relevant articles found in advance BIBREF2 .",
          "Given a legal question, retrieving relevant legal articles and deciding whether the content of a relevant article can be used to answer the question are two vital steps in building a legal question answering system. Kim et al. BIBREF2 exploited Ranking SVM with a set of features for legal IR and Convolutional Neural Network (CNN) BIBREF3 combining with linguistic features for question answering (QA) task. However, generating linguistic features is a non-trivial task in the legal domain. Carvalho et al. BIBREF1 utilized n-gram features to rank articles by using an extension of TF-IDF. For QA task, the authors adopted AdaBoost BIBREF4 with a set of similarity features between a query and an article pair BIBREF5 to classify a query-article pair into \u201cYES\" or \u201cNO\". However, overfitting in training may be a limitation of this method. Sushimita et al. BIBREF6 used the voting of Hiemstra, BM25 and PL2F for IR task. Meanwhile, Tran et al. BIBREF7 used Hidden Markov model (HMM) as a generative query model for legal IR task. Kano BIBREF8 addressed legal IR task by using a keyword-based method in which the score of each keyword was computed from a query and its relevant articles using inverse frequency. After calculating, relevant articles were retrieved based on three ranked scores. These methods, however, lack the analysis of feature contribution, which can reveal the relation between legal and NLP domain. This paper makes the following contributions:",
          "In the following sections, we first show our idea along with data analysis in the context of COLIEE. Next, we describe our method for legal IR and legal QA tasks. After building a legal QA system, we show experimental results along with discussion and analysis. We finish by drawing some important conclusions."
        ]
      },
      {
        "section_name": "Basic Idea",
        "paragraphs": [
          "In the context of COLIEE 2016, our approach is to build a pipeline framework which addresses two important tasks: IR and QA. In Figure 1 , in training phase, a legal text corpus was built based on all articles. Each training query-article pair for LIR task and LQA task was represented as a feature vector. Those feature vectors were utilized to train a learning-to-rank (L2R) model (Ranking SVM) for IR and a classifier (CNN) for QA. The red arrows mean that those steps were prepared in advance. In the testing phase, given a query $q$ , the system extracts its features and computes the relevance score corresponding to each article by using the L2R model. Higher score yielded by SVM-Rank means the article is more relevant. As shown in Figure 1 , the article ranked first with the highest score, i.e. 2.6, followed by other lower score articles. After retrieving a set of relevant articles, CNN model was employed to determine the \u201cYES\" or \u201cNO\" answer of the query based on these relevant articles."
        ]
      },
      {
        "section_name": "Data Observation",
        "paragraphs": [
          "The published training dataset in COLIEE 2016 consists of a text file containing Japanese Civil Code and eight XML files. Each XML file contains multiple pairs of queries and their relevant articles, and each pair has a label \u201cYES\" or \u201cNO\", which confirms the query corresponding to the relevant articles. There is a total of 412 pairs in eight XML files and 1,105 articles in the Japanese Civil Code file, and each query can have more than one relevant articles.",
          "After analyzing the dataset in the Civil Code file, we observed that the content of a query is often more or less related to only a paragraph of an article instead of the entire content. Based on that, each article was treated as one of two types: single-paragraph or multiple-paragraph, in which a multiple-paragraph article is an article which consists of more than one paragraphs. There are 7 empty articles, 682 single-paragraph articles and the rest are multiple-paragraph.",
          "Based on our findings, we proposed to split each multiple-paragraph article into several independent articles according to their paragraphs. For instance, in Table 1 , the Article 233 consisting of two paragraphs was split into two single-paragraph articles 233(1) and 233(2). After splitting, there are in total 1,663 single-paragraph articles.",
          "Stopwords were also removed before building the corpus. Text was processed in the following order: tokenization, POS tagging, lemmatization, and stopword removal. In BIBREF1 , the stopword removal stage was done before the lemmatization stage, but we found that after lemmatizing, some words might become stopwords, for instance, \u201cdone\" becomes \u201cdo\". Therefore, the extracted features based on words are more prone to be distorted, leading to lower ranking performance if stopword removal is carried out before lemmatization step. Terms were tokenized and lemmatized using NLTK, and POS tagged by Stanford Tagger."
        ]
      },
      {
        "section_name": "Legal Information Retrieval",
        "paragraphs": [
          "In order to build a legal IR, traditional models such as TF-IDF, BM25 or PL2F can be used to generate basic features for matching documents with a query. Nevertheless, to improve not only the accuracy but also the robustness of ranking function, it is essential to take into account a combination of fundamental features and other potential features. Hence, the idea is to build a L2R model, which incorporates various features to generate an optimal ranking function.",
          "Among different L2R methods, Ranking SVM (SVM-Rank) BIBREF9 , a state-of-the-art pairwise ranking method and also a strong method for IR BIBREF10 , BIBREF11 , was used. Our model is an extended version of Kim's model BIBREF2 with two new aspects. Firstly, there is a big distinction between our features and Kim's features. While Kim used three types of features: lexical words, dependency pairs, and TF-IDF score; we conducted a series of experiments to discover a set of best features among six features as shown in Table 2 . Secondly, our model is applied to individual paragraphs as described in section \"Data Observation\" instead of the whole articles as in Kim's work.",
          "Given n training queries $\\lbrace q_i\\rbrace _{i=1}^{n}$ , their associated document pairs $(x_u^{(i)},x_v^{(i)})$ and the corresponding ground truth label $y_{u,v}^{(i)}$ , SVM Rank optimizes the objective function shown in Equation ( 13 ) subject to constraints ( 14 ), and ( 15 ): ",
          "$$min \\quad \\frac{1}{2}\\Vert w\\Vert ^2 + \\lambda \\sum _{i=1}^{n}\\sum _{u,v:y_{u,v}^{(i)}} \\xi _{u,v}^{(i)}$$   (Eq. 13) ",
          "$$s.t. \\quad w^T(x_u^{(i)} - x_v^{(i)}) \\ge 1 - \\xi _{u,v}^{(i)} \\quad \\text{if} \\quad y_{u,v}^{(i)}=1$$   (Eq. 14) ",
          "where: $f(x)=w^Tx$ is a linear scoring function, $(x_u,x_v)$ is a pairwise and $\\xi _{u,v}^{(i)}$ is the loss. The document pairwise in our model is a pair of a query and an article.",
          "Based on the corpus constructed from all of the single-paragraph articles (see Section \"Data Observation\" ), three basic models were built: TF-IDF, LSI and Latent Dirichlet Allocation (LDA) BIBREF12 . Note that, LSI and LDA model transform articles and queries from their TF-IDF-weighted space into a latent space of a lower dimension. For COLIEE 2016 corpora, the dimension of both LSI and LDA is 300 instead of over 2,100 of TF-IDF model. Those features were extracted by using gensim library BIBREF13 . Additionally, to capture the similarity between a query and an article, we investigated other potential features described in Table 2 . Normally, the Jaccard coefficient measures similarity between two finite sets based on the ratio between the size of the intersection and the size of the union of those sets. However, in this paper, we calculated Generalized Jaccard similarity as: ",
          "$$ J(q,A) = J(X,Y) = \\frac{\\sum _{i}^{} min(x_i,y_i)}{\\sum _{i}^{} max(x_i,y_i)}$$   (Eq. 16) ",
          "and Jaccard distance as: ",
          "$$ D(q,A) = 1 - J(q,A)$$   (Eq. 17) ",
          "where $X = \\lbrace x_1,x_2,..,x_n\\rbrace $ and $Y=\\lbrace y_1,y_2,...,y_n\\rbrace $ are two TF-IDF vectors of a query $q$ and an article $A$ respectively.",
          "The observation in Section \"Data Observation\" also indicates that one of the important properties of legal documents is the reference or citation among articles. In other words, an article could refer to the whole other articles or to their paragraphs. In BIBREF1 , if an article has a reference to other articles, the authors expanded it with words of referential ones. In our experiment, however, we found that this approach makes the system confused to rank articles and leads to worse performance. Because of that, we ignored the reference and only took into account individual articles themselves. The results of splitting and non-splitting are shown in Table 5 ."
        ]
      },
      {
        "section_name": "Legal Question Answering",
        "paragraphs": [
          "Legal Question Answering is a form of textual entailment problem BIBREF14 , which can be viewed as a binary classification task. To capture the relation between a question and an article, a set of features can be used. In the COLLIE 2015, Kim BIBREF3 efficiently applied Convolution Neural Network (CNN) for the legal QA task. However, the small dataset is a limit of deep learning models. Therefores, we provided additional features to the CNN model.",
          "The idea behind the QA is that we use CNN BIBREF2 with additional features. This is because: (i) CNN is capable to capture local relationship between neighboring words, which helps CNN to achieve excellent performance in NLP problems BIBREF15 , BIBREF2 , BIBREF16 , BIBREF17 and (ii) we can integrate our knowledge in legal domain in the form of statistical features, e.g. TF-IDF and LSI.",
          "In Figure 2 , the input features $v_1,v_2,...,v_{400}$ are constructed and fed to the network as follows :",
          " $v_1,v_3,v_5,...,v_{399}$ : a word embedding vector of the question sentence",
          " $v_2,v_4,...,v_{400}$ : a word embedding vector of the most relevant article sentence",
          "A sentence represented by a set of words was converted to a word embedding vector $v_1^{200}$ by using bag-of-words model (BOW) BIBREF18 . BOW model generates a vector representation for a sentence by taking a summation over embedding of words in the sentence. The vector is then normalized by the length of the sentence: ",
          "$$s= \\frac{1}{n}\\sum _{i= 1}^{n}s_{i}$$   (Eq. 22) ",
          "where: $s$ is a $d$ -dimensional vector of a sentence, $s_{i}$ is a $d$ -dimensional vector of $i^{th}$ word in the sentence, $n$ is the length of sentence. A word embedding model ( $d=200$ ) was trained by using Word2Vec BIBREF19 on the data of Japanese law corpus BIBREF1 . The corpus contains all Civil law articles of Japan's constitution with 13.5 million words from 642 cleaned and tokenized articles.",
          "A filter was denoted as a weight vector $w$ with length $h$ ; $w$ will have $h$ parameters to be estimated. For each input vector $S \\in \\mathbb {R}^{d} $ , the feature map vector $O \\in \\mathbb {R}^{d-h+1}$ of the convolution operator with a filter $w$ was obtained by applying repeatedly $w$ to sub-vectors of $S$ : ",
          "$$o_{i}=w\\cdot S[i:i+h-1]$$   (Eq. 24) ",
          "where: $i=0,1,2,...,d-h+1$ and ( $\\cdot $ ) is dot product operation.",
          "Each feature map was fed to a pooling layer to generate potential features by using the average mechanism BIBREF20 . These features were concatenated to a single vector for classification by using Multi-Layer Perceptron with sigmoid activation. During training process, parameters of filters and perceptrons are learned to optimize the objective function.",
          "In our model, 10 convolution filters (length = 2) were applied to two adjacent input nodes because these nodes are the same feature type. An average pooling layer (length = 100) is then utilized to synthesize important features. To enhance the performance of CNN, two additional statistic features: TF-IDF and LSI were concatenated with the result of the pooling layer, then fed them into a 2-layer Perceptron model to predict the answer.",
          "In Legal QA task, the proposed model was compared to the original CNN model and separate TF-IDF, LSI features. For evaluation, we took out 10% samples from training set for validation, and carried out experiments on dataset with balanced label distribution for training set, validation set and testing set.",
          "In CNN models, we found that these models are sensitive to the initial value of parameters. Different values lead to large difference in results ( $\\pm $ 5%). Therefore, each model was run $n$ times (n=10) and we chose the best-optimized parameters against the validation set. Table 7 shows that CNN with additional features performs better. Also, CNN with LSI produces a better result as opposed to CNN with TF-IDF. We suspect that this is because TF-IDF vector is large but quite sparse (most values are zero), therefore it increases the number of parameters in CNN and consequently makes the model to be overfitted easily.",
          "To achieve the best configuration of CNN architecture, the original CNN model was run with different settings of number filter and hidden layer dimension. According to Table 8 , the change of hyperparameter does not significantly affect to the performance of CNN. We, therefore, chose the configuration with the best performance and least number of parameters: 10 filters and 200 hidden layer size."
        ]
      },
      {
        "section_name": "Information Retrieval",
        "paragraphs": [
          "For information retrieval task, 20% of query-article pairs are used for evaluating our model while the rest is for training. As we only consider single-paragraph articles in the training phase, if a multiple-paragraph article is relevant, all of its generated single-paragraph articles will be marked as relevant. In addition, the label for each query-article pair is set either 1 (relevant) or 0 (irrelevant). In our experiment, instead of selecting top $k$ retrieved articles as relevant articles, we consider a retrieved article $A_i$ as a relevant article if its score $S_i$ satisfies Equation ( 26 ): ",
          "$$\\frac{S_i}{S_0} \\ge 0.85$$   (Eq. 26) ",
          "where: $S_0$ is the highest relevant score. In other words, the score ratio of a relevant article and the most relevant article should not be lower than 85% (choosing the value 0.85 for this threshold is simply heuristic based). This is to prevent a relevant article to have a very low score as opposed to the most relevant article.",
          "We ran SVM-Rank with different combinations of features listed in Table 2 , but due to limited space, we only report the result of those combinations which achieved highest F1-score. We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. Results from Table 3 indicate that (LSI, Manhattan, Jaccard) is the triple of features which achieves the best result and the most stability.",
          "The contribution of each feature was investigated by using leave-one-out test. Table 4 shows that when all six features are utilized, the F1-score is approximately 0.55. However when excluding Jaccard, F1-score drops to around 0.5. In contrast, when other features are excluded individually from the feature set, the result remains stable or goes up slightly. From this result, we conclude that Jaccard feature significantly contributes to SVM-Rank performance.",
          "We also analyzed the contribution of feature groups to the performance of SVM-Rank. When removing different triples of features from the feature set, it can be seen that (TF-IDF, Manhattan, Jaccard) combination witnesses the highest loss. Nevertheless, as shown in Table 3 , the result of (LSI, Manhattan, Jaccard) combination is more stable and better.",
          "As mentioned, we proposed to split a multiple-paragraph article into several single-paragraph articles. Table 5 shows that after splitting, the F1-score performance increases by 0.05 and 0.04 with references and without references respectively. In both cases (with and without the reference), using single-paragraph articles always results a higher performance.",
          "Results from Table 5 also indicate that expanding the reference of an article negatively affects the performance of our model, reducing the F1-score by more than 0.02. This is because if we only expand the content of an article with the content of referential one, it is more likely to be noisy and distorted, leading to lower performance. Therefore, we conclude that a simple expansion of articles via their references does not always positively contribute to the performance of the model.",
          "Since linear kernel was used to train the SVM-Rank model, the role of trade-off training parameter was analyzed by tuning $C$ value from 100 to 2000 with step size 100. Empirically, F1-score peaks at 0.6087 with $C$ = 600 when it comes to COLIEE 2016 training dataset. We, therefore, use this value for training the L2R model."
        ]
      },
      {
        "section_name": "Formal run phase 1 - COLIEE 2016",
        "paragraphs": [
          "In COLIEE 2016 competition, Table 6 shows the top three systems and the baseline for the formal run in phase 1 BIBREF21 . Among 7 submissions, iLis7 BIBREF22 was ranked first with outstanding performance (0.6261) by exploiting ensemble methods for legal IR. Several features such as syntactic similarity, lexical similarity, semantic similarity, were used as features for two ensemble methods Least Square Method (LSM) and Linear Discriminant Analysis (LDA).",
          "HUKB-2 BIBREF23 used a fundamental feature BM25 and applied mutatis mutandis for articles. If both an article and a query have conditional parts, they are divided into two parts like conditional parts and the rest part before measuring their similarity. This investigation in conditional parts is valuable since it is a common structure in laws. Their F1-score in formal rune is the second highest (0.5532), which is slightly higher than our system (0.5478) using SVM-Rank and a set of features LSI, Manhattan, Jaccard. This shows that for phase 1, our model with a set of defined features is relatively competitive."
        ]
      },
      {
        "section_name": "Legal Question Answering System",
        "paragraphs": [
          "In this stage, we illustrate our framework on COLIEE 2016 data. The framework was trained on XML files, from H18 to H23 and tested on XML file H24. Given a legal question, the framework first retrieves top five relevant articles and then transfers the question and relevant articles to CNN classifier. The running of framework was evaluated with 3 scenarios:",
          "No voting: taking only a top relevant article to use for predicting an answer for that question.",
          "Voting without ratio: each of results, which is generated by applying our Textual entailment model to each article, gives one vote to the answer which it belongs to. The final result is the answer with more votes.",
          "Voting with ratio: similar to Voting without ratio. However, each of results gives one vote corresponding to article's relevant score. The final result is the answer with higher voting score.",
          "Table 9 shows results with different scenarios. The result of No voting approach is influenced by IR task's performance, so the accuracy is not as high as using voting. The relevant score disparity between the first and second relevant article is large, which causes a worse result of Voting with ratio compared to Voting without ratio."
        ]
      },
      {
        "section_name": "Formal run phase 2 & 3 - COLIEE 2016",
        "paragraphs": [
          "Table 10 lists the state-of-the art methods for the formal run 2016 in phase 2 and 3. In phase 2, two best systems are iList7 and KIS-1. iList7 applies major voting of decision tree, SVM and CNN with various features; KIS-1 just uses simple rules of subjective cases and an end-of-sentence expression. In phase 3, UofA achives the best score. It extracts the article segment which related to the query. This system also performs paraphrasing and detects condition-conclusion-exceptions for the query/article. From the experimental results, deep learning models do not show their advantages in case of a small dataset. On the other hand, providing handcraft features and rules are shown to be useful in this case."
        ]
      },
      {
        "section_name": "Splitting and non-splitting error analysis",
        "paragraphs": [
          "In this section, we show an example in which our proposed model using single-paragraph articles gives a correct answer in contrast with utilizing non-splitting one. Given a query with id H20-26-3: \u201cA mandate contract is gratuitous contract in principle, but if there is a special provision, the mandatary may demand renumeration from the mandator.\u201d, which refers to Article 648:",
          "Apparently, three paragraphs and the query share several words namely mandatary, remuneration, etc. In this case, however, the correct answer is only located in paragraph 1, which is ranked first in the single-paragraph model in contrast to two remaining paragraphs with lower ranks, 5th and 29th as shown in Table 12 .",
          "Interestingly, Article 653 has the highest relevant score in non-splitting method and rank 2nd in splitting approach. The reason for this is that Article 653 shares other words like mandatary, mandator as well. Therefore, it makes retrieval system confuse and yield incorrect order rank. By using single-paragraph, the system can find more accurately which part of the multiple-paragraph article is associated with the query's content."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This work investigates Ranking SVM model and CNN for building a legal question answering system for Japan Civil Code. Experimental results show that feature selection affects significantly to the performance of SVM-Rank, in which a set of features consisting of (LSI, Manhattan, Jaccard) gives promising results for information retrieval task. For question answering task, the CNN model is sensitive to initial values of parameters and exerts higher accuracy when adding auxiliary features.",
          "In our current work, we have not yet fully explored the characteristics of legal texts in order to utilize these features for building legal QA system. Properties such as references between articles or structured relations in legal sentences should be investigated more deeply. In addition, there should be more evaluation of SVM-Rank and other L2R methods to observe how they perform on this legal data using the same feature set. These are left as our future work."
        ]
      },
      {
        "section_name": "Acknowledgement",
        "paragraphs": [
          "This work was supported by JSPS KAKENHI Grant number 15K16048, JSPS KAKENHI Grant Number JP15K12094, and CREST, JST."
        ]
      }
    ],
    "qas": [
      {
        "question": "what is the baseline model",
        "question_id": "50bcbb730aa74637503c227f022a10f57d43f1f7",
        "nlp_background": "five",
        "topic_background": "research",
        "paper_read": "no",
        "search_query": "question",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "two baseline models TF-IDF and LSI which only use Cosine similarity"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We ran SVM-Rank with different combinations of features listed in Table 2 , but due to limited space, we only report the result of those combinations which achieved highest F1-score. We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. Results from Table 3 indicate that (LSI, Manhattan, Jaccard) is the triple of features which achieves the best result and the most stability."
              ],
              "highlighted_evidence": [
                "We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. "
              ]
            },
            "annotation_id": "5e9536a3634813567e8f7cf547f6902935de4fff",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "two baseline models TF-IDF and LSI"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "We ran SVM-Rank with different combinations of features listed in Table 2 , but due to limited space, we only report the result of those combinations which achieved highest F1-score. We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. Results from Table 3 indicate that (LSI, Manhattan, Jaccard) is the triple of features which achieves the best result and the most stability."
              ],
              "highlighted_evidence": [
                "We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles."
              ]
            },
            "annotation_id": "81464803827c8aca76e4b7b95a5d60ed4e546ca6",
            "worker_id": "45b212ff3348e2473d3e5504ca1200bcf85fcbf5"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "The baseline models used for this paper are based on the TF-IDF and LSI features and cosine similarity as a retrieval method.",
              "evidence": [
                "We ran SVM-Rank with different combinations of features listed in Table 2 , but due to limited space, we only report the result of those combinations which achieved highest F1-score. We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. Results from Table 3 indicate that (LSI, Manhattan, Jaccard) is the triple of features which achieves the best result and the most stability."
              ],
              "highlighted_evidence": [
                "We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. "
              ]
            },
            "annotation_id": "d5cd025fb24958874181d9f2cb32dcebabb59849",
            "worker_id": "291c6b2df1bac379d47f5557f9e564a1f6618bf7"
          },
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "We ran SVM-Rank with different combinations of features listed in Table 2 , but due to limited space, we only report the result of those combinations which achieved highest F1-score. We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles. Results from Table 3 indicate that (LSI, Manhattan, Jaccard) is the triple of features which achieves the best result and the most stability.",
                "In Legal QA task, the proposed model was compared to the original CNN model and separate TF-IDF, LSI features. For evaluation, we took out 10% samples from training set for validation, and carried out experiments on dataset with balanced label distribution for training set, validation set and testing set."
              ],
              "highlighted_evidence": [
                "tf-idf ",
                "We compared our method to two baseline models TF-IDF and LSI which only use Cosine similarity to retrieve the relevant articles.",
                "In Legal QA task, the proposed model was compared to the original CNN model and separate TF-IDF, LSI features."
              ],
              "yes_no": null,
              "free_form_answer": "For the first task they have two baseline models, TF-IDF and LSI which both use cosine similarity. For the QA task, they baseline models were the original CNN and CNN with separate TF-IDF, LSI features.",
              "extractive_spans": []
            },
            "annotation_id": "d15033d6716431e36b83bf22bf3a7520e36a45cc",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Fig. 1. The proposed model overview"
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1. Splitting a multiple-paragraph article into some single-paragraph articles"
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2. Similarity features for Ranking SVM"
      },
      {
        "file": "6-Figure2-1.png",
        "caption": "Fig. 2. The illustration of CNN model with additional features: LSI and TF-IDF. Given an input vector, CNN applies 10 filers (length = 2) to generate 10 feature maps (length = 399). Afterward, an average pooling filter (length = 100) is employed to produce average values from 4 feature maps. Finally, the average values with LSI and TF-IDF are used as input of two hidden neural network layers for QA"
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3. F1-score with different feature groups with the best parameters of SVM-Rank"
      },
      {
        "file": "8-Table4-1.png",
        "caption": "Table 4. F1-score when excluding some features from all feature set"
      },
      {
        "file": "9-Table5-1.png",
        "caption": "Table 5. IR results with various methods in COLIEE 2016."
      },
      {
        "file": "9-Table6-1.png",
        "caption": "Table 6. Formal run in phase 1, COLIEE 2016."
      },
      {
        "file": "10-Table7-1.png",
        "caption": "Table 7. Phase 2 results with different models"
      },
      {
        "file": "10-Table8-1.png",
        "caption": "Table 8. Results of the original CNN with different settings"
      },
      {
        "file": "11-Table9-1.png",
        "caption": "Table 9. Task 3 results with various scenarios"
      },
      {
        "file": "12-Table11-1.png",
        "caption": "Table 11. An example of retrieval articles between two methods: Splitting and Nonsplitting"
      },
      {
        "file": "12-Table10-1.png",
        "caption": "Table 10. Formal run in phase 2 & 3, COLIEE 2016."
      }
    ]
  },
  "1910.10762": {
    "title": "Analyzing ASR pretraining for low-resource speech-to-text translation",
    "abstract": "Previous work has shown that for low-resource source languages, automatic speech-to-text translation (AST) can be improved by pretraining an end-to-end model on automatic speech recognition (ASR) data from a high-resource language. However, it is not clear what factors --e.g., language relatedness or size of the pretraining data-- yield the biggest improvements, or whether pretraining can be effectively combined with other methods such as data augmentation. Here, we experiment with pretraining on datasets of varying sizes, including languages related and unrelated to the AST source language. We find that the best predictor of final AST performance is the word error rate of the pretrained ASR model, and that differences in ASR/AST performance correlate with how phonetic information is encoded in the later RNN layers of our model. We also show that pretraining and data augmentation yield complementary benefits for AST.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Low-resource automatic speech-to-text translation (AST) has recently gained traction as a way to bring NLP tools to under-represented languages. An end-to-end approach BIBREF0, BIBREF1, BIBREF2, BIBREF3, BIBREF4, BIBREF5, BIBREF6 is particularly appealing for source languages with no written form, or for endangered languages where translations into a high-resource language may be easier to collect than transcriptions BIBREF7. However, building high-quality end-to-end AST with little parallel data is challenging, and has led researchers to explore how other sources of data could be used to help.",
          "A number of methods have been investigated. Several of these use transcribed source language audio and/or translated source language text in a multitask learning scenario BIBREF8, BIBREF3, BIBREF5 or to pre-train parts of the model before fine-tuning on the end-to-end AST task BIBREF3. Others assume, as we do here, that no additional source language resources are available, in which case transfer learning using data from language(s) other than the source language is a good option. In particular, several researchers have shown that low-resource AST can be improved by pretraining on an ASR task in some other language, then transferring the encoder parameters to initialize the AST model. For example, Bansal et al. BIBREF4 showed that pre-training on either English or French ASR improved their Spanish-English AST system (trained on 20 hours of parallel data) and Tian BIBREF9 got improvements on an 8-hour Swahili-English AST dataset using English ASR pretraining.",
          "Overall these results show that pretraining helps, but leave open the question of what factors affect the degree of improvement. For example, does language relatedness play a role, or simply the amount of pretraining data? Bansal et al. showed bigger AST gains as the amount of English pretraining data increased from 20 to 300 hours, and also found a slightly larger improvement when pretraining on 20 hours of English versus 20 hours of French, but they pointed out that the Spanish data contains many English code-switched words, which could explain the latter result. In related work on multilingual pretraining for low-resource ASR, Adams et al. BIBREF10 showed that pre-training on more languages helps, but it is not clear whether the improvement is due to including more languages, or just more data.",
          "To begin to tease apart these issues, we focus here on monolingual pretraining for low-resource AST, and investigate two questions. First, can we predict what sort of pretraining data is best for a particular AST task? Does it matter if the pretraining language is related to the AST source language (defined here as part of the same language family, since phonetic similarity is difficult to measure), or is the amount of pretraining data (or some other factor) more important? Second, can pretraining be effectively combined with other methods, such as data augmentation, in order to further improve AST results?",
          "To answer these questions, we use the same AST architecture and Spanish-English parallel data as Bansal et al. BIBREF4, but pretrain the encoder using a number of different ASR datasets: the 150-hour AISHELL corpus of Chinese as well as seven GlobalPhone languages, each with about 20 hours of data. We find that pretraining on a larger amount of data from an unrelated language is much better than pretraining on a smaller amount of data from a related language. Moreover, even when controlling for the amount of data, the WER of the ASR model from pretraining seems to be a better predictor of final AST performance than does language relatedness. Indeed, we show that there is a very strong correlation between the WER of the pretraining model and BLEU score of the final AST model\u2014i.e., the best pretraining strategy may simply be to use datasets and methods that will yield the lowest ASR WER during pretraining. However, we also found that AST results can be improved further by augmenting the AST data using standard speed perturbation techniques BIBREF11. Our best results using non-English pretraining data improve the test set BLEU scores of an AST system trained on 20 hours of parallel data from 10.2 to 14.3, increasing to 15.8 with data augmentation.",
          "Finally, we analyze the representations learned by the models and show that better performance seems to correlate with the extent to which phonetic information is encoded in a linearly separable way in the later RNN layers."
        ]
      },
      {
        "section_name": "Methodology",
        "paragraphs": [
          "For both ASR and AST tasks we use the same end-to-end system architecture shown in Figure FIGREF1: the encoder-decoder model from BIBREF4, which itself is adapted from BIBREF1, BIBREF3 and BIBREF2. Details of the architecture and training parameters are described in Section SECREF9.",
          "After pretraining an ASR model, we transfer only its encoder parameters to the AST task. Previous experiments BIBREF4 showed that the encoder accounts for most of the benefits of transferring the parameters. Transferring also the decoder and attention mechanism does bring some improvements, but is only feasible when the ASR pretraining language is the same as the AST target language, which is not true in most of our experiments.",
          "In addition to pretraining, we experimented with data augmentation. Specifically, we augmented the AST data using Kaldi's BIBREF12 3-way speed perturbation, adding versions of the AST data where the audio is sped down and up by a factor of 0.9 and 1.1, respectively.",
          "To evaluate ASR performance we compute the word error rate (WER). To evaluate AST performance we calculate the 4-gram BLEU score BIBREF13 on four reference translations."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Parallel data",
        "paragraphs": [
          "For the AST models, we use Spanish-English parallel data from Fisher corpus BIBREF14, containing 160 hours of Spanish telephone speech translated into English text. To simulate low-resource settings, we randomly downsample the original corpus to 20 hours of training data. Each of the dev and test sets comprise 4.5 hours of speech."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Pretraining data",
        "paragraphs": [
          "Since we focus on investigating factors that might affect the AST improvements over the baseline when pretraining, we have chosen ASR datasets for pretraining that contrast in the number of hours and/or in the language similarity with Spanish. Statistics for each dataset are in the left half of Table TABREF7, with further details below.",
          "To look at a range of languages with similar amounts of data, we used GlobalPhone corpora from seven languages BIBREF15, each with around 20 hours of speech: Mandarin Chinese (zh), Croatian (hr), Czech (cs), French (fr), Polish (pl), Portuguese (pt), and Swedish (sv). French and Portuguese, like the source language (Spanish), belong to the Romance family of languages, while the other languages are less related\u2014especially Chinese, which is not an Indo-European language. GlobalPhone consists of read speech recorded using similar conditions across languages, and the transcriptions for Chinese are Romanized, with annotated word boundaries.",
          "To explore the effects of using a large amount of pretraining data from an unrelated language, we used the AISHELL-1 corpus of Mandarin Chinese BIBREF16, which contains 150 hours of read speech. Transcriptions with annotated word boundaries are available in both Hanzi (Chinese characters) and Romanized versions, and we built models with each. To compare to the GlobalPhone data, we also created a 20-hour subset of the Romanized AISHELL (zh-ai-small) by randomly selecting utterances from a subset of the speakers (81, roughly the number present in most of the GlobalPhone datasets).",
          "Finally, to reproduce one of the experiments from BIBREF4, we pre-trained one model using 300 hours of Switchboard English BIBREF17. This data is the most similar to the AST speech data in terms of style and channel (both are conversational telephone speech). However, as noted by BIBREF4, the Fisher Spanish speech contains many words that are actually in English (code-switching), so pretraining on English may provide an unfair advantage relative to other languages."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Preprocessing",
        "paragraphs": [
          "We compute 13-dim MFCCs and cepstral mean and variance normalization along speakers using Kaldi BIBREF12 on our ASR and AST audio. To shorten the training time, we trimmed utterances from the AST data to 16 seconds (or 12 seconds for the 160h augmented dataset).",
          "To account for unseen words in the test data, we model the ASR and AST text outputs via sub-word units using byte-pair encoding (BPE) BIBREF18. We do this separately for each dataset as BPE works best as a language-specific tool (i.e. it depends on the frequency of different subword units, which varies with the language). We use 1k merge operations in all cases except Hanzi, where there are around 3000 symbols initially (vs around 60 in the other datasets). For Hanzi we ran experiments with both 1k and 15k merge operations. For Chinese Romanized transcriptions we removed tone diacritics."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Model architecture and training",
        "paragraphs": [
          "Following the architecture and training procedure described in BIBREF4, input speech features are fed into a stack of two CNN layers. In each CNN layer we stride the input with a factor of 2 along time, apply ReLU activation BIBREF19 followed by batch normalization BIBREF20. The CNN output is fed into a three-layer bi-directional long short-term memory network (LSTM) BIBREF21, with 512 hidden layer dimensions. For decoding, we use the predicted token 20% of the time and the training token 80% of the time BIBREF22 as input to a 128-dimensional embedding layer followed by a three-layer LSTM, with 256 hidden layer dimensions, and combine this with the output from the attention mechanism BIBREF23 to predict the word at the current time step.",
          "We use code and hyperparameter settings from BIBREF4: the Adam optimizer BIBREF24 with an initial learning rate of 0.001 and decay it by a factor of 0.5 based on the dev set BLEU score. When training AST models, we regularize using dropout BIBREF25 with a ratio of $0.3$ over the embedding and LSTM layers BIBREF26; weight decay with a rate of $0.0001$; and, after the first 20 epochs, 30% of the time we replace the predicted output word by a random word from the target vocabulary. At test time we use beam decoding with a beam size of 5 and length normalization BIBREF27 with a weight of 0.6."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Baseline and ASR results",
        "paragraphs": [
          "Our baseline 20-hour AST system obtains a BLEU score of 10.3 (Table TABREF7, first row), 0.5 BLEU point lower than that reported by BIBREF4. This discrepancy might be due to differences in subsampling from the 160-hour AST dataset to create the 20-hour subset, or from Kaldi parameters when computing the MFCCs.",
          "WERs for our pre-trained models (Table TABREF7) vary from 22.5 for the large AISHELL dataset with Romanized transcript to 80.5 for Portuguese GlobalPhone. These are considerably worse than state-of-the-art ASR systems (e.g., Kaldi recipes can achieve WER of 7.5 on AISHELL and 26.5 on Portuguese GlobalPhone), but we did not optimize our architecture or hyperparameters for the ASR task since our main goal is to analyze the relationship between pretraining and AST performance (and in order to use pretraining, we must use a seq2seq model with the architecture as for AST)."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Pretraining the AST task on ASR models",
        "paragraphs": [
          "AST results for our pre-trained models are given in Table TABREF7. Pretraining improves AST performance in every case, with improvements ranging from 0.2 (pt-gp) to 4.3 (zh-ai-large). These results make it clear that language relatedness does not play a strong role in predicting AST improvements, since on the similar-sized GlobalPhone datasets, the two languages most related to Spanish (French and Portuguese) yield the highest and lowest improvements, respectively. Moreover, pretraining on the large Chinese dataset yields a bigger improvement than either of these\u20144.3 BLEU points. This is nearly as much as the 6 point improvement reported by BIBREF4 when pretraining on 100 hours of English data, which is especially surprising given not only that Chinese is very different from Spanish, but also that the Spanish data contains some English words.",
          "This finding seems to suggest that data size is more important than language relatedness for predicting the effects of pretraining. However, there are big differences even amongst the languages with similar amounts of pretraining data. Analyzing our results further, we found a striking correlation between the WER of the initial ASR model and the BLEU score of the AST system pretrained using that model, as shown in Figure FIGREF11. Therefore, although pretraining data size clearly influences AST performance, this appears to be mainly due to its effect on WER of the ASR model. We therefore hypothesize that WER is a better direct predictor of AST performance than either data size or language relatedness."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Multilingual pretraining",
        "paragraphs": [
          "Although our main focus is monolingual pretraining, we also looked briefly at multilingual pretraining, inspired by recent work on multilingual ASR BIBREF28, BIBREF29 and evidence that multilingual pretraining followed by fine-tuning on a distinct target language can improve ASR on the target language BIBREF10, BIBREF30, BIBREF31. These experiments did not directly compare pretraining using a similar amount of monolingual data, but such a comparison was done by BIBREF32, BIBREF33 in their work on learning feature representations for a target language with no transcribed data. They found a benefit for multilingual vs monolingual pretraining given the same amount of data.",
          "Following up on this work, we tried pretraining using 124 hours of multilingual data (all GlobalPhone languages except Chinese), roughly the amount of data in our large Chinese models. We combined all the data together and trained an ASR model using a common target BPE with 6k merge operations, then transferred only the encoder to the AST model. However, we did not see a benefit to the multilingual training (Table TABREF7, final row); in fact the resulting AST model was slightly worse than the zh-ai-large model (BLEU of 13.3 vs 14.6). Other configurations of multilingual training might still outperform their monolingual counterparts, but we leave this investigation as future work."
        ]
      },
      {
        "section_name": "Results and Discussion ::: Augmenting the parallel data",
        "paragraphs": [
          "Table TABREF16 (top) shows how data augmentation affects the results of the baseline 20h AST system, as well as three of the best-performing pretrained models from Table TABREF7. For these experiments only, we changed the learning rates of the augmented-data systems so that all models took about the same amount of time to train (see Figure FIGREF17). Despite a more aggressive learning schedule, the performance of the augmented-data systems surpasses that of the baseline and pretrained models, even those trained on the largest ASR sets (150-hr Chinese and 300-hr English).",
          "For comparison to other work, Table TABREF16 (bottom) gives results for AST models trained on the full 160 hours of parallel data, including models with both pretraining and data augmentation. For the latter, we used the original learning schedule, but had to stop training early due to time constraints (after 15 days, compared to 8 days for complete training of the non-augmented 160h models). We find that both pretraining and augmentation still help, providing a combined gain of 3.8 (3.2) BLEU points over the baseline on the dev (test) set."
        ]
      },
      {
        "section_name": "Analyzing the models' representations",
        "paragraphs": [
          "Finally, we hope to gain some understanding into why pretraining on ASR helps with AST, and specifically how the neural network representations change during pretraining and fine-tuning. We follow BIBREF34 and BIBREF9, who built diagnostic classifiers BIBREF35 to examine the representation of phonetic information in end-to-end ASR and AST systems, respectively. Unlike BIBREF34, BIBREF9, who used non-linear classifiers, we use a linear classifier to predict phone labels from the internal representations of the trained ASR or AST model.",
          "Using a linear classifier allows us to make more precise claims: if the classifier performs better using the representation from a particular layer, we can say that layer represents the phonetic information in a more linearly separable way. Using a nonlinear classifier raises questions about how to choose the complexity of the classifier itself, and therefore makes any results difficult to interpret.",
          "We hypothesized that pretraining allows the models to abstract away from nonlinguistic acoustic differences, and to better represent phonetic information: crucially, both in the trained language and in other languages. To test this hypothesis, we used two phone-labelled datasets distinct from all our ASR and AST datasets: the English TIMIT corpus (a language different to all of our trained models, with hand-labeled phones) and the Spanish GlobalPhone corpus (the same language as our AST source language, with phonetic forced-alignments produced using Kaldi). We randomly sampled utterances from these and passed them through the trained encoders, giving us a total of about 600k encoded frames. We used 400k of these to train logistic regression models to predict the phone labels, and tested on the remaining 200k frames.",
          "Separate logistic regression models were trained on the representations from each layer of the encoder. Since convolutional layers have a stride of 2, the number of frames decreases at each convolutional layer. To label the frames after a convolutional layer we eliminated every other label (and corresponding frame) from the original label sequence. For example, given label sequence S$_{\\text{1}}$ = aaaaaaann at input layer, we get sequence S$_{\\text{2}}$ = aaaan at the first convolutional layer and sequence S$_{\\text{3}}$ = aan at the second convolutional layer and at the following recurrent layers.",
          "Results for the two classification data sets (Figure FIGREF18) show very similar patterns. In both the ASR and the AST models, the pretraining data seems to make little difference to phonetic encoding at the early layers, and classification accuracy peaks at the second CNN layer. However, the RNN layers show a clear trend where phone classification accuracy drops off more slowly for models with better ASR/AST performance (i.e., zh $>$ fr $>$ pt). That is, the later RNN layers more transparently encode language-universal phonetic information.",
          "Phone classification accuracy in the RNN layers drops for both English and Spanish after fine-tuning on the AST data. This is slightly surprising for Spanish, since the fine-tuning data (unlike the pretraining data) is actually Spanish speech. However, we hypothesize that for AST, higher layers of the encoder may be recruited more to encode semantic information needed for the translation task, and therefore lose some of the linear separability in the phonetic information. Nevertheless, we still see the same pattern where better end-to-end models have higher classification accuracy in the later layers."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "This paper explored what factors help pretraining for low-resource AST. We performed careful comparisons to tease apart the effects of language relatedness and data size, ultimately finding that rather than either of these, the WER of the pre-trained ASR model is likely the best direct predictor of AST performance. Given equivalent amounts of data, we did not find multilingual pretraining to help more than monolingual pretraining, but we did find an added benefit from using speed perturbation to augment the AST data. Finally, analysis of the pretrained models suggests that those models with better WER are transparently encoding more language-universal phonetic information in the later RNN layers, and this appears to help with AST."
        ]
      }
    ],
    "qas": [
      {
        "question": "What languages did they use?",
        "question_id": "119c404da6e42d4879eee10edeab4b2851162659",
        "nlp_background": "two",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Spanish",
                "English ",
                "Chinese ",
                "Mandarin Chinese ",
                "Croatian ",
                "Czech ",
                "French ",
                "Polish ",
                "Portuguese ",
                "Swedish "
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "To answer these questions, we use the same AST architecture and Spanish-English parallel data as Bansal et al. BIBREF4, but pretrain the encoder using a number of different ASR datasets: the 150-hour AISHELL corpus of Chinese as well as seven GlobalPhone languages, each with about 20 hours of data. We find that pretraining on a larger amount of data from an unrelated language is much better than pretraining on a smaller amount of data from a related language. Moreover, even when controlling for the amount of data, the WER of the ASR model from pretraining seems to be a better predictor of final AST performance than does language relatedness. Indeed, we show that there is a very strong correlation between the WER of the pretraining model and BLEU score of the final AST model\u2014i.e., the best pretraining strategy may simply be to use datasets and methods that will yield the lowest ASR WER during pretraining. However, we also found that AST results can be improved further by augmenting the AST data using standard speed perturbation techniques BIBREF11. Our best results using non-English pretraining data improve the test set BLEU scores of an AST system trained on 20 hours of parallel data from 10.2 to 14.3, increasing to 15.8 with data augmentation.",
                "To look at a range of languages with similar amounts of data, we used GlobalPhone corpora from seven languages BIBREF15, each with around 20 hours of speech: Mandarin Chinese (zh), Croatian (hr), Czech (cs), French (fr), Polish (pl), Portuguese (pt), and Swedish (sv). French and Portuguese, like the source language (Spanish), belong to the Romance family of languages, while the other languages are less related\u2014especially Chinese, which is not an Indo-European language. GlobalPhone consists of read speech recorded using similar conditions across languages, and the transcriptions for Chinese are Romanized, with annotated word boundaries."
              ],
              "highlighted_evidence": [
                "To answer these questions, we use the same AST architecture and Spanish-English parallel data as Bansal et al. BIBREF4, but pretrain the encoder using a number of different ASR datasets: the 150-hour AISHELL corpus of Chinese as well as seven GlobalPhone languages, each with about 20 hours of data.",
                "To look at a range of languages with similar amounts of data, we used GlobalPhone corpora from seven languages BIBREF15, each with around 20 hours of speech: Mandarin Chinese (zh), Croatian (hr), Czech (cs), French (fr), Polish (pl), Portuguese (pt), and Swedish (sv). French and Portuguese, like the source language (Spanish), belong to the Romance family of languages, while the other languages are less related\u2014especially Chinese, which is not an Indo-European language. "
              ]
            },
            "annotation_id": "a5584aaeaeb4020efcfb459e553659095a29b36b",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Spanish",
                "English",
                "Mandarin Chinese",
                "Croatian",
                "Czech",
                "French",
                "Polish",
                "Portuguese",
                "Swedish"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For the AST models, we use Spanish-English parallel data from Fisher corpus BIBREF14, containing 160 hours of Spanish telephone speech translated into English text. To simulate low-resource settings, we randomly downsample the original corpus to 20 hours of training data. Each of the dev and test sets comprise 4.5 hours of speech.",
                "To look at a range of languages with similar amounts of data, we used GlobalPhone corpora from seven languages BIBREF15, each with around 20 hours of speech: Mandarin Chinese (zh), Croatian (hr), Czech (cs), French (fr), Polish (pl), Portuguese (pt), and Swedish (sv). French and Portuguese, like the source language (Spanish), belong to the Romance family of languages, while the other languages are less related\u2014especially Chinese, which is not an Indo-European language. GlobalPhone consists of read speech recorded using similar conditions across languages, and the transcriptions for Chinese are Romanized, with annotated word boundaries."
              ],
              "highlighted_evidence": [
                "For the AST models, we use Spanish-English parallel data from Fisher corpus BIBREF14, containing 160 hours of Spanish telephone speech translated into English text.",
                "To look at a range of languages with similar amounts of data, we used GlobalPhone corpora from seven languages BIBREF15, each with around 20 hours of speech: Mandarin Chinese (zh), Croatian (hr), Czech (cs), French (fr), Polish (pl), Portuguese (pt), and Swedish (sv)."
              ]
            },
            "annotation_id": "aedece3b852ed74a3201c68030256eae9fe80e3e",
            "worker_id": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Spanish-English"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "For the AST models, we use Spanish-English parallel data from Fisher corpus BIBREF14, containing 160 hours of Spanish telephone speech translated into English text. To simulate low-resource settings, we randomly downsample the original corpus to 20 hours of training data. Each of the dev and test sets comprise 4.5 hours of speech."
              ],
              "highlighted_evidence": [
                "For the AST models, we use Spanish-English parallel data from Fisher corpus BIBREF14, containing 160 hours of Spanish telephone speech translated into English text. To simulate low-resource settings, we randomly downsample the original corpus to 20 hours of training data."
              ]
            },
            "annotation_id": "d71020166099fdc23bf483604142c167b7c740b0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Fig. 1: Encoder-decoder architecture used for both ASR and AST."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Dataset statistics (left); dev set results from ASR pretraining and from the final AST system (right). AST results in all rows except the first are from pretraining using the dataset listed in that row, followed by fine-tuning using ast-20h. Numbers in brackets are the improvement over the baseline."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Fig. 2: WER of each ASR model vs BLEU score of the corresponding pre-trained AST model, computed in both cases on dev sets. Diamond markers are AISHELL data sets; circles are from GlobalPhone. The points in the circled group come from different runs on the same dataset but with different BPE or learning rate schedules. The Spearman rank correlation of these points is -0.97; the correlation is -0.92 when using test sets to compute both ASR and BLEU."
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Fig. 4: Phonetic classification accuracy at different layers of our ASR (left) and AST (right) models. Different color bars indicate representations extracted from models (pre)trained on different datasets (pt-gp, fr-gp, or zh-ai-large). Results from the baseline AST model (without pretraining) are shown in both panels for comparison. The bars with black edges are results on TIMIT (majority baseline: 12.9%); the taller bars are for Spanish GlobalPhone (majority baseline: 15.2%)."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: BLEU scores on dev and test sets for models trained with and without data augmentation. We used either 20h of AST training data (top block) or 160h (bottom block), with various pretraining."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Fig. 3: The AST performance over time (without beam-search) of baseline, pretrained, and pretrained+augmented models."
      }
    ]
  },
  "1711.01567": {
    "title": "Robust Speech Recognition Using Generative Adversarial Networks",
    "abstract": "This paper describes a general, scalable, end-to-end framework that uses the generative adversarial network (GAN) objective to enable robust speech recognition. Encoders trained with the proposed approach enjoy improved invariance by learning to map noisy audio to the same embedding space as that of clean audio. Unlike previous methods, the new framework does not rely on domain expertise or simplifying assumptions as are often needed in signal processing, and directly encourages robustness in a data-driven way. We show the new approach improves simulated far-field speech recognition of vanilla sequence-to-sequence models without specialized front-ends or preprocessing.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Automatic speech recognition (ASR) is becoming increasingly more integral in our day-to-day lives enabling virtual assistants and smart speakers like Siri, Google Now, Cortana, Amazon Echo, Google Home, Apple HomePod, Microsoft Invoke, Baidu Duer and many more. While recent breakthroughs have tremendously improved ASR performance BIBREF0 , BIBREF1 these models still suffer considerable degradation from reasonable variations in reverberations, ambient noise, accents and Lombard reflexes that humans have little or no issue recognizing.",
          "Most of these problems can be mitigated by training the models on a large volume of data that exemplify these effects. However, in the case of non-stationary processes, such as accents, accurate data augmentation is most likely infeasible, and in general, collecting high quality datasets can be expensive and time-consuming. Past robust ASR literature has considered hand-engineered front-ends and data-driven approaches in an attempt to increase the value of relatively parsimonious data with desired effects BIBREF2 , BIBREF3 . While these techniques are quite effective in their respective operating regimes, they do not generalize well to other modalities in practice due to the aforementioned reasons. Namely, it is difficult to model anything beyond reverberation and background noise from the first principles. Existing techniques do not directly induce invariance for ASR or are not scalable. And, due to the sequential nature of speech, alignments are needed to compare two different utterances of the same text.",
          "In this work, we employ the generative adversarial network (GAN) framework BIBREF4 to increase the robustness of seq-to-seq models BIBREF5 in a scalable, end-to-end fashion. The encoder component is treated as the generator of GAN and is trained to produce indistinguishable embeddings between noisy and clean audio samples. Because no restricting assumptions are made, this new robust training approach can in theory learn to induce robustness without alignment or complicated inference pipeline and even where augmentation is not possible. We also experiment with encoder distance objective to explicitly restrict the embedding space and demonstrate that achieving invariance at the hidden representation level is a promising direction for robust ASR.",
          "The rest of the paper is organized as follows. Related work is documented in Section \"RELATED WORK\" . Section \"ROBUST ASR\" defines our notations and details the robust ASR GAN. Section \"EXPERIMENTAL SETUP\" explains the experimental setup. Section \"RESULTS\" shows results on the Wall Street Journal (WSJ) dataset with simulated far-field effects. Finishing thoughts are found in Section \"CONCLUSION\" ."
        ]
      },
      {
        "section_name": "RELATED WORK",
        "paragraphs": [
          "A vast majority of work in robust ASR deals with reverberations and ambient noise; BIBREF2 provides an extensive survey in this effort. One of the most effective approaches in this variability is to devise a strong front-end such as the weighted prediction error (WPE) speech dereverberation BIBREF6 , BIBREF7 and train the resulting neural network with realistic augmented data BIBREF8 , BIBREF9 .",
          "A shift from more traditional signal processing techniques to more modern, data-driven methods was seen when the denoising autoencoder BIBREF10 was employed to induce invariance to reverberations BIBREF11 . This is novel in that the autoencoder is explicitly trained to predict the original audio features from a perturbed version convolved with an impulse response. While denoising autoencoder models for enhancing speech have been shown to improve perceptual quality of the produced speech, they have not demonstrated significant improvement for the task of speech recognition. This is because autoencoders are trained to reconstruct all aspects of the original audio, including many features that are not important for speech recognition, such as the voice and accent of the speaker, background noises etc. In fact, ASR systems learn to remove such artifacts of the input audio as they can hinder speech recognition performance. BIBREF12 proposed multiple rounds of joint denoising and ASR training for each audio sample, but this approach is not scalable for large datasets.",
          "A similar approach in spirit is to minimize the distance in the embedding space between clean and noisy audio. The intuition here is that the embedding distance is a measure of semantic similarity BIBREF13 . However, the perturbed speech may have a different time duration than the reference audio; dynamic time warping BIBREF14 can be used to approximate the alignment and compare sequences of varying lengths, but there is an increased computational overhead.",
          " BIBREF15 uses the generative adversarial networks (GAN) for domain adaptation to make the simulated images look more realistic to improve the task of robotic hand grasping. GAN BIBREF4 is an unsupervised learning framework, where the generator network learns to produce increasingly more realistic data in attempt to fool a competing discriminator. Because equilibrium is reached at a saddle point, it is notoriously hard to train. There have been many improvements to this technique. For example, Wasserstein GAN BIBREF16 uses the Earth-Mover distance to mitigate optimization issues. It is also less susceptible to architectural choices.",
          "For speech, BIBREF17 proposes a GAN based speech enhancement method called SEGAN but without the end goal of speech recognition. SEGAN operates on raw speech samples and hence it is computationally impractical for large scale experiments."
        ]
      },
      {
        "section_name": "Encoder distance enhancer",
        "paragraphs": [
          "As explained in Section \"RELATED WORK\" , denoising reconstruction and perceptual enhancement do not significantly improve ASR. A better approach would be to reconstruct only those aspects of the audio which are important for predicting the text spoken and ignore everything else. We hypothesize that the encoders of well trained ASR systems would learn to retain only this information from the input audio. Based on this idea, we propose a new sequence-to-sequence architecture for robust speech recognition that tries to match the output of the encoder for clean audio and noisy audio.",
          "The system works as follows: the same encoder, $g$ , is applied to the clean audio $x$ and the corresponding noisy audio $\\widetilde{x}$ to produce hidden states $z=g(x)$ and $\\widetilde{z}=g(\\widetilde{x})$ . The decoder, $h$ , models the conditional probability $p(y|x) = p(y|z)$ and is used to predict the output text sequence one character at a time. This architecture is described in Figure 1 . The entire system is trained end-to-end using a multi-task objective that tries to minimize the cross-entropy loss of predicting $y$ from $\\widetilde{x}$ and the normalized $L^1-$ distance between $x$0 and $x$1 : ",
          "$$ \n\\mathbb {E}_{(x,y) \\sim \\mathcal {D}} \\left[\nH(h(\\widetilde{z}), y) + \\lambda \\frac{\\Vert z - \\widetilde{z} \\Vert _{1}}{\\Vert z \\Vert _{1} + \\Vert \\widetilde{z} \\Vert _{1} + \\epsilon }\n\\right].$$   (Eq. 2) "
        ]
      },
      {
        "section_name": "GAN enhancer",
        "paragraphs": [
          "[htb!] $n_\\text{critic}$ , the number of critic per robust ASR updates. $c$ , the clipping parameter. $m$ , the batch size. $\\theta $ has not converged $t=1,\\dots ,n_\\text{critic}$ Sample $\\lbrace (x^{(i)}, y^{(i)}) \\sim \\mathcal {D}\\rbrace _{i=1}^m$ a batch of labeled speech data. Sample $\\lbrace \\widetilde{x}^{(i)}\\rbrace _{i=1}^m$ by augmentation or from a different distribution. Sample $\\lbrace \\varepsilon ^{(i)}\\rbrace _{i=1}^m$ a batch of prior noise. $g_\\theta \\leftarrow \\nabla _\\theta \\left[\n\\frac{1}{m}\\sum _{i=1}^m H(h_\\theta (g_\\theta (x^{(i)})), y^{(i)})\n\\right]$ $\\theta \\leftarrow \\theta - \\text{Optimizer}(\\theta , g_\\theta )$ $c$0 $c$1 $c$2 Sample $c$3 a batch of labeled speech data. Sample $c$4 by augmentation or from a different distribution. Sample $c$5 a batch of prior noise. $c$6 $c$7 WGAN enhancer training. The seq-to-seq model was trained using the Adam optimizer in our experiments. If $c$8 can be generated from $c$9 , data augmentation can also be used to update the seq-to-seq model.",
          "In our experiments, we found the encoder distance penalty to yield excellent results but it has the disadvantage that the encoder content between clean and noisy audio has to match frame for frame. Instead, employing the GAN framework, we can have a discriminator output a scalar likelihood of the entire speech being clean, and train the encoder to generate embeddings that are indistinguishable by the discriminator.",
          "In this paper, Wasserstein GAN (WGAN) BIBREF16 is used. Following the notations of WGAN, we parametrize the seq-to-seq and discriminator models with $\\theta $ and $w$ respectively. The overall architecture depicted in Figure 1 remains the same, but the encoder distance in ( 2 ) is now replaced with the dual of Earth-Mover (EM) distance ",
          "$$\\max _{w\\in \\mathcal {W}}\n\\left\\lbrace \n\\mathbb {E}_{x}\n\\left[f_w(g_\\theta (x))\\right] -\n\\mathbb {E}_{\\widetilde{x},\\varepsilon }\n\\left[f_w(g_\\theta (\\widetilde{x} + \\varepsilon )\\right]\n\\right\\rbrace .$$   (Eq. 5) ",
          "We treat the embedding of the clean input $x$ as real data and the embedding of $\\widetilde{x}$ , which can either be augmented from $x$ or drawn from a different modality, as being fake. And so, as GAN training progresses, the encoder $g_\\theta $ should learn to remove extraneous information to ASR to be able to fool the discriminator. In practice, we found that including a random Gaussian noise $\\varepsilon $ to the input prior of the generator helps improve training. Also, weights in the parameter set $\\mathcal {W}$ should be clipped to ensure the duality of ( 5 ) holds up to a constant multiple BIBREF16 . The adapted WGAN training procedure is detailed in Algorithm \"EXPERIMENTAL SETUP\" ."
        ]
      },
      {
        "section_name": "Corpora and Tasks",
        "paragraphs": [
          "We evaluated the enhancer framework on the Wall Street Journal (WSJ) corpus with simulated far-field effects. The dev93 and eval92 sets were used for hyperparameter selection and evaluation respectively. The reverberant speech is generated with room impulse response (RIR) augmentation as in BIBREF18 , where each audio is convolved with a randomly chosen RIR signal. The clean and far-field audio durations are kept the same with valid convolution so that the encoder distance enhancer can be applied. We collected 1088 impulse responses, using a linear array of 8 microphones, 120 and 192 of which were held out for development and evaluation. The speaker was placed in a variety of configurations, ranging from 1 to 3 meters distance and 60 to 120 degrees inclination with respect to the array, for 20 different rooms. Mel spectrograms of 20 ms samples with 10 ms stride and 40 bins were used as input features to all of our baseline and enhancer models."
        ]
      },
      {
        "section_name": "Network Architecture",
        "paragraphs": [
          "For the acoustic model, we used the sequence-to-sequence framework with soft attention based on BIBREF5 . The architecture of the encoder is described in Table 1 . The decoder consisted of a single 256 dimensional GRU layer with a hybrid attention mechanism similar to the models described in BIBREF19 .",
          "The discriminator network of the WGAN enhancer is described in Table 2 . All convolutional layers use leaky ReLU activation BIBREF20 with 0.2 slope for the leak, and batch normalization BIBREF21 ."
        ]
      },
      {
        "section_name": "Training",
        "paragraphs": [
          "To establish a baseline, in the first experiment, we trained a simple attention based seq-to-seq model. All the seq-to-seq networks in our experiments were trained using the Adam optimizer. We evaluate all models on both clean and far-field test sets.",
          "To study the effects of data augmentation, we train a new seq-to-seq model with the same architecture and training procedure as the baseline. However this time, in each epoch, we randomly select 40% of the training utterances and apply the train RIRs to them (in our previous experiments we had observed that 40% augmentation results in the best validation performance).",
          "For the enhancer models, $\\lambda $ in Equation 2 was tuned over the dev set by doing a logarithmic sweep in [0.01, 10]. $\\lambda = 1$ gave the best performance.",
          "We use Algorithm \"EXPERIMENTAL SETUP\" to train the WGAN enhancer. The clipping parameter was 0.05 and $\\varepsilon $ was random normal with 0.001 standard deviation. We found that having a schedule for $n_\\text{critic}$ was crucial. Namely, we do not update the encoder parameters with WGAN gradients for the first 3000 steps. Then, we use the normal $n_\\text{critic}=5$ . We hypothesize that the initial encoder embedding is of poor quality and encouraging invariance at this stage through the critic gradients significantly hinders seq-to-seq training."
        ]
      },
      {
        "section_name": "RESULTS",
        "paragraphs": [
          "We present results in Table 3 . All of the evaluations were performed using greedy decoding and no language models. To provide context, our near-field result is comparable to the 18.6% WER of BIBREF5 obtained with language model beam decoding with 200 beam size. We can see that a seq-to-seq model trained only on near-field audio data performs extremely poorly on far-field audio. This suggests that it is non-trivial for an ASR model to generalize from homogeneous near-field audio to far-field audio.",
          "To overcome this, we train a stronger baseline with simulated far-field audio examples. This model had the same architecture but 40% of the examples that the model was trained on were convolved with a randomly chosen room impulse response during training. We can see from Table 3 that simple data augmentation can significantly improve performance on far-field audio without compromising the performance on near-field audio, implying that seq-to-seq models have a strong ability to learn from far-field examples.",
          "Even with data augmentation, however, there is still a large gap between the WERs on near-field and far-field test sets. The bottom two rows of Table 3 show the performance of the methods introduced in this paper on the same test sets. An $L^1$ -distance penalty can lower the test set WER by 1.32% absolute. Using a GAN enhancer can reduce the WER by an additional 1.07%. Overall, the gap between near-field and far-field performance decreases by almost 27% compared to the model that only uses data augmentation.",
          "An additional benefit of our methods is that the $L^1$ -distance penalty and GAN loss function act as regularizers which reduce generalization error on near field data. The enhancer models have lower WERs even on near-field data compared to the baseline models."
        ]
      },
      {
        "section_name": "CONCLUSION",
        "paragraphs": [
          "We introduced a GAN-based framework to train robust ASR models in a scalable, data-driven way, and showed that inducing invariance at the encoder embedding level considerably improves the recognition of simulated far-field speech by vanilla seq-to-seq models. This method has effectively imbued the seq-to-seq encoder with a far-field front-end. We anticipate that coupling the new framework with specialized trainable front-ends, such as WPE, would enhance robustness even more significantly."
        ]
      }
    ],
    "qas": [
      {
        "question": "Are there experiments with real data?",
        "question_id": "32f2aa2df0152050cbcd27dd2f408b2fa5894031",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "The rest of the paper is organized as follows. Related work is documented in Section \"RELATED WORK\" . Section \"ROBUST ASR\" defines our notations and details the robust ASR GAN. Section \"EXPERIMENTAL SETUP\" explains the experimental setup. Section \"RESULTS\" shows results on the Wall Street Journal (WSJ) dataset with simulated far-field effects. Finishing thoughts are found in Section \"CONCLUSION\" ."
              ],
              "highlighted_evidence": [
                "Section \"RESULTS\" shows results on the Wall Street Journal (WSJ) dataset with simulated far-field effects."
              ],
              "yes_no": null,
              "free_form_answer": "Yes. They show results on the Wall Street Journal Corpus, which consists of recordings of real speech.",
              "extractive_spans": []
            },
            "annotation_id": "205d1f3bea2df7e9362a67f6e4687daaf8f3d174",
            "worker_id": "057bf5a20e4406f1f05cf82ecd49cf4f227dd287"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "We evaluated the enhancer framework on the Wall Street Journal (WSJ) corpus with simulated far-field effects. The dev93 and eval92 sets were used for hyperparameter selection and evaluation respectively. The reverberant speech is generated with room impulse response (RIR) augmentation as in BIBREF18 , where each audio is convolved with a randomly chosen RIR signal. The clean and far-field audio durations are kept the same with valid convolution so that the encoder distance enhancer can be applied. We collected 1088 impulse responses, using a linear array of 8 microphones, 120 and 192 of which were held out for development and evaluation. The speaker was placed in a variety of configurations, ranging from 1 to 3 meters distance and 60 to 120 degrees inclination with respect to the array, for 20 different rooms. Mel spectrograms of 20 ms samples with 10 ms stride and 40 bins were used as input features to all of our baseline and enhancer models."
              ],
              "highlighted_evidence": [
                "We evaluated the enhancer framework on the Wall Street Journal (WSJ) corpus with simulated far-field effects. "
              ]
            },
            "annotation_id": "809fc706f338b28fbd1640e84ca573172342dac7",
            "worker_id": "043654eefd60242ac8da08ddc1d4b8d73f86f653"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We evaluated the enhancer framework on the Wall Street Journal (WSJ) corpus with simulated far-field effects. The dev93 and eval92 sets were used for hyperparameter selection and evaluation respectively. The reverberant speech is generated with room impulse response (RIR) augmentation as in BIBREF18 , where each audio is convolved with a randomly chosen RIR signal. The clean and far-field audio durations are kept the same with valid convolution so that the encoder distance enhancer can be applied. We collected 1088 impulse responses, using a linear array of 8 microphones, 120 and 192 of which were held out for development and evaluation. The speaker was placed in a variety of configurations, ranging from 1 to 3 meters distance and 60 to 120 degrees inclination with respect to the array, for 20 different rooms. Mel spectrograms of 20 ms samples with 10 ms stride and 40 bins were used as input features to all of our baseline and enhancer models."
              ],
              "highlighted_evidence": [
                "We evaluated the enhancer framework on the Wall Street Journal (WSJ) corpus with simulated far-field effects."
              ]
            },
            "annotation_id": "f1daed9b43d8a719215fdc9c091cdd7685fc78b8",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Fig. 1. Architecture of the enhancer models introduced in this paper. The discriminator loss can be L1-distance or WGAN loss. The entire model is trained end-to-end using both the discriminator loss and the cross-entropy loss. We use RIR convolution to simulate far-field audio. It\u2019s also possible to train this model with the same speech recorded in different conditions."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1. Architecture of the encoder."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2. Architecture of the critic. (feature)\u00d7(time)."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3. Speech recognition performance on the Wall Street Journal Corpus"
      }
    ]
  },
  "1706.04206": {
    "title": "Identifying Condition-Action Statements in Medical Guidelines Using Domain-Independent Features",
    "abstract": "This paper advances the state of the art in text understanding of medical guidelines by releasing two new annotated clinical guidelines datasets, and establishing baselines for using machine learning to extract condition-action pairs. In contrast to prior work that relies on manually created rules, we report experiment with several supervised machine learning techniques to classify sentences as to whether they express conditions and actions. We show the limitations and possible extensions of this work on text mining of medical guidelines.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Clinical decision-support system (CDSS) is any computer system intended to provide decision support for healthcare professionals, and using clinical data or knowledge BIBREF0 . The classic problem of diagnosis is only one of the clinical decision problems. Deciding which questions to ask, tests to order, procedures to perform, treatment to indicate, or which alternative medical care to try, are other examples of clinical decisions. CDSSs generally fall into two categories BIBREF0 ",
          "Most of the questions physicians need to consult about with CDSSs are from the latter category. Medical guidelines (also known as clinical guidelines, clinical protocols or clinical practice guidelines) are most useful at the point of care and answering to \"what to do\" questions.",
          "Medical guidelines are systematically developed statements to assist with practitioners' and patients' decisions. They establish criteria regarding diagnosis, management, and treatment in specific areas of healthcare. For example, a sentence such as \"if the A1C is 7.0% and a repeat result is 6.8%, the diagnosis of diabetes is confirmed\" in medical guidelines determines what is true about a patient. Sentences such as \"Topical and oral decongestants and antihistamines should be avoided in patients with ABRS\" guide what to do or not to do with a patient. These examples illustrate conditions, criteria applicable to patients, and consequences of the conditions. The consequences may refer to activities, effects, intentions, or events. If a guideline-based CDSS needs to answer \"what to do\" questions, it has to have access to condition-action statements describing under what circumstances an action can be performed.",
          "Medical guidelines contain many condition-action statements. Condition-action statements provide information about expected process flow. If a guideline-based CDSS could extract and formalize these statements, it could help practitioners in the decision-making process. For example, it could help automatically asses the relationship between therapies, guidelines and outcomes, and in particular could help the impact of changing guidelines.",
          "However, completely automated extraction of condition-action statements does not seem possible. This is due among other things to the variety of linguistic expressions used in condition-action sentences. For example, they are not always in form of \"{if} condition {then} action\u201d. In the sentence \"Conditions that affect erythrocyte turnover and hemoglobin variants must be considered, particularly when the A1C result does not correlate with the patient's clinical situation\u201d, we have a condition-action sentence without an \"{if}\" term.",
          "We propose a supervised machine learning model classifying sentences as to whether they express a condition or not. After we determine a sentence contain a condition, we use natural language processing and information extraction tools to extract conditions and resulting activities.",
          "With the help of a domain expert, we annotated three sets of guidelines to create gold standards to measure the performance of our condition-action extracting models. The sets of guidelines are: hypertension BIBREF1 , chapter4 of asthma BIBREF2 , and rhinosinusitis BIBREF3 . Chapter 4 of asthma guidelines was selected for comparison with prior work of Wenzina and Kaiser BIBREF4 . We have annotated the guidelines for the conditions, consequences, modifiers of conditions, and type of consequences. These annotate sets of guidelines are available for experiments https://www.dropbox.com/."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "We will briefly discuss the modeling and annotation of condition-action for medical usage in this section. Our corpus and method of identifying conditions in clinical guidelines is explained in section 3.",
          "Research on CIGs started about 20 years ago and became more popular in the late-1990s and early 2000s. Different approaches have been developed to represent and execute clinical guidelines over patient-specific clinical data. They include document-centric models, decision trees and probabilistic models, and \"Task-Network Models\"(TNMs) BIBREF5 , which represent guideline knowledge in hierarchical structures containing networks of clinical actions and decisions that unfold over time. Serban et. al BIBREF6 developed a methodology for extracting and using linguistic patterns in guideline formalization, to aid the human modellers in guideline formalization and reduce the human modelling effort. Kaiser et. al BIBREF7 developed a method to identify activities to be performed during a treatment which are described in a guideline document. They used relations of the UMLS Semantic Network BIBREF8 to identify these activities in a guideline document. Wenzina and Kaiser BIBREF4 developed a rule-based method to automatically identifying conditional activities in guideline documents.They achieved a recall of 75% and a precision of 88% on chapter 4 of asthma guidelines which was mentioned before."
        ]
      },
      {
        "section_name": "Condition-Action Extraction",
        "paragraphs": [
          "Medical guidelines\u2019 condition-action statements provide information to determine \"what to do\" with a patient. Other types of consequences of a condition in a sentence may help practitioner to find what is true about a patient. In this paper, we propose an automated process to find and extract condition-action statements from medical guidelines. We employed NLP tools and concepts in the process to achieve more general models.",
          "We define the task as classification task. Given an input statement, classify it to one of the three categories: NC (no condition) if the statement doesn\u2019t have a condition; CA if the statement is a condition-action sentence; and CC (condition-consequence) if the statement has a condition which has a non-action consequence. For a CDSS, to determine both \"what is true\" about a patient and \"what to do\" with a patient, CC and CA statements can be merged to one category.",
          "There are limitations in this specification of classification categories. For example, guidelines may contain statements with a condition referring to a consequence in another statement. Or, we can see condition and effect in two different sentences: \"However, there are some cases for which the results for black persons were different from the results for the general population (question 3, evidence statements 2, 10, and 17). In those cases, separate evidence statements were developed.\"",
          "In this work we focus only on statements that follow the above sentence categorization rules. This allows us to make clear comparison to prior work e.g. by Wenzina and Kaiser BIBREF4 . They annotated chapter 4 of asthma and other guidelines. They used information extraction rules and semantic pattern rules to extract conditional activities, condition-action statements. We use POS tags as features in the classification models. In our opinion, using POS tags instead of semantic pattern rules makes our model more domain-independent, and therefore more suitable for establishing baselines, not only for text mining of medical guidelines but also in other domains, such as text mining of business rules. But we also expect to improve the performance of our extraction programs by adding semantic and discourse information (this work is ongoing)."
        ]
      },
      {
        "section_name": "Classification",
        "paragraphs": [
          "Most of the condition-action sentences have a modifier in the sentences. For example, in \"In the population aged 18 years or older with CKD and hypertension, initial (or add-on) antihypertensive treatment should include an ACEI or ARB to improve kidney outcomes\", we have \"the population aged 18 years or older with CKD and hypertension\" as a condition and \"{in}\" is the modifier. \"If\", \"in\", \"for\", \"to\", \"which\", and \"when\" are the most frequent modifiers in our guidelines.",
          "We used CoreNLP BIBREF9 Shift-Reduce Constituency Parser to parse sentences in guidelines. As we mentioned, \"if\", \"in\", \"for\", \"to\", \"which\", and \"when\" are the most frequent modifiers in our guidelines. \"If\", \"in\", and \"for\" are tagged as \"IN\" which represents preposition or subordinating conjunction. \"To\" is tagged as \"TO\" and \"when\" and \"which\" are tagged as \"WHADV\". We used regular expressions to find those parses which are promising candidates for extraction of condition-action pairs; for example, we selected sentences which include these tags: IN, TO and WHADVP.",
          "We extracted part of speech (POS) tags as our features for our model. Each candidate sentence has at least one candidate condition part. We extract these parts by regular expressions. Each part of sentence which starts with below patterns is a candidate condition part:",
          "\"\\((SBAR|PP) \\(IN\"",
          "\"\\(SBAR \\(WHADVP\"",
          "\"\\(PP \\(TO\"",
          "For example, \"(ROOT (S (PP (IN In) (NP (NP (NNS adults)) (PP (IN with) (NP (NN hypertension))))) (, ,) (VP (VBZ does) (S (VP (VBG initiating) (S (NP (NP (JJ antihypertensive) (JJ pharmacologic) (NN therapy)) (PP (IN at) (NP (JJ specific) (NN BP) (NNS thresholds)))) (VP (VBP improve) (NP (NN health) (NNS outcomes))))))) (. ?)))\" is the constituent parsed tree of \"In adults with hypertension, does initiating antihypertensive pharmacologic therapy at specific BP thresholds improve health outcomes?\". \"(PP (IN In) (NP (NP (NNS adults)) (PP (IN with) (NP (NN hypertension)))))\" and \"(PP (IN at) (NP (JJ specific) (NN BP) (NNS thresholds)))\" are two candidate condition parts in this example.",
          "We created features for our model based on POS tags and their combinations. The sets of features and the combinations are learned automatically from annotated examples. We used these novel features to make our model more domain-independent.",
          "For each sentence, we extracted POS tags, sequences of 3 POS tags, and combination of all POS tags of candidate conditions as features. For example, \"PP IN NP NP NNS PP IN NP NN PPINNP INNPNP NPNPNNS NPNNSPP NNSPPIN PPINNP INNPNN PPINNPNPNNSPPINNPNN PP IN NP NN PPINNP INNPNN PPINNPNN PP IN NP JJ NN NNS PPINNP INNPJJ NPJJNN JJNNNNS PPINNPJJNNNNS\" represents \"In adults with hypertension, does initiating antihypertensive pharmacologic therapy at specific BP thresholds improve health outcomes?\" in our model. Note that the glued together part of speech tags are not a formatting error but features automatically derived by our model (from consecutive part of speech tags)."
        ]
      },
      {
        "section_name": "Gold Standard Datasets",
        "paragraphs": [
          "We use three medical guidelines documents to create gold standard datasets. They provide statements, tables, and figures about hypertension, rhinosinusitis, and asthma. The creation of the gold standard datasets is described below in detail.",
          "Our data preparation process proceeded as follows: We started by converting the guidelines from PDF or html to text format, editing sentences only to manage conversion errors, the majority of which were bullet points. Tables and some figures pose a problem, and we are simply treating them as unstructured text. We are not dealing at this time with the ambiguities introduced by this approach; we do have plans to address it in future work.",
          "Using regular expressions, as described above, we selected candidate sentences from text files. Note that candidate sentences do not always include a modifier such as \"if\" or \"in\". For example, in \"Patients on long-term steroid tablets (e.g. longer than three months) or requiring frequent courses of steroid tablets (e.g. three to four per year) will be at risk of systemic side-effects\", there is no modifier in the sentence.",
          "The annotation of the guidelines text (the next step), focused on determining whether there were condition statements in the candidate sentences or not. The instruction to the annotators were to try to paraphrase candidate sentences as sentences with \"if condition, then consequence\". If the transformed/paraphrased sentence conveyed the same meaning as the original, we considered to be a condition-consequence sentence. Then we we could annotate condition and consequence parts. For example, we paraphrased \"Beta-blockers, including eye drops, are contraindicated in patients with asthma\" to \"If patients have asthma, then beta-blockers, including eye drops, are contraindicated\". The paraphrased sentence conveys same meaning. So it became a condition-consequence sentence in our dataset. On the other hand, for example, we cannot paraphrase \"Further, the diagnostic criteria for CKD do not consider age-related decline in kidney function as reflected in estimated GFR\" to an if-then sentence.",
          "We also annotated the type of sentences based on their semantics: We classified them into three classes: condition-action, condition-consequence(effect, intention, and event) and action. Examples are shown in table 1.",
          "Each sentence was annotated by one domain expert and us (and the disagreements where less than 10 percent). Table 2 shows the statistics of the annotated sentences for 3 different medical guidelines."
        ]
      },
      {
        "section_name": "Model Performance",
        "paragraphs": [
          "Hypertension, asthma, and rhinosinusitis guidelines and gold standard datasets were applied to evaluate our model. Since two of these annotated corpora are new, our model is establishing a baseline. The asthma corpus was investigated previously by BIBREF4 .",
          "We extracted candidate statements by applying aforementioned regex on POS tags. Hypertension, asthma, and rhinosinusitis guidelines had 278, 172, and 761 candidate statements respectively. By applying this filtering subtask, we get rid of 38, 116, and 5 no condition statement respectively from guidelines. We used Weka BIBREF10 classifiers to create our models. ZeroR, Na\u00efve Bayes, J48, and random forest classifiers were applied in our project. Table 3 , 4 , and 5 show the results of classifiers for each guidelines.The results are based on 10-fold cross-validation on respective datasets.",
          "The results show that generally random forest classifier seems to work best in extracting Condition-Action statements.",
          "Notice that these results are lower than previously reported by BIBREF4 . The difference is due to our using of completely automated feature selection when training on an annotated corpus, and not relying on manually created extraction rules. In addition, their results demonstrate recalls on activities with specific patterns. If we consider all activities in their annotated corpus, their recall will be 56%. And if we apply their approach on our annotated corpus, the recall will be 39%. In ongoing work we hope to reduce or close this gap by adding semantic and discourse information to our feature sets."
        ]
      },
      {
        "section_name": "Conclusions and Future Work",
        "paragraphs": [
          "We investigated the problem of automated extraction of condition-action from clinical guidelines based on an annotated corpus. We proposed a simple supervised model which classifies statements based on combinations of part of speech tags used as features. We showed results of classifiers using this model on three different annotated datasets which we created. We release these dataset for others to use.",
          "Obviously, this is very preliminary work. Our work established baselines for automated extraction of condition-action rules from medical guidelines, but its performance is still inferior to a collection of manually created extraction rules. To close this gap we are currently augmenting our model with semantic information along the lines of BIBREF7 and BIBREF4 . In addition, we are beginning to experiment with some discourse relations \u2013 these are important, for example, in understanding of lists and tables. We also plan to make our annotated datasets more convenient to use by re-annotating them with standard annotation tools e.g. BRAT BIBREF11 ."
        ]
      }
    ],
    "qas": [
      {
        "question": "Does the supervised machine learning approach outperform previous work?",
        "question_id": "5c17559749810c67c50a7dbe34580d5e3b4f9acb",
        "nlp_background": "infinity",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Research on CIGs started about 20 years ago and became more popular in the late-1990s and early 2000s. Different approaches have been developed to represent and execute clinical guidelines over patient-specific clinical data. They include document-centric models, decision trees and probabilistic models, and \"Task-Network Models\"(TNMs) BIBREF5 , which represent guideline knowledge in hierarchical structures containing networks of clinical actions and decisions that unfold over time. Serban et. al BIBREF6 developed a methodology for extracting and using linguistic patterns in guideline formalization, to aid the human modellers in guideline formalization and reduce the human modelling effort. Kaiser et. al BIBREF7 developed a method to identify activities to be performed during a treatment which are described in a guideline document. They used relations of the UMLS Semantic Network BIBREF8 to identify these activities in a guideline document. Wenzina and Kaiser BIBREF4 developed a rule-based method to automatically identifying conditional activities in guideline documents.They achieved a recall of 75% and a precision of 88% on chapter 4 of asthma guidelines which was mentioned before.",
                "Notice that these results are lower than previously reported by BIBREF4 . The difference is due to our using of completely automated feature selection when training on an annotated corpus, and not relying on manually created extraction rules. In addition, their results demonstrate recalls on activities with specific patterns. If we consider all activities in their annotated corpus, their recall will be 56%. And if we apply their approach on our annotated corpus, the recall will be 39%. In ongoing work we hope to reduce or close this gap by adding semantic and discourse information to our feature sets."
              ],
              "highlighted_evidence": [
                "Wenzina and Kaiser BIBREF4 developed a rule-based method to automatically identifying conditional activities in guideline documents.They achieved a recall of 75% and a precision of 88% on chapter 4 of asthma guidelines which was mentioned before.",
                "Notice that these results are lower than previously reported by BIBREF4 ."
              ]
            },
            "annotation_id": "219f0bea1996aef80477cee6cb2dd370bd6c2d82",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Notice that these results are lower than previously reported by BIBREF4 . The difference is due to our using of completely automated feature selection when training on an annotated corpus, and not relying on manually created extraction rules. In addition, their results demonstrate recalls on activities with specific patterns. If we consider all activities in their annotated corpus, their recall will be 56%. And if we apply their approach on our annotated corpus, the recall will be 39%. In ongoing work we hope to reduce or close this gap by adding semantic and discourse information to our feature sets."
              ],
              "highlighted_evidence": [
                "Notice that these results are lower than previously reported by BIBREF4 . The difference is due to our using of completely automated feature selection when training on an annotated corpus, and not relying on manually created extraction rules."
              ]
            },
            "annotation_id": "33927d890582aa8c7dc39134ebfcd4fe2ee90318",
            "worker_id": "043654eefd60242ac8da08ddc1d4b8d73f86f653"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": false,
              "free_form_answer": "",
              "evidence": [
                "Notice that these results are lower than previously reported by BIBREF4 . The difference is due to our using of completely automated feature selection when training on an annotated corpus, and not relying on manually created extraction rules. In addition, their results demonstrate recalls on activities with specific patterns. If we consider all activities in their annotated corpus, their recall will be 56%. And if we apply their approach on our annotated corpus, the recall will be 39%. In ongoing work we hope to reduce or close this gap by adding semantic and discourse information to our feature sets."
              ],
              "highlighted_evidence": [
                "Notice that these results are lower than previously reported by BIBREF4 ."
              ]
            },
            "annotation_id": "7bc8088368a4e392aa7f3f41ec0d9d84003f678b",
            "worker_id": "291c6b2df1bac379d47f5557f9e564a1f6618bf7"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Examples of classified sentence classes"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Statistical information about annotated guidelines"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Classification results on asthma guidelines. (The ZeroR gives 0 precision and recall, because the majority of the guidelines sentences do not contain conditions and actions)."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Classification results on rhinosinusitis guidelines"
      },
      {
        "file": "4-Table5-1.png",
        "caption": "Table 5: Classification results on hypertension guidelines"
      }
    ]
  },
  "1707.06875": {
    "title": "Why We Need New Evaluation Metrics for NLG",
    "abstract": "The majority of NLG evaluation relies on automatic metrics, such as BLEU . In this paper, we motivate the need for novel, system- and data-independent automatic evaluation methods: We investigate a wide range of metrics, including state-of-the-art word-based and novel grammar-based ones, and demonstrate that they only weakly reflect human judgements of system outputs as generated by data-driven, end-to-end NLG. We also show that metric performance is data- and system-specific. Nevertheless, our results also suggest that automatic metrics perform reliably at system-level and can support system development by finding cases where a system performs poorly.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Automatic evaluation measures, such as bleu BIBREF0 , are used with increasing frequency to evaluate Natural Language Generation (NLG) systems: Up to 60% of NLG research published between 2012\u20132015 relies on automatic metrics BIBREF1 . Automatic evaluation is popular because it is cheaper and faster to run than human evaluation, and it is needed for automatic benchmarking and tuning of algorithms. The use of such metrics is, however, only sensible if they are known to be sufficiently correlated with human preferences. This is rarely the case, as shown by various studies in NLG ( BIBREF2 ; BIBREF3 , BIBREF4 ), as well as in related fields, such as dialogue systems BIBREF5 , machine translation (MT) BIBREF6 , and image captioning BIBREF7 , BIBREF8 . This paper follows on from the above previous work and presents another evaluation study into automatic metrics with the aim to firmly establish the need for new metrics. We consider this paper to be the most complete study to date, across metrics, systems, datasets and domains, focusing on recent advances in data-driven NLG. In contrast to previous work, we are the first to:",
          " $\\bullet $ Target end-to-end data-driven NLG, where we compare 3 different approaches. In contrast to NLG methods evaluated in previous work, our systems can produce ungrammatical output by (a) generating word-by-word, and (b) learning from noisy data.",
          " $\\bullet $ Compare a large number of 21 automated metrics, including novel grammar-based ones.",
          " $\\bullet $ Report results on two different domains and three different datasets, which allows us to draw more general conclusions.",
          " $\\bullet $ Conduct a detailed error analysis, which suggests that, while metrics can be reasonable indicators at the system-level, they are not reliable at the sentence-level.",
          " $\\bullet $ Make all associated code and data publicly available, including detailed analysis results."
        ]
      },
      {
        "section_name": "End-to-End NLG Systems",
        "paragraphs": [
          "In this paper, we focus on recent end-to-end, data-driven NLG methods, which jointly learn sentence planning and surface realisation from non-aligned data ( BIBREF9 , BIBREF10 , BIBREF11 , BIBREF12 ; BIBREF13 , BIBREF13 ; BIBREF14 , BIBREF15 ). These approaches do not require costly semantic alignment between Meaning Representations (MR) and human references (also referred to as \u201cground truth\" or \u201ctargets\"), but are based on parallel datasets, which can be collected in sufficient quality and quantity using effective crowdsourcing techniques, e.g. BIBREF16 , and as such, enable rapid development of NLG components in new domains. In particular, we compare the performance of the following systems:",
          " $\\bullet $ rnnlg: The system by BIBREF10 uses a Long Short-term Memory (LSTM) network to jointly address sentence planning and surface realisation. It augments each LSTM cell with a gate that conditions it on the input MR, which allows it to keep track of MR contents generated so far.",
          " $\\bullet $ TGen: The system by BIBREF9 learns to incrementally generate deep-syntax dependency trees of candidate sentence plans (i.e. which MR elements to mention and the overall sentence structure). Surface realisation is performed using a separate, domain-independent rule-based module.",
          " $\\bullet $ lols: The system by BIBREF15 learns sentence planning and surface realisation using Locally Optimal Learning to Search (lols), an imitation learning framework which learns using bleu and rouge as non-decomposable loss functions."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "We consider the following crowdsourced datasets, which target utterance generation for spoken dialogue systems. Table 1 shows the number of system outputs for each dataset. Each data instance consists of one MR and one or more natural language references as produced by humans, such as the following example, taken from the Bagel dataset:",
          " MR: inform(name=X, area=X, pricerange=moderate, type=restaurant)",
          "Reference: \u201cX is a moderately priced restaurant in X.\u201d ",
          " $\\bullet $ SFHotel & SFRest BIBREF10 provide information about hotels and restaurants in San Francisco. There are 8 system dialogue act types, such as inform, confirm, goodbye etc. Each domain contains 12 attributes, where some are common to both domains, such as name, type, pricerange, address, area, etc., and the others are domain-specific, e.g. food and kids-allowed for restaurants; hasinternet and dogs-allowed for hotels. For each domain, around 5K human references were collected with 2.3K unique human utterances for SFHotel and 1.6K for SFRest. The number of unique system outputs produced is 1181 for SFRest and 875 for SFHotel.",
          " $\\bullet $ Bagel BIBREF17 provides information about restaurants in Cambridge. The dataset contains 202 aligned pairs of MRs and 2 corresponding references each. The domain is a subset of SFRest, including only the inform act and 8 attributes."
        ]
      },
      {
        "section_name": "Word-based Metrics (WBMs)",
        "paragraphs": [
          "NLG evaluation has borrowed a number of automatic metrics from related fields, such as MT, summarisation or image captioning, which compare output texts generated by systems to ground-truth references produced by humans. We refer to this group as word-based metrics. In general, the higher these scores are, the better or more similar to the human references the output is. The following order reflects the degree these metrics move from simple $n$ -gram overlap to also considering term frequency (TF-IDF) weighting and semantically similar words.",
          " $\\bullet $ Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
          " $\\bullet $ Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet."
        ]
      },
      {
        "section_name": "Grammar-based metrics (GBMs)",
        "paragraphs": [
          "Grammar-based measures have been explored in related fields, such as MT BIBREF25 or grammatical error correction BIBREF26 , and, in contrast to WBMs, do not rely on ground-truth references. To our knowledge, we are the first to consider GBMs for sentence-level NLG evaluation. We focus on two important properties of texts here \u2013 readability and grammaticality:",
          " $\\bullet $ Readability quantifies the difficulty with which a reader understands a text, as used for e.g. evaluating summarisation BIBREF27 or text simplification BIBREF28 . We measure readability by the Flesch Reading Ease score (re) BIBREF29 , which calculates a ratio between the number of characters per sentence, the number of words per sentence, and the number of syllables per word. Higher re score indicates a less complex utterance that is easier to read and understand. We also consider related measures, such as characters per utterance (len) and per word (cpw), words per sentence (wps), syllables per sentence (sps) and per word (spw), as well as polysyllabic words per utterance (pol) and per word (ppw). The higher these scores, the more complex the utterance.",
          " $\\bullet $ Grammaticality: In contrast to previous NLG methods, our corpus-based end-to-end systems can produce ungrammatical output by (a) generating word-by-word, and (b) learning from noisy data. As a first approximation of grammaticality, we measure the number of misspellings (msp) and the parsing score as returned by the Stanford parser (prs). The lower the msp, the more grammatically correct an utterance is. The Stanford parser score is not designed to measure grammaticality, however, it will generally prefer a grammatical parse to a non-grammatical one. Thus, lower parser scores indicate less grammatically-correct utterances. In future work, we aim to use specifically designed grammar-scoring functions, e.g. BIBREF26 , once they become publicly available."
        ]
      },
      {
        "section_name": "Human Data Collection",
        "paragraphs": [
          "To collect human rankings, we presented the MR together with 2 utterances generated by different systems side-by-side to crowdworkers, which were asked to score each utterance on a 6-point Likert scale for:",
          " $\\bullet $ Informativeness: Does the utterance provide all the useful information from the meaning representation?",
          " $\\bullet $ Naturalness: Could the utterance have been produced by a native speaker?",
          " $\\bullet $ Quality: How do you judge the overall quality of the utterance in terms of its grammatical correctness and fluency? Each system output (see Table 1 ) was scored by 3 different crowdworkers. To reduce participants' bias, the order of appearance of utterances produced by each system was randomised and crowdworkers were restricted to evaluate a maximum of 20 utterances. The crowdworkers were selected from English-speaking countries only, based on their IP addresses, and asked to confirm that English was their native language.",
          "To assess the reliability of ratings, we calculated the intra-class correlation coefficient (ICC), which measures inter-observer reliability on ordinal data for more than two raters BIBREF30 . The overall ICC across all three datasets is 0.45 ( $p<0.001$ ), which corresponds to a moderate agreement. In general, we find consistent differences in inter-annotator agreement per system and dataset, with lower agreements for lols than for rnnlg and TGen. Agreement is highest for the SFHotel dataset, followed by SFRest and Bagel (details provided in supplementary material)."
        ]
      },
      {
        "section_name": "System Evaluation",
        "paragraphs": [
          "Table 2 summarises the individual systems' overall corpus-level performance in terms of automatic and human scores (details are provided in the supplementary material).",
          "All WOMs produce similar results, with sim showing different results for the restaurant domain (Bagel and SFRest). Most GBMs show the same trend (with different levels of statistical significance), but re is showing inverse results. System performance is dataset-specific: For WBMs, the lols system consistently produces better results on Bagel compared to TGen, while for SFRest and SFHotel, lols is outperformed by rnnlg in terms of WBMs. We observe that human informativeness ratings follow the same pattern as WBMs, while the average similarity score (sim) seems to be related to human quality ratings.",
          "Looking at GBMs, we observe that they seem to be related to naturalness and quality ratings. Less complex utterances, as measured by readability (re) and word length (cpw), have higher naturalness ratings. More complex utterances, as measured in terms of their length (len), number of words (wps), syllables (sps, spw) and polysyllables (pol, ppw), have lower quality evaluation. Utterances measured as more grammatical are on average evaluated higher in terms of naturalness.",
          "These initial results suggest a relation between automatic metrics and human ratings at system level. However, average scores can be misleading, as they do not identify worst-case scenarios. This leads us to inspect the correlation of human and automatic metrics for each MR-system output pair at utterance level."
        ]
      },
      {
        "section_name": "Human Correlation Analysis",
        "paragraphs": [
          "We calculate the correlation between automatic metrics and human ratings using the Spearman coefficient ( $\\rho $ ). We split the data per dataset and system in order to make valid pairwise comparisons. To handle outliers within human ratings, we use the median score of the three human raters. Following BIBREF8 , we use the Williams' test BIBREF32 to determine significant differences between correlations. Table 3 summarises the utterance-level correlation results between automatic metrics and human ratings, listing the best (i.e. highest absolute $\\rho $ ) results for each type of metric (details provided in supplementary material). Our results suggest that:",
          " $\\bullet $ In sum, no metric produces an even moderate correlation with human ratings, independently of dataset, system, or aspect of human rating. This contrasts with our initially promising results on the system level (see Section \"System Evaluation\" ) and will be further discussed in Section \"Error Analysis\" . Note that similar inconsistencies between document- and sentence-level evaluation results are observed in MT BIBREF33 .",
          " $\\bullet $ Similar to our results in Section \"System Evaluation\" , we find that WBMs show better correlations to human ratings of informativeness (which reflects content selection), whereas GBMs show better correlations to quality and naturalness.",
          " $\\bullet $ Human ratings for informativeness, naturalness and quality are highly correlated with each other, with the highest correlation between the latter two ( $\\rho =0.81$ ) reflecting that they both target surface realisation.",
          " $\\bullet $ All WBMs produce similar results (see Figure 1 and 2 ): They are strongly correlated with each other, and most of them produce correlations with human ratings which are not significantly different from each other. GBMs, on the other hand, show greater diversity.",
          " $\\bullet $ Correlation results are system- and dataset-specific (details provided in supplementary material). We observe the highest correlation for TGen on Bagel (Figures 1 and 2 ) and lols on SFRest, whereas rnnlg often shows low correlation between metrics and human ratings. This lets us conclude that WBMs and GBMs are sensitive to different systems and datasets.",
          " $\\bullet $ The highest positive correlation is observed between the number of words (wps) and informativeness for the TGen system on Bagel ( $\\rho =0.33$ , $p<0.01$ , see Figure 1 ). However, the wps metric (amongst most others) is not robust across systems and datasets: Its correlation on other datasets is very weak, ( $\\rho \\le .18$ ) and its correlation with informativeness ratings of lols outputs is insignificant.",
          " $\\bullet $ As a sanity check, we also measure a random score $[0.0,1.0]$ which proves to have a close-to-zero correlation with human ratings (highest $\\rho =0.09$ )."
        ]
      },
      {
        "section_name": "Accuracy of Relative Rankings",
        "paragraphs": [
          "We now evaluate a more coarse measure, namely the metrics' ability to predict relative human ratings. That is, we compute the score of each metric for two system output sentences corresponding to the same MR. The prediction of a metric is correct if it orders the sentences in the same way as median human ratings (note that ties are allowed). Following previous work BIBREF22 , BIBREF8 , we mainly concentrate on WBMs. Results summarised in Table 4 show that most metrics' performance is not significantly different from that of a random score (Wilcoxon signed rank test). While the random score fluctuates between 25.4\u201344.5% prediction accuracy, the metrics achieve an accuracy of between 30.6\u201349.8%. Again, the performance of the metrics is dataset-specific: Metrics perform best on Bagel data; for SFHotel, metrics show mixed performance while for SFRest, metrics perform worst.",
          "Discussion: Our data differs from the one used in previous work BIBREF22 , BIBREF8 , which uses explicit relative rankings (\u201cWhich output do you prefer?\"), whereas we compare two Likert-scale ratings. As such, we have 3 possible outcomes (allowing ties). This way, we can account for equally valid system outputs, which is one of the main drawbacks of forced-choice approaches BIBREF34 . Our results are akin to previous work: BIBREF8 report results between 60-74% accuracy for binary classification on machine-machine data, which is comparable to our results for 3-way classification.",
          "Still, we observe a mismatch between the ordinal human ratings and the continuous metrics. For example, humans might rate system A and system B both as a 6, whereas bleu, for example, might assign 0.98 and 1.0 respectively, meaning that bleu will declare system B as the winner. In order to account for this mismatch, we quantise our metric data to the same scale as the median scores from our human ratings. Applied to SFRest, where we previously got our worst results, we can see an improvement for predicting informativeness, where all WBMs now perform significantly better than the random baseline (see Table 4 ). In the future, we will investigate related discriminative approaches, e.g. BIBREF34 , BIBREF36 , where the task is simplified to distinguishing correct from incorrect output."
        ]
      },
      {
        "section_name": "Error Analysis",
        "paragraphs": [
          "In this section, we attempt to uncover why automatic metrics perform so poorly."
        ]
      },
      {
        "section_name": "Scales",
        "paragraphs": [
          "We first explore the hypothesis that metrics are good in distinguishing extreme cases, i.e. system outputs which are rated as clearly good or bad by the human judges, but do not perform well for utterances rated in the middle of the Likert scale, as suggested by BIBREF8 . We `bin' our data into three groups: bad, which comprises low ratings ( $\\le $ 2); good, comprising high ratings ( $\\ge $ 5); and finally a group comprising average ratings.",
          "We find that utterances with low human ratings of informativeness and naturalness correlate significantly better ( $p<0.05$ ) with automatic metrics than those with average and good human ratings. For example, as shown in Figure 3 , the correlation between WBMs and human ratings for utterances with low informativeness scores ranges between $0.3 \\le \\rho \\le 0.5$ (moderate correlation), while the highest correlation for utterances of average and high informativeness barely reaches $\\rho \\le 0.2$ (very weak correlation). The same pattern can be observed for correlations with quality and naturalness ratings. This discrepancy in correlation results between low and other user ratings, together with the fact that the majority of system outputs are rated \u201cgood\" for informativeness (79%), naturalness (64%) and quality (58%), whereas low ratings do not exceed 7% in total, could explain why the overall correlations are low (Section \"Relation of Human and Automatic Metrics\" ) despite the observed trends in relationship between average system-level performance scores (Section \"System Evaluation\" ). It also explains why the rnnlg system, which contains very few instances of low user ratings, shows poor correlation between human ratings and automatic metrics."
        ]
      },
      {
        "section_name": "Impact of Target Data",
        "paragraphs": [
          "Characteristics of Data: In Section \"Human Correlation Analysis\" , we observed that datasets have a significant impact on how well automatic metrics reflect human ratings. A closer inspection shows that Bagel data differs significantly from SFRest and SFHotel, both in terms of grammatical and MR properties. Bagel has significantly shorter references both in terms of number of characters and words compared to the other two datasets. Although being shorter, the words in Bagel references are significantly more often polysyllabic. Furthermore, Bagel only consists of utterances generated from inform MRs, while SFRest and SFHotel also have less complex MR types, such as confirm, goodbye, etc. Utterances produced from inform MRs are significantly longer and have a significantly higher correlation with human ratings of informativeness and naturalness than non-inform utterance types. In other words, Bagel is the most complex dataset to generate from. Even though it is more complex, metrics perform most reliably on Bagel here (note that the correlation is still only weak). One possible explanation is that Bagel only contains two human references per MR, whereas SFHotel and SFRest both contain 5.35 references per MR on average. Having more references means that WBMs naturally will return higher scores (`anything goes'). This problem could possibly be solved by weighting multiple references according to their quality, as suggested by BIBREF37 , or following a reference-less approach BIBREF33 .",
          "Quality of Data: Our corpora contain crowdsourced human references that have grammatical errors, e.g. \u201cFifth Floor does not allow childs\u201d (SFRest reference). Corpus-based methods may pick up these errors, and word-based metrics will rate these system utterances as correct, whereas we can expect human judges to be sensitive to ungrammatical utterances. Note that the parsing score (while being a crude approximation of grammaticality) achieves one of our highest correlation results against human ratings, with $|\\rho |=.31$ . Grammatical errors raise questions about the quality of the training data, especially when being crowdsourced. For example, BIBREF3 find that human experts assign low rankings to their original corpus text. Again, weighting BIBREF37 or reference-less approaches BIBREF33 might remedy this issue."
        ]
      },
      {
        "section_name": "Example-based Analysis",
        "paragraphs": [
          "As shown in previous sections, word-based metrics moderately agree with humans on bad quality output, but cannot distinguish output of good or medium quality. Table 5 provides examples from our three systems. Again, we observe different behaviour between WOMs and sim scores. In Example 1, lols generates a grammatically correct English sentence, which represents the meaning of the MR well, and, as a result, this utterance received high human ratings (median = 6) for informativeness, naturalness and quality. However, WOMs rate this utterance low, i.e. scores of bleu1-4, nist, lepor, cider, rouge and meteor normalised into the 1-6 range all stay below 1.5. This is because the system-generated utterance has low overlap with the human/corpus references. Note that the sim score is high (5), as it ignores human references and computes distributional semantic similarity between the MR and the system output. Examples 2 and 3 show outputs which receive low scores from both automatic metrics and humans. WOMs score these system outputs low due to little or no overlap with human references, whereas humans are sensitive to ungrammatical output and missing information (the former is partially captured by GBMs). Examples 2 and 3 also illustrate inconsistencies in human ratings since system output 2 is clearly worse than output 3 and both are rated by human with a median score of 1. Example 4 shows an output of the rnnlg system which is semantically very similar to the reference (sim=4) and rated high by humans, but WOMs fail to capture this similarity. GBMs show more accurate results for this utterance, with mean of readability scores 4 and parsing score 3.5."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Table 6 summarises results published by previous studies in related fields which investigate the relation between human scores and automatic metrics. These studies mainly considered WBMs, while we are the first study to consider GBMs. Some studies ask users to provide separate ratings for surface realisation (e.g. asking about `clarity' or `fluency'), whereas other studies focus only on sentence planning (e.g. `accuracy', `adequacy', or `correctness'). In general, correlations reported by previous work range from weak to strong. The results confirm that metrics can be reliable indicators at system-level BIBREF4 , while they perform less reliably at sentence-level BIBREF2 . Also, the results show that the metrics capture realization better than sentence planning. There is a general trend showing that best-performing metrics tend to be the more complex ones, combining word-overlap, semantic similarity and term frequency weighting. Note, however, that the majority of previous works do not report whether any of the metric correlations are significantly different from each other."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "This paper shows that state-of-the-art automatic evaluation metrics for NLG systems do not sufficiently reflect human ratings, which stresses the need for human evaluations. This result is opposed to the current trend of relying on automatic evaluation identified in BIBREF1 .",
          "A detailed error analysis suggests that automatic metrics are particularly weak in distinguishing outputs of medium and good quality, which can be partially attributed to the fact that human judgements and metrics are given on different scales. We also show that metric performance is data- and system-specific.",
          "Nevertheless, our results also suggest that automatic metrics can be useful for error analysis by helping to find cases where the system is performing poorly. In addition, we find reliable results on system-level, which suggests that metrics can be useful for system development."
        ]
      },
      {
        "section_name": "Future Directions",
        "paragraphs": [
          "Word-based metrics make two strong assumptions: They treat human-generated references as a gold standard, which is correct and complete. We argue that these assumptions are invalid for corpus-based NLG, especially when using crowdsourced datasets. Grammar-based metrics, on the other hand, do not rely on human-generated references and are not influenced by their quality. However, these metrics can be easily manipulated with grammatically correct and easily readable output that is unrelated to the input. We have experimented with combining WBMs and GBMs using ensemble-based learning. However, while our model achieved high correlation with humans within a single domain, its cross-domain performance is insufficient.",
          "Our paper clearly demonstrates the need for more advanced metrics, as used in related fields, including: assessing output quality within the dialogue context, e.g. BIBREF40 ; extrinsic evaluation metrics, such as NLG's contribution to task success, e.g. BIBREF41 , BIBREF42 , BIBREF43 ; building discriminative models, e.g. BIBREF34 , BIBREF36 ; or reference-less quality prediction as used in MT, e.g. BIBREF33 . We see our paper as a first step towards reference-less evaluation for NLG by introducing grammar-based metrics. In current work BIBREF44 , we investigate a reference-less quality estimation approach based on recurrent neural networks, which predicts a quality score for a NLG system output by comparing it to the source meaning representation only.",
          "Finally, note that the datasets considered in this study are fairly small (between 404 and 2.3k human references per domain). To remedy this, systems train on de-lexicalised versions BIBREF10 , which bears the danger of ungrammatical lexicalisation BIBREF13 and a possible overlap between testing and training set BIBREF15 . There are ongoing efforts to release larger and more diverse data sets, e.g. BIBREF16 , BIBREF45 ."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "This research received funding from the EPSRC projects DILiGENt (EP/M005429/1) and MaDrIgAL (EP/N017536/1). The Titan Xp used for this research was donated by the NVIDIA Corporation."
        ]
      },
      {
        "section_name": "Appendix A: Detailed Results",
        "paragraphs": [
          "[thp] max width=1",
          " Spearman correlation between metrics and human ratings for individual datasets and systems. \u201c*\u201d denotes statistically significant correlation ( $p<0.05$ ), bold font denotes significantly stronger correlation when comparing two systems on the same dataset.",
          "[htp] max width=1",
          "Accuracy of metrics predicting relative human ratings, with \u201c*\u201d denoting statistical significance ( $p<0.05$ )."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which metrics were considered?",
        "question_id": "97708d93bccc832ea671dc31a76dad6a121fcd60",
        "nlp_background": "infinity",
        "topic_background": "research",
        "paper_read": "no",
        "search_query": "NLG",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "ter",
                "bleu ",
                "rouge ",
                "nist",
                "lepor",
                "cider",
                "meteor",
                "Semantic Text Similarity",
                " Flesch Reading Ease ",
                "characters per utterance (len) and per word (cpw)",
                "words per sentence",
                "syllables per sentence (sps) and per word (spw)",
                "polysyllabic words per utterance (pol) and per word (ppw)",
                "the number of misspellings (msp) and the parsing score as returned by the Stanford parser (prs)"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "$\\bullet $ Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "$\\bullet $ Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet.",
                "$\\bullet $ Readability quantifies the difficulty with which a reader understands a text, as used for e.g. evaluating summarisation BIBREF27 or text simplification BIBREF28 . We measure readability by the Flesch Reading Ease score (re) BIBREF29 , which calculates a ratio between the number of characters per sentence, the number of words per sentence, and the number of syllables per word. Higher re score indicates a less complex utterance that is easier to read and understand. We also consider related measures, such as characters per utterance (len) and per word (cpw), words per sentence (wps), syllables per sentence (sps) and per word (spw), as well as polysyllabic words per utterance (pol) and per word (ppw). The higher these scores, the more complex the utterance.",
                "$\\bullet $ Grammaticality: In contrast to previous NLG methods, our corpus-based end-to-end systems can produce ungrammatical output by (a) generating word-by-word, and (b) learning from noisy data. As a first approximation of grammaticality, we measure the number of misspellings (msp) and the parsing score as returned by the Stanford parser (prs). The lower the msp, the more grammatically correct an utterance is. The Stanford parser score is not designed to measure grammaticality, however, it will generally prefer a grammatical parse to a non-grammatical one. Thus, lower parser scores indicate less grammatically-correct utterances. In future work, we aim to use specifically designed grammar-scoring functions, e.g. BIBREF26 , once they become publicly available."
              ],
              "highlighted_evidence": [
                "We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet.",
                "We measure readability by the Flesch Reading Ease score (re) BIBREF29 , which calculates a ratio between the number of characters per sentence, the number of words per sentence, and the number of syllables per word.",
                "We also consider related measures, such as characters per utterance (len) and per word (cpw), words per sentence (wps), syllables per sentence (sps) and per word (spw), as well as polysyllabic words per utterance (pol) and per word (ppw).",
                "As a first approximation of grammaticality, we measure the number of misspellings (msp) and the parsing score as returned by the Stanford parser (prs)."
              ]
            },
            "annotation_id": "22151549daa1d4bd10f804e006ebd446ab8692b3",
            "worker_id": "486a870694ba60f1a1e7e4ec13e328164cd4b43c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "ter",
                "bleu",
                "rouge",
                "nist",
                "lepor",
                "cider",
                "meteor",
                "Semantic Similarity (sim)",
                "readability and grammaticality"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "$\\bullet $ Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "$\\bullet $ Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet.",
                "Grammar-based measures have been explored in related fields, such as MT BIBREF25 or grammatical error correction BIBREF26 , and, in contrast to WBMs, do not rely on ground-truth references. To our knowledge, we are the first to consider GBMs for sentence-level NLG evaluation. We focus on two important properties of texts here \u2013 readability and grammaticality:"
              ],
              "highlighted_evidence": [
                "$\\bullet $ Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "$\\bullet $ Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 .",
                "Grammar-based measures have been explored in related fields, such as MT BIBREF25 or grammatical error correction BIBREF26 , and, in contrast to WBMs, do not rely on ground-truth references. To our knowledge, we are the first to consider GBMs for sentence-level NLG evaluation. We focus on two important properties of texts here \u2013 readability and grammaticality:"
              ]
            },
            "annotation_id": "832fbf8fcc86e7ac5b58da0237530c1dab2b7a59",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23",
                "Semantic Similarity (sim)",
                "readability and grammaticality"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "$\\bullet $ Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "$\\bullet $ Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet.",
                "Grammar-based measures have been explored in related fields, such as MT BIBREF25 or grammatical error correction BIBREF26 , and, in contrast to WBMs, do not rely on ground-truth references. To our knowledge, we are the first to consider GBMs for sentence-level NLG evaluation. We focus on two important properties of texts here \u2013 readability and grammaticality:"
              ],
              "highlighted_evidence": [
                "Word-overlap Metrics (WOMs): We consider frequently used metrics, including ter BIBREF18 , bleu BIBREF0 , rouge BIBREF19 , nist BIBREF20 , lepor BIBREF21 , cider BIBREF22 , and meteor BIBREF23 .",
                "Semantic Similarity (sim): We calculate the Semantic Text Similarity measure designed by BIBREF24 . This measure is based on distributional similarity and Latent Semantic Analysis (LSA) and is further complemented with semantic relations extracted from WordNet.",
                "Grammar-based measures have been explored in related fields, such as MT BIBREF25 or grammatical error correction BIBREF26 , and, in contrast to WBMs, do not rely on ground-truth references. To our knowledge, we are the first to consider GBMs for sentence-level NLG evaluation. We focus on two important properties of texts here \u2013 readability and grammaticality:"
              ]
            },
            "annotation_id": "be89ffc0e120f77895c77f05e077140becdb5347",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Number of NLG system outputs from different datasets and systems used in this study."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: System performance per dataset (summarised over metrics), where \u201c*\u201d denotes p < 0.05 for all the metrics and \u201c(*)\u201d shows significance on p < 0.05 level for the majority of the metrics."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Highest absolute Spearman correlation between metrics and human ratings, with \u201c*\u201d denoting p < 0.05 (metric with the highest absolute value of \u03c1 given in brackets)."
      },
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Spearman correlation results for TGEN on BAGEL. Bordered area shows correlations between human ratings and automatic metrics, the rest shows correlations among the metrics. Blue colour of circles indicates positive correlation, while red indicates negative correlation. The size of circles denotes the correlation strength."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Williams test results: X represents a non-significant difference between correlations (p < 0.05; top: WBMs, bottom: GBMs)."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Metrics predicting relative human rating with significantly higher accuracy than a random baseline."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: Example pairs of MRs and system outputs from our data, contrasting the average of wordoverlap metrics (normalised in the 1-6 range) and semantic similarity (SIM) with human ratings (median of all measures)."
      },
      {
        "file": "7-Figure3-1.png",
        "caption": "Figure 3: Correlation between automatic metrics (WBMs) and human ratings for utterances of bad informativeness (top), and average and good informativeness (bottom)."
      },
      {
        "file": "8-Table6-1.png",
        "caption": "Table 6: Best correlation results achieved by our and previous work. Dimensions targeted towards Sentence Planning include \u2018accuracy\u2019, \u2018adequacy\u2019, \u2018correctness\u2019, \u2018informativeness\u2019. Dimensions for Surface Realisation include \u2018clarity\u2019, \u2018fluency\u2019, \u2018naturalness\u2019."
      }
    ]
  },
  "1708.07690": {
    "title": "Revisiting the Centroid-based Method: A Strong Baseline for Multi-Document Summarization",
    "abstract": "The centroid-based model for extractive document summarization is a simple and fast baseline that ranks sentences based on their similarity to a centroid vector. In this paper, we apply this ranking to possible summaries instead of sentences and use a simple greedy algorithm to find the best summary. Furthermore, we show possi- bilities to scale up to larger input docu- ment collections by selecting a small num- ber of sentences from each document prior to constructing the summary. Experiments were done on the DUC2004 dataset for multi-document summarization. We ob- serve a higher performance over the orig- inal model, on par with more complex state-of-the-art methods.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Extractive multi-document summarization (MDS) aims to summarize a collection of documents by selecting a small number of sentences that represent the original content appropriately. Typical objectives for assembling a summary include information coverage and non-redundancy. A wide variety of methods have been introduced to approach MDS.",
          "Many approaches are based on sentence ranking, i.e. assigning each sentence a score that indicates how well the sentence summarizes the input BIBREF0 , BIBREF1 , BIBREF2 . A summary is created by selecting the top entries of the ranked list of sentences. Since the sentences are often treated separately, these models might allow redundancy in the summary. Therefore, they are often extended by an anti-redundancy filter while de-queuing ranked sentence lists.",
          "Other approaches work at summary-level rather than sentence-level and aim to optimize functions of sets of sentences to find good summaries, such as KL-divergence between probability distributions BIBREF3 or submodular functions that represent coverage, diversity, etc. BIBREF4 ",
          "The centroid-based model belongs to the former group: it represents sentences as bag-of-word (BOW) vectors with TF-IDF weighting and uses a centroid of these vectors to represent the whole document collection BIBREF5 . The sentences are ranked by their cosine similarity to the centroid vector. This method is often found as a baseline in evaluations where it usually is outperformed BIBREF0 , BIBREF6 .",
          "This baseline can easily be adapted to work at the summary-level instead the sentence level. This is done by representing a summary as the centroid of its sentence vectors and maximizing the similarity between the summary centroid and the centroid of the document collection. A simple greedy algorithm is used to find the best summary under a length constraint.",
          "In order to keep the method efficient, we outline different methods to select a small number of candidate sentences from each document in the input collection before constructing the summary.",
          "We test these modifications on the DUC2004 dataset for multi-document summarization. The results show an improvement of Rouge scores over the original centroid method. The performance is on par with state-of-the-art methods which shows that the similarity between a summary centroid and the input centroid is a well-suited function for global summary optimization.",
          "The summarization approach presented in this paper is fast, unsupervised and simple to implement. Nevertheless, it performs as well as more complex state-of-the-art approaches in terms of Rouge scores on the DUC2004 dataset. It can be used as a strong baseline for future research or as a fast and easy-to-deploy summarization tool."
        ]
      },
      {
        "section_name": "Original Centroid-based Method",
        "paragraphs": [
          "The original centroid-based model is described by BIBREF5 . It represents sentences as BOW vectors with TF-IDF weighting. The centroid vector is the sum of all sentence vectors and each sentence is scored by the cosine similarity between its vector representation and the centroid vector. Cosine similarity measures how close two vectors INLINEFORM0 and INLINEFORM1 are based on their angle and is defined as follows: DISPLAYFORM0 ",
          "A summary is selected by de-queuing the ranked list of sentences in decreasing order until the desired summary length is reached.",
          " BIBREF7 implement this original model with the following modifications:",
          "In order to avoid redundant sentences in the summary, a new sentence is only included if it does not exceed a certain maximum similarity to any of the already included sentences.",
          "To focus on only the most important terms of the input documents, the values in the centroid vector which fall below a tuned threshold are set to zero.",
          "This model, which includes the anti-redundancy filter and the selection of top-ranking features, is treated as the \"original\" centroid-based model in this paper.",
          "We implement the selection of top-ranking features for both the original and modified models slightly differently to BIBREF7 : all words in the vocabulary are ranked by their value in the centroid vector. On a development dataset, a parameter is tuned that defines the proportion of the ranked vocabulary that is represented in the centroid vector and the rest is set to zero. This variant resulted in more stable behavior for different amounts of input documents."
        ]
      },
      {
        "section_name": "Modified Summary Selection",
        "paragraphs": [
          "The similarity to the centroid vector can also be used to score a summary instead of a sentence. By representing a summary as the sum of its sentence vectors, it can be compared to the centroid, which is different from adding centroid-similarity scores of individual sentences.",
          "With this modification, the summarization task is explicitly modelled as finding a combination of sentences that summarize the input well together instead of finding sentences that summarize the input well independently. This strategy should also be less dependent on anti-redundancy filtering since a combination of redundant sentences is probably less similar to the centroid than a more diverse selection that covers different prevalent topics.",
          "In the experiments, we will therefore call this modification the \"global\" variant of the centroid model. The same principle is used by the KLSum model BIBREF3 in which the optimal summary minimizes the KL-divergence of the probability distribution of words in the input from the distribution in the summary. KLSum uses a greedy algorithm to find the best summary. Starting with an empty summary, the algorithm includes at each iteration the sentence that maximizes the similarity to the centroid when added to the already selected sentences. We also use this algorithm for sentence selection. The procedure is depicted in Algorithm SECREF5 below. [H] [1] Input: INLINEFORM0 Output: INLINEFORM1 INLINEFORM2 INLINEFORM3 INLINEFORM4 INLINEFORM5 INLINEFORM6 INLINEFORM7 INLINEFORM8 Greedy Sentence Selection"
        ]
      },
      {
        "section_name": "Preselection of Sentences",
        "paragraphs": [
          "The modified sentence selection method is less efficient than the orginal method since at each iteration the score of a possible summary has to be computed for all remaining candidate sentences. It may not be noticeable for a small number of input sentences. However, it would have an impact if the amount of input documents was larger, e.g. for the summarization of top-100 search results in document retrieval.",
          "Therefore, we explore different methods for reducing the number of input sentences before applying the greedy sentence selection algorithm to make the model more suited for larger inputs. It is also important to examine how this affects Rouge scores.",
          "We test the following methods of selecting INLINEFORM0 sentences from each document as candidates for the greedy sentence selection algorithm:",
          "The first INLINEFORM0 sentences of the document are selected. This results in a mixture of a lead- INLINEFORM1 baseline and the centroid-based method.",
          "The sentences are ranked separately in each document by their cosine similarity to the centroid vector, in decreasing order. The INLINEFORM0 best sentences of each document are selected as candidates.",
          "Each sentence is scored by the sum of the TF-IDF scores of the terms that are mentioned in that sentence for the first time in the document. The intuition is that sentences are preferred if they introduce new important information to a document.",
          "Note that in each of these candidate selection methods, the centroid vector is always computed as the sum of all sentence vectors, including the ones of the ignored sentences."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "For testing, we use the DUC2004 Task 2 dataset from the Document Understanding Conference (DUC). The dataset consists of 50 document clusters containing 10 documents each. For tuning hyperparameters, we use the CNN/Daily Mail dataset BIBREF8 which provides summary bulletpoints for individual news articles. In order to adapt the dataset for MDS, 50 CNN articles were randomly selected as documents to initialize 50 clusters. For each of these seed articles, 9 articles with the highest word-overlap in the first 3 sentences were added to that cluster. This resulted in 50 documents clusters, each containing 10 topically related articles. The reference summaries for each cluster were created by interleaving the sentences of the article summaries until a length contraint (100 words) was reached."
        ]
      },
      {
        "section_name": "Baselines & Evaluation",
        "paragraphs": [
          " BIBREF6 published SumRepo, a repository of summaries for the DUC2004 dataset generated by several baseline and state-of-the-art methods . We evaluate summaries generated by a selection of these methods on the same data that we use for testing. We calculate Rouge scores with the Rouge toolkit BIBREF9 . In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. The baselines include a basic centroid-based model without an anti-redundancy filter and feature reduction."
        ]
      },
      {
        "section_name": "Preprocessing",
        "paragraphs": [
          "In the summarization methods proposed in this paper, the preprocessing includes sentence segmentation, lowercasing and stopword removal."
        ]
      },
      {
        "section_name": "Parameter Tuning",
        "paragraphs": [
          "The similarity threshold for avoiding redundancy ( INLINEFORM0 ) and the vocabulary-included-in-centroid ratio ( INLINEFORM1 ) are tuned with the original centroid model on our development set. Values from 0 to 1 with step size INLINEFORM2 were tested using a grid search. The optimal values for INLINEFORM3 and INLINEFORM4 were INLINEFORM5 and INLINEFORM6 , respectively. These values were used for all tested variants of the centroid model. For the different methods of choosing INLINEFORM7 sentences of each document before summarization, we tuned INLINEFORM8 separately for each, with values from 1 to 10, using the global model. The best INLINEFORM9 found for INLINEFORM10 -first, INLINEFORM11 -best, new-tfidf were 7, 2 and 3 respectively."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Table TABREF9 shows the Rouge scores measured in our experiments.",
          "The first two sections show results for baseline and SOTA summaries from SumRepo. The third section shows the summarization variants presented in this paper. \"G\" indicates that the global greedy algorithm was used instead of sentence-level ranking. In the last section, \"- R\" indicates that the method was tested without the anti-redundancy filter.",
          "Both the global optimization and the sentence preselection have a positive impact on the performance.",
          "The global + new-TF-IDF variant outperforms all but the DPP model in Rouge-1 recall. The global + N-first variant outperforms all other models in Rouge-2 recall. However, the Rouge scores of the SOTA methods and the introduced centroid variants are in a very similar range.",
          "Interestingly, the original centroid-based model, without any of the new modifications introduced in this paper, already shows quite high Rouge scores in comparison to the other baseline methods. This is due to the anti-redundancy filter and the selection of top-ranking features.",
          "In order to see whether the global sentence selection alleviates the need for an anti-redundancy filter, the original method and the global method (without INLINEFORM0 sentences per document selection) were tested without it (section 4 in Table TABREF9 ). In terms of Rouge-1 recall, the original model is clearly very dependent on checking for redundancy when including sentences, while the global variant does not change its performance much without the anti-redundancy filter. This matches the expectation that the globally motivated method handles redundancy implicitly."
        ]
      },
      {
        "section_name": "Example Summaries",
        "paragraphs": [
          "Table TABREF10 shows generated example summaries using the global centroid method with the three sentence preselection methods. For readability, truncated sentences (due to the 100-word limit) at the end of the summaries are excluded. The original positions of the summary sentences, i.e. the indices of the document and the sentence inside the document are given. As can be seen in the examples, the N-first method is restricted to sentences appearing early in documents. In the new-TF-IDF example, the second and third sentences were preselected because high ranking features such as \"robot\" and \"arm\" appeared for the first time in the respective documents."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "In addition to various works on sophisticated models for multi-document summarization, other experiments have been done showing that simple modifications to the standard baseline methods can perform quite well.",
          " BIBREF7 improved the centroid-based method by representing sentences as sums of word embeddings instead of TF-IDF vectors so that semantic relationships between sentences that have no words in common can be captured. BIBREF10 also evaluated summaries from SumRepo and did experiments on improving baseline systems such as the centroid-based and the KL-divergence method with different anti-redundancy filters. Their best optimized baseline obtained a performance similar to the ICSI method in SumRepo."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper we show that simple modifications to the centroid-based method can bring its performance to the same level as state-of-the-art methods on the DUC2004 dataset. The resulting summarization methods are unsupervised, efficient and do not require complicated feature engineering or training.",
          "Changing from a ranking-based method to a global optimization method increases performance and makes the summarizer less dependent on explicitly checking for redundancy. This can be useful for input document collections with differing levels of content diversity.",
          "The presented methods for restricting the input to a maximum of INLINEFORM0 sentences per document lead to additional improvements while reducing computation effort, if global optimization is being used. These methods could be useful for other summarization models that rely on pairwise similarity computations between all input sentences, or other properties which would slow down summarization of large numbers of input sentences.",
          "The modified methods can also be used as strong baselines for future experiments in multi-document summarization. "
        ]
      }
    ],
    "qas": [
      {
        "question": "what are the performance metrics?",
        "question_id": "7ba6330d105f49c7f71dba148bb73245a8ef2966",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Rouge-1, Rouge-2 and Rouge-4 recall"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "BIBREF6 published SumRepo, a repository of summaries for the DUC2004 dataset generated by several baseline and state-of-the-art methods . We evaluate summaries generated by a selection of these methods on the same data that we use for testing. We calculate Rouge scores with the Rouge toolkit BIBREF9 . In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. The baselines include a basic centroid-based model without an anti-redundancy filter and feature reduction."
              ],
              "highlighted_evidence": [
                "In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. "
              ]
            },
            "annotation_id": "47765cb313b5bfcf4fe1cee440d0305c4d701847",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Rouge-1 recall, Rouge-2 recall, Rouge-4 recall",
              "evidence": [
                "BIBREF6 published SumRepo, a repository of summaries for the DUC2004 dataset generated by several baseline and state-of-the-art methods . We evaluate summaries generated by a selection of these methods on the same data that we use for testing. We calculate Rouge scores with the Rouge toolkit BIBREF9 . In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. The baselines include a basic centroid-based model without an anti-redundancy filter and feature reduction."
              ],
              "highlighted_evidence": [
                "In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. "
              ]
            },
            "annotation_id": "a99a9939517ac297d24c18c09df657f5a9b74346",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Rouge-1, Rouge-2 and Rouge-4 recall"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "BIBREF6 published SumRepo, a repository of summaries for the DUC2004 dataset generated by several baseline and state-of-the-art methods . We evaluate summaries generated by a selection of these methods on the same data that we use for testing. We calculate Rouge scores with the Rouge toolkit BIBREF9 . In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. The baselines include a basic centroid-based model without an anti-redundancy filter and feature reduction."
              ],
              "highlighted_evidence": [
                " In order to compare our results to BIBREF6 we use the same Rouge settings as they do and report results for Rouge-1, Rouge-2 and Rouge-4 recall. "
              ]
            },
            "annotation_id": "ba5ee4c6c8b02d0adb4fa08f2a26dc8e93101320",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Rouge scores on DUC2004."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Summaries of the cluster d30031 in DUC2004 generated by the modified centroid method using different sentence preselection methods."
      }
    ]
  },
  "1804.05253": {
    "title": "\"With 1 follower I must be AWESOME :P\". Exploring the role of irony markers in irony recognition",
    "abstract": "Conversations in social media often contain the use of irony or sarcasm, when the users say the opposite of what they really mean. Irony markers are the meta-communicative clues that inform the reader that an utterance is ironic. We propose a thorough analysis of theoretically grounded irony markers in two social media platforms: $Twitter$ and $Reddit$. Classification and frequency analysis show that for $Twitter$, typographic markers such as emoticons and emojis are the most discriminative markers to recognize ironic utterances, while for $Reddit$ the morphological markers (e.g., interjections, tag questions) are the most discriminative.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "With the advent of social media, irony and sarcasm detection has become an active area of research in Natural Language Processing (NLP) BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 . Most computational studies have focused on building state-of-the-art models to detect whether an utterance or comment is ironic/sarcastic or not, sometimes without theoretical grounding. In linguistics and discourse studies, BIBREF4 (2000) and later BIBREF5 (2010) have studied two theoretical aspects of irony in the text: irony factors' and irony markers. Irony factors are characteristics of ironic utterances that cannot be removed without destroying the irony. In contrast, irony markers are a meta-communicative clue that \u201calert the reader to the fact that a sentence is ironical\u201d BIBREF4 . They can be removed and the utterance is still ironic.",
          "In this paper, we examine the role of irony markers in social media for irony recognition. Although punctuations, capitalization, and hyperboles are previously used as features in irony detection BIBREF6 , BIBREF7 , here we thoroughly analyze a set of theoretically-grounded types of irony markers, such as tropes (e.g., metaphors), morpho-syntactic indicators (e.g., tag questions), and typographic markers (e.g., emoji) and their use in ironic utterances. Consider the following two irony examples from INLINEFORM0 and INLINEFORM1 given in Table TABREF2 .",
          "Both utterances are labeled as ironic by their authors (using hashtags in INLINEFORM0 and the /s marker in INLINEFORM1 ). In the INLINEFORM2 example, the author uses several irony markers such as Rhetorical question (e.g., \u201care you telling\u201d ...) and metaphor (e.g., \u201cgolden age\u201d). In the INLINEFORM3 example, we notice the use of capitalization (\u201cAWESOME\u201d) and emoticons (\u201c:P\u201d (tongue out)) that the author uses to alert the readers that it is an ironic tweet.",
          "We present three contributions in this paper. First, we provide a detailed investigation of a set of theoretically-grounded irony markers (e.g., tropes, morpho-syntactic, and typographic markers) in social media. We conduct the classification and frequency analysis based on their occurrence. Second, we analyze and compare the use of irony markers on two social media platforms ( INLINEFORM0 and INLINEFORM1 ). Third, we provide an analysis of markers on topically different social media content (e.g., technology vs. political subreddits)."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "Twitter: We use a set of 350K tweets for our experiments. The ironic/sarcastic tweets are collected using hashtags, such as #irony, #sarcasm, and #sarcastic whereas the non-sarcastic tweets do not contain these hashtags, but they might include sentiment hashtags, such as #happy, #love, #sad, #hate (similar to BIBREF8 , BIBREF9 ). As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English. Also, we deleted all tweets where the hashtags of interest were not located at the very end (i.e., we eliminated \u201c#sarcasm is something that I love\u201d). We lowercased the tweets, except the words where all the characters are uppercased.",
          "Reddit: BIBREF10 (2018) introduced an extensive collection of sarcastic and non-sarcastic posts collected from different subreddits. In Reddit, authors mark their sarcastic intent of their posts by adding \u201c/s\u201d at the end of a post/comment. We collected 50K instances from the corpus for our experiments (denoted as INLINEFORM0 ), where the sarcastic and non-sarcastic replies are at least two sentences (i.e., we discard posts that are too short). For brevity, we denote ironic utterances as INLINEFORM1 and non-ironic utterances as INLINEFORM2 . Both INLINEFORM3 and INLINEFORM4 datasets are balanced between the INLINEFORM5 and INLINEFORM6 classes. We uuse 80% of the datasets for training, 10% for development, and the remaining 10% for testing."
        ]
      },
      {
        "section_name": "Irony Markers",
        "paragraphs": [
          "Three types of markers \u2014 tropes, morpho-syntactic, and typographic are used as features."
        ]
      },
      {
        "section_name": "Tropes:",
        "paragraphs": [
          "Tropes are figurative use of expressions.",
          "Metaphors - Metaphors often facilitate ironic representation and are used as markers. We have drawn metaphors from different sources (e.g., 884 and 8,600 adjective/noun metaphors from BIBREF11 and BIBREF12 , respectively, and used them as binary features. We also evaluate the metaphor detector BIBREF13 over INLINEFORM0 and INLINEFORM1 datasets. We considered metaphor candidates that have precision INLINEFORM2 0.75 (see BIBREF13 (2017)).",
          "Hyperbole - Hyperboles or intensifiers are commonly used in irony because speakers frequently overstate the magnitude of a situation or event. We use terms that are denoted as \u201cstrong subjective\u201d (positive/negative) from the MPQA corpus BIBREF14 as hyperboles. Apart from using hyperboles directly as the binary feature we also use their sentiment as features.",
          "Rhetorical Questions - Rhetorical Questions (for brevity INLINEFORM0 ) have the structure of a question but are not typical information seeking questions. We follow the hypothesis introduced by BIBREF15 (2017) that questions that are in the middle of a comment are more likely to be RQ since since questions followed by text cannot be typical information seeking questions. Presence of INLINEFORM1 is used as a binary feature."
        ]
      },
      {
        "section_name": "Morpho-syntactic (MS) irony markers:",
        "paragraphs": [
          "This type of markers appear at the morphologic and syntactic levels of an utterance.",
          "Exclamation - Exclamation marks emphasize a sense of surprise on the literal evaluation that is reversed in the ironic reading BIBREF5 . We use two binary features, single or multiple uses of the marker.",
          "Tag questions - We built a list of tag questions (e.g.,, \u201cdidn't you?\u201d, \u201caren't we?\u201d) from a grammar site and use them as binary indicators.",
          "Interjections - Interjections seem to undermine a literal evaluation and occur frequently in ironic utterances (e.g., \u201c`yeah\", `wow\u201d, \u201cyay\u201d,\u201couch\u201d etc.). Similar to tag questions we assembled interjections (a total of 250) from different grammar sites."
        ]
      },
      {
        "section_name": "Typographic irony markers:",
        "paragraphs": [
          "Capitalization - Users often capitalize words to represent their ironic use (e.g., the use of \u201cGREAT\", \u201cSO\u201d, and \u201cWONDERFUL\u201d in the ironic tweet \u201cGREAT i'm SO happy shattered phone on this WONDERFUL day!!!\u201d).",
          "Quotation mark - Users regularly put quotation marks to stress the ironic meaning (e.g., \u201cgreat\u201d instead of GREAT in the above example).",
          "Other punctuation marks - Punctuation marks such as \u201c?\u201d, \u201c.\u201d, \u201c;\u201d and their various uses (e.g., single/multiple/mix of two different punctuations) are used as features.",
          "Hashtag - Particularly in INLINEFORM0 , hashtags often represent the sentiment of the author. For example, in the ironic tweet \u201cnice to wake up to cute text. #suck\u201d, the hashtag \u201c#suck\u201d depicts the negative sentiment. We use binary sentiment feature (positive or negative) to identify the sentiment of the hashtag, while comparing against the MPQA sentiment lexicon. Often multiple words are combined in a hashtag without spacing (e.g., \u201cfun\u201d and \u201cnight\u201d in #funnight). We use an off-the-shelf tool to split words in such hashtags and then checked the sentiment of the words.",
          "Emoticon - Emoticons are frequently used to emphasize the ironic intent of the user. In the example \u201cI love the weather ;) #irony\u201d, the emoticon \u201c;)\u201d (wink) alerts the reader to a possible ironic interpretation of weather (i.e., bad weather). We collected a comprehensive list of emoticons (over one-hundred) from Wikipedia and also used standard regular expressions to identify emoticons in our datasets. Beside using the emoticons directly as binary features, we use their sentiment as features as well (e.g., \u201cwink\u201d is regarded as positive sentiment in MPQA).",
          "Emoji - Emojis are like emoticons, but they are actual pictures and recently have become very popular in social media. Figure FIGREF22 shows a tweet with two emojis (e.g., \u201cunassumed\u201d and \u201cconfounded\u201d faces respectively) used as markers. We use an emoji library of 1,400 emojis to identify the particular emoji used in irony utterances and use them as binary indicators."
        ]
      },
      {
        "section_name": "Classification Experiments and Results",
        "paragraphs": [
          "We first conduct a binary classification task to decide whether an utterance (e.g., a tweet or a INLINEFORM0 post) is ironic or non-ironic, exclusively based on the irony marker features. We use Support Vector Machines (SVM) classifier with linear kernel BIBREF16 . Table TABREF23 and Table TABREF24 present the results of the ablation tests for INLINEFORM1 and INLINEFORM2 . We report Precision ( INLINEFORM3 ), Recall ( INLINEFORM4 ) and INLINEFORM5 scores of both INLINEFORM6 and INLINEFORM7 categories.",
          "Table TABREF23 shows that for ironic utterances in INLINEFORM0 , removing tropes have the maximum negative effect on Recall, with a reduction on INLINEFORM1 score by 15%. This is primarily due to the removal of hyperboles that frequently appear in ironic utterances in INLINEFORM2 . Removing typographic markers (e.g., emojis, emoticons, etc.) have the maximum negative effect on the Precision for the irony INLINEFORM3 category, since particular emojis and emoticons appear regularly in ironic utterances (Table TABREF25 ). For INLINEFORM4 , Table TABREF24 shows that removal of typographic markers such as emoticons does not affect the F1 scores, whereas the removal of morpho-syntactic markers, e.g., tag questions, interjections have a negative effect on the F1. Table TABREF25 and Table TABREF26 represent the INLINEFORM5 most discriminative features for both categories based on the feature weights learned during the SVM training for INLINEFORM6 and INLINEFORM7 , respectively. Table TABREF25 shows that for INLINEFORM8 , typographic features such as emojis and emoticons have the highest feature weights for both categories. Interestingly, we observe that for ironic tweets users often express negative sentiment directly via emojis (e.g., angry face, rage) whereas for non-ironic utterances, emojis with positive sentiments (e.g., hearts, wedding) are more familiar. For INLINEFORM9 (Table TABREF26 ), we observe that instead of emojis, other markers such as exclamation marks, negative tag questions, and metaphors are discriminatory markers for the irony category. In contrary, for the non-irony category, positive tag questions and negative sentiment hyperboles are influential features."
        ]
      },
      {
        "section_name": "Frequency analysis of markers",
        "paragraphs": [
          "We also investigate the occurrence of markers in the two platforms via frequency analysis (Table TABREF29 ). We report the mean of occurrence per utterance and the standard deviation (SD) of each marker. Table TABREF29 shows that markers such as hyperbole, punctuations, and interjections are popular in both platforms. Emojis and emoticons, although the two most popular markers in INLINEFORM0 are almost unused in INLINEFORM1 . Exclamations and INLINEFORM2 s are more common in the INLINEFORM3 corpus. Next, we combine each marker with the type they belong to (i.e., either trope, morpho-syntactic and typographic) and compare the means between each pair of types via independent t-tests. We found that the difference of means is significant ( INLINEFORM4 ) for all pair of types across the two platforms."
        ]
      },
      {
        "section_name": "Irony markers across topical subreddits",
        "paragraphs": [
          "Finally, we collected another set of irony posts from BIBREF10 , but this time we collected posts from specific topical subreddits. We collected irony posts about politics (e.g., subreddits: politics, hillary, the_donald), sports (e.g., subreddits: nba, football, soccer), religion (e.g., subreddits: religion) and technology (e.g., subreddits: technology). Table TABREF27 presents the mean and SD for each genre. We observe that users use tropes such as hyperbole and INLINEFORM0 , morpho-syntactic markers such as exclamation and interjections and multiple-punctuations more in politics and religion than in technology and sports. This is expected since subreddits regarding politics and religion are often more controversial than technology and sports and the users might want to stress that they are ironic or sarcastic using the markers."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We provided a thorough investigation of irony markers across two social media platforms: Twitter and Reddit. Classification experiments and frequency analysis suggest that typographic markers such as emojis and emoticons are most frequent for INLINEFORM0 whereas tag questions, exclamation, metaphors are frequent for INLINEFORM1 . We also provide an analysis across different topical subreddits. In future, we are planning to experiment with other markers (e.g., ironic echo, repetition, understatements)."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they evaluate only on English datasets?",
        "question_id": "000549a217ea24432c0656598279dbb85378c113",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "irony",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "The twitter dataset is English-only; no information for the reddit dataset is given",
              "evidence": [
                "Twitter: We use a set of 350K tweets for our experiments. The ironic/sarcastic tweets are collected using hashtags, such as #irony, #sarcasm, and #sarcastic whereas the non-sarcastic tweets do not contain these hashtags, but they might include sentiment hashtags, such as #happy, #love, #sad, #hate (similar to BIBREF8 , BIBREF9 ). As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English. Also, we deleted all tweets where the hashtags of interest were not located at the very end (i.e., we eliminated \u201c#sarcasm is something that I love\u201d). We lowercased the tweets, except the words where all the characters are uppercased."
              ],
              "highlighted_evidence": [
                "As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English."
              ]
            },
            "annotation_id": "232a20a0c74e592c8987aa28722eebbd086c2feb",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Twitter: We use a set of 350K tweets for our experiments. The ironic/sarcastic tweets are collected using hashtags, such as #irony, #sarcasm, and #sarcastic whereas the non-sarcastic tweets do not contain these hashtags, but they might include sentiment hashtags, such as #happy, #love, #sad, #hate (similar to BIBREF8 , BIBREF9 ). As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English. Also, we deleted all tweets where the hashtags of interest were not located at the very end (i.e., we eliminated \u201c#sarcasm is something that I love\u201d). We lowercased the tweets, except the words where all the characters are uppercased."
              ],
              "highlighted_evidence": [
                "As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English."
              ]
            },
            "annotation_id": "b1c2b588f586820f5f7376ecde119aa19e03f229",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Twitter: We use a set of 350K tweets for our experiments. The ironic/sarcastic tweets are collected using hashtags, such as #irony, #sarcasm, and #sarcastic whereas the non-sarcastic tweets do not contain these hashtags, but they might include sentiment hashtags, such as #happy, #love, #sad, #hate (similar to BIBREF8 , BIBREF9 ). As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English. Also, we deleted all tweets where the hashtags of interest were not located at the very end (i.e., we eliminated \u201c#sarcasm is something that I love\u201d). We lowercased the tweets, except the words where all the characters are uppercased."
              ],
              "highlighted_evidence": [
                "As pre-processing, we removed the retweets, spam, duplicates, and tweets written in languages other than English."
              ]
            },
            "annotation_id": "b5cb087d5d35d03a6ee37cee99855e1229fc7bb0",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Table1-1.png",
        "caption": "Table 1: Use of irony markers in two social media platforms"
      },
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Utterance with emoji (best in color)"
      },
      {
        "file": "3-Table4-1.png",
        "caption": "Table 4: Irony markers based on feature weights for Twitter"
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Ablation Tests of irony markers for Twitter. bold are best scores (in %)."
      },
      {
        "file": "3-Table5-1.png",
        "caption": "Table 5: Irony markers based on feature weights for Reddit"
      },
      {
        "file": "3-Table3-1.png",
        "caption": "Table 3: Ablation Tests of irony markers for Reddit posts. bold are best scores (in %)."
      },
      {
        "file": "4-Table6-1.png",
        "caption": "Table 6: Frequency of irony markers in different genres (subreddits). The mean and the SD (in bracket) are reported.x \u2217\u2217 and x \u2217 depict significance on p \u2264 0.005 and p \u2264 0.05, respectively."
      },
      {
        "file": "4-Table7-1.png",
        "caption": "Table 7: Frequency of irony markers in two platforms. The mean and the SD (in bracket) are reported."
      }
    ]
  },
  "1805.11598": {
    "title": "Polyglot Semantic Role Labeling",
    "abstract": "Previous approaches to multilingual semantic dependency parsing treat languages independently, without exploiting the similarities between semantic structures across languages. We experiment with a new approach where we combine resources from a pair of languages in the CoNLL 2009 shared task to build a polyglot semantic role labeler. Notwithstanding the absence of parallel data, and the dissimilarity in annotations between languages, our approach results in an improvement in SRL performance on multiple languages over a monolingual baseline. Analysis of the polyglot model shows it to be advantageous in lower-resource settings.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "The standard approach to multilingual NLP is to design a single architecture, but tune and train a separate model for each language. While this method allows for customizing the model to the particulars of each language and the available data, it also presents a problem when little data is available: extensive language-specific annotation is required. The reality is that most languages have very little annotated data for most NLP tasks.",
          "ammar2016malopa found that using training data from multiple languages annotated with Universal Dependencies BIBREF1 , and represented using multilingual word vectors, outperformed monolingual training. Inspired by this, we apply the idea of training one model on multiple languages\u2014which we call polyglot training\u2014to PropBank-style semantic role labeling (SRL). We train several parsers for each language in the CoNLL 2009 dataset BIBREF0 : a traditional monolingual version, and variants which additionally incorporate supervision from English portion of the dataset. To our knowledge, this is the first multilingual SRL approach to combine supervision from several languages.",
          "The CoNLL 2009 dataset includes seven different languages, allowing study of trends across the same. Unlike the Universal Dependencies dataset, however, the semantic label spaces are entirely language-specific, making our task more challenging. Nonetheless, the success of polyglot training in this setting demonstrates that sharing of statistical strength across languages does not depend on explicit alignment in annotation conventions, and can be done simply through parameter sharing. We show that polyglot training can result in better labeling accuracy than a monolingual parser, especially for low-resource languages. We find that even a simple combination of data is as effective as more complex kinds of polyglot training. We include a breakdown into label categories of the differences between the monolingual and polyglot models. Our findings indicate that polyglot training consistently improves label accuracy for common labels."
        ]
      },
      {
        "section_name": "Data",
        "paragraphs": [
          "We evaluate our system on the semantic role labeling portion of the CoNLL-2009 shared task BIBREF0 , on all seven languages, namely Catalan, Chinese, Czech, English, German, Japanese and Spanish. For each language, certain tokens in each sentence in the dataset are marked as predicates. Each predicate takes as arguments other words in the same sentence, their relationship marked by labeled dependency arcs. Sentences may contain no predicates.",
          "Despite the consistency of this format, there are significant differences between the training sets across languages. English uses PropBank role labels BIBREF2 . Catalan, Chinese, English, German, and Spanish include (but are not limited to) labels such as \u201carg INLINEFORM0 -agt\u201d (for \u201cagent\u201d) or \u201cA INLINEFORM1 \u201d that may correspond to some degree to each other and to the English roles. Catalan and Spanish share most labels (being drawn from the same source corpus, AnCora; BIBREF3 ), and English and German share some labels. Czech and Japanese each have their own distinct sets of argument labels, most of which do not have clear correspondences to English or to each other.",
          "We also note that, due to semi-automatic projection of annotations to construct the German dataset, more than half of German sentences do not include labeled predicate and arguments. Thus while German has almost as many sentences as Czech, it has by far the fewest training examples (predicate-argument structures); see Table TABREF3 ."
        ]
      },
      {
        "section_name": "Model",
        "paragraphs": [
          "Given a sentence with a marked predicate, the CoNLL 2009 shared task requires disambiguation of the sense of the predicate, and labeling all its dependent arguments. The shared task assumed predicates have already been identified, hence we do not handle the predicate identification task.",
          "Our basic model adapts the span-based dependency SRL model of He2017-deepsrl. This adaptation treats the dependent arguments as argument spans of length 1. Additionally, BIO consistency constraints are removed from the original model\u2014 each token is tagged simply with the argument label or an empty tag. A similar approach has also been proposed by marcheggiani2017lstm.",
          "The input to the model consists of a sequence of pretrained embeddings for the surface forms of the sentence tokens. Each token embedding is also concatenated with a vector indicating whether the word is a predicate or not. Since the part-of-speech tags in the CoNLL 2009 dataset are based on a different tagset for each language, we do not use these. Each training instance consists of the annotations for a single predicate. These representations are then passed through a deep, multi-layer bidirectional LSTM BIBREF4 , BIBREF5 with highway connections BIBREF6 .",
          "We use the hidden representations produced by the deep biLSTM for both argument labeling and predicate sense disambiguation in a multitask setup; this is a modification to the models of He2017-deepsrl, who did not handle predicate senses, and of marcheggiani2017lstm, who used a separate model. These two predictions are made independently, with separate softmaxes over different last-layer parameters; we then combine the losses for each task when training. For predicate sense disambiguation, since the predicate has been identified, we choose from a small set of valid predicate senses as the tag for that token. This set of possible senses is selected based on the training data: we map from lemmatized tokens to predicates and from predicates to the set of all senses of that predicate. Most predicates are only observed to have one or two corresponding senses, making the set of available senses at test time quite small (less than five senses/predicate on average across all languages). If a particular lemma was not observed in training, we heuristically predict it as the first sense of that predicate. For Czech and Japanese, the predicate sense annotation is simply the lemmatized token of the predicate, giving a one-to-one predicate-\u201csense\u201d mapping.",
          "For argument labeling, every token in the sentence is assigned one of the argument labels, or INLINEFORM0 if the model predicts it is not an argument to the indicated predicate."
        ]
      },
      {
        "section_name": "Monolingual Baseline",
        "paragraphs": [
          "We use pretrained word embeddings as input to the model. For each of the shared task languages, we produced GloVe vectors BIBREF7 from the news, web, and Wikipedia text of the Leipzig Corpora Collection BIBREF8 . We trained 300-dimensional vectors, then reduced them to 100 dimensions with principal component analysis for efficiency."
        ]
      },
      {
        "section_name": "Simple Polyglot Sharing",
        "paragraphs": [
          "In the first polyglot variant, we consider multilingual sharing between each language and English by using pretrained multilingual embeddings. This polyglot model is trained on the union of annotations in the two languages. We use stratified sampling to give the two datasets equal effective weight in training, and we ensure that every training instance is seen at least once per epoch.",
          "The basis of our polyglot training is the use of pretrained multilingual word vectors, which allow representing entirely distinct vocabularies (such as the tokens of different languages) in a shared representation space, allowing crosslingual learning BIBREF9 . We produced multilingual embeddings from the monolingual embeddings using the method of ammar2016massively: for each non-English language, a small crosslingual dictionary and canonical correlation analysis was used to find a transformation of the non-English vectors into the English vector space BIBREF10 .",
          "Unlike multilingual word representations, argument label sets are disjoint between language pairs, and correspondences are not clearly defined. Hence, we use separate label representations for each language's labels. Similarly, while (for example) eng:look and spa:mira may be semantically connected, the senses look.01 and mira.01 may not correspond. Hence, predicate sense representations are also language-specific."
        ]
      },
      {
        "section_name": "Language Identification",
        "paragraphs": [
          "In the second variant, we concatenate a language ID vector to each multilingual word embedding and predicate indicator feature in the input representation. This vector is randomly initialized and updated in training. These additional parameters provide a small degree of language-specificity in the model, while still sharing most parameters."
        ]
      },
      {
        "section_name": "Language-Specific LSTMs",
        "paragraphs": [
          "This third variant takes inspiration from the \u201cfrustratingly easy\u201d architecture of daumeiii2007easy for domain adaptation. In addition to processing every example with a shared biLSTM as in previous models, we add language-specific biLSTMs that are trained only on the examples belonging to one language. Each of these language-specific biLSTMs is two layers deep, and is combined with the shared biSLTM in the input to the third layer. This adds a greater degree of language-specific processing while still sharing representations across languages. It also uses the language identification vector and multilingual word vectors in the input."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We present our results in Table TABREF11 . We observe that simple polyglot training improves over monolingual training, with the exception of Czech, where we observe no change in performance. The languages with the fewest training examples (German, Japanese, Catalan) show the most improvement, while large-dataset languages such as Czech or Chinese see little or no improvement (Figure FIGREF10 ).",
          "The language ID model performs inconsistently; it is better than the simple polyglot model in some cases, including Czech, but not in all. The language-specific LSTMs model performs best on a few languages, such as Catalan and Chinese, but worst on others. While these results may reflect differences between languages in the optimal amount of crosslingual sharing, we focus on the simple polyglot results in our analysis, which sufficiently demonstrate that polyglot training can improve performance over monolingual training.",
          "We also report performance of state-of-the-art systems in each of these languages, all of which make explicit use of syntactic features, marcheggiani2017lstm excepted. While this results in better performance on many languages, our model has the advantage of not relying on a syntactic parser, and is hence more applicable to languages with lower resources. However, the results suggest that syntactic information is critical for strong performance on German, which has the fewest predicates and thus the least semantic annotation for a semantics-only model to learn from. Nevertheless, our baseline is on par with the best published scores for Chinese, and it shows strong performance on most languages."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Recent improvements in multilingual SRL can be attributed to neural architectures. Swayamdipta2016-qt present a transition-based stack LSTM model that predicts syntax and semantics jointly, as a remedy to the reliance on pipelined models. Guo2016-zc and BIBREF11 use deep biLSTM architectures which use syntactic information to guide the composition. marcheggiani2017lstm use a simple LSTM model over word tokens to tag semantic dependencies, like our model. Their model predicts a token's label based on the combination of the token vector and the predicate vector, and saw benefits from using POS tags, both improvements that could be added to our model. marcheggiani2017gcn apply the recently-developed graph convolutional networks to SRL, obtaining state of the art results on English and Chinese. All of these approaches are orthogonal to ours, and might benefit from polyglot training.",
          "Other polyglot models have been proposed for semantics. Richardson2018-ov-naacl train on multiple (natural language)-(programming language) pairs to improve a model that translates API text into code signature representations. Duong2017-qy treat English and German semantic parsing as a multi-task learning problem and saw improvement over monolingual baselines, especially for small datasets. Most relevant to our work is Johannsen2015-nb, which trains a polyglot model for frame-semantic parsing. In addition to sharing features with multilingual word vectors, they use them to find word translations of target language words for additional lexical features."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this work, we have explored a straightforward method for polyglot training in SRL: use multilingual word vectors and combine training data across languages. This allows sharing without crosslingual alignments, shared annotation, or parallel data. We demonstrate that a polyglot model can outperform a monolingual one for semantic analysis, particularly for languages with less data."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "We thank Luke Zettlemoyer, Luheng He, and the anonymous reviewers for helpful comments and feedback. This research was supported in part by the Defense Advanced Research Projects Agency (DARPA) Information Innovation Office (I2O) under the Low Resource Languages for Emergent Incidents (LORELEI) program issued by DARPA/I2O under contract HR001115C0113 to BBN. Views expressed are those of the authors alone."
        ]
      }
    ],
    "qas": [
      {
        "question": "what resources are combined to build the labeler?",
        "question_id": "475e698a801be0ad9e4f74756d1fff4fe0728009",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "multilingual word vectors",
                "training data across languages"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this work, we have explored a straightforward method for polyglot training in SRL: use multilingual word vectors and combine training data across languages. This allows sharing without crosslingual alignments, shared annotation, or parallel data. We demonstrate that a polyglot model can outperform a monolingual one for semantic analysis, particularly for languages with less data."
              ],
              "highlighted_evidence": [
                "In this work, we have explored a straightforward method for polyglot training in SRL: use multilingual word vectors and combine training data across languages. "
              ]
            },
            "annotation_id": "276a9f30bc9c6b13285cb6f336694507b3d69daa",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "a sequence of pretrained embeddings for the surface forms of the sentence tokens",
                "annotations for a single predicate",
                "CoNLL 2009 dataset"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The input to the model consists of a sequence of pretrained embeddings for the surface forms of the sentence tokens. Each token embedding is also concatenated with a vector indicating whether the word is a predicate or not. Since the part-of-speech tags in the CoNLL 2009 dataset are based on a different tagset for each language, we do not use these. Each training instance consists of the annotations for a single predicate. These representations are then passed through a deep, multi-layer bidirectional LSTM BIBREF4 , BIBREF5 with highway connections BIBREF6 ."
              ],
              "highlighted_evidence": [
                "The input to the model consists of a sequence of pretrained embeddings for the surface forms of the sentence tokens. Each token embedding is also concatenated with a vector indicating whether the word is a predicate or not. Since the part-of-speech tags in the CoNLL 2009 dataset are based on a different tagset for each language, we do not use these. Each training instance consists of the annotations for a single predicate. These representations are then passed through a deep, multi-layer bidirectional LSTM BIBREF4 , BIBREF5 with highway connections BIBREF6 ."
              ]
            },
            "annotation_id": "e6ac8aa7eb698957511d53d5a6a483d7313ca9f4",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "multilingual word vectors",
                "concatenate a language ID vector to each multilingual word embedding"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The basis of our polyglot training is the use of pretrained multilingual word vectors, which allow representing entirely distinct vocabularies (such as the tokens of different languages) in a shared representation space, allowing crosslingual learning BIBREF9 . We produced multilingual embeddings from the monolingual embeddings using the method of ammar2016massively: for each non-English language, a small crosslingual dictionary and canonical correlation analysis was used to find a transformation of the non-English vectors into the English vector space BIBREF10 .",
                "In the second variant, we concatenate a language ID vector to each multilingual word embedding and predicate indicator feature in the input representation. This vector is randomly initialized and updated in training. These additional parameters provide a small degree of language-specificity in the model, while still sharing most parameters."
              ],
              "highlighted_evidence": [
                "The basis of our polyglot training is the use of pretrained multilingual word vectors, which allow representing entirely distinct vocabularies (such as the tokens of different languages) in a shared representation space, allowing crosslingual learning BIBREF9 .",
                "In the second variant, we concatenate a language ID vector to each multilingual word embedding and predicate indicator feature in the input representation."
              ]
            },
            "annotation_id": "ebbd6f30a320cc0444393903adbd78a1106bddfb",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Example predicate-argument structures from English, Spanish, and Czech. Note that the argument labels are different in each language."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Train data statistics. Languages are indicated with ISO 639-3 codes."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Improvement in absolute F1 with polyglot training with addition of English. Languages are sorted in order of increasing number of predicates in the training set."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Semantic F1 scores (including predicate sense disambiguation) on the CoNLL 2009 dataset. State of the art for Catalan and Japanese is from Zhao et al. (2009), for German and Spanish from Roth and Lapata (2016), for English and Chinese from Marcheggiani and Titov (2017). Italics indicate use of syntax."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Per-label breakdown of F1 scores for Catalan and Spanish. These numbers reflect labels for each argument; the combination is different from the overall semantic F1, which includes predicate sense disambiguation."
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Semantic F1 scores on the English test set for each language pair."
      },
      {
        "file": "5-Table5-1.png",
        "caption": "Table 5: Unlabeled semantic F1 scores on the CoNLL 2009 dataset."
      }
    ]
  },
  "1610.03807": {
    "title": "Question Generation from a Knowledge Base with Web Exploration",
    "abstract": "Question generation from a knowledge base (KB) is the task of generating questions related to the domain of the input KB. We propose a system for generating fluent and natural questions from a KB, which significantly reduces the human effort by leveraging massive web resources. In more detail, a seed question set is first generated by applying a small number of hand-crafted templates on the input KB, then more questions are retrieved by iteratively forming already obtained questions as search queries into a standard search engine, before finally questions are selected by estimating their fluency and domain relevance. Evaluated by human graders on 500 random-selected triples from Freebase, questions generated by our system are judged to be more fluent than those of \\newcite{serban-EtAl:2016:P16-1} by human graders.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Question generation is important as questions are useful for student assessment or coaching purposes in educational or professional contexts, and a large-scale corpus of question and answer pairs is also critical to many NLP tasks including question answering, dialogue interaction and intelligent tutoring systems. There has been much literature so far BIBREF0 , BIBREF1 , BIBREF2 , BIBREF3 , BIBREF4 , BIBREF5 , BIBREF6 studying question generation from text. Recently people are becoming interested in question generation from KB, since large-scale KBs, such as Freebase BIBREF7 and DBPedia BIBREF8 , are freely available, and entities and their relations are already present in KBs but not for texts.",
          "Question generation from KB is challenging as function words and morphological forms for entities are abstracted away when a KB is created. To tackle this challenge, previous work BIBREF9 , BIBREF10 relies on massive human-labeled data. Treating question generation as a machine translation problem, serban-EtAl:2016:P16-1 train a neural machine translation (NMT) system with 10,000 $\\langle $ triple, question $\\rangle $ pairs. At test time, input triples are \u201ctranslated\u201d into questions with the NMT system. On the other hand, the question part of the 10,000 pairs are human generated, which requires a large amount of human effort. In addition, the grammaticality and naturalness of generated questions can not be guaranteed (as seen in Table 1 ).",
          "We propose a system for generating questions from KB that significantly reduces the human effort by leveraging the massive web resources. Given a KB, a small set of question templates are first hand-crafted based on the predicates in the KB. These templates consist of a transcription of the predicate in the KB (e.g. performsActivity $\\Rightarrow $ how to) and placeholders for the subject (#X#) and the object (#Y#). A seed question set is then generated by applying the templates on the KB. The seed question set is further expanded through a search engine (e.g., Google, Bing), by iteratively forming each generated question as a search query to retrieve more related question candidates. Finally a selection step is applied by estimating the fluency and domain relevance of each question candidate.",
          "The only human labor in this work is the question template construction. Our system does not require a large number of templates because: (1) the iterative question expansion can produce a large number of questions even with a relatively small number of seed questions, as we see in the experiments, (2) multiple entities in the KB share the same predicates. Another advantage is that our system can easily generate updated questions as web is self-updating consistently. In our experiment, we compare with serban-EtAl:2016:P16-1 on 500 random selected triples from Freebase BIBREF7 . Evaluated by 3 human graders, questions generated by our system are significantly better then serban-EtAl:2016:P16-1 on grammaticality and naturalness."
        ]
      },
      {
        "section_name": "Knowledge Base",
        "paragraphs": [
          "A knowledge base (KB) can be viewed as a directed graph, in which nodes are entities (such as \u201cjigsaw\u201d and \u201cCurveCut\u201d) and edges are relations of entities (such as \u201cperformsActivity\u201d). A KB can also be viewed as a list of triples in the format of $\\langle $ subject, predicate, object $\\rangle $ , where subjects and objects are entities, and predicates are relations."
        ]
      },
      {
        "section_name": "System",
        "paragraphs": [
          "Shown in Figure 1 , our system contains the sub-modules of question template construction, seed question generation, question expansion and selection. Given an input KB, a small set of question templates is first constructed such that each template is associated with a predicate, then a seed question set is generated by applying the template set on the input KB, before finally more questions are generated from related questions that are iteratively retrieved from a search engine with already-obtained questions as search queries (section \"Experiments\" ). Taking our in-house KB of power tool domain as an example, template \u201chow to use #X#\u201d is first constructed for predicate \u201cperformsActivity\u201d. In addition, seed question \u201chow to use jigsaw\u201d is generated by applying the template on triple \u201c $\\langle $ jigsaw, performsActivity, CurveCut $\\rangle $ \u201d, before finally questions (Figure 2 ) are retrieved from Google with the seed question."
        ]
      },
      {
        "section_name": "Question expansion and selection",
        "paragraphs": [
          "[t] seed question set $S$ candidate questions $E$ $E \\leftarrow S$ $Q \\leftarrow S$ $I \\leftarrow 0$ len $(Q) > 0$ and $I < I_{max}$ $I = I + 1$ $q_{cur}$ $\\leftarrow $ $E$0 .Pop() $E$1 in WebExp $E$2 not $E$3 .contains $E$4 $E$5 .Append( $E$6 ) $E$7 .Push( $E$8 ) Question expansion method",
          "Shown in Algorithm \"Experiments\" , the expanded question set $E$ is initialized as the seed question set (Line 1). In each iteration, an already-obtained question is expanded from web and the retrieved questions are added to $E$ if $E$ does not contain them (Lines 6-10). As there may be a large number of questions generated in the loop, we limit the maximum number of iterations with $I_{max}$ (Line 4).",
          "The questions collected from the web search engine may not be fluent or domain relevant; especially the domain relevance drops significantly as the iteration goes on. Here we adopt a skip-gram model BIBREF11 and a language model for evaluating the domain relevance and fluency of the expanded questions, respectively. For domain relevance, we take the seed question set as the in-domain data $D_{in}$ , the domain relevance of expanded question $q$ is defined as: ",
          "$$\\textsc {Rel}(q) = \\cos (v(q),v(D_{in}))$$   (Eq. 7) ",
          "where $v(\\cdot )$ is the document embedding defined as the averaged word embedding within the document. For fluency, we define the averaged language model score as: ",
          "$$\\textsc {AvgLM}(q) = \\frac{\\textsc {Lm}(q)}{\\textsc {Len}(q)}$$   (Eq. 8) ",
          "where $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We perform three experiments to evaluate our system qualitatively and quantitatively. In the first experiment, we compare our end-to-end system with the previous state-of-the-art method BIBREF10 on Freebase BIBREF7 , a domain-general KB. In the second experiment, we validate our domain relevance evaluation method on a standard dataset about short document classification. In the final experiment, we run our end-to-end system on a highly specialized in-house KB and present sample results, showing that our system is capable of generating questions from domain specific KBs."
        ]
      },
      {
        "section_name": "Evaluation on Freebase",
        "paragraphs": [
          "We first compare our system with serban-EtAl:2016:P16-1 on 500 randomly selected triples from Freebase BIBREF7 . For the 500 triples, we hand-crafted 106 templates, as these triples share only 53 distinct predicates (we made 2 templates for each predicate on average). 991 seed questions are generated by applying the templates on the triples, and 1529 more questions are retrieved from Google. To evaluate the fluency of the candidate questions, we train a 4-gram language model (LM) on gigaword (LDC2011T07) with Kneser Ney smoothing. Using the averaged language model score as index, the top 500 questions are selected to compare with the results from serban-EtAl:2016:P16-1. We ask three native English speakers to evaluate the fluency and the naturalness of both results based on a 4-point scheme where 4 is the best.",
          "We show the averaged human rate in Table 2 , where we can see that our questions are more grammatical and natural than serban-EtAl:2016:P16-1. The naturalness score is less than the grammatical score for both methods. It is because naturalness is a more strict metric since a natural question should also be grammatical.",
          "Shown in Table 1 , we compare our questions with serban-EtAl:2016:P16-1 where questions in the same line describe the same entity. We can see that our questions are grammatical and natural as these questions are what people usually ask on the web. On the other hand, questions from serban-EtAl:2016:P16-1 are either ungrammatical (such as \u201cwho was someone who was involved in the leukemia ?\u201d and \u201cwhats the title of a book of the subject of the bible ?\u201d), unnatural (\u201cwhat 's one of the mountain where can you found in argentina in netflix ?\u201d) or confusing (\u201cwho was someone who was involved in the leukemia ?\u201d)."
        ]
      },
      {
        "section_name": "Domain Relevance",
        "paragraphs": [
          "We test our domain-relevance evaluating method on the web snippet dataset, which is a commonly-used for domain classification of short documents. It contains 10,060 training and 2,280 test snippets (short documents) in 8 classes (domains), and each snippet has 18 words on average. There have been plenty of prior results BIBREF12 , BIBREF13 , BIBREF14 on the dataset.",
          "Shown in Table 3 , we compare our domain-relevance evaluation method (section \"Experiments\" ) with previous state-of-the-art methods: phan2008learning first derives latent topics with LDA BIBREF15 from Wikipedia, then uses the topics as appended features to expand the short text. chen2011short further expanded phan2008learning by using multi-granularity topics. ma-EtAl:2015:VSM-NLP adopts a Bayesian model that the probability a document $D$ belongs to a topic $t$ equals to the prior of $t$ times the probability each word $w$ in $D$ comes from $t$ . Our method first concatenates training documents of the same domain into one \u201cdomain document\u201d, then calculates each document embedding by averaging word embeddings within it, before finally assigns the label of the nearest (cosine similarity) \u201cdomain document\u201d to each test document.",
          "Simple as it is, our method outperforms all previous methods proving its effectiveness. The reason can be that word embeddings captures the similarity between distinct words (such as \u201cfinance\u201d and \u201ceconomy\u201d), while it is hard for traditional methods. On the order hand, LDA only learns probabilities of words belonging to topics."
        ]
      },
      {
        "section_name": "Evaluation on the Domain-specific KB",
        "paragraphs": [
          "The last experiment is on our in-house KB in the power tool domain. It contains 67 distinct predicates, 293 distinct subjects and 279 distinct objects respectively. For the 67 predicates, we hand-craft 163 templates. Here we use the same language model as in our first experiment, and learn a skip-gram model BIBREF11 on Wikipedia for evaluating domain relevance.",
          "We generate 12,228 seed questions from which 20,000 more questions are expanded with Google. Shown in Table 4 are some expanded questions from which we can see that most of them are grammatical and relevant to the power tool domain. In addition, most questions are informative and correspond to a specific answer, except the one \u201cdo I need a hammer drill\u201d that lacks context information. Finally, in addition to the simple factoid questions, our system generates many complex questions such as \u201chow to cut a groove in wood without a router\u201d."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "We presented a system to generate natural language questions from a knowledge base. By leveraging rich web information, our system is able to generate domain-relevant questions in wide scope, while human effort is significantly reduced. Evaluated by human graders, questions generated by our system are significantly better than these from serban-EtAl:2016:P16-1 on 500 random-selected triples from Freebase. We also demonstrated generated questions from our in-house KB of power tool domain, which are fluent and domain-relevant in general. Our current system only generates questions without answers, leaving automatic answer mining as our future work."
        ]
      }
    ],
    "qas": [
      {
        "question": "Was the filtering based on fluency and domain relevance done automatically?",
        "question_id": "6157567c5614e1954b801431fec680f044e102c6",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "question generation",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "The questions collected from the web search engine may not be fluent or domain relevant; especially the domain relevance drops significantly as the iteration goes on. Here we adopt a skip-gram model BIBREF11 and a language model for evaluating the domain relevance and fluency of the expanded questions, respectively. For domain relevance, we take the seed question set as the in-domain data $D_{in}$ , the domain relevance of expanded question $q$ is defined as:",
                "$$\\textsc {Rel}(q) = \\cos (v(q),v(D_{in}))$$ (Eq. 7)",
                "where $v(\\cdot )$ is the document embedding defined as the averaged word embedding within the document. For fluency, we define the averaged language model score as:",
                "$$\\textsc {AvgLM}(q) = \\frac{\\textsc {Lm}(q)}{\\textsc {Len}(q)}$$ (Eq. 8)",
                "where $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
              ],
              "highlighted_evidence": [
                "The questions collected from the web search engine may not be fluent or domain relevant",
                "Here we adopt a skip-gram model BIBREF11 and a language model for evaluating the domain relevance and fluency of the expanded questions, respectively.",
                "For domain relevance, we take the seed question set as the in-domain data $D_{in}$ , the domain relevance of expanded question $q$ is defined as:\n\n$$\\textsc {Rel}(q) = \\cos (v(q),v(D_{in}))$$ (Eq. 7)\n\nwhere $v(\\cdot )$ is the document embedding defined as the averaged word embedding within the document.",
                "For fluency, we define the averaged language model score as:\n\n$$\\textsc {AvgLM}(q) = \\frac{\\textsc {Lm}(q)}{\\textsc {Len}(q)}$$ (Eq. 8)\n\nwhere $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. ",
                "We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
              ]
            },
            "annotation_id": "2a1b8f1fc516070fefc7257dce0079e8ade29a0b",
            "worker_id": "74eea9f3f4f790836045fcc75d0b3f5156901499"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "The questions collected from the web search engine may not be fluent or domain relevant; especially the domain relevance drops significantly as the iteration goes on. Here we adopt a skip-gram model BIBREF11 and a language model for evaluating the domain relevance and fluency of the expanded questions, respectively. For domain relevance, we take the seed question set as the in-domain data $D_{in}$ , the domain relevance of expanded question $q$ is defined as:",
                "$$\\textsc {Rel}(q) = \\cos (v(q),v(D_{in}))$$ (Eq. 7)",
                "where $v(\\cdot )$ is the document embedding defined as the averaged word embedding within the document. For fluency, we define the averaged language model score as:",
                "$$\\textsc {AvgLM}(q) = \\frac{\\textsc {Lm}(q)}{\\textsc {Len}(q)}$$ (Eq. 8)",
                "where $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
              ],
              "highlighted_evidence": [
                "Here we adopt a skip-gram model BIBREF11 and a language model for evaluating the domain relevance and fluency of the expanded questions, respectively. For domain relevance, we take the seed question set as the in-domain data $D_{in}$ , the domain relevance of expanded question $q$ is defined as:\n\n$$\\textsc {Rel}(q) = \\cos (v(q),v(D_{in}))$$ (Eq. 7)\n\nwhere $v(\\cdot )$ is the document embedding defined as the averaged word embedding within the document. For fluency, we define the averaged language model score as:\n\n$$\\textsc {AvgLM}(q) = \\frac{\\textsc {Lm}(q)}{\\textsc {Len}(q)}$$ (Eq. 8)\n\nwhere $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
              ]
            },
            "annotation_id": "2c3e7d6057ace540d12d9294375a86f8dfe90f98",
            "worker_id": "efdb8f7f2fe9c47e34dfe1fb7c491d0638ec2d86"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "where $\\textsc {Lm}(\\cdot )$ is the general-domain language model score (log probability), and $\\textsc {Len}(\\cdot )$ is the word count. We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds."
              ],
              "highlighted_evidence": [
                "We apply thresholds $t_{rel}$ and $t_{flu}$ for domain relevance and fluency respectively, and filter out questions whose scores are below these thresholds"
              ]
            },
            "annotation_id": "56247f1efcf1f26eb0b448ba4e0e208ce73c83a1",
            "worker_id": "64535162a1194b06db3080285c566202b651354c"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Overview of our framework."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2: Related search results for the question \u201chow to use jigsaw\u201d."
      },
      {
        "file": "2-Table2-1.png",
        "caption": "Table 2: Human ratings of generated questions"
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Comparing generated questions"
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Precision on the web snippet dataset"
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Example question expanded"
      }
    ]
  },
  "1904.03670": {
    "title": "Speech Model Pre-training for End-to-End Spoken Language Understanding",
    "abstract": "Whereas conventional spoken language understanding (SLU) systems map speech to text, and then text to intent, end-to-end SLU systems map speech directly to intent through a single trainable model. Achieving high accuracy with these end-to-end models without a large amount of training data is difficult. We propose a method to reduce the data requirements of end-to-end SLU in which the model is first pre-trained to predict words and phonemes, thus learning good features for SLU. We introduce a new SLU dataset, Fluent Speech Commands, and show that our method improves performance both when the full dataset is used for training and when only a small subset is used. We also describe preliminary experiments to gauge the model's ability to generalize to new phrases not heard during training.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Spoken language understanding (SLU) systems infer the meaning or intent of a spoken utterance BIBREF0 . This is crucial for voice user interfaces, in which the speaker's utterance needs to be converted into an action or query. For example, for a voice-controlled coffee machine, an utterance like \u201cmake me a large coffee with two milks and a sugar, please\u201d might have an intent representation like {drink: \"coffee\", size: \"large\", additions: [{type: \"milk\", count: 2}, {type: \"sugar\", count: 1}]}.",
          "The conventional SLU pipeline is composed of two modules: an automatic speech recognition (ASR) module that maps the speech to a text transcript, and a natural language understanding (NLU) module that maps the text transcript to the speaker's intent BIBREF1 , BIBREF2 , BIBREF3 . An alternative approach that is beginning to gain popularity is end-to-end SLU BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 , BIBREF8 . In end-to-end SLU, a single trainable model maps the speech audio directly to the speaker's intent without explicitly producing a text transcript (Fig. FIGREF4 ). Unlike the conventional SLU pipeline, end-to-end SLU:",
          "End-to-end models have been made possible by deep learning, which automatically learns hierarchical representations of the input signal BIBREF9 , BIBREF10 , BIBREF11 , BIBREF12 , BIBREF13 . Speech is natural to represent in a hierarchical way: waveform INLINEFORM0 phonemes INLINEFORM1 morphemes INLINEFORM2 words INLINEFORM3 concepts INLINEFORM4 meaning. However, because speech signals are high-dimensional and highly variable even for a single speaker, training deep models and learning these hierarchical representations without a large amount of training data is difficult.",
          "The computer vision BIBREF14 , BIBREF15 , natural language processing BIBREF16 , BIBREF17 , BIBREF18 , BIBREF19 , BIBREF20 , and ASR BIBREF21 , BIBREF22 communities have attacked the problem of limited supervised training data with great success by pre-training deep models on related tasks for which there is more training data. Following their lead, we propose an efficient ASR-based pre-training methodology in this paper and show that it may be used to improve the performance of end-to-end SLU models, especially when the amount of training data is very small.",
          "Our contributions are as follows:"
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Three key papers describing end-to-end SLU were written by Qian et al. BIBREF4 , Serdyuk et al. BIBREF5 , and Chen et al. BIBREF6 . Serdyuk et al. in BIBREF5 use no pre-training whatsoever. Qian et al. in BIBREF4 use an auto-encoder to initialize the SLU model. Chen et al. BIBREF6 pre-train the first stage of an SLU model to recognize graphemes; the softmax outputs of the first stage are then fed to a classifier second stage. The model proposed in this paper is similar to theirs, but removes the restriction of the softmax bottleneck and uses alternative training targets, as we will describe later.",
          "More recently, Haghani et al. in BIBREF7 compare four types of sequence-to-sequence models for SLU, including a direct model (end-to-end with no pre-training) and a multi-task model (uses a shared encoder whose output is ingested by a separate ASR decoder and SLU decoder). The model proposed here is somewhat similar to their multi-task model, although we do not use or require the ASR targets during SLU training.",
          "The work listed above deals with very high resource SLU\u2014in BIBREF7 , for instance, the Google Home BIBREF23 dataset consists of 24 million labeled utterances. In contrast, Renkens et al. in BIBREF8 consider the problem of end-to-end SLU with limited training data, and find that capsule networks BIBREF24 , compared to conventional neural network models, are more easily capable of learning end-to-end SLU from scratch. However, they do not consider the effect of pre-training on other speech data.",
          "This previous work has all been conducted on datasets that are closed-source or too small to test hypotheses about the amount of data required to generalize well. The lack of a good open-source dataset for end-to-end SLU experiments makes it difficult for most people to perform high-quality, reproducible research on this topic. We therefore created a new SLU dataset, the \u201cFluent Speech Commands\u201d dataset, which Fluent.ai releases along with this paper."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "This section describes the structure and creation of Fluent Speech Commands."
        ]
      },
      {
        "section_name": "Audio and labels",
        "paragraphs": [
          "The dataset is composed of 16 kHz single-channel .wav audio files. Each audio file contains a recording of a single command that one might use for a smart home or virtual assistant, like \u201cput on the music\u201d or \u201cturn up the heat in the kitchen\u201d.",
          "Each audio is labeled with three slots: action, object, and location. A slot takes on one of multiple values: for instance, the \u201clocation\u201d slot can take on the values \u201cnone\u201d, \u201ckitchen\u201d, \u201cbedroom\u201d, or \u201cwashroom\u201d. We refer to the combination of slot values as the intent of the utterance. The dataset has 31 unique intents in total. We do not distinguish between domain, intent, and slot prediction, as is sometimes done in SLU BIBREF25 .",
          "The dataset can be used as a multi-label classification task, where the goal is to predict the action, object, and location labels. Since the slots are not actually independent of each other, a more careful approach would model the relationship between slots, e.g. using an autoregressive model, as in BIBREF7 . We use the simpler multi-label classification approach in this paper, so as to avoid the issues sometimes encountered training autoregressive models and instead focus on questions related to generalization using a simpler model. Alternately, the 31 distinct intents can be \u201cflattened\u201d and used as 31 distinct labels for a single-label classification task.",
          "For each intent, there are multiple possible wordings: for example, the intent {action: \"activate\", object: \"lights\", location: \"none\"} can be expressed as \u201cturn on the lights\u201d, \u201cswitch the lights on\u201d, \u201clights on\u201d, etc.. These phrases were decided upon before data collection by asking employees at Fluent.ai, including both native and non-native English speakers, for various ways in which they might express a particular intent. There are 248 different phrases in total."
        ]
      },
      {
        "section_name": "Data collection",
        "paragraphs": [
          "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order. Participants consented to data being released and provided demographic information about themselves. The demographic information about these anonymized speakers (age range, gender, speaking ability, etc.) is included along with the dataset.",
          "The data was validated by a separate set of crowdsourcers. All audios deemed by the crowdsourcers to be unintelligible or contain the wrong phrase were removed. The total number of speakers, utterances, and hours of audio remaining is shown in Table TABREF12 ."
        ]
      },
      {
        "section_name": "Dataset splits",
        "paragraphs": [
          "The utterances are randomly divided into train, valid, and test splits in such a way that no speaker appears in more than one split. Each split contains all possible wordings for each intent, though our code has the option to include data for only certain wordings for different sets, to test the model's ability to recognize wordings not heard during training. The dataset has a .csv file for each split that lists the speaker ID, file path, transcription, and slots for all the .wav files in that split."
        ]
      },
      {
        "section_name": "Related datasets",
        "paragraphs": [
          "Here we review some related public datasets and show the gap that Fluent Speech Commands fills.",
          "The Google Speech Commands dataset BIBREF26 (to which the name \u201cFluent Speech Commands\u201d is an homage) is a free dataset of 30 single-word spoken commands (\u201cyes\u201d, \u201cno\u201d, \u201cstop\u201d, \u201cgo\u201d, etc.). This dataset is suitable for keyword spotting experiments, but not for SLU.",
          "ATIS is an SLU dataset consisting of utterances related to travel planning. This dataset can only be obtained expensively from the Linguistic Data Consortium.",
          "The Snips NLU Benchmark BIBREF2 has a rich set of virtual assistant commands, but contains only text, with no audio, and hence is not suitable for end-to-end SLU experiments.",
          "The Grabo, Domotica, and Patcor datasets are three related datasets of spoken commands for robot control and card games developed by KU Leuven and used in BIBREF8 . These datasets are free, but have only a small number of speakers and phrases.",
          "In contrast to these datasets, Fluent Speech Commands is simultaneously audio-based, reasonably large, and free, and contains several multiple-word commands corresponding to each of the intents."
        ]
      },
      {
        "section_name": "Model and Pre-training Strategy",
        "paragraphs": [
          "The model proposed in this paper, shown in Fig. FIGREF17 , is a deep neural network consisting of a stack of modules, where the first modules are pre-trained to predict phonemes and words. The word and phoneme classifiers are discarded, and the entire model is then trained end-to-end on the supervised SLU task. In what follows, we justify these design decisions and give more details about the model hyperparameters."
        ]
      },
      {
        "section_name": "Which ASR targets to use?",
        "paragraphs": [
          "ASR models are trained using a variety of targets, including phonemes, graphemes, wordpieces, or more recently whole words BIBREF27 , BIBREF28 , BIBREF29 . We choose whole words as the pre-training targets, since this is what a typical NLU module would expect as input. A typical ASR dataset contains too many unique words (LibriSpeech BIBREF30 has more than 200,000) to assign an output to each one; we only assign a label to the 10,000 most common words. This leaves much of the pre-training data without any labels, which wastes data. By using phonemes as intermediate pre-training targets BIBREF31 , BIBREF19 , BIBREF32 , we are able to pre-train on speech segments with no word label. Additionally, we find that using phonemes as intermediate targets speeds up word-level pre-training BIBREF33 , BIBREF34 .",
          "We use the Montreal Forced Aligner BIBREF35 to obtain word- and phoneme-level alignments for LibriSpeech, and we pre-train the model on the entire 960 hours of training data using these alignments INLINEFORM0 . Using force-aligned labels has the additional benefit of enabling pre-training using short, random crops rather than entire utterances, which reduces the computation and memory required to pre-train the model.",
          "",
          "",
          "",
          ""
        ]
      },
      {
        "section_name": "Phoneme module",
        "paragraphs": [
          "The first module takes as input the audio signal INLINEFORM0 and outputs INLINEFORM1 , a sequence of hidden representations that are pre-trained to predict phonemes. The phoneme-level logits are computed using a linear classifier: DISPLAYFORM0 ",
          "The phoneme module is implemented using a SincNet layer BIBREF36 , BIBREF37 , which processes the raw input waveform, followed by multiple convolutional layers and recurrent layers with pooling and dropout. More detailed hyperparameters can be found in our code."
        ]
      },
      {
        "section_name": "Word module",
        "paragraphs": [
          "The second module takes as input INLINEFORM0 and outputs INLINEFORM1 . Similar to the phoneme-level module, it uses recurrent layers with dropout and pooling, and is pre-trained to predict words using another linear classifier: DISPLAYFORM0 ",
          "Notice that the input to this module is INLINEFORM0 , not INLINEFORM1 , and likewise the output to the next stage is INLINEFORM2 , not INLINEFORM3 . There are two good reasons for forwarding INLINEFORM4 instead of INLINEFORM5 . The first is that we don't want to remove a degree of freedom from the model: the size of INLINEFORM6 is fixed by the number of targets, and this would in turn fix the size of the next layer of the model. The second reason is that computing INLINEFORM7 requires multiplying and storing a large ( INLINEFORM8 2.5 million parameters) weight matrix, and by discarding this matrix after pre-training, we save on memory and computation."
        ]
      },
      {
        "section_name": "Intent module",
        "paragraphs": [
          "The third module, which is not pre-trained, maps INLINEFORM0 to the predicted intent. Depending on the structure of the intent representation, the intent module might take on various forms. Since in this work we use a fixed three-slot intent representation, we implement this module using a recurrent layer, followed by max-pooling to squash the sequence of outputs from the recurrent layer into a single vector of logits corresponding to the different slot values, similar to BIBREF5 ."
        ]
      },
      {
        "section_name": "Unfreezing schedule",
        "paragraphs": [
          "Although the pre-trained model works well as a frozen feature extractor, it may be preferable to \u201cunfreeze\u201d its weights and finetune them for the SLU task with backpropagation. Similar to ULMFiT BIBREF17 , we find that gradually unfreezing the pre-trained layers works better than unfreezing them all at once. We unfreeze one layer each epoch, and stop at a pre-determined layer, which is a hyperparameter."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "Here we report results for three experiments on Fluent Speech Commands: using the full dataset, using a subset of the dataset, and using a subset of wordings."
        ]
      },
      {
        "section_name": "Full dataset",
        "paragraphs": [
          "We first trained models given the entire SLU training set. The models used one of: 1) no pre-training (randomly initialized), 2) pre-training with no unfreezing, 3) gradually unfreezing only the word layers, or 4) gradually unfreezing both the word layers and phoneme layers. What we report here as \u201caccuracy\u201d refers to the accuracy of all slots for an utterance taken together\u2014that is, if the predicted intent differs from the true intent in even one slot, the prediction is deemed incorrect.",
          "The validation accuracy of these models over time is shown in Fig. . The best results are obtained when only the word layers of the pre-trained model are unfrozen. This may be because the model begins to forget the more general phonetic knowledge acquired during pre-training. For the test set, the frozen model and partially unfrozen model perform roughly equally well (Table TABREF28 , \u201cfull\u201d column), possibly because the test set is \u201ceasier\u201d than the validation set. In all cases, the pre-trained models outperform the randomly initialized model."
        ]
      },
      {
        "section_name": "Partial dataset",
        "paragraphs": [
          "To simulate a smaller dataset, we randomly selected 10% of the training set, and used this instead of the entire training set. Fig. shows the validation accuracy (on the entire validation set, not a subset) over time. A similar trend is observed as for the entire dataset: unfreezing the word layers works best. The gap in final test accuracy between the randomly initialized model and the pre-trained models increases (Table TABREF28 , \u201c10%\u201d column); the final test accuracy for the pre-trained models drops only slightly, further highlighting the advantage of our proposed method."
        ]
      },
      {
        "section_name": "Generalizing to new wordings",
        "paragraphs": [
          "What happens if new wordings appear in the test data that never appear in the training data? This is an important question, since it is generally impractical to try to imagine every possible wording for a particular intent while gathering training data.",
          "To test this, we trained models on three specific phrases, \u201cturn on the lights\u201d, \u201cturn off the lights\u201d, and \u201cswitch on the lights\u201d (273 utterances total), and tested on those same phrases, as well as a new phrase: \u201cswitch off the lights\u201d. If the model incorrectly infers that utterances that contain \u201cswitch\u201d always correspond to turning on the lights, it will incorrectly guess that \u201cswitch off the lights\u201d corresponds to turning on the lights; if the model infers that the presence of the word \u201coff\u201d corresponds to turning off the lights, it will generalize to the new phrase. The randomly initialized model was unable to fit this tiny training set, even with a very low learning rate and no regularization. The pre-trained models were able to generalize to the new wording (with 97% accuracy on the validation set, which contains more examples of the new phrase than of the training phrases).",
          "However, there are many situations in which our model does not correctly generalize. For example, if the model is trained only with examples containing \u201cbedroom\u201d and \u201cwashroom\u201d, but then tested on an example containing \u201cbathroom\u201d, it will guess the intent corresponding to \u201cbedroom\u201d because \u201cbedroom\u201d sounds more similar to \u201cbathroom\u201d than to \u201cwashroom\u201d, even though \u201cwashroom\u201d is the correct meaning. In text-based NLU, this scenario can be handled using word embeddings, which represent words in such a way that words with similar meanings have similar vector representations BIBREF1 , BIBREF38 . It may be possible to teach the pre-trained part of the model to output \u201cembedding-like\u201d word representations so that the intent module can recognize the meaning of phrases with synonyms."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we proposed a pre-training methodology for end-to-end SLU models, introduced the Fluent Speech Commands dataset, and used this dataset to show that our pre-training techniques improve performance both for large and small SLU training sets. In the future, we plan to continue using Fluent Speech Commands to explore the limitations of end-to-end SLU, like new wordings and synonyms not observed in the SLU dataset, to see if these limitations can be overcome."
        ]
      },
      {
        "section_name": "Acknowledgements",
        "paragraphs": [
          "We would like to acknowledge the following for research funding and computing support: NSERC, Calcul Qu\u00e9bec, Compute Canada, the Canada Research Chairs, and CIFAR.",
          "Thanks to Dima Serdyuk and Kyle Kastner at Mila, and Farzaneh Fard, Luis Rodriguez Ruiz, Sam Myer, Mohamed Mhiri, and Arash Rad at Fluent.ai for helpful discussions with us about this work."
        ]
      }
    ],
    "qas": [
      {
        "question": "How was the dataset collected?",
        "question_id": "63cdac43a643fc1e06da44910458e89b2c7cd921",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "data was collected using crowdsourcing where speakers were recorded saying random ordered phrases for each intent twice",
              "evidence": [
                "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order. Participants consented to data being released and provided demographic information about themselves. The demographic information about these anonymized speakers (age range, gender, speaking ability, etc.) is included along with the dataset."
              ],
              "highlighted_evidence": [
                "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order."
              ]
            },
            "annotation_id": "2dc524e6062c5ede03075ec93f0372844288368d",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "crowdsourcing"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order. Participants consented to data being released and provided demographic information about themselves. The demographic information about these anonymized speakers (age range, gender, speaking ability, etc.) is included along with the dataset."
              ],
              "highlighted_evidence": [
                "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order."
              ]
            },
            "annotation_id": "7c84fb594cec81129ed66ae18f32faf7dc845fa6",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "using crowdsourcing"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The data was collected using crowdsourcing. Each speaker was recorded saying each wording for each intent twice. The phrases to record were presented in a random order. Participants consented to data being released and provided demographic information about themselves. The demographic information about these anonymized speakers (age range, gender, speaking ability, etc.) is included along with the dataset."
              ],
              "highlighted_evidence": [
                "The data was collected using crowdsourcing. "
              ]
            },
            "annotation_id": "a62fff440f3c40dc441a09f7212e89c4b8a1b1a2",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1: Conventional ASR \u2192 NLU system for SLU versus end-to-end SLU."
      },
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Information about the Fluent Speech Commands dataset."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: The lower layers of the model are pre-trained using ASR targets (words and phonemes). The word and phoneme classifiers are discarded, and the features from the pre-trained part of the model (blue) are used as the input to the subsequent module (white), which is trained using SLU targets."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3: Accuracy on the validation set over time for models trained on (a) the full SLU dataset or (b) 10% of the dataset."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Accuracy on the test set for different models, given the full training dataset or a 10% subset of the training data."
      }
    ]
  },
  "1601.03313": {
    "title": "Political Speech Generation",
    "abstract": "In this report we present a system that can generate political speeches for a desired political party. Furthermore, the system allows to specify whether a speech should hold a supportive or opposing opinion. The system relies on a combination of several state-of-the-art NLP methods which are discussed in this report. These include n-grams, Justeson&Katz POS tag filter, recurrent neural networks, and latent Dirichlet allocation. Sequences of words are generated based on probabilities obtained from two underlying models: A language model takes care of the grammatical correctness while a topic model aims for textual consistency. Both models were trained on the Convote dataset which contains transcripts from US congressional floor debates. Furthermore, we present a manual and an automated approach to evaluate the quality of generated speeches. In an experimental evaluation generated speeches have shown very high quality in terms of grammatical correctness and sentence transitions.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Many political speeches show the same structures and same characteristics regardless of the actual topic. Some phrases and arguments appear again and again and indicate a certain political affiliation or opinion. We want to use these remarkable patterns to train a system that generates new speeches. Since there are major differences between the political parties we want the system to consider the political affiliation and the opinion of the intended speaker. The goal is to generate speeches where no one can tell the difference to hand-written speeches.",
          "In this report we first discuss related works which deal with similar or related methods. Then we describe and analyze the dataset we use. Next, we present the methods we used to implement our system. We also describe investigated methods that were not used in the final implementation. Then we describe a performed experiment and how we evaluated the results. Finally, we conclude our work and give an outlook. The appendix of this report contains the generated speeches from the experiment."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Creating models for a corpus that allow retrieving certain information is a major part of this project as well as in the entire NLP domain. Blei et al. UID17 present in their paper a model which is known as latent Dirichlet allocation (LDA). LDA has become one of the most popular topic models in the NLP domain. LDA is generative probabilistic model that discovers automatically the underlying topics. Each document is modeled as a mixture of various topics. These topics can be understood as a collection of words that have different probabilities of appearance. Words with the highest probabilities represent the topics.",
          "However, LDA is a bag-of-words model which means that the word orders are not preserved. That means LDA does not capture collocations or multiword named entities. Lau et al. UID18 claim that collocations empirically enhance topic models. In an experiment they replaced the top-ranked bigrams with single tokens, deleted the 200 most frequent terms from the vocabulary and performed ordinary LDA. The results from experiments on four distinct datasets have shown that this bigram-variant is very beneficial for LDA topic models.",
          "F\u00fcrnkranz UID19 has studied the usage of n-grams in the text-categorization domain. He has shown that using bi- and trigrams in addition to the set-of-word representation improves the classification performance significantly. Furthermore, he has shown that sequences longer than three words reduce the classification performance. That also indicates that collocations play a crucial role when it comes to inferring the latent structure of documents.",
          "Cavnar and Trenkle UID20 have also used an n-gram-based approach for text categorization. Their system is based on calculating and comparing profiles of N-gram frequencies. They compute for every category a representing profile from the training data. Then the system computes a profile for a particular document that is to be classified. Finally, the system computes a distance measure between the document\u2019s profile and each of the category profiles and selects the category whose profile has the smallest distance.",
          "Smadja UID21 presents a tool, Xtract, which implements methods to extracts variable-length collocations. The extraction process is done in several stages. In the first stage the system determines the top-ranked bigrams of the corpus. In the second stage Xtract examines the statistical distribution of words and part-of-speech tags around the bigrams from the previous stage. Compounds with a probability above a certain threshold are retained while the others are rejected. In the third stage they enrich the collocations with syntactical information obtained from Cass UID22 . The syntactical information helps to evaluate the candidate collocations and to decide whether they should be rejected or not.",
          "Wang et al UID23 propose a topical n-gram model that is capable of extracting meaningful phrases and topics. It combines the bigram topic model UID24 and LDA collocation model UID25 . One of the key features of this model is to decide whether two consecutive words should be treated as a single token or not depending on their nearby context. Compared to LDA the extracted topics are semantically more meaningful. This model shows also really good results in information retrieval (IR) tasks.",
          "Justeson and Katz UID26 present a method to extract technical terms from documents. Their approach is not restricted to technical terms but applies to all multiword named entities of length two or three. The foundations of their method are bi- and trigrams which have a certain POS tag structure. That is, they extract all bi- and trigrams from the corpus, identify their POS tags and check them against a predefined list of accepted POS tag patterns. In their experiment this method identifies 99% of the technical multiword terms in the test data.",
          "Wacholder UID27 presents an approach for identifying significant topics within a document. The proposed method bases on the identification of Noun Phrases (NPs) and consists of three steps. First, a list of candidate significant topics consisting of all simplex NPs is extracted from the document. Next, these NPs are clustered by head. Finally, a significance measure is obtained by ranking frequency of heads. Those NPs with heads that occur with greater frequency in the document are more significant than NPs whose head occurs less frequently.",
          "Blei and Lafferty UID28 propose their Correlated Topic model (CTM). While LDA assumes all latent topics are independent CTM aims to capture correlations between them. They argue that a document about genetics is more likely also about disease than X-ray astronomy. The CTM builds on the LDA model but they use a hierarchical topic model of documents that replaces the Dirichlet distribution of per-document topic proportions with a logistic normal. According to their results the model gives better predictive performance and uncovers interesting descriptive statistics.",
          "Ivyer et al. UID35 apply Recursive Neural Networks (RNN) to political ideology detection. The RNNs were initialized with word2vec embeddings. The word vector dimensions were set to 300 to allow direct comparison with other experiments. However, they claim that smaller vector sizes (50, 100) do not significantly change accuracy. They performed experiments on two different dataset: the Convote dataset UID41 and the Ideological Books Corpus (IBC) UID37 . They claim that their model outperforms existing models on these two datasets.",
          "There has been a lot of research in the field of Natural Language Generation (NLG). The paper Building Applied Natural Language Generation Systems UID29 discusses the main requirements and tasks of NLG systems. Among others, they investigate a so-called Corpus-based approach. That is, a collection of example inputs is mapped to output texts of the corpus. This is basically what we plan to do because we have already all the speech segments labeled with the political party and the opinion. However, our generator will have a simpler architecture but we will use the described list of tasks as a guideline.",
          "Most NLG systems are designed to create a textual representation of some input data. That is, the input data determines the content. For example SumTime-Mousam UID30 generates a textual weather forecast based on numerical weather simulations. Another example is the ModelExplainer system UID31 which takes as input a specification of an object-oriented class model and produces as output a text describing the model. Other NLG systems are used as authoring aid for example to help personnel officers to write job descriptions UID32 or to help technical authors produce instructions for using software UID33 .",
          "A NLG system that follows a different approach is SciGen UID38 . SciGen is an automatic computer science research paper generator developed by three MIT students. That is, it creates random papers which show actually a very high quality in terms of structuring and lexicalization, and they even include graphs, figures, and citations. SciGen has become pretty famous after some of its generated papers got accepted at conferences and published in journals. In particular, their paper Rooter: A Methodology for the Typical Unification of Access Points and Redundancy raised a lot of attention because it was accepted to the 2005 World Multiconference on Systemics, Cybernetics and Informatics (WMSCI) and the authors were even invited to speak at the conference. SciGen requires as input only the names of the authors; all the content will be generated randomly. Our generator will follow the same approach since we also do not specify the content of the generated speech. The content is determined by the training data and requires no further specification."
        ]
      },
      {
        "section_name": "Data set",
        "paragraphs": [
          "The main data source for this project is the Convote data set UID41 . It contains a total of 3857 speech segments from 53 US Congressional floor debates from the year 2005. Each speech segment can be referred to its debate, its speaker, the speaker\u2019s party and the speaker\u2019s vote which serves as the ground-truth label for the speech. The dataset was originally created in the course of the project Get out the vote UID34 . The authors used the dataset to train a classifier in order to determine whether a speech represents support of or opposition to proposed legislation. They did not only analyze the speeches individually but also investigated agreements and disagreements with the opinions of other speakers. That is, they identified references in the speech segments, determined the targets of those references, and decided whether a reference represents an instance of agreement or disagreement. However, we focus only on the individual speech segments and disregard references.",
          "For our work we have removed single-sentence speeches, HTML-tags and corrected punctuation marks. In order to enable simple sentence splitting we replaced all sentence delimiters by a stop-token. Furthermore, we inserted special tokens which indicate the start and the end of a speech. Then we divided all the speeches into the four classes given by the combination of possible political parties and speech opinions. Table TABREF1 shows the four speech classes and table TABREF2 gives a quantitative overview of the corpus\u2019 content. It can be seen that the classes RY and DN contain the majority of the speeches."
        ]
      },
      {
        "section_name": "Language Model",
        "paragraphs": [
          "We use a simple statistical language model based on n-grams. In particular, we use 6-grams. That is, for each sequence of six consecutive words we calculate the probability of seeing the sixth word given the previous five ones. That allows us to determine very quickly all words which can occur after the previous five ones and how likely each of them is."
        ]
      },
      {
        "section_name": "Topic Model",
        "paragraphs": [
          "For our topic model we use a Justeson and Katz (J&K) POS tag filter for two- and three-word terms UID26 . As suggested by WordHoard UID39 we expanded the list of POS tag patterns by the sequence Noun-Conjunction-Noun. We determined the POS tags for each sentence in the corpus and identified then all two- and three-word terms that match one of the patterns. For the POS tagging we used maxent treebank pos tagging model from the Natural Language Toolkit (NLTK) for Python. It uses the maximum entropy model and was trained on the Wall Street Journal subset of the Penn Tree bank corpus UID40 .",
          "Some of the terms are very generic and appear very often in all classes. In order to find those terms that appear particularly often in a certain class we calculate a significance score. Our significance score INLINEFORM0 is defined by the ratio of the probability of seeing a word INLINEFORM1 in a certain class INLINEFORM2 to the probability to see the word in the entire corpus: INLINEFORM3 ",
          "This significance score gives information about how often a term occurs in a certain class compared to the entire corpus. That is, every score greater than 1.0 indicates that in the given class a certain term occurs more often than average. We consider all phrases which occur at least 20 times in the corpus and have a ratio greater than 1. These terms represent the topics of the corpus. Table TABREF5 lists the top ten topics of each class ordered by their score. All these terms represent meaningful topics and it seems reasonable that there were debates about them."
        ]
      },
      {
        "section_name": "Speech Generation",
        "paragraphs": [
          "For the speech generation one has to specify the desired class which consists of the political party and the intended vote. Based on the selected class the corresponding models for the generation are picked. From the language model of the selected class we obtain the probabilities for each 5-gram that starts a speech. From that distribution we pick one of the 5-grams at random and use it as the beginning of our opening sentence. Then the system starts to predict word after word until it predicts the token that indicates the end of the speech. In order to predict the next word we first determine what topics the so far generated speech is about. This is done by checking every topic-term if it appears in the speech. For every occurring term we calculate the topic coverage INLINEFORM0 in our speech. The topic coverage is an indicator of how well a certain topic INLINEFORM1 is represented in a speech INLINEFORM2 . The following equation shows the definition of the topic coverage: INLINEFORM3 ",
          "We rank all topics by their topic coverage values and pick the top 3 terms as our current topic set INLINEFORM0 . For these 3 terms we normalize the values of the ratios so that they sum up to 1. This gives us the probability INLINEFORM1 of seeing a topic INLINEFORM2 in our current speech INLINEFORM3 of class INLINEFORM4 .",
          "The next step is to find our candidate words. All words which have been seen in the training data following the previous 5-gram are our candidates. For each candidate we calculate the probability of the language model INLINEFORM0 and the probability of the topic model INLINEFORM1 .",
          " INLINEFORM0 tells how likely this word is to occur after the previous 5 ones. This value can be directly obtained by the language model of the specified class. INLINEFORM1 tells how likely the word w is to occur in a speech which covers the current topics INLINEFORM2 . The following equation shows the definition of INLINEFORM3 where INLINEFORM4 denotes our dataset and INLINEFORM5 is the subset containing only speeches of class INLINEFORM6 . INLINEFORM7 ",
          "The factor INLINEFORM0 prevents divisions by zero is set to a very small value ( INLINEFORM1 ). The probabilities for all candidate words are normalized so that they sum up to 1.",
          "With the probabilities from the language model and the topic model we can now calculate the probability of predicting a certain word. This is done by combining those two probabilities. The weighting factor INLINEFORM0 balances the impact of the two probabilities. Furthermore, we want to make sure that a phrase is not repeated again and again. Thus, we check how often the phrase consisting of the previous five words and the current candidate word has already occurred in the generated speech and divide the combined probability by this value squared plus 1. So if this phrase has not been generated yet the denominator of this fraction is 1 and the original probability remains unchanged. The following equation shows how to calculate for a word INLINEFORM1 the probability of being predicted as next word of the incomplete speech INLINEFORM2 : INLINEFORM3 ",
          "From the distribution given by the normalized probabilities of all candidate words we pick then one of the words at random. Then the whole procedure starts again with assessing the current topics. This is repeated until the end-of-speech token is generated or a certain word limit is reached.",
          "Instead of using the probability distribution of the candidates we could have also just picked the word with the highest probability. But then the method would be deterministic. Using the distribution to pick a word at random enables the generator to produce every time a different speech."
        ]
      },
      {
        "section_name": "Alternative Methods",
        "paragraphs": [
          "In this section we present some alternative approaches which were pursued in the course of this project. These methods have not shown sufficiently good results and were therefore not further pursued."
        ]
      },
      {
        "section_name": "Recurrent Neural Networks",
        "paragraphs": [
          "Instead of using n-grams we also considered using Recurrent Neural Networks (RNN) as language models. Our approach was heavily based on the online tutorial from Denny Britz UID42 . The RNN takes as input a sequence of words and outputs the next word. We limited the vocabulary to the 6000 most frequent words. Words were represented by one-hot-encoded feature vectors. The RNN had 50 hidden layers and used tanh as activation function. For assessing the error we used cross-entropy loss function. Furthermore we used Stochastic Gradient Descent (SGD) to minimize the loss and Backpropagation Through Time (BPTT) to calculate the gradients.",
          "After training the network for 100 time epochs ( INLINEFORM0 14 h) the results were still pretty bad. Most of the generated sentences were grammatically incorrect. There are many options to improve the performance of RNNs but due to the good performance shown by n-grams, the time-consuming training, and the limited time for this project we have decided to not further purse this approach."
        ]
      },
      {
        "section_name": "Latent Dirichlet Allocation",
        "paragraphs": [
          "As alternative to the J&K POS tag filter we used LDA as topic model. In particular we used the approach from Lau et al. UID18 . That is, we removed all occurrences of stop words, stemmed the remaining words, replaced the 1000 most-frequent bigrams with single tokens, and deleted the 200 most frequent terms from the vocabulary before applying ordinary LDA. Since our dataset contains speech segments from 53 different debates we set the number of underlying topics to 53. Some of the results represented quite meaningful topics. However, the majority did not reveal any useful information. Table TABREF9 shows some examples of good and bad results from LDA. It can be seen that the extracted terms of the bad examples are very generic and do not necessarily indicate a meaningful topic."
        ]
      },
      {
        "section_name": "Sentence-based approach",
        "paragraphs": [
          "For the speech generation task we have also pursued a sentence-based approach in the beginning of this project. The idea of the sentence-based approach is to take whole sentences from the training data and concatenate them in a meaningful way. We start by picking a speech of the desired class at random and take the first sentence of it. This will be the start sentence of our speech. Then we pick 20 speeches at random from the same class. We compare our first sentence with each sentence in those 20 speeches by calculating a similarity measure. The next sentence is than determined by the successor of the sentence with the highest similarity. In case no sentence shows sufficient similarity (similarity score below threshold) we just take the successor of our last sentence. In the next step we pick again 20 speeches at random and compare each sentence with the last one in order to find the most similar sentence. This will be repeated until we come across the speech-termination token or the generated speech reaches a certain length.",
          "The crucial part of this method is the measure of similarity between two sentences. Our similarity is composed of structural and textual similarity. Both are normalized to a range between 0 and 1 and weighted through a factor INLINEFORM0 . We compute the similarity between two sentences INLINEFORM1 and INLINEFORM2 as follows: INLINEFORM3 ",
          "For the structural similarity we compare the POS tags of both sentences and determine the longest sequence of congruent POS tags. The length of this sequence, normalized by the length of the shorter sentence, gives us the structural similarity. The structural similarity measure aims to support smooth sentence transitions. That is, if we find sentences which have a very similar sentence structure, it is very likely that they connect well to either of their following sentences. The textual similarity is defined by the number of trigrams that occur in both sentences, normalized by the length of the longer sentence. This similarity aims to find sentences which use the same words.",
          "The obvious advantage of the sentence-based approach is that every sentence is grammatically correct since they originate directly from the training data. However, connecting sentences reasonable is a very challenging task. A further step to improve this approach would be to extend the similarity measure by a topical similarity and a semantic similarity. The topical similarity should measure the topical correspondence of the originating speeches, while the semantic similarity should help to find sentences which express the same meaning although using different words. However, the results from the word-based approach were more promising and therefore we have decided to discard the sentence-based approach."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "This section describes the experimental setup we used to evaluate our system. Furthermore, we present here two different approach of evaluating the quality of generated speeches."
        ]
      },
      {
        "section_name": "Setup",
        "paragraphs": [
          "In order to test our implemented methods we performed an experimental evaluation. In this experiment we generated ten speeches, five for class DN and five for class RY. We set the weighting factor INLINEFORM0 to 0.5 which means the topic and the language model have both equal impact on predicting the next word. The quality of the generated speeches was then evaluated. We used two different evaluation methods: a manual evaluation and an automatic evaluation. Both methods will be described in more detail in the following paragraphs of this section. The generated speeches can be found in the appendix of this report."
        ]
      },
      {
        "section_name": "Manual Evaluation",
        "paragraphs": [
          "For the manual evaluation we have defined a list of evaluation criteria. That is, a generated speech is evaluated by assessing each of the criterion and assigning a score between 0 and 3 to it. Table TABREF13 lists all evaluation criteria and describes the meaning of the different scores."
        ]
      },
      {
        "section_name": "Automatic Evaluation",
        "paragraphs": [
          "The automatic evaluation aims to evaluate both the grammatical correctness and the consistency of the speech in terms of its content. For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually.",
          "In order to evaluate the content of the generated speech we determine the mixture of topics covered by the speech and order them by their topic coverage. That gives us information about the primary topic and secondary topics. Then we do the same for each speech in our dataset which is of the same class and compare the topic order with the one of the generated speech. We sum up the topic coverage values of each topic that occurs in both speeches at the same position. The highest achieved value is used as evaluation score. That is, finding a speech which covers the same topics with the same order of significance give us a score of 1."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "In this section we present the results from our experiments. Table TABREF15 shows the results from the manual evaluation. Note that each criterion scores between 0 and 3 which leads to a maximum total score of 12. The achieved total score range from 5 to 10 with an average of 8.1. In particular, the grammatical correctness and the sentence transitions were very good. Each of them scored on average 2.3 out of 3. The speech content yielded the lowest scores. This indicates that the topic model may need some improvement.",
          "Table TABREF16 shows the results from the automatic evaluation. The automatic evaluation confirms pretty much the results from the manual evaluation. Most of the speeches which achieved a high score in the manual evaluation scored also high in the automatic evaluation. Furthermore, it also confirms that the overall the grammatical correctness of the speeches is very good while the content is a bit behind."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this report we have presented a novel approach of training a system on speech transcripts in order to generate new speeches. We have shown that n-grams and J&K POS tag filter are very effective as language and topic model for this task. We have shown how to combine these models to a system that produces good results. Furthermore, we have presented different methods to evaluate the quality of generated texts. In an experimental evaluation our system performed very well. In particular, the grammatical correctness and the sentence transitions of most speeches were very good. However, there are no comparable systems which would allow a direct comparison.",
          "Despite the good results it is very unlikely that these methods will be actually used to generate speeches for politicians. However, the approach applies to the generation of all kind of texts given a suitable dataset. With some modifications it would be possible to use the system to summarize texts about the same topic from different source, for example when several newspapers report about the same event. Terms that occur in the report of every newspaper would get a high probability to be generated.",
          "All of our source code is available on GitHub UID43 . We explicitly encourage others to try using, modifying and extending it. Feedback and ideas for improvement are most welcome."
        ]
      },
      {
        "section_name": "Generated speeches from experiment",
        "paragraphs": [
          "__START__ mr. speaker , i thank my colleague on the committee on rules . i rise in full support of this resolution and urge my colleagues to support this bill and urge my colleagues to support the bill . mr. speaker , supporting this rule and supporting this bill is good for small business . it is great for american small business , for main street , for jobs creation . we have an economy that has created nearly 2 million jobs in the past couple of months : apparel , textiles , transportation and equipment , electronic components and equipment , chemicals , industrial and commercial equipment and computers , instruments , photographic equipment , metals , food , wood and wood products . virtually every state in the union can claim at least one of these industrial sectors . in fact , one young girl , lucy , wanted to make sure that the economy keeps growing . that should not be done on borrowed money , on borrowed time . it should be done with a growing economy . it is under this restraint , with this discipline , that this budget comes before the house , and we should honor that work . __END__",
          "__START__ mr. speaker , for years , honest but unfortunate consumers have had the ability to plead their case to come under bankruptcy protection and have their reasonable and valid debts discharged . the way the system is supposed to work , the bankruptcy court evaluates various factors including income , assets and debt to determine what debts can be paid and how consumers can get back on their feet . stand up for growth and opportunity . pass this legislation . __END__",
          "__START__ mr. speaker , i yield back the balance of my time , and i want to commend , finally , the chairman of the committee , there will be vigorous oversight of the department of justice on a regular and on a timely basis , and the answer to how many civil liberties violations have been proven is none . repeatedly they have said there are no civil liberties violations that the inspector general has been able to uncover . further , i resisted a premature repeal or extension of the sunset prior to this congress because i felt it was important that the oversight be done for as long a time as possible so that the congress will be able to vote and a decision can be made today . mr. speaker , i reserve the balance of my time , and i want to thank the gentleman from texas for helping put together this package and for all the work that he and his staff put into this bill . this was an important thing for us to go through , and i think that we produced a good bill at the end of that dark ally over there . and the gentleman says : because there is more light over here . sometimes i think the way we look at these medical issues , instead of looking at the cost savings involved with prevention , we simply are able to look at how much it saves in the long run . again , i look at such things as if we are able to have more people go to federally approved health centers , community health centers in their community instead of showing up in the emergency departments , yes , it may cost money ; the president called for a couple billion dollars to put into those community health centers . but if it is going to relate to state law , that is the discussion that needs to take place . my state may have lucked out because a clerical error in this particular case did not refer specifically to the utah state law ; and , therefore , it may not be applicable . but the fear factor is still there , that in the future he continue that policy . __END__",
          "__START__ mr. speaker , for years , honest but unfortunate consumers have had the ability to plead their case to come under bankruptcy protection and have their reasonable and valid debts discharged . the way the system is supposed to work , the bankruptcy court evaluates various factors including income , assets and debt to determine what debts can be paid and how consumers can get back on their feet , they need to have money to pay for child care . they need transportation . it allows them to get reestablished , and we think this is certainly very helpful . and then it also allows faith-based organizations to offer job training service . we think this is critical and has great potential . at the present time , brazil mandates 23 percent of their fuel supply be from ethanol . we certainly could hit 7 or 8 percent in this country . mr. speaker , this is a very modest proposal . i think it is important that this resolution be considered quickly , so that members may be appointed to the task force and can begin their work and produce a report by june 2006 . __END__",
          "__START__ mr. speaker , i yield myself the time remaining . mr. speaker , i rise today in support of the rule on h.r. 418 . our nation's immigration policy has been of top concern in recent years , and for good reason . with between eight and twelve million illegal aliens in the united states , the late ronald wilson reagan , enshrined these three words as part of american policy : trust but verify . the legislation on the floor today deals with verification . i say as one who opposed a trading agreement with china that this legislation brings the monitoring capacity necessary to understand what happens in international trade . simply stated , madam speaker , if you want to cut those things , you can put it in your program . if you do not like that , you better go out and lobby against what they are doing in in vitro fertilization clinics throughout the u.s. , about 2 percent are discarded annually \u2013 that is about 8 , 000 \u2013 11 , 000 embryos that could be slated for research . allowing the option of donating these excess embryos to research is similar to donating organs for organ transplantation in order to save or improve the quality of another person's life . the bottom line is that class-action reform is badly needed . currently , crafty lawyers are able to game the system by filing large , nationwide class-action suits in certain preferred state courts such as madison county , illinois , where judges are quick to certify classes and quick to approve settlements that give the lawyers millions of dollars in fees . this problem will be addressed by providing greater scrutiny over settlements that involve coupons or very small cash amounts . this legislation also ensures that deserving plaintiffs are able to make full use of the class action system . it allows easier removal of class action cases to federal courts . this is important because class actions tend to affect numerous americans and often involve millions of dollars . federal court is the right place for such large lawsuits . moving more class actions to federal courts also prevents one of the worst problems in class actions today , forum shopping . mr. speaker , while many concessions were made on both sides , this is still a very worthwhile bill that contains many good reforms , and i fully support it and look forward to its enactment into law and also encourage my colleagues to support this bill . __END__",
          "__START__ mr. speaker , i yield 2 minutes to the gentleman from illinois ( mr. hyde ) , my dear friend , with whom i agree on some things but not on this issue , although the majority of the bill i know is consistent with the gentleman from california's ( mr. lantos ) and the gentleman from virginia with their very wise substitute give a chance to help the consumer and declare energy independence . i also want to point out that this bill is far from perfect . in many respects it is troubling . this congress has a proven history of lax oversight of the administration , and there is a difference . __END__",
          "__START__ mr. speaker , the gentleman is absolutely right . the amazing thing to me when i was listening to the republicans in the last hour is when they were trying to make the analogy to their households and talking about their kids . and one of the most significant broken promises is in the area of making higher educational opportunities more available to minority and low-income students . i am so proud of the fact that every iraqi school child on the opening day of school had received a book bag with the seal of the u.s. , pencils , pads , all kinds of things , free of charge . i had just come back from iraq , and they had been there on the first day of this new congress , the republican majority is publicly demonstrating what has been evident for some time , and that is its arrogance , its pettiness , its shortsighted focus on their political life rather than to decide how we are each of us fit to govern . here is the thing . we have this rules package before us . they did some flash last night so that the press is saying , oh , they blinked . they did blink on a couple of different scores , but the fundamental challenge to the ethical standard of the house being enforced is still in this rules package are destructive , and they are unethical . mr. speaker , i reserve the balance of my time . mr. chairman , this bill frightens me . it scares me . i would hope that we could deal with this in as bipartisan a fashion as possible so that when we send it to the other body that we may have more success there , more success out of conference , and send a bill to the president that will facilitate both energy independence and the effective and efficient discovery , development , and delivery at retail to the consumer of energy options . i do not know if politics was part of that . maybe someone can answer that question . but therein lies the problem , that from time to time need to be recognized . that is what this is about . this bill is opposed by every consumer group , by all the bankruptcy judges , the trustees , law professors , by all of organized labor , by the military groups , by the civil rights organizations , and by every major group concerned about seniors , women , and children are dead ; the fact that hundreds of thousands more have become evacuees in the richest country in the world . our children will then be forced to live with the consequences of an undereducated workforce , a weak economy , and a society where good health and social justice are only afforded to the most privileged . mr. speaker , i reserve the balance of my time to read the resolution that i believe ought to be before us , mr. speaker . the president has a credibility gap when it comes to iraq . we have been misled too often , and it is time to go back and revisit those. \u201d i would remind the house that it was widely pointed out when that legislation was before us what a remarkable example of bipartisanship and legislative cooperation it was . of course , the defense appropriations bill is of great interest to our members . __END__",
          "__START__ mr. speaker , i rise today in opposition to the labor , health and human services and education appropriations conference report before us . one month ago , the house of representatives voted this bill down because it failed to address the priorities of the american people : good jobs , safe communities , quality education , and access to health care . with over 7 million americans out of work . yet the bill cuts $ 437 million out of training and employment services . that is the lowest level of adult training grants in a decade . this bill also cuts the community college initiative , the president's initiative for community colleges , an effort to train workers for high-skill , high-paying jobs . it cuts that effort by INLINEFORM0 125 million from funds provided last year , denying the help that the president was talking about giving to 100 , 000 americans of a continued education to help them get a new job . this bill also cuts job search assistance through the employment service by 11 percent and cut state unemployment insurance and employment service offices are cut $ 245 million eliminating help for 1.9 million people . this bill is no better for those attending college full-time . despite the fact that college costs have increased by $ 3 , 095 , 34 percent , since 2001 . consumers are expected to pay 52 percent more for natural gas , 30 percent more for home heating oil , you are expected to pay three times as much as you did 4 years ago , the first year president bush took office . winter is around the corner , and so are skyrocketing increases in home heating costs . families who heat with natural gas could see their fuel costs increase more than 70 percent in some parts of the country . this honorable response to the tragedy of september 11 puts to shame what has been proposed today in the wake of hurricane katrina , that the workers in the afflicted area who are trying to put that area back together are not even going to be allowed to get a decent prevailing wage that they would otherwise be guaranteed under davis-bacon . and yet while it is chiseling on the wages of those workers , it is bad for those countries that desperately need a middle class , it is bad for those workers , it is saying to the persons who make over $ 400 , 000 a year , and we roll back cuts on the top 2 percent of americans , and by doing so , we have saved almost $ 47 billion that we have used to invest in the human assets of this country , the american people . __END__",
          "__START__ mr. speaker , i yield 2 minutes to the gentlewoman from california ( mrs. capps ) pointed out , after the knowledge was available and was continued to pursue the use of this compound as an additive to the fuels of our automobiles . those communities now are stuck with the costs of either cleaning up that drinking water supply , finding an alternative source and dealing with it , and they must do so . to suggest now that we are going to be giving to seniors , to keep them in nursing homes with alzheimer's and with parkinson's disease , just keep cutting it . give more tax breaks to the richest one-tenth of 1 percent . they call it the death tax . i think that is a flaw in the bill . that leads to the second point . the bill specifically mentions weight gain and obesity . well , i think most of us have a sense of what obesity is . weight gain is a whole different issue , and weight gain may occur not from obesity , not from getting fat , not from putting on too many calories ; weight gain can occur for a variety of medical reasons related to a variety of different causes . for example , i mean probably all of us have had a mom or a grandmom or an uncle to whom we say , hey , i noticed your legs are swelling again . fluid retention . fluid retention . now , that can be from a variety of causes . that is not from increased caloric intake . that could have been , for example , from a food additive , maybe a cause that was not known to the public of some kind of additive in something that they had eaten or drank . it may have been something that interfered with one of their medications and led to fluid retention . i am just making up hypotheticals here . or , the hypothetical , perhaps you have something that is actually a heart poison from some food additive that has no calories in it , zero calories in it , but over a period of time does bad things to the ability of under this bill , which i believe is absolutely essential for our health system . at a time when our country has been severely impacted by natural disasters , it is extremely urgent that congress maintain csbg funding at its current level so that the delivery of much needed services to low-income people is not disrupted . we have a responsibility to protect our environment \u2013 as well as the diverse forms of life that share it . the bipartisan substitute will help us achieve the goal . i urge my colleagues on both sides of the aisle to protect the benefits that our constituents earned and deserve and to prevent the increase in the number of frivolous filings . __END__",
          "__START__ mr. speaker , i yield 2 minutes to the gentlewoman from texas ( ms. jackson-lee ) , the gentleman from new jersey ( mr. andrews ) , for the leadership he has shown on this issue . here we are again , mr. speaker . year after year after year trying to get into federal court . what it also does is minimizes the opportunity of those who can secure their local lawyer to get them into a state court and burdens them with the responsibility of finding some high-priced counsel that they can not afford to buy food . seven million more people , an increase of 12 percent , and what does this combination of reconciliation in order to give tax cuts to people making more than $ 500 , 000 . footnote right there . what about the committees of jurisdiction already in existence in congress . and what about creating a circus atmosphere that drains resources from this congress do you not understand . shamefully , the house will not have an opportunity to vote on the hastings-menendez independent katrina commission legislation , because republicans have blocked us from offering it . just as they always do , republicans block what they can not defeat . despite what republicans will suggest , today's debate is not about politics . it is about the need for truth to assure the american people that we will not allow their retirement checks to be slashed to pay for private accounts . it is time for congress , as part of the national marine sanctuary program , but there have been no hearings on this bill or any other bill to protect our oceans . let us reject this unnecessary task force and get down to some real work . mr. speaker , i reserve the balance of my time to the gentleman from maryland ( mr. cardin ) , who is the ranking member , was part and parcel of that , as well as the gentleman from virginia ( chairman tom davis ) is trying to do to improve the integrity of driver's licenses , but i find it interesting that the state of utah , while the gentleman from utah ( mr. bishop ) is arguing that they are not getting enough money for education , the state of utah legislature passed measures saying they do not want any kind of investigation of themselves . the republicans control the white house , they control the senate , and they control the house of representatives . mr. speaker , is it possible for us to let this young woman take her leave in peace . __END__"
        ]
      }
    ],
    "qas": [
      {
        "question": "how did they measure grammatical correctness?",
        "question_id": "e6204daf4efeb752fdbd5c26e179efcb8ddd2807",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Identify  POS tags for each sentence,  check whether one sentence from the corpus has the same sequence of POS tags. If the same POS sequence has been found, that points in a certain direction, if not found, the evaluation for that sentence is performed manually.",
              "evidence": [
                "The automatic evaluation aims to evaluate both the grammatical correctness and the consistency of the speech in terms of its content. For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually."
              ],
              "highlighted_evidence": [
                " For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually."
              ]
            },
            "annotation_id": "7c486b4dfbafa9d4aa3077a0c12279b547e54299",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "They measure grammatical correctness by checking whether a sentence has the same sequence of POS tags.",
              "evidence": [
                "The automatic evaluation aims to evaluate both the grammatical correctness and the consistency of the speech in terms of its content. For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually."
              ],
              "highlighted_evidence": [
                "For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags."
              ]
            },
            "annotation_id": "c9d85431b4105999d7a2f194acb5e92a2963d2d8",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "identify for each sentence of the speech its POS tags",
                "Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct.",
                "points in a certain direction",
                "evaluate those sentences manually"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "The automatic evaluation aims to evaluate both the grammatical correctness and the consistency of the speech in terms of its content. For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually."
              ],
              "highlighted_evidence": [
                "For evaluating the grammatical correctness we identify for each sentence of the speech its POS tags. Then we check all sentences of the entire corpus whether one has the same sequence of POS tags. Having a sentence with the same POS tag structure does not necessarily mean that the grammar is correct. Neither does the lack of finding a matching sentence imply the existence of an error. But it points in a certain direction. Furthermore, we let the system output the sentence for which it could not find a matching sentence so that we can evaluate those sentences manually."
              ]
            },
            "annotation_id": "ed3c99d4882a1ff3a81cd05950800c39ba0ee232",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1: Speech classes"
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Corpus overview"
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Top topics per class"
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Results from LDA"
      },
      {
        "file": "8-Table5-1.png",
        "caption": "Table 5: Evaluation criteria"
      },
      {
        "file": "9-Table6-1.png",
        "caption": "Table 6: Results from manual evaluation"
      },
      {
        "file": "9-Table7-1.png",
        "caption": "Table 7: Results from automatic evaluation"
      }
    ]
  },
  "1911.12848": {
    "title": "Sentiment Analysis On Indian Indigenous Languages: A Review On Multilingual Opinion Mining",
    "abstract": "An increase in the use of smartphones has laid to the use of the internet and social media platforms. The most commonly used social media platforms are Twitter, Facebook, WhatsApp and Instagram. People are sharing their personal experiences, reviews, feedbacks on the web. The information which is available on the web is unstructured and enormous. Hence, there is a huge scope of research on understanding the sentiment of the data available on the web. Sentiment Analysis (SA) can be carried out on the reviews, feedbacks, discussions available on the web. There has been extensive research carried out on SA in the English language, but data on the web also contains different other languages which should be analyzed. This paper aims to analyze, review and discuss the approaches, algorithms, challenges faced by the researchers while carrying out the SA on Indigenous languages.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "SA is the process of extracting the opinions of people and use it to understand the people\u2019s attitude, reactions expressed on the web regarding the various issues in the world and is also known as opinion mining. Nowadays with the increasing use of the internet a lot of information is available on the web which is about the different products, movies, books, technologies etc. People express their views, opinions etc on the different products,services,books etc on the web. For e.g. customer has bought a smart phone, as soon as the customer starts using the phone, he/she gives the feedback about whether they liked the phone, which features they liked or disliked. This type of reviews or feedback from the customers or users have become a boon to the industry. These views can help the industry or a company to improve their services i.e. if the reviews are negative then the aspects can be improved and if the reviews are positive, then that aspect can be kept in mind while creating a newer version of the service.",
          "According to the authors Medagoda et al. BIBREF0 there has being a continuous research going on in the English language but the research carried out in the indigenous languages is less. Also, the researches in indigenous languages follow the techniques used for the English language but this has one disadvantage which is, techniques have properties which are specific to a language. Hence It is really important to understand and analyze Indigenous language data because it can give meaningful insights to the companies. For example, India and China have world's largest population and are rich in diverse languages, analysing these indigenous language will be useful to companies because they have large share of users in India and China. In the current study, the types of languages i.e. indigenous languages and code mix languages are discussed prior to the approaches, methodologies used by the researchers and challenges faced by them."
        ]
      },
      {
        "section_name": "Introduction ::: Indigenous Languages",
        "paragraphs": [
          "Indigenous languages are the languages that are native to a region or spoken by a group of people in a particular state. It is not necessarily a national language. For e.g. Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil are the indigenous languages."
        ]
      },
      {
        "section_name": "Introduction ::: Code Mix Languages",
        "paragraphs": [
          "Code-mixing is mixing two or more languages while communicating in person or over the web. Code-mixing is basically observed in the multilingual speakers. Code-mixed languages are a challenge to the sentiment analysis problem. A classic example of the code-mix language is Hinglish which is combination of English and Hindi words present in a sentence. Hinglish is widely used language in India to communicate over the web. For e.g. movie review in Hinglish is \u201cyeh movie kitni best hai.. Awesome.\u201d In this sentence movie, best and awesome are English words but the remaining words are Hindi words, so the language identification becomes the first step in code mix languages followed by the SA which indirectly increases the overhead for the researchers and becomes time consuming process.",
          "The remaining paper is structured as follows. Section II explains about the the process carried out in SA. Section III describes about SA levels and the different work done in each level. Section IV is about the current trending techniques in Natural Language Processing(NLP). Section V describes about the data-sets used by the researchers. Section VI explains about the SA techniques and the work done by the researchers using the different techniques. Section VII is about the challenges and limitations faced by the researches. Section VIII is the discussions and analysis about the papers been studied. Section IX is conclusion and future scope."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process",
        "paragraphs": [
          "The process of SA is carried out in 6 major steps which are data extraction, annotation, pre-processing, feature extraction, modelling, evaluation. Figure FIGREF3 shows the steps in the SA task and the explanation of each step is as follows."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Data Extraction",
        "paragraphs": [
          "The first step of any SA task is data extraction. The data can be extracted either manually or automatically. Different web scraping algorithms help in automatically extracting the data from the web. One of the popular web scraping technique is Text pattern matching, which extracts only the information which matches the search criteria mentioned in the algorithm. Also, different Application Programming Interface (API) offered by social media platforms like Twitter, YouTube, Facebook etc. help in the data extraction process."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Annotation",
        "paragraphs": [
          "Once the data extraction step is completed it is important to label the data. Annotation is process to add comments, observations, notes, questions related to the data at a particular point in the document. Labeling is a part of annotation and is used to classify the data as positive, negative or neutral. Labelling can be carried out manually or automatically. Majority of the researchers have done manual labelling on the dataset BIBREF1, BIBREF2. Data collected from the web is raw and unstructured. It is essential for the researchers to carry out the pre-processing step which is as follows."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Pre-processing",
        "paragraphs": [
          "Pre-processing is the process of converting the raw and unstructured data into the understandable and structured form. There are 3 major steps which are involved in pre-processing which are data cleaning, data transformation, data reduction. Each step is explained as follows."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Pre-processing ::: Data Cleaning",
        "paragraphs": [
          "In this step the missing values and the noisy data is handled. Missing values in the data can be handled by filling the missing values manually or by finding the attribute mean or probability values. Noisy data can be due to data collection , data entry errors.Noisy data can be handled by using clustering algorithm. In clustering algorithm similar data is grouped together to form one cluster and the noisy data which is usually an outlier lies outside the clusters."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Pre-processing ::: Data Transformation",
        "paragraphs": [
          "Data is sometimes not in the suitable form for mining process therefore some type of transformation is required. Normalization, attribute derivation are ways of data transformation. Normalization is a process of scaling the data values in a specific scale ( 0 to 1 , -1 to 1). Attribute derivation is process of extracting the data from multiple attributes and creating new attribute. For e.g. age can be a derived attribute from the date of birth of customer."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Pre-processing ::: Data Reduction",
        "paragraphs": [
          "Data which is available on the web is huge. In order to process the data lot of efforts and time is required. There are some attributes in the data which are not that important and can be removed. Data reduction process can be carried out using attribute selection, numerosity reduction technique. Attribute selection is a process of selecting only the important and relevant attributes from the dataset and discarding the remaining attributes. Numerosity reduction stores the model of the data instead of the whole data. There are different pre-processing techniques used by the researchers and the most common ones are tokenization, stop-word removal, Parts Of Speech Tagging (POS), stemming and lemmatization. Tokenization splits the data into individual words known as tokens BIBREF3. Tokenization can be explained using Figure FIGREF10 which is as follows.",
          "Stop words are frequent words used in the sentences. Removal of stop words will not effect the sentiment polarity. Common stop words for English language are \u201cis\u201d, \u201cwas\u201d, \u201cthere\u201d, \u201cthat\u201d, \u201cthey\u201d,\u201d he\u201d,\u201d she\u201d etc. POS tagging is the technique where the words are tagged based on the parts of speech they are present in . For e.g. \u201c She is beautiful\u201d for this sentence the POS Tagger will tag words as follows \u2018She\u2019- pronoun , \u2018is\u2019- verb , \u2018beautiful\u2019- adjective BIBREF3.",
          "Stemming is the process to reduced words to the root form by removing the suffix and the prefix present in the word. For e.g. \u201coccurring\u201d is the word the stem form of it is \u201coccur\u201d because the suffix \u201cing\u201d is removed from it. One disadvantage of stemming is that sometimes the words do not have any dictionary meaning.",
          "Lemmitization solves the problem of stemming. It first tries to find the root form of the word and then only the prefix and suffix of the words are removed. For e.g \u201cleaves\u201d is the word. The stem form of it is \u201cleav\u201d and the lemmitized form of it is \u201cleaf\u201d.",
          "Different feature extraction techniques can be applied on this pre-processed data which is explained in detail as follow."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Data Vectorization",
        "paragraphs": [
          "Text vectorization is the process of converting the textual attributes into the numeric format. Machine learning algorithms usually work with the numeric data and hence there is a need to convert the textual data into the numeric or vector format. The most common vectorization techniques are bag of words, Term Frequency and Inverse Term frequency (TF-IDF) and count vectorizer. Bag-of-Words (BOW) is the most common vectorization technique. In this technique the pre-defined list of words i.e BOW is maintained and the words in the BOW are compared to the sentences. If the word in the sentence is present in the BOW list, it is marked as 1 else it is marked as 0. The vector created is of the size of the BOW. Figure FIGREF12 explains the BOW in detail.",
          "TF-IDF is the very common feature extraction technique. It is a statistical measure to find how important the word is in the document. Term Frequency (TF) calculates the occurance of the word in the single document by the total number of words in the document, where as inverse term frequency (IDF) tries to find how important the word is in all documents BIBREF4.",
          "Statistically TF and IDF are represented in equations DISPLAY_FORM13 and DISPLAY_FORM14 respectively.",
          "Count Vectorization is a vectorization technique in which a document matrix is maintained. The document matrix contains the words present in each document with the frequency of occurrence of that word in the document. Figure FIGREF15 explains the count vectorization with an example."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Classification Techniques",
        "paragraphs": [
          "Classification of the data can be done by 3 approaches which are machine learning approach, lexicon based approach, rule based approaches."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Classification Techniques ::: Machine Learning approaches",
        "paragraphs": [
          "These are the approaches in which different supervised, unsupervised and semi-supervised learning algorithms are applied on the dataset to carry out the analysis and predictions."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Classification Techniques ::: Lexicon based approach",
        "paragraphs": [
          "In this approach the dictionary or corpora is used to carry out the SA task. In this approach the dictionary or the corpus words have polarity values assigned to each one of them. The words in the dataset are searched in the lexicon and if the word match is found the polarity of the word is assigned. For e.g the task is to find out the list of computer programming languages in the sentences which can be done using lexicon based approach by maintaining the predefined list of the programming language as a dictionary and then searching the words from the sentences in it."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Classification Techniques ::: Rule based approach",
        "paragraphs": [
          "It is the traditional approach in which the set of rules are defined to carry out the SA task. For e.g the task is to find out the list of computer programming languages in the sentences. The rule developers scan the sentences and try to define rules which can perfectly predict the languages. Rule defined by developers is to extract all the capital words in the sentence except the first capital word. Test sentence is \u201cLanguage above is Python\u201d. The rule based approach will correctly identify the language but it will be failed when the sentence is \u201cJava is programming language\u201d.",
          "Figure FIGREF20 represents the different classification techniques."
        ]
      },
      {
        "section_name": "Sentiment Analysis Process ::: Evaluation",
        "paragraphs": [
          "Once the model is validated and the results are available the different models are evaluated using different performance metrics. The most common performance evaluation metrics are accuracy , precision , recall , F1-score.",
          "Accuracy:",
          "It is the number of correct predictions over the total number of the instances of data BIBREF4.",
          "Precision:",
          "It is the number of the correct positive results over the total number of positive predicted results BIBREF4.",
          "Recall:",
          "It is number of correct predicted results over the total number of actual positive results BIBREF4.",
          "F1 score:",
          "It is the weighed average of precision and recall BIBREF4.",
          "Statistically accuracy, precision, recall and F1-score are represented in equations DISPLAY_FORM26, DISPLAY_FORM27, DISPLAY_FORM28, DISPLAY_FORM29 respectively.",
          "where , TP = Truly predicted positives, TN = Truly predicted negatives , FP = Falsely predicted positives , FN = Falsely predicted negatives."
        ]
      },
      {
        "section_name": "Sentiment Analysis Levels",
        "paragraphs": [
          "SA can be carried out at 3 levels. document level, sentence level and aspect level."
        ]
      },
      {
        "section_name": "Sentiment Analysis Levels ::: Document Level",
        "paragraphs": [
          "In this process the SA is carried out on the document or paragraph as a whole. Whenever a document is about a single subject it is best to carry out document level SA. Examples of document level SA datasets are speeches of the word leaders, movie review, mobile review etc.",
          "SentiWordNet(SWN) is a opinion based lexicon derived from the WordNets. WordNets are the lexical database which consist of words with short definition and example. SWN consist of dictionary words and the numeric positive and negative sentiment score of each word. WordNets and SWNs are researchers common choice when carrying out SA on document level. Pundlik et al. BIBREF5 were working on multi-domain Hindi language dataset. The architecture implemented in the paper BIBREF5 contained two steps. Domain classification which was the first step was performed using ontology based approach. Sentiment classification being the second step was performed using HNSW and Language Model (LM) Classifier. There was a comparative study done on the results by the HNSW and HNSW + LM Classifiers. The combination of HNSW and LM Classifier gave better classification results as compared to HNSW BIBREF5.",
          "The work by Yadav et al. BIBREF6 showed that SA for the mix-Hindi language can be performed using three approaches. The first approach was to perform classification based on neural network on the predefined words. Second approach used IIT Bombay HNSW. Third approach performed classification using neural network on the predefined Hindi sentences. The approaches in BIBREF6 are explained in detail as follows. The first approach maintained the positive and negative word list. The mix-Hindi words were converted into pure Hindi words and were searched in the positive and negative list which was created manually. If the word was found in the positive word list the positive word count was incremented and if the negative word was found the negative word counter was incremented. In second approach instead of the positive and negative word list the HNSW was used remaining all the steps were same as in the first approach. In third approach seven features were created and applied on the sentences. The features are as follows, to find the frequency of the word, adjective, noun, verb, adverb, total positive polarity and negative polarity of the sentence. These features were send to the neural network for testing and the polarity of the word was detected. After the comparison of all approaches it was found that the second approach had the best accuracy which was 71.5%.",
          "Ansari et al. BIBREF7 introduced an architecture for two code mix languages Hindi and Marathi. The architecture included language identification, feature generation and sentiment classification as major steps. Hindi and English WordNet\u2019s and SWNs were used as there was no SWN for Marathi. The Marathi words were first translated into English and the sentiment score of the English words were found and assigned to the words. Also, classification algorithms like Random Forest, Na\u00efve Bayes, Support Vector Machine (SVM) were used for finding the polarity in the final step. Slang identification and emoticons were also crucial steps in the study. Slang are a group of words which are used informally and in a particular language. Emoticons are the representation of different facial expressions. SVM performed the best among all the algorithms with accuracy of 90% and 70% for Marathi and Hindi language.",
          "In the paper, Jha et al. BIBREF8 explains that there is a lot of research done in the English language for SA, but little for the Hindi language. The system developed by the authors carried out the SA in Hindi language using two approaches. In first approach, supervised machine learning algorithm Na\u00efve Bayes was used for document classification and in the second approach, the parts of speech (POS) tagging was done using TnT POS Tagger and using the rule-based approach the classification of opinionated words was completed. 200 positive and 200 negative movie review documents are web scraping for testing the system. Accuracy of 80% was achieved by the system."
        ]
      },
      {
        "section_name": "Sentiment Analysis Levels ::: Sentence Level",
        "paragraphs": [
          "Sentence level SA identifies the opinions on the sentence and classify the sentence as positive, negative or neutral. There are two types of sentences, subjective and objective sentences which are required to be identified while performing sentence level SA. Subjective sentences carry opinions, expressions and emotions in them. Objective sentences are the factual information. Sentence level SA can be carried out only on the subjective sentences hence it is important to first filter out objective sentences.",
          "SWN is a most common lexicon-based approach used by the researchers. Haithem et al. BIBREF9 developed the Irish SWN whose accuracy was 6% greater than the accuracy obtained by transliteration of the Irish Tweets into English language. The lexicon was manually created. The accuracy difference between the systems was because of the translation carried out into the English language BIBREF9. Naidu et al. BIBREF10 carried out the SA on Telugu e-newspapers. Their system was divided in two steps. First step was subjectivity classification. Second step was sentiment classification. In the first step the sentences were divided as subjective and objective sentences. In the second step only, the subjective sentences were further classified as positive, negative and neutral. Both the steps were performed using the SWN which gave the accuracy of 74% and 81% BIBREF10.",
          "Nanda et al. BIBREF11 used the SWN to automatically annotate the movie review dataset. Machine learning algorithms Random Forest and SVM were used to carry out the sentiment classification. Random Forest performed better than SVM giving the accuracy of 91%. Performance metrics used to evaluate the algorithms were accuracy, precision, recall, F1-score BIBREF11.",
          "Pandey et al. BIBREF12 defined a framework to carry out the SA task on the Hindi movie reviews. BIBREF12 observed that the lower accuracy was obtained by using SWN as a classification technique and hence suggested using synset replacement algorithm along with the SWN. Synset replacement algorithms groups the synonymous words having same concepts together. It helped in increasing the accuracy of the system because if the word was not present in the Hindi SWN then it found the closest word and assigned the score of that word BIBREF12. In the study, Bhargava et al. BIBREF13 completed the SA task on the FIRE 2015 dataset. The dataset consisted of code-mixed sentences in English along with 4 Indian languages (Hindi, Bengali, Tamil, Telugu). The architecture consisted of 2 main steps Language Identification and Sentiment Classification. Punctuations, hashtags were identified and handled by the CMU Ark tagger. Machine learning techniques like logistic regression and SVM were used for language identification. SWN\u2019s of each language were used for sentiment classification. The results of the implemented system were compared with the previous language translation technique and 8% better precision was observed BIBREF13.",
          "Kaur, Mangat and Krail BIBREF14 carried out their SA task on Hinglish language, which is code mix language highly popular in India. It is mainly used for the social media communication. The authors [10] had created a Hinglish corpus which contained movie reviews domain specific Hindi words. Stop-word removal, tokenization were the pre-processing techniques used in the system, along with TF-IDF as the vectorization technique. Classification algorithms like SVM and Na\u00efve Bayes where used to carry out the classification task. As a future work, the authors in BIBREF14 are trying to find the best feature and classifier combination.",
          "SVM is the machine learning algorithm which is among the top choice by researchers nowadays. The researchers have even compared the results of the different deep learning models with SVM Sun et al. BIBREF15. In BIBREF15 SA task performed on Tibetan microblog. Word2vec was the vectorization technique used. It converts the words into the numeric vector. After the vectorization step the classification of the data was carried out by the different machine learning and deep learning algorithms like SVM, Convolution Neural Network (CNN), Long short-term memory (LSTM), CNN-LSTM. CNN is a type of neural network having 4 layers. Input layer, convolution layer, global max pooling layer, output layer. Convolutional layer is the main layer because feature extraction is done in this layer. LSTM is the variant of the RNN (Recurrent Neural Network) which are capable of learning long term dependencies and detecting patterns in the data. The comparative study of different algorithm displays CNN-LSTM model as the best model with the accuracy of 86.21% BIBREF15.",
          "Joshi et al. BIBREF16 carried out SA on the Gujarati tweets. Stopword removal, stemming were the pre-processing techniques used in the implemented model. Feature extraction technique Parts of Speech (POS) tagging and the classification algorithm SVM was used in the system. SVM performed very well and gave the accuracy of 92%. Sharma et al. BIBREF17 tried to predict the Indian election results by extracting the Hindi tweets for political domain. The tweets were mainly for 5 major political parties. Three approaches where implemented to predict the winner in the election. First approach was dictionary based in which n-gram was used as a pre-processing technique and TF-IDF was used as a vectorization technique. SWN was used to classify the data and assign the polarity score to the words. Na\u00efve Bayes algorithm and SVM were the remaining two approaches which were used. SVM and Na\u00efve Bayes predicted party BJP (Bhartiya Janta Party) as the winner. SVM had the accuracy of 78.4% which was highest among the three implemented approaches.",
          "The authors, Phani et al. BIBREF18 carried out SA in three different languages Hindi, Tamil and Bengali. Feature extraction techniques n-grams and surface features were explored in detail because they were language independent, simple and robust. 12 surface features where considered in the study in which some of them were number of the words in tweet, number of hashtags in the tweet, number of characters in the tweet etc. Comparative study was carried out to find out which feature extraction and sentiment classifier algorithm worked best together. The classifiers like Multinomial Na\u00efve Bayes, Logical Regression (LR), Decision Trees, Random Forest, SVM SVC and SVM Linear SVC were applied on the dataset. Majority of the languages worked best with the word unigram and LR algorithm. Highest accuracy of 81.57% was for Hindi BIBREF18. Research by Sahu et al. BIBREF19 was carried out on movie reviews in Odia language. Na\u00efve Bayes, Logistic Regression, SVM were used for the purpose of classification. Comparison of the results of different algorithms was done using performance metrics like accuracy, precision and recall. Logistic Regression performed the best with the accuracy of 88% followed by Na\u00efve Bayes with accuracy of 81% and SVM with the accuracy of 60% BIBREF19.",
          "In paper by, Guthier et al. BIBREF20 proposed the language independent approach for SA. An emoticon dictionary was created and score were assigned to the emoticons. When the tweet contained the combination of Hashtags and emoticon, The hashtags were also added in the dictionary. A graph-based approach was implemented in the study. The graph-based approach worked on the principle, if multiple hashtags were present in the sentence then all the hashtags would have the same sentiment score. Also, all the hashtags present in the same sentence could be linked with each other. The work was tested on 5 different languages and the accuracy obtained was above 75%. Average accuracy of the model was 79.8%. The approach worked fairly with the single word hashtags and the hashtags which formed the sentences and accuracy for them were 98.3% and 84.5% respectively.",
          "Kaur et al. BIBREF21 worked on the Hinglish language dataset. YouTube comments of two popular cookery channels were extracted and analysis was carried on them. Pre-processing techniques like stop words removal, null values removal, spell errors removal, tokenization and stemming were performed. DBSCAN which is the unsupervised learning clustering algorithm was used and 7 clusters were formed for the entire dataset. Dataset was manually annotated with the labels of 7 classes. 8 machine learning algorithms were used to perform the sentiment classification. Logistic regression along with term frequency vectorization outperforms the other classification techniques with the accuracy of 74.01% for one dataset and 75.37% for the other dataset. Statistical testing was also being carried out to confirm the accuracy of the classifiers.",
          "Both document level and sentence level SA extract the sentiments for the given text but the feature for which the sentiment is expressed cannot be found out. This shortcoming is fulfilled by aspect level SA."
        ]
      },
      {
        "section_name": "Sentiment Analysis Levels ::: Aspect Level",
        "paragraphs": [
          "Aspect level SA is carried out in two steps. First step is to find the features or the components in the text and the second step is to find polarity of sentiments attached to each feature. For e.g. Mobile reviews are given in the series of the tweets. The companies first find out which part or feature of the mobile the users are talking about and then find out the emotions related to that feature.",
          "In the paper by Ekbal et al. BIBREF22 the aspect level SA was carried out on the product reviews. Dataset was obtained by web scrapping on different websites. Multi-domain product reviews obtained were analyzed in two steps process, first step was aspect extraction i.e. the aspects(features) in the review were extracted using the Condition Random Field Algorithm. In the second step SVM was used to carry out the SA task. Performance evaluation metrics like F-measure and accuracy were used. SVM gave the accuracy of 54.05% for sentiment classification.",
          "The proposed work by Ray et al. BIBREF23 is SA of twitter data. POS tagging was used as feature extraction technique. Word embedding was used as the vectorization technique. Word embedding is the method where the words of sentences are converted into vectors of real numbers. Aspect were not directly labelled instead aspects were tagged to predefined list of categories. Classification of the data was done using three approaches CNN, Rule based approach, CNN + Rule based approach. The hybrid model of CNN + Rule based approach gave the accuracy of 87%. Table 1 is the representation of the work done by different researchers in indigenous language."
        ]
      },
      {
        "section_name": "Current Trending Techniques in NLP",
        "paragraphs": [
          "The traditional machine learning and lexicon-based approaches did not give the expected results. With the emergence of the deep learning techniques like CNN, RNN, LSTM the performance improvements in the results was observed. The main problem of the deep learning algorithms is that they have high complexity and computational cost. BERT, ELMo are few pre-trained classifiers which solved the problems of the deep learning models and also outperformed them. This section identifies the different papers in which deep learning models and advanced models like BERT, ELMo etc. are used.",
          "In the paper by, Hoang et al. BIBREF27 aspect-based sentiment analysis on the SemEval-2016 - Task 5 was performed. There were three models implemented in the paper, the aspect classification model which identified whether the aspect was related or not to the text. Sentiment Classifier which classified the text into the three sentiment classes positive, negative, neutral. Both of the classifiers follow the structure of the sentence pair classifier which takes two inputs, the classifier token and the separation token which were added to the beginning and end of the sentences respectively. Final classifier implemented was the combined model which identified the sentiments of the text as well as the aspect of the text. The sentence pair classifier is the part of the Bidirectional encoder representation from transformer (BERT) model. BERT is a bidirectional and unsupervised language representation model. It considers the context of a word from both left to right and right to left simultaneously and provide better features compared to the traditional models. The performance of the combined model was better than the traditional approaches and was tested on 18 different datasets.",
          "Khatua et al. BIBREF24 performed SA on the twitter to understand user\u2019s response on the supreme court verdict of the decimalization of the LGBT. The authors had extracted 0.58 million tweets and used different machine learning and deep learning classifiers like Na\u00efve Bayes, SVM-R, SVM-P, BLM, multi layer perceptron (MLP), Long short-term memory (LSTM), Bi- LSTM and CNN. Bi-LSTM are special type of LSTM in which the information is available from forward to backward and backward to forward that is in both directions. Bi \u2013 LSTM outperforms with the accuracy of 90%.",
          "In this study, Rani et al. BIBREF26 have performed SA on the Hindi movie reviews collected from e-newspapers and different online websites. The classification technique used in the paper was CNN. CNN gave the accuracy of 95% which was much higher than the other traditional algorithms.",
          "In the paper, Godino et al. BIBREF25 carried out SA on Spanish tweets using three different classifier models which are feature classifier, FastText classifier, BERT classifier. Feature classifier extracted the important features from the tweets such as the length of the tweets, number of hashtags etc. and applied these features to the traditional machine learning algorithms to carry out the sentiment classification. The traditional algorithms used where: Logistic Regression, Multinomial Naive Bayes, Decision Tree, Support Vector Machines, Random Forest, Extra Trees, AdaBoost and Gradient Boost. FastText Classifier was developed by Facebook AI research and it internally works on the neural network architecture. BERT Classifier was also applied on the tweets. The output of the three classifiers were combined using the averaging assembling. The model was evaluated using the F1 score. F1 score of 45% and 46% was obtained on the train and test data of the implemented model."
        ]
      },
      {
        "section_name": "Datasets",
        "paragraphs": [
          "With the increasing use of the web there is a lot of User Generated Content (UGC) available on different websites. Lot of research is carried out for the English language. Work done for the indigenous languages is less as compared to the English language. By studying different papers on SA, it can be found out that researchers have started working on the indigenous languages. Data for the indigenous languages is available across the web but is mainly collected from social media platforms like Twitter, Facebook and YouTube.",
          "Some researchers have extracted their data from Twitter BIBREF9, BIBREF16, BIBREF17, BIBREF20, BIBREF23, BIBREF24, BIBREF25, while some have opted for extracting the data manually or by performing web scrapping on different websites like Facebook, microblogs, e-commerce websites, YouTube etc. BIBREF7, BIBREF8, BIBREF11, BIBREF12, BIBREF14, BIBREF22. Authors in BIBREF13 have accessed the FIRE 2015 dataset. The dataset has 792 utterances and has 8 different languages other than English. Researchers in BIBREF19 collected 3000 positive and 3000 negative Odia movie reviews. Authors in BIBREF10 collected 1400 Telugu sentences from e-Newspapers from data 1st December 2016 to 31st December 2016.",
          "The study in BIBREF5 contained the speeches of different leaders who spoke about different domain topics like festivals, environment, society etc. The dataset was manually created. BIBREF15 performed SA on the Tibetan language and hence collected the data from the Tibetan micro-blog. In BIBREF6 112 Hindi text file pertaining to different domains have been collected for analysis. Authors in BIBREF18 have used the SAIL Dataset which consist of training and test data for three different languages. Approximately 1000 tweets for each language was present as a training data. BIBREF21 extracted the data from the YouTube comments. The data extracted was related to the cookery website from 2 channels. Total of 9800 comments were collected.",
          "Major observations made in this paper are listed below. Not many researches have carried out SA on the large dataset, Majority of the research work is done on Facebook, Twitter, YouTube data, Extensive research is mainly carried out only on 2 domains which are movie reviews and politics. Very few researches are done on the cookery websites, medical data, multi-domain data. Data is not extracted from the popular social media platforms like Instagram, LinkedIn in spite of Instagram and LinkedIn being among the top websites used by the people."
        ]
      },
      {
        "section_name": "Classification Techniques",
        "paragraphs": [
          "Sentiment Analysis is the Natural language processing task. Machine Learning, Deep learning and Lexicon based approach are mainly used to classify the data based on the sentiments. Rule based approaches which were once used for the SA task are now used to carry out the pre-processing and feature extraction on the data.",
          "Machine learning based approaches split the data into the training and test set. The training set trains the different machine learning algorithms so that they can understand the patterns present in the data and helps in finding the association between the different attributes in the data which can further help for future predictions. After the machine learning algorithms are trained the test set helps the algorithm to check the accuracy of the model. Accuracy helps us to understand how much the algorithm was able to learn from the training set and perform on the unknown data (test set). In the lexicon-based approach the words present in the dataset are searched in the SWN\u2019s. Lexicon based approach is considered as an unsupervised learning technique because it does not require any prior knowledge about the data. Rule Based approaches are approaches which have a set of rules which are to be applied to the dataset to carry out the SA task.",
          "In various studies machine learning algorithms were used to carry out the SA task BIBREF7, BIBREF8, BIBREF11, BIBREF16, BIBREF19, BIBREF21, BIBREF22. It was observed that SVM performed very well for the sentiment classification followed by LR and Na\u00efve Bayes algorithm. Deep learning algorithms like CNN, LSTM, Bi-LSTM were applied on the datasets to find out the performance improvement over the traditional machine learning algorithms. From the final analysis it was concluded that the CNN-LSTM and Bi-LSTM performed the best as compared to the other algorithms BIBREF15, BIBREF23, BIBREF24, BIBREF28.",
          "In some paper\u2019s lexicon-based approach was used to carry out the classification task BIBREF9, BIBREF10, BIBREF12, BIBREF14, BIBREF18, BIBREF20. SWN\u2019s of different languages were created and improved to carry out the task effectively. Some studies suggested use of both Lexicon and Machine Learning approaches to carry out SA task. Also, suggestions to compare the algorithms and find the best algorithm was given by BIBREF5, BIBREF6, BIBREF17. In BIBREF13 Machine learning algorithms LR and SVM were used for Language detection and SWN was used for classification of sentiments. SVM outperformed LR in Language detection.",
          "With the advancement of techniques various advanced deep learning algorithms like BERT, ELMo, FastText Classifier were applied on the datasets BERT classifier performed the best BIBREF27, BIBREF25. Different rule-based approach has been used for pre-processing of the data because without the pre-processing the accuracy of the model cannot be found out correctly."
        ]
      },
      {
        "section_name": "Challenges and Limitations",
        "paragraphs": [
          "The main challenges faced by the authors are the availability of the annotated corpora, poor quality SWNs or no SWNs, no stop word list for languages. Along with these challenges some of the individual specific challenges faced by the authors are listed below. In BIBREF5 Document having more than 1000 and less than 500 words could not be classified by the implemented model. Ontology was also manually created which can affect the accuracy of the system. In BIBREF11 the data was classified based on only 2 sentiments positive and negative. Neutral polarity was not considered which could affect the analysis to greater extent. In BIBREF13 transliteration of words caused issues. Authors in BIBREF14 faced issue in automatic detection of the topic hashtags because the context was no provided to the system. In BIBREF22 Multi word aspect terms were not detected and the accuracy of the negative class was low."
        ]
      },
      {
        "section_name": "Discussions and Analysis",
        "paragraphs": [
          "After the detailed review of different papers, few points that can be considered for discussion further are mentioned below.",
          "Small Dataset:",
          "There is no substantial research carried out for the sentiment analysis in indigenous language for larger dataset. All the datasets have size in between 10k-20k. Usually the data available on the internet is of millions and millions of rows and hence the models which are not tested on the larger dataset can have accuracy problems.",
          "Less Usage of Deep Learning Algorithms:",
          "Majority of the research carried out for indigenous languages is performed using Machine Learning algorithms except the research carried out by the authors in BIBREF12, BIBREF24, BIBREF26, BIBREF25. Deep learning algorithms have time and again proved to be much better than the traditional machine learning techniques.",
          "Non-Availability of corpus:",
          "The datasets for many of the indigenous languages are not available easily. Many of the researches have to manually collected the data and hence this becomes one of the reasons for the smaller dataset.",
          "Non-Availability of the SWNs and WordNet\u2019s:",
          "There are lot of Indian Languages which don\u2019t have the WordNet\u2019s and SWNs developed hence some of the researchers had to create the WordNet\u2019s and SWN manually. Also, WordNet\u2019s and SWNs are constantly in the evolving state and are not stable.",
          "Code-Mix Languages:",
          "There is a lot of code-mix language used especially in India on the social media. As multiple languages are mixed it takes large computation time to first perform the language identification and second perform the SA task. There are no resources like WordNet\u2019s, POS Taggers etc. for the code-mix languages. Hence the research in such languages is limited and still evolving.",
          "Less Development on the Aspect Level SA:",
          "There are very few research papers available on the SA at the aspect level on the indigenous languages."
        ]
      },
      {
        "section_name": "Conclusion and Future Scope",
        "paragraphs": [
          "In this review paper, the main aim is to understand the recent work that has been done in SA for indigenous languages. 23 papers are being studied to find the trends in the field of SA. 67% of the papers reviewed have used Machine learning, deep learning and advanced deep learning algorithms. Only 29% of researchers have used lexicon-based approach. SVM (Support Vector Machine) and LR (Logical Regression) performed the best among the machine learning approach. CNN performed the best in the deep learning techniques and BERT was the choice by the researchers in the advanced deep learning techniques. The code-mix languages are the new non official language which we can see on the web. There isn\u2019t much work done on code-mix language data. Also, a lot of work is done in SA of Hindi language as compared to the other Indian languages like Gujarati, Marathi, Telugu. There is a lot of work carried out in the sentence level of sentiment analysis. There is a need for more SA work to be carried out at document level or aspect. Also, there are very few papers which have multi domain dataset. In majority of the papers, analysis is carried out on the movie reviews and the political domain data. There is a need for research on the other domains like festivals, development, education, sociology etc. Also, there is negligible research done on the data collected from Instagram and LinkedIn. BERT model can be considered for classification of code-mix languages because there has been no such research carried out so far.",
          "The future work will involve the investigation on using the advance deep learning model such as Bert in mix code language classification. We have collected over 20000 reviews (combination of Marathi and English). We would be comparing the state of the art methods discussed in the current paper during our investigation and discussed the insightful."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which languages do they explore?",
        "question_id": "1a1d94c981c58e2f2ee18bdfc4abc69fd8f15e14",
        "nlp_background": "",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Irish, Tibetian, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil, Hinglish, Bengali,Arabic, French, German, Odia",
              "evidence": [
                "Indigenous languages are the languages that are native to a region or spoken by a group of people in a particular state. It is not necessarily a national language. For e.g. Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil are the indigenous languages.",
                "Code-mixing is mixing two or more languages while communicating in person or over the web. Code-mixing is basically observed in the multilingual speakers. Code-mixed languages are a challenge to the sentiment analysis problem. A classic example of the code-mix language is Hinglish which is combination of English and Hindi words present in a sentence. Hinglish is widely used language in India to communicate over the web. For e.g. movie review in Hinglish is \u201cyeh movie kitni best hai.. Awesome.\u201d In this sentence movie, best and awesome are English words but the remaining words are Hindi words, so the language identification becomes the first step in code mix languages followed by the SA which indirectly increases the overhead for the researchers and becomes time consuming process.",
                "Pandey et al. BIBREF12 defined a framework to carry out the SA task on the Hindi movie reviews. BIBREF12 observed that the lower accuracy was obtained by using SWN as a classification technique and hence suggested using synset replacement algorithm along with the SWN. Synset replacement algorithms groups the synonymous words having same concepts together. It helped in increasing the accuracy of the system because if the word was not present in the Hindi SWN then it found the closest word and assigned the score of that word BIBREF12. In the study, Bhargava et al. BIBREF13 completed the SA task on the FIRE 2015 dataset. The dataset consisted of code-mixed sentences in English along with 4 Indian languages (Hindi, Bengali, Tamil, Telugu). The architecture consisted of 2 main steps Language Identification and Sentiment Classification. Punctuations, hashtags were identified and handled by the CMU Ark tagger. Machine learning techniques like logistic regression and SVM were used for language identification. SWN\u2019s of each language were used for sentiment classification. The results of the implemented system were compared with the previous language translation technique and 8% better precision was observed BIBREF13."
              ],
              "highlighted_evidence": [
                "For e.g. Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil are the indigenous languages.",
                "A classic example of the code-mix language is Hinglish which is combination of English and Hindi words present in a sentence.",
                " The dataset consisted of code-mixed sentences in English along with 4 Indian languages (Hindi, Bengali, Tamil, Telugu)"
              ]
            },
            "annotation_id": "4dd06b475699025134560620dce7976cd17be08d",
            "worker_id": "9cf96ca8b584b5de948019dc75e305c9e7707b92"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Ansari et al. BIBREF7 introduced an architecture for two code mix languages Hindi and Marathi. The architecture included language identification, feature generation and sentiment classification as major steps. Hindi and English WordNet\u2019s and SWNs were used as there was no SWN for Marathi. The Marathi words were first translated into English and the sentiment score of the English words were found and assigned to the words. Also, classification algorithms like Random Forest, Na\u00efve Bayes, Support Vector Machine (SVM) were used for finding the polarity in the final step. Slang identification and emoticons were also crucial steps in the study. Slang are a group of words which are used informally and in a particular language. Emoticons are the representation of different facial expressions. SVM performed the best among all the algorithms with accuracy of 90% and 70% for Marathi and Hindi language.",
                "SWN is a most common lexicon-based approach used by the researchers. Haithem et al. BIBREF9 developed the Irish SWN whose accuracy was 6% greater than the accuracy obtained by transliteration of the Irish Tweets into English language. The lexicon was manually created. The accuracy difference between the systems was because of the translation carried out into the English language BIBREF9. Naidu et al. BIBREF10 carried out the SA on Telugu e-newspapers. Their system was divided in two steps. First step was subjectivity classification. Second step was sentiment classification. In the first step the sentences were divided as subjective and objective sentences. In the second step only, the subjective sentences were further classified as positive, negative and neutral. Both the steps were performed using the SWN which gave the accuracy of 74% and 81% BIBREF10.",
                "Pandey et al. BIBREF12 defined a framework to carry out the SA task on the Hindi movie reviews. BIBREF12 observed that the lower accuracy was obtained by using SWN as a classification technique and hence suggested using synset replacement algorithm along with the SWN. Synset replacement algorithms groups the synonymous words having same concepts together. It helped in increasing the accuracy of the system because if the word was not present in the Hindi SWN then it found the closest word and assigned the score of that word BIBREF12. In the study, Bhargava et al. BIBREF13 completed the SA task on the FIRE 2015 dataset. The dataset consisted of code-mixed sentences in English along with 4 Indian languages (Hindi, Bengali, Tamil, Telugu). The architecture consisted of 2 main steps Language Identification and Sentiment Classification. Punctuations, hashtags were identified and handled by the CMU Ark tagger. Machine learning techniques like logistic regression and SVM were used for language identification. SWN\u2019s of each language were used for sentiment classification. The results of the implemented system were compared with the previous language translation technique and 8% better precision was observed BIBREF13.",
                "Kaur, Mangat and Krail BIBREF14 carried out their SA task on Hinglish language, which is code mix language highly popular in India. It is mainly used for the social media communication. The authors [10] had created a Hinglish corpus which contained movie reviews domain specific Hindi words. Stop-word removal, tokenization were the pre-processing techniques used in the system, along with TF-IDF as the vectorization technique. Classification algorithms like SVM and Na\u00efve Bayes where used to carry out the classification task. As a future work, the authors in BIBREF14 are trying to find the best feature and classifier combination.",
                "The study in BIBREF5 contained the speeches of different leaders who spoke about different domain topics like festivals, environment, society etc. The dataset was manually created. BIBREF15 performed SA on the Tibetan language and hence collected the data from the Tibetan micro-blog. In BIBREF6 112 Hindi text file pertaining to different domains have been collected for analysis. Authors in BIBREF18 have used the SAIL Dataset which consist of training and test data for three different languages. Approximately 1000 tweets for each language was present as a training data. BIBREF21 extracted the data from the YouTube comments. The data extracted was related to the cookery website from 2 channels. Total of 9800 comments were collected.",
                "In the paper, Godino et al. BIBREF25 carried out SA on Spanish tweets using three different classifier models which are feature classifier, FastText classifier, BERT classifier. Feature classifier extracted the important features from the tweets such as the length of the tweets, number of hashtags etc. and applied these features to the traditional machine learning algorithms to carry out the sentiment classification. The traditional algorithms used where: Logistic Regression, Multinomial Naive Bayes, Decision Tree, Support Vector Machines, Random Forest, Extra Trees, AdaBoost and Gradient Boost. FastText Classifier was developed by Facebook AI research and it internally works on the neural network architecture. BERT Classifier was also applied on the tweets. The output of the three classifiers were combined using the averaging assembling. The model was evaluated using the F1 score. F1 score of 45% and 46% was obtained on the train and test data of the implemented model.",
                "Joshi et al. BIBREF16 carried out SA on the Gujarati tweets. Stopword removal, stemming were the pre-processing techniques used in the implemented model. Feature extraction technique Parts of Speech (POS) tagging and the classification algorithm SVM was used in the system. SVM performed very well and gave the accuracy of 92%. Sharma et al. BIBREF17 tried to predict the Indian election results by extracting the Hindi tweets for political domain. The tweets were mainly for 5 major political parties. Three approaches where implemented to predict the winner in the election. First approach was dictionary based in which n-gram was used as a pre-processing technique and TF-IDF was used as a vectorization technique. SWN was used to classify the data and assign the polarity score to the words. Na\u00efve Bayes algorithm and SVM were the remaining two approaches which were used. SVM and Na\u00efve Bayes predicted party BJP (Bhartiya Janta Party) as the winner. SVM had the accuracy of 78.4% which was highest among the three implemented approaches.",
                "Indigenous languages are the languages that are native to a region or spoken by a group of people in a particular state. It is not necessarily a national language. For e.g. Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil are the indigenous languages."
              ],
              "highlighted_evidence": [
                "Ansari et al. BIBREF7 introduced an architecture for two code mix languages Hindi and Marathi.",
                "BIBREF9 developed the Irish SWN whose accuracy was 6% greater than the accuracy obtained by transliteration of the Irish Tweets into English language.",
                "The dataset consisted of code-mixed sentences in English along with 4 Indian languages (Hindi, Bengali, Tamil, Telugu).",
                "Kaur, Mangat and Krail BIBREF14 carried out their SA task on Hinglish language, which is code mix language highly popular in India.",
                "The dataset was manually created. BIBREF15 performed SA on the Tibetan language and hence collected the data from the Tibetan micro-blog.",
                " BIBREF25 carried out SA on Spanish tweets using three different classifier models which are feature classifier, FastText classifier, BERT classifier.",
                "BIBREF16 carried out SA on the Gujarati tweets.",
                "For e.g. Irish, Tibetan, Spanish, Hindi, Marathi, Gujarati, Telugu, Tamil are the indigenous languages."
              ]
            },
            "annotation_id": "9ca3a376f638d8701280eb545bfe0e30650640ae",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Irish, Gujarati, Hindi, Arabic, English, Spanish, French, German, Tamil, Bengali, Odia, Marathi, Telugu, Hinglish",
              "evidence": [
                "FLOAT SELECTED: Table 1: Review Papers.11"
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Table 1: Review Papers.11"
              ]
            },
            "annotation_id": "fa2e149bd12d1695db3a5fc99b2a91c168b84907",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Sentiment Analysis Process."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Tokenization"
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Bag of Words Steps"
      },
      {
        "file": "5-Figure4-1.png",
        "caption": "Figure 4: Count Vectorizer"
      },
      {
        "file": "7-Figure5-1.png",
        "caption": "Figure 5: Classification techniques"
      },
      {
        "file": "11-Table1-1.png",
        "caption": "Table 1: Review Papers.11"
      }
    ]
  },
  "1903.10548": {
    "title": "Recognizing Arrow Of Time In The Short Stories",
    "abstract": "Recognizing arrow of time in short stories is a challenging task. i.e., given only two paragraphs, determining which comes first and which comes next is a difficult task even for humans. In this paper, we have collected and curated a novel dataset for tackling this challenging task. We have shown that a pre-trained BERT architecture achieves reasonable accuracy on the task, and outperforms RNN-based architectures.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Recurrent neural networks (RNN) and architectures based on RNNs like LSTM BIBREF0 has been used to process sequential data more than a decade. Recently, alternative architectures such as convolutional networks BIBREF1 , BIBREF2 and transformer model BIBREF3 have been used extensively and achieved the state of the art result in diverse natural language processing (NLP) tasks. Specifically, pre-trained models such as the OpenAI transformer BIBREF4 and BERT BIBREF5 which are based on transformer architecture, have significantly improved accuracy on different benchmarks.",
          "In this paper, we are introducing a new dataset which we call ParagraphOrdering, and test the ability of the mentioned models on this newly introduced dataset. We have got inspiration from \"Learning and Using the Arrow of Time\" paper BIBREF6 for defining our task. They sought to understand the arrow of time in the videos; Given ordered frames from the video, whether the video is playing backward or forward. They hypothesized that the deep learning algorithm should have the good grasp of the physics principle (e.g. water flows downward) to be able to predict the frame orders in time.",
          "Getting inspiration from this work, we have defined a similar task in the domain of NLP. Given two paragraphs, whether the second paragraph comes really after the first one or the order has been reversed. It is the way of learning the arrow of times in the stories and can be very beneficial in neural story generation tasks. Moreover, this is a self-supervised task, which means the labels come from the text itself."
        ]
      },
      {
        "section_name": "Paragraph Ordering Dataset",
        "paragraphs": [
          "We have prepared a dataset, ParagraphOrdreing, which consists of around 300,000 paragraph pairs. We collected our data from Project Gutenberg. We have written an API for gathering and pre-processing in order to have the appropriate format for the defined task. Each example contains two paragraphs and a label which determines whether the second paragraph comes really after the first paragraph (true order with label 1) or the order has been reversed (Table 1 ). The detailed statistics of the data can be found in Table 2 ."
        ]
      },
      {
        "section_name": "Approach",
        "paragraphs": [
          "Different approaches have been used to solve this task. The best result belongs to classifying order of paragraphs using pre-trained BERT model. It achieves around $84\\%$ accuracy on test set which outperforms other models significantly."
        ]
      },
      {
        "section_name": "Encoding with LSTM and Gated CNN",
        "paragraphs": [
          "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier. First, each paragraph is encoded with LSTM. The hidden state at the end of each sentence is extracted, and the resulting matrix is going through gated CNN BIBREF1 for extraction of single encoding for each paragraph. The accuracy is barely above $50\\%$ , which depicts that this method is not very promising."
        ]
      },
      {
        "section_name": "Fine-tuning BERT",
        "paragraphs": [
          "We have used a pre-trained BERT in two different ways. First, as a feature extractor without fine-tuning, and second, by fine-tuning the weights during training. The classification is completely based on the BERT paper, i.e., we represent the first and second paragraph as a single packed sequence, with the first paragraph using the A embedding and the second paragraph using the B embedding. In the case of feature extraction, the network weights freeze and CLS token are fed to the classifier. In the case of fine-tuning, we have used different numbers for maximum sequence length to test the capability of BERT in this task. First, just the last sentence of the first paragraph and the beginning sentence of the second paragraph has been used for classification. We wanted to know whether two sentences are enough for ordering classification or not. After that, we increased the number of tokens and accuracy respectively increases. We found this method very promising and the accuracy significantly increases with respect to previous methods (Table 3 ). This result reveals fine-tuning pre-trained BERT can approximately learn the order of the paragraphs and arrow of the time in the stories."
        ]
      }
    ],
    "qas": [
      {
        "question": "Are the two paragraphs encoded independently?",
        "question_id": "d976c22e9d068e4e31fb46e929023459f8290a63",
        "nlp_background": "",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier. First, each paragraph is encoded with LSTM. The hidden state at the end of each sentence is extracted, and the resulting matrix is going through gated CNN BIBREF1 for extraction of single encoding for each paragraph. The accuracy is barely above $50\\%$ , which depicts that this method is not very promising."
              ],
              "highlighted_evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier."
              ]
            },
            "annotation_id": "675807f77d4453c2091ae9ce523cfcaae24565fa",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier. First, each paragraph is encoded with LSTM. The hidden state at the end of each sentence is extracted, and the resulting matrix is going through gated CNN BIBREF1 for extraction of single encoding for each paragraph. The accuracy is barely above $50\\%$ , which depicts that this method is not very promising."
              ],
              "highlighted_evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier."
              ]
            },
            "annotation_id": "b6493394a44ba381d2447769315e4fbec6053b61",
            "worker_id": "35491e1e579f6d147f4793edce4c1a80ab2410e7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier. First, each paragraph is encoded with LSTM. The hidden state at the end of each sentence is extracted, and the resulting matrix is going through gated CNN BIBREF1 for extraction of single encoding for each paragraph. The accuracy is barely above $50\\%$ , which depicts that this method is not very promising."
              ],
              "highlighted_evidence": [
                "In this method, paragraphs are encoded separately, and the concatenation of the resulted encoding is going through the classifier."
              ]
            },
            "annotation_id": "f73a2319491c560e81be890dfac88d38286936f7",
            "worker_id": "c7d4a630661cd719ea504dba56393f78278b296b"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Table1-1.png",
        "caption": "Table 1: A single example of ParagraphOrdering dataset."
      },
      {
        "file": "2-Table2-1.png",
        "caption": "Table 2: Statistics of ParagraphOrdering dataset."
      },
      {
        "file": "2-Table3-1.png",
        "caption": "Table 3: Accuracy on Test set."
      }
    ]
  },
  "2002.12699": {
    "title": "Automatic Section Recognition in Obituaries",
    "abstract": "Obituaries contain information about people's values across times and cultures, which makes them a useful resource for exploring cultural history. They are typically structured similarly, with sections corresponding to Personal Information, Biographical Sketch, Characteristics, Family, Gratitude, Tribute, Funeral Information and Other aspects of the person. To make this information available for further studies, we propose a statistical model which recognizes these sections. To achieve that, we collect a corpus of 20058 English obituaries from TheDaily Item, this http URL and The London Free Press. The evaluation of our annotation guidelines with three annotators on 1008 obituaries shows a substantial agreement of Fleiss k = 0.87. Formulated as an automatic segmentation task, a convolutional neural network outperforms bag-of-words and embedding-based BiLSTMs and BiLSTM-CRFs with a micro F1 = 0.81.",
    "full_text": [
      {
        "section_name": "Introduction and Motivation",
        "paragraphs": [
          "An obituary, typically found in newspapers, informs about the recent death of a person, and usually includes a brief biography of the deceased person, which sometimes recounts detailed life stories and anecdotes. Structural elements, styles, formats, and information presented vary slightly from culture to culture or from community to community BIBREF0. Obituaries can be considered to be short essays and contain information on the living family members and information about the upcoming funeral, such as visitation, burial service, and memorial information as well as the cause of death BIBREF0.",
          "Similarly to biographies, obituaries represent an interesting type of text because the information contained is usually focused on the values and the qualities of a given human being that is part of a particular community BIBREF1, BIBREF2, BIBREF3. From the digital humanities perspective investigating obituaries also provides an understanding of how the community who writes the obituaries decides what is relevant about life and death.",
          "Potential applications that are enabled by having access to large collections of obituaries are finding such themes that are relevant while discussing life and death, investigation of different aspects of social memory BIBREF4, BIBREF5 (finding what is being remembered or chosen to be excluded from an obiturary), investigation of correlations between work or other different themes and the cause of death, analysis of linguistic, structural or cultural differences BIBREF6, and the investigation of different biases and values within a community BIBREF7, BIBREF8, BIBREF9, BIBREF10.",
          "More recently, obituaries have been published on dedicated social networks where the mourners who write the obituaries express their emotions and tell stories of the deceased in comments to the obituaries (e. g. Legacy.com, Remembering.CA). These networks facilitate interactions between readers and the family of the deceased BIBREF11. With this paper, we focus on online publications of obituaries which are available online and are in English.",
          "Research that builds on top of such data is presumably mostly concerned with a part of the information contained in obituaries. For example, when investigating mortality records BIBREF12, one might only be interested in the Personal Information section. Therefore, we propose to perform zoning as a preprocessing step and publish a corpus and trained models for the sections Personal information (including names of the deceased, birth date, date of death, and cause of death), Biographical sketch, Tribute, Family, and Funeral Information (such as time, place, and date of the funeral). No such resource is currently available to the research community.",
          "Our main contributions are therefore (1) to annotate a collection of obituaries, (2) to analyze the corpus and to formulate the task of automatic recognition of structures, (3) to evaluate which models perform best on this task, and (4) to compare the models' results qualitatively and quantitatively. To achieve our goals and as additional support for future research, we publish information how to obtain the data and the annotated dataset as well as the models at http://www.ims.uni-stuttgart.de/data/obituaries."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Research on obituaries can be structured by research area, namely language studies, cultural studies, computational linguistics, psychology studies, and medical studies."
        ]
      },
      {
        "section_name": "Related Work ::: Obituaries in Cultural and Medical Studies",
        "paragraphs": [
          "One of the common topics that are studied in the context of cultural studies and obituaries is religion. herat2014 investigate how certain language expressions are used in obituaries in Sri Lanka, how religion and culture play a role in the conceptualization of death, and how language reflects social status. They find that the conceptualization of death is in terms of a journey in the Buddhist and Hindu communities whereas death is conceptualized as an end in Christian and Muslim communities. They show that the language of obituaries appears to be conditioned by the religious and cultural identity of the deceased.",
          "ergin2012 look into Turkish obituary data from H\u00fcrriyet, a major Turkish daily newspaper, from 1970 to 2009, with the goal of finding expressions of religiosity and constructions of death in relation to gender and temporal variations together with markers of status. Their results show that the obituaries considered are relying on \u201can emotional tone of loss\u201d and that the spiritual preferences are linked to the status and appartenance to a specific social class.",
          "Next to religion, elements of the obituary language are in the focus of various works across countries and cultures. metaphors2019 undertake a qualitative analysis of metaphors in 150 obituaries of professional athletes published in various newspapers. They find traditional metaphors of death but also creative metaphors that describe death euphemistically. Some of the creative metaphors have a connection to sports but not necessarily to the sport practiced by the deceased athlete.",
          "The language of obituaries is also investigated in the context of gender analysis by malesvsfemales who test the hypothesis that obituaries are less emotional in the language used for females than for males. They collect 703 obituaries from a local newspaper from US and investigate whether the person is described to have \u201cdied\u201d or \u201cpassed away\u201d. Their results show that the deaths of females are more likely to be described as \u201cpassing away\u201d.",
          "Furthermore, the perception of women in leading positions in communist and post-communist Romania is researched by gender2011 by analyzing the content of obituaries published in the Romanian newspaper Rom\u00e2nia Liber\u0103 from 1975 to 2003. They show that the gender gap in management widened after the fall of communism.",
          "epstein2013 study the relationship between career success, terminal disease frequency, and longevity using New York Times obituaries. Their results show that obituaries written in the memory of men are more prevalent and the mean age of death was higher for males than females. They concluded that \u201csmoking and other risk behaviours may be either the causes or effects of success and/or early death\u201d, and fame and achievement in performance-related careers correlate with a shorter life span expectancy.",
          "rusu2017 also look at famous people, and the posthumous articles written about them to test whether the deceased are protected from negative evaluations within their community. They find out that more than one fifth of the articles do contain negative evaluations of the deceased.",
          "barth2013 gains insights into how different communities deal with death according to their respective norms. They study the differences between German and Dutch obituaries in terms of visual and textual elements, information about the deceased, and funeral-related information. Their study shows that German obituaries use illustrations more than the Dutch ones and that the Dutch obituaries provide more information than the German ones.",
          "Another cross-cultural study is made by hubbard2009 who investigate whether obituaries placed by families reflect specific societal attitudes towards aging and dementia. They use discourse analysis of obituaries in newspapers from Canada and the UK and show that donations to dementia charities were more common in obituaries from Canada than in the UK.",
          "themesopiod study the public perception on the opioid epidemic in obituaries from the US where the cause of death is related to overdose. They investigated emotion related themes and categories by using the IBM Watson Tone Analyzer and show that joy and sadness are the most prevalent emotion categories with the most common emotion being love. The terms that are most used to describe death are \u201caccidental\u201d and \u201caddiction\u201d. Shame and stigma are less prevalent \u201cwhich might suggest that addiction is perceived as a disease rather than a criminal behaviour\u201d.",
          "usobi investigate the shared values of the community of neurosurgeons in the US by doing a text analysis on obituaries from Neurosurgery, Journal of Neurosurgery and the New York Times. Their study analyzes frequent terms and derives the relative importance of various concepts: innovation, research, training and family. Within this work, the sentiment of the obituaries within the Neurosurgery research community is being annotated. A result of this study is that the obituaries of neurosurgeons written by the research community put a greater emphasis on professional leadership and residency training and that the family mentions occured more in the lay press.",
          "vital develop a methodology to link mortality data from internet sources with administrative data from electronic health records. To do so they implement and evaluate the performance of different linkage methods. The electronic health records are from patients in Rennes, France and the extracted obituaries are all available online obituaries from French funeral home websites. They evaluate three different linkage methods and obtain almost perfect precisions with all methods. They conclude that using obituaries published online could address the problem of long delays in the sharing of mortality data whereas online obituaries could be considered as reliable data source for real-time suveillance of mortality in patients with cancer."
        ]
      },
      {
        "section_name": "Related Work ::: Obituaries as a Data Source in Various Tasks of Computational Linguistics",
        "paragraphs": [
          "With a focus on computational linguistics, obituarymining1 analyze text data from obituary websites, with the intention to use it to prevent identity theft. The goal was to evaluate how \u201coften and how accurately name and address fragments extracted from these notices developed into complete name and address information corresponding to the deceased individual\u201d. They use a knowledge base with name and address information, extracte the name and address fragments from the text and match them against the knowledge base to create a set of name and address candidates. This result set is then compared to an authoritative source in order to determine which of the candidate records actually correspond to the name and address of an individual reported as deceased.",
          "alfano2018 collect obituaries from various newspapers, to get a better understanding of people's values. They conduct three studies in which the obituaries are annotated with age at death, gender and general categories that summarize traits of the deceased (a trait like hiker would be summarized by the category \u201cnature-lover\u201d). All studies are analyzed from a network perspective: when the deceased is described as having the traits X and Y, then an edge between the two traits is created with the weight of the edge being the total number of persons described as having both traits. The first study is done on obituaries collected from local newspapers. They find that women's obituaries focus more on family and \u201ccare-related affairs\u201d in contrast to men's obituaries which focus on \u201cpublic and political matters\u201d. In the second study they explore the New York Times Obituaries and find that the network of the second study differs from the first study in terms of network density, mean clustering coefficient and modularity. The last study is done on data from ObituaryData.com and the annotation with traits is performed in a semi-automatic manner.",
          "obi1 extract various facts about persons from obituaries. They use a feature scoring method that uses prior knowledge. Their method achieved high performance for the attributes person name, affiliation, position (occupation), age, gender, and cause of death.",
          "bamman2014 present an unsupervised model for learning life event classes from biographical texts in Wikipedia along with the structure that connects them. They discover evidence of systematic bias in the presentation of male and female biographies in which female biographies placed a significantly disproportionate emphasis on the personal events of marriage and divorce. This work is of interest here because it handled biographical information (Wikipedia biographies), of which obituaries are also a part.",
          "simonson2016 investigate the distribution of narrative schemas BIBREF13 throughout different categories of documents and show that the structure of the narrative schemas are conditioned by the type of document. Their work uses the New York Times corpus, which makes the work relevant for us, because obituary data is part of the NYT library and a category of document the work focuses on. Their results show that obituaries are narratologically homogeneous and therefore more rigid in their wording and the events they describe.",
          "The stability of narrative schemas is explored in a follow up paper by simonson2018. Their goal was to test whether small changes in the corpus would produce small changes in the induced schemas. The results confirm the distinction between the homogeneous and heterogeneous articles and show that homogeneous categories produced more stable batches of schemas than the heterogeneous ones. This is not surprising but supports that obituaries have a coherent structure which could be turned into a stable narrative schema.",
          "he2019 propose using online obituaries as a new data source for doing named entity recognition and relation extraction to capture kinship and family relation information. Their corpus consists of 1809 obituaries annotated with a novel tagging scheme. Using a joint neural model they classify to 57 kinships each with 10 or more examples in 10-fold cross-validation experiment."
        ]
      },
      {
        "section_name": "Related Work ::: Zoning",
        "paragraphs": [
          "Many NLP tasks focus on the extraction and abstraction of specific types of information in documents. To make searching and retrieving information in documents accessible, the logical structure of documents in titles, headings, sections, arguments, and thematically related parts must be recognized BIBREF14.",
          "A notable amount of work focuses on the argumentative zoning of scientific documents BIBREF15, BIBREF16, BIBREF17, BIBREF18, BIBREF19, BIBREF20, BIBREF21. zoning2 stated that readers of scientific work may be looking for \u201cinformation about the objective of the study in question, the methods used in the study, the results obtained, or the conclusions drawn by authors\u201d.",
          "The recognition of document structures generally makes use of two sources of information. On one side, text layout enables recognition of relationships between the various structural units such as headings, body text, references, figures, etc. On the other side, the wording and content itself can be used to recognize the connections and semantics of text passages. Most methods use section names, argumentative zoning, qualitative dimensions, or the conceptual structure of documents BIBREF22.",
          "Common to all the works that focus on zoning of scientific articles is the formulation or use of an annotation scheme, which in this case relies on the form and meaning of the argumentative aspects found in text rather than on the layout or contents. In contrast to argumentative zoning, our work does not make use of an annotation scheme of categories that relate to rhetorical moves of argumentation BIBREF15, but focuses instead on content."
        ]
      },
      {
        "section_name": "Data ::: Collection",
        "paragraphs": [
          "We collected obituaries from three websites: The Daily Item, where obituaries from the USA are published, Remembering.CA, which covers obituaries from Canada, and The London Free Press, which covers obituaries from London (see Table TABREF5). The obituaries on The Daily Item and The London Free Press are dedicated websites where people could publish their obituaries. Remembering.CA is an aggregator and shows obituaries published from different sources. The total set consists of 20058 obituaries."
        ]
      },
      {
        "section_name": "Data ::: Annotation Scheme and Guidelines",
        "paragraphs": [
          "In each obituary, we can find certain recurring elements, some factual, such as the statement that announces the death which contains the names of the deceased, age, date of death, information about career, information about the context and the cause of death (detailed if the person was young or suffering of a specific disease). The life events and career steps are sketched after that. This is usually followed by a list of hobbies and interests paired with accomplishments and expressions of gratitude or a tribute from the community of the deceased. Towards the end of the obituary, there are mentions of family members (through names and type of relation). The obituaries commonly end with details about the funeral BIBREF0.",
          "Therefore, we define the following eight classes: Personal information, Biographical sketch, Characteristics, Tribute, Expression of gratitude, Family, Funeral information, and Other to structure obituaries at the sentence level. An example of these classes in context of one obituary is depicted in Table TABREF1.",
          "The Personal Information class serves the purpose to classify most of the introductory clauses in obituaries. We have chosen to refer to a sentence as Personal Information when it includes the name of the deceased, the date of death, the cause of death, or the place of death. For example John Doe, 64, of Newport, found eternal rest on Nov. 22, 2018.",
          "The Biographical sketch is similar to a curriculum vitae. Sections in a person's life fall into this category. However, it should not be regarded exclusively as a curriculum vitae, since it forms the superset of personal information. We decided to label a sentence as Biographical sketch if it includes the place of birth, the date of birth, the last place of residence, the wedding date, the duration of the marriage, the attended schools, the occupations, or the further events in life. An example is He entered Bloomsburg State Teachers College in 1955 and graduated in 1959.",
          "The class Characteristics is recognizable by the fact that the deceased person is described through character traits or things the dead person loved to do. Apart from hobbies and interests, the deceased's beliefs are also part of the characteristics. An example is He enjoyed playing basketball, tennis, golf and Lyon's softball.",
          "Sentences about major achievements and contributions to society are labeled as Tribute. An example is His work was a credit to the Ukrainian community, elevating the efforts of its arts sector beyond its own expectations.",
          "Sentences in obituaries are labeled as an expression of Gratitude if any form of gratitude occurs in it, be it directed to doctors, friends, or other people. In most cases, it comes from the deceased's family. An example is We like to thank Leamington Hospital ICU staff, Windsor Regional Hospital ICU staff and Trillium for all your great care and support.",
          "The class Family is assigned to all sentences that address the survivors or in which previously deceased close relatives, such as siblings or partners, are mentioned. The mentioning of the wedding date is not covered by this category, because we consider it an event and as such, it falls under the Biographical sketch category. If the precedence of those persons is mentioned it falls in this category. If a marriage is mentioned without the wedding date or the duration it falls into the Family category. An example is: Magnus is survived by his daughter Marlene (Dwight), son Kelvin (Patricia), brother Otto (Jean) and also by numerous grandchildren & great grandchildren, nieces and nephews.",
          "Sentences are labeled as Funeral information when they contain information related to the funeral, such as date of the funeral, time of the funeral, place of the funeral, and where to make memorial contributions. An example is A Celebration of Life will be held at the Maple Ridge Legion 12101-224th Street, Maple Ridge Saturday December 8, 2018 from 1 to 3 p.m.",
          "Everything that does not fall into the above-mentioned classes is assigned the class Other. An example is: Dad referred to Lynda as his Swiss Army wife."
        ]
      },
      {
        "section_name": "Data ::: Annotation Procedure and Inter-Annotator Agreement",
        "paragraphs": [
          "Our overall annotated data set consists of 1008 obituaries which are randomly sampled from the overall crawled data. For the evaluation of our annotation guidelines, three students of computer science at the University of Stuttgart (all of age 23) annotate a subset of 99 obituaries from these 1008 instances. The first and second annotator are male and the third is female. The mother tongue of the first annotator is Italian and the mother tongue of the second and third annotator is German. All pairwise Kappa scores as well as the overall Fleiss' kappa scores are .87 (except for the pairwise Kappa between the first and the second annotator, being .86). Based on this result, the first annotator continued to label all 1008 instances.",
          "Table TABREF13 reports the agreement scores by country and category. Annotated obituaries from the UK have the lowest $\\kappa =$$0.59$ and the ones from the US the highest $\\kappa =$$0.88$. Category-wise, we observed difficulties to classify some of the rarer categories that appeared, such as examples from the class Tribute or Other. Another quite difficult distinction is the one between the class Family and the class Biographical sketch due to the occurrence of a wedding date, which we considered an event, in connection with the other family criteria. Furthermore we found difficult to decide on the border between Personal Information and Biographical sketch zones."
        ]
      },
      {
        "section_name": "Data ::: Analysis",
        "paragraphs": [
          "Table TABREF14 shows the analysis of our 1008 annotated obituaries from three different sources which form altogether 11087 sentences (where the longest sentence as 321 words). 475 obituaries are from The Daily Item (USA), 445 obituaries are from Remembering.CA (Canada), and 88 obituaries are from The London Free Press (UK). Most sentences in the dataset are labeled as Biographical sketch (3041), followed by Funeral information (2831) and Family (2195). The least assigned label is Tribute, with 11 sentences, followed by Gratitude with 144 sentences.",
          "Sentences of class Biographical Sketch and Characteristics are more frequent in obituaries from the US than from Canada and UK. On the other side, Family is a more dominant class ins UK than in the other sources.",
          "Surprisingly, the class Funeral information is also not equally distributed across locations, which is dominated by the UK.",
          "Finally, Canada has a substantially higher section of sentences labeled with Other. A manual inspection of the annotation showed that this is mostly because it seems to be more common than in other locations to mention that the person will be remembered."
        ]
      },
      {
        "section_name": "Methods",
        "paragraphs": [
          "To answer the question whether or not we can recognize the structure in obituaries we formulate the task as sentence classification, where each sentence will be assigned to one of the eight classes we defined previously. We evaluate four different models."
        ]
      },
      {
        "section_name": "Methods ::: CNN",
        "paragraphs": [
          "Convolutional Neural Networks (CNN) BIBREF23, BIBREF24 have been succesfully applied to practical NLP problems in the recent years. We use the sequential model in Keras where each sentence is represented as a sequence of one-hot embeddings of its words. We use three consecutive pairs of convolutional layers with 128 output channels, the ReLu activation function and max pooling followed by the output layer with softmax as activation function and with cross entropy as loss. This model does not have access to information of neighboring sentences."
        ]
      },
      {
        "section_name": "Methods ::: BiLSTM",
        "paragraphs": [
          "The BiLSTM models are structurally different from the CNN. The CNN predicts on the sentence-level without having access to neighboring information. For the BiLSTM models we opt for a token-based IOB scheme in which we map the dominantly predicted class inside of one sentence to the whole sentence. Our BiLSTM (BOW) model BIBREF25, BIBREF26 uses 100 memory units, a softmax activation function and categorical cross entropy as the loss function. The BiLSTM (W2V) model uses pre-trained word embeddings (Word2Vec on Google News) BIBREF27 instead of the bag of words. The BiLSTM-CRF is an extension of the BiLSTM (W2V) which uses a conditional random field layer for the output."
        ]
      },
      {
        "section_name": "Experimental Setup",
        "paragraphs": [
          "We split our 1008 obituaries into training set (70 %) and test set (30 %). From the training set, 10 % are used for validation. The batch size is set to 8 and the optimizer to rmsprop for all experiments. We do not perform hyperparameter tuning."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Results",
        "paragraphs": [
          "The CNN model has the highest macro average $\\textrm {F}_1$ score with a value of 0.65. This results from the high values for the classes Family and Funeral information. The $\\textrm {F}_1$ score for the class Other is 0.52 in contrast with the $\\textrm {F}_1$ of the other three models, which is lower than 0.22. The macro average $\\textrm {F}_1$ for the BiLSTM (BOW) model is 0.58. It also has highest F1-scores for the classes Personal Information and Biographical Sketch among all models. For the classes Family, and Funeral information has comparable scores to the CNN model. Interestingly this model performs the best among the BiLSTM variants. The BiLSTM (W2V) model performs overall worse than the one which makes use only of a BOW. It also has the worst macro average $\\textrm {F}_1$ together with the BiLSTM-CRF with a value of 0.50. The BiLSTM-CRF performs better than the other BiLSTM variants on the rare classes Gratitude and Other.",
          "Since we have few samples labelled as Tribute none of our models predict a sentence as such, resulting in precision, recall, and $\\textrm {F}_1$ value of 0 for each model.",
          "From the results we conclude that the CNN model works best. Apart from the high $\\textrm {F}_1$ it is also the only model that predicts the class Gratitude as well as the class Other better than the other models."
        ]
      },
      {
        "section_name": "Experimental Setup ::: Error Analysis",
        "paragraphs": [
          "We investigate the best performing model by making use of the confusion matrix (see Figure FIGREF20) and by inspecting all errors made by the model on the test set (see Table TABREF21).",
          "In Figure FIGREF20, we observe that the diagonal has relatively high numbers with more correctly labeled instances than confused ones for all classes, with the exception of class Tribute (the rarest class). Secondly, the confusions are not globally symmetric. However, we observe that the lower left corner formed by the classes Family, Characteristics and Biographical Sketch is almost symmetric in its confusions, which led us to inspect and classify the types of errors.",
          "Therefore, we investigated all errors manually and classified them in three main types of errors: errors due to Ambiguity (39%), errors due to wrong Annotation (18%) and errors tagged as Other (42%) where the errors are more difficult to explain (see last column in Table TABREF21).",
          "The errors due to Ambiguity are those where a test sentence could be reasonably assigned multiple different zones, and both the annotated class and the predicted class would be valid zones of the sentence. Such cases are most common between the zones Biographical Sketch, Personal Information, Characteristics, Other, and Family and occur even for the rare zones Tribute and Gratitude. An example of this error type is sentence 7 in Table TABREF21, which shows that there is a significant event that happened in the life of the deceased that changed their characteristics.",
          "Another pattern we observe emerging within the Ambiguity class of errors is that borders between the classes confused are not as rigid, and sometimes parts of one class could be entailed in another. An example of this is when the class Other being entailed in Funeral Information or Characteristics as a quote, as a wish in sentence 5 (e. g., \u201cmay you find comfort...\u201d) or as a last message from the family to the deceased (e. g. \u201cYou are truly special.\u201d) in sentence 14.",
          "The errors we mark as being errors of Annotation are those where the model is actually right in its prediction. Such cases are spread among all classes. The class that is the most affected by these errors is the class Characteristics, for which there are 23 cases of sentences wrongly annotated as being in the class Other or Biographical Sketch (e. g. sentences 9, 12). The second most affected class by this type of error is Biographical Sketch where the sentences are also wrongly annotated as Other. The rare class Gratitude is also 13 time wrongly annotated as Other, Personal Information or Biographical Sketch. This might explain why the model confuses these classes as well (Figure FIGREF20) Other examples for this type of error we can see for sentence 2, 6 and 16.",
          "The rest of the errors, labeled here as Other, are diverse and more difficult to categorize. However, we see a pattern within this group of errors as well, such as when the model appears to be mislead by the presence of words that are strong predictive features of other classes. This could be seen for instance in sentence 19 where Gratitude in confused with Family due to the presence of words like \u201cfamily\u201d, \u201clove\u201d, \u201csupport\u201d. This type of error can be also seen in sentence 11, 19. Another pattern that shows for errors of the type Other is when the model fails to predict the correct class because is not able to do coreference resolution as in sentences 10 and 15.",
          "Regarding Gratitude, the confusion matrix shows that it is confounded with Family, Other, and Funeral Information. Inspecting these cases shows that the wrongly classified cases are due to the presence of strong predictive features of other classes, like family mentions or locations which are more prevalent in other classes as in the sentences 18 and 19.",
          "Further, the class Funeral Information is confounded the most with Other, followed by Personal Information and Characteristics. We see a high number of confusions between Funeral Information and Gratitude as well, and since Gratitude is one of the rare classes we decide to have a closer look at these cases. We find that most of the misclassified sentences include expressions of gratitude and are therefore wrongly annotated, which shows that the model correctly learned that expressions like \u201cwould like to thank\u201d, \u201cthanks\u201d, \u201cthank you\u201d include predictive features for the class Gratitude (see sentence 6).",
          "When the class Characteristics is confounded with Other, this happens mostly due to presence of words related to memory \u201cwe will miss\u201d, \u201cwe will always remember\u201d, \u201cour memories\u201d, \u201cwill be deeply missed\u201d which are most occurring within the class Other. This hints to a potential improvement in the Annotation Scheme, where one could add the class Societal Memory where all the sentences that mention what the community will miss due to the loss would belong to. We think that another improvement would be if the class Other would be further divided into Wish and Quote as well, this would eliminate the issue of entailed sentences of Other in other classes."
        ]
      },
      {
        "section_name": "Conclusion and Future Work",
        "paragraphs": [
          "This work addresses the question of how to automatically structure obituaries. Therefore, we acquire a new corpus consisting of 20058 obituaries of which 1008 are annotated. To tackle the task of assigning zones to sentences and uncover the structure of obituaries, four segmentation models are implemented and tested: a CNN, a BiLSTM network using a BOW model and one using word embeddings, and a BiLSTM-CRF. The models are then compared based on precision, recall, and F1-score. From our results, we conclude that the CNN text classifier produced the best results with a macro F1-score of 0.81, considering the experimental settings, and the highest macro average F1-score of 0.65. The BiLSTM (BOW) model produced comparable results and even better regarding the classes Personal information and Biographical sketch, which makes it also a valid baseline for the task.",
          "Our work enables future research, showing that automatic recognition of structures in obituaries is a viable task. Through performing zoning on the raw obituaries, it is becoming possible to address other research questions: whether there is a correlation between the occupation of the deceased and the cause of death, what are the cultural and structural differences between obituaries from different countries.",
          "Another open question is if the annotation scheme is the best. Given the errors we found, we argue that the annotation scheme could be refined and that the class Other could be split into at least two different new classes. We leave to future work developing a new annotation scheme. Further, one could annotate obituaries across cultures, optimize the parameters of our models for the structuring task or improve over the existing models. It might be an interesting direction to compare our defined structure with one of a topic modeler. Also possible is to postannotate the dataset with emotion classes and investigate the emotional connotation of different zones."
        ]
      }
    ],
    "qas": [
      {
        "question": "by how much did their model outperform the other models?",
        "question_id": "46146ff3ef3430924e6b673a28df96ccb869dee4",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "In terms of macro F1 score their model has 0.65 compared to 0.58 of best other model.",
              "evidence": [
                "The CNN model has the highest macro average $\\textrm {F}_1$ score with a value of 0.65. This results from the high values for the classes Family and Funeral information. The $\\textrm {F}_1$ score for the class Other is 0.52 in contrast with the $\\textrm {F}_1$ of the other three models, which is lower than 0.22. The macro average $\\textrm {F}_1$ for the BiLSTM (BOW) model is 0.58. It also has highest F1-scores for the classes Personal Information and Biographical Sketch among all models. For the classes Family, and Funeral information has comparable scores to the CNN model. Interestingly this model performs the best among the BiLSTM variants. The BiLSTM (W2V) model performs overall worse than the one which makes use only of a BOW. It also has the worst macro average $\\textrm {F}_1$ together with the BiLSTM-CRF with a value of 0.50. The BiLSTM-CRF performs better than the other BiLSTM variants on the rare classes Gratitude and Other."
              ],
              "highlighted_evidence": [
                "The CNN model has the highest macro average $\\textrm {F}_1$ score with a value of 0.65.",
                "The macro average $\\textrm {F}_1$ for the BiLSTM (BOW) model is 0.58.",
                "The BiLSTM (W2V) model performs overall worse than the one which makes use only of a BOW. It also has the worst macro average $\\textrm {F}_1$ together with the BiLSTM-CRF with a value of 0.50"
              ]
            },
            "annotation_id": "6e738c940b55a6d6899c89f06b51226a1dc59d02",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "8dddb11572ff364313ba3a169e58f7092316a609",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Their model outperforms other models by 0.01 micro F1 and 0.07 macro F1",
              "evidence": [
                "FLOAT SELECTED: Table 5: Comparison of the models using Precision, Recall, and F1-score (macro and micro)"
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Table 5: Comparison of the models using Precision, Recall, and F1-score (macro and micro)"
              ]
            },
            "annotation_id": "e0706424b7d73ef2cf16cd8001ee649b5a25fbb5",
            "worker_id": "c1018a31c3272ce74964a3280069f62f314a1a58"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Table1-1.png",
        "caption": "Table 1: Example of an annotated obituary together with specific constituent elements for each of the zones."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: Overview of the sources of obituary data."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Inter-annotator agreement scores with Fleiss\u2019 \u03ba. PI: Personal information, BS: Biographical Sketch, FA: Family, C: Characteristics, T: Tribute, G: Gratitude, FI: Funeral"
      },
      {
        "file": "5-Table4-1.png",
        "caption": "Table 4: Information on full annotated dataset of obituaries. PI: Personal information, BS: Biographical Sketch, FA: Family, C: Characteristics, T: Tribute, G: Gratitude, FI: Funeral Information, O: Other # sent. denotes number of sentences. % denotes the relative counts in each class."
      },
      {
        "file": "6-Table5-1.png",
        "caption": "Table 5: Comparison of the models using Precision, Recall, and F1-score (macro and micro)"
      },
      {
        "file": "6-Table6-1.png",
        "caption": "Table 6: Example of errors done by the CNN model. PI: Personal information, BS: Biographical Sketch, FA: Family, C: Characteristics, T: Tribute, G: Gratitude, FI: Funeral Information, O: Other"
      },
      {
        "file": "7-Figure1-1.png",
        "caption": "Figure 1: Confusion matrix of the CNN model."
      }
    ]
  },
  "1901.01590": {
    "title": "Improving Unsupervised Word-by-Word Translation with Language Model and Denoising Autoencoder",
    "abstract": "Unsupervised learning of cross-lingual word embedding offers elegant matching of words across languages, but has fundamental limitations in translating sentences. In this paper, we propose simple yet effective methods to improve word-by-word translation of cross-lingual embeddings, using only monolingual corpora but without any back-translation. We integrate a language model for context-aware search, and use a novel denoising autoencoder to handle reordering. Our system surpasses state-of-the-art unsupervised neural translation systems without costly iterative training. We also analyze the effect of vocabulary size and denoising type on the translation performance, which provides better understanding of learning the cross-lingual word embedding and its usage in translation.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Building a machine translation (MT) system requires lots of bilingual data. Neural MT models BIBREF0 , which become the current standard, are even more difficult to train without huge bilingual supervision BIBREF1 . However, bilingual resources are still limited to some of the selected language pairs\u2014mostly from or to English.",
          "A workaround for zero-resource language pairs is translating via an intermediate (pivot) language. To do so, we need to collect parallel data and train MT models for source-to-pivot and pivot-to-target individually; it takes a double effort and the decoding is twice as slow.",
          "Unsupervised learning is another alternative, where we can train an MT system with only monolingual corpora. Decipherment methods BIBREF2 , BIBREF3 are the first work in this direction, but they often suffer from a huge latent hypothesis space BIBREF4 .",
          "Recent work by unmt-artetxe and unmt-facebook train sequence-to-sequence MT models of both translation directions together in an unsupervised way. They do back-translation BIBREF5 back and forth for every iteration or batch, which needs an immensely long time and careful tuning of hyperparameters for massive monolingual data.",
          "Here we suggest rather simple methods to build an unsupervised MT system quickly, based on word translation using cross-lingual word embeddings. The contributions of this paper are:",
          "The proposed models can be efficiently trained with off-the-shelf softwares with little or no changes in the implementation, using only monolingual data. The provided analyses help for better learning of cross-lingual word embeddings for translation purpose. Altogether, our unsupervised MT system outperforms the sequence-to-sequence neural models even without training signals from the opposite translation direction, i.e. via back-translation."
        ]
      },
      {
        "section_name": "Cross-lingual Word Embedding",
        "paragraphs": [
          "As a basic step for unsupervised MT, we learn a word translation model from monolingual corpora of each language. In this work, we exploit cross-lingual word embedding for word-by-word translation, which is state-of-the-art in terms of type translation quality BIBREF6 , BIBREF7 .",
          "Cross-lingual word embedding is a continuous representation of words whose vector space is shared across multiple languages. This enables distance calculation between word embeddings across languages, which is actually finding translation candidates.",
          "We train cross-lingual word embedding in a fully unsupervised manner:",
          "Once we have the cross-lingual mapping, we can transform the embedding of a given source word and find a target word with the closest embedding, i.e. nearest neighbor search. Here, we apply cross-domain similarity local scaling BIBREF7 to penalize the word similarities in dense areas of the embedding distribution.",
          "We further refine the mapping obtained from Step 2 as follows BIBREF6 :"
        ]
      },
      {
        "section_name": "Sentence Translation",
        "paragraphs": [
          "In translating sentences, cross-lingual word embedding has several drawbacks. We describe each of them and our corresponding solutions."
        ]
      },
      {
        "section_name": "Context-aware Beam Search",
        "paragraphs": [
          "The word translation using nearest neighbor search does not consider context around the current word. In many cases, the correct translation is not the nearest target word but other close words with morphological variations or synonyms, depending on the context.",
          "The reasons are in two-fold: 1) Word embedding is trained to place semantically related words nearby, even though they have opposite meanings. 2) A hubness problem of high-dimensional embedding space hinders a correct search, where lots of different words happen to be close to each other BIBREF10 .",
          "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:",
          " $\nL(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h)\n$ ",
          "Here, $q(f,e)$ is a lexical score defined as:",
          " $\nq(f,e) = \\frac{d(f,e) + 1}{2}\n$ ",
          " where $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance.",
          "Accumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
        ]
      },
      {
        "section_name": "Denoising",
        "paragraphs": [
          "Even when we have correctly translated words for each position, the output is still far from an acceptable translation. We adopt sequence denoising autoencoder BIBREF11 to improve the translation output of Section \"Context-aware Beam Search\" . The main idea is to train a sequence-to-sequence neural network model that takes a noisy sentence as input and produces a (denoised) clean sentence as output, both of which are of the same (target) language. The model was originally proposed to learn sentence embeddings, but here we use it directly to actually remove noise in a sentence.",
          "Training label sequences for the denoising network would be target monolingual sentences, but we do not have their noisy versions at hand. Given a clean target sentence, the noisy input should be ideally word-by-word translation of the corresponding source sentence. However, such bilingual sentence alignment is not available in our unsupervised setup.",
          "Instead, we inject artificial noise into a clean sentence to simulate the noise of word-by-word translation. We design different noise types after the following aspects of word-by-word translation.",
          "Word-by-word translation always outputs a target word for every position. However, there are a plenty of cases that multiple source words should be translated to a single target word, or that some source words are rather not translated to any word to make a fluent output. For example, a German sentence \u201cIch h\u00f6re zu.\u201d would be translated to \u201cI'm listening to.\u201d by a word-by-word translator, but \u201cI'm listening.\u201d is more natural in English (Figure 1 ).",
          "We pretend to have extra target words which might be translation of redundant source words, by inserting random target words to a clean sentence:",
          "For each position $i$ , sample a probability $p_i \\sim \\text{Uniform}(0,1)$ .",
          "If $p_i < p_\\text{ins}$ , sample a word $e$ from the most frequent $V_\\text{ins}$ target words and insert it before position $i$ .",
          "We limit the inserted words by $V_\\text{ins}$ because target insertion occurs mostly with common words, e.g. prepositions or articles, as the example above. We insert words only before\u2014not after\u2014a position, since an extra word after the ending word (usually a punctuation) is not probable.",
          "Similarly, word-by-word translation cannot handle the contrary case: when a source word should be translated into more than one target words, or a target word should be generated from no source words for fluency. For example, a German word \u201cim\u201d must be \u201cin the\u201d in English, but word translation generates only one of the two English words. Another example is shown in Figure 2 .",
          "To simulate such situations, we drop some words randomly from a clean target sentence BIBREF11 :",
          "For each position $i$ , sample a probability $p_i \\sim \\text{Uniform}(0,1)$ .",
          "If $p_i < p_\\text{del}$ , drop the word in the position $i$ .",
          "Also, translations generated word-by-word are not in an order of the target language. In our beam search, LM only assists in choosing the right word in context but does not modify the word order. A common reordering problem of German $\\rightarrow $ English is illustrated in Figure 3 .",
          "From a clean target sentence, we corrupt its word order by random permutations. We limit the maximum distance between an original position and its new position like unmt-facebook:",
          "For each position $i$ , sample an integer $\\delta _i$ from $[0,d_\\text{per}]$ .",
          "Add $\\delta _i$ to index $i$ and sort the incremented indices $i + \\delta _i$ in an increasing order.",
          "Rearrange the words to be in the new positions, to which their original indices have moved by Step 2.",
          "This is a generalized version of swapping two neighboring words BIBREF11 . Reordering is highly dependent of each language, but we found that this noise is generally close to word-by-word translation outputs.",
          "Insertion, deletion, and reordering noises were applied to each mini-batch with different random seeds, allowing the model to see various noisy versions of the same clean sentence over the epochs.",
          "Note that the deletion and permutation noises are integrated in the neural MT training of unmt-artetxe and unmt-facebook as additional training objectives. Whereas we optimize an independent model solely for denoising without architecture change. It allows us to easily train a larger network with a larger data. Insertion noise is of our original design, which we found to be the most effective (Section \"Ablation Study: Denoising\" )."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We applied the proposed methods on WMT 2016 German $\\leftrightarrow $ English task and WMT 2014 French $\\leftrightarrow $ English task. For German/English, we trained word embeddings with 100M sentences sampled from News Crawl 2014-2017 monolingual corpora. For French, we used News Crawl 2007-2014 (around 42M sentences). The data was lowercased and filtered to have a maximum sentence length 100. German compound words were splitted beforehand. Numbers were replaced with category labels and recovered back after decoding by looking at the source sentence.",
          "fasttext BIBREF8 was used to learn monolingual embeddings for only the words with minimum count 10. MUSE BIBREF7 was used for cross-lingual mappings with $V_\\text{cross-train}$ = 100k and 10 refinement iterations (Step 3-5 in Section \"Cross-lingual Word Embedding\" ). Other parameters follow the values in cross-facebook. With the same data, we trained 5-gram count-based LMs using KenLM BIBREF14 with its default setting.",
          "Denoising autoencoders were trained using Sockeye BIBREF15 on News Crawl 2016 for German/English and News Crawl 2014 for French. We considered only top 50k frequent words for each language and mapped other words to <unk>. The unknowns in the denoised output were replaced with missing words from the noisy input by a simple line search.",
          "We used 6-layer Transformer encoder/decoder BIBREF16 for denoisers, with embedding/hidden layer size 512, feedforward sublayer size 2048 and 8 attention heads.",
          "As a validation set for the denoiser training, we used newstest2015 (German $\\leftrightarrow $ English) or newstest2013 (French $\\leftrightarrow $ English), where the input/output sides both have the same clean target sentences, encouraging a denoiser to keep at least clean part of word-by-word translations. Here, the noisy input showed a slight degradation of performance; the model seemed to overfit to specific noises in the small validation set.",
          "Optimization of the denoising models was done with Adam BIBREF17 : initial learning rate 0.0001, checkpoint frequency 4000, no learning rate warmup, multiplying 0.7 to the learning rate when the perplexity on the validation set did not improve for 3 checkpoints. We stopped the training if it was not improved for 8 checkpoints.",
          "In decoding, we used $\\lambda _\\text{embed} = 1$ and $\\lambda _\\text{LM} = 0.1$ with beam size 10. We only translated top frequent 50k source words and merely copied other words to target side. For each position, only the nearest 100 target words were considered.",
          "Table 1 shows the results. LM improves word-by-word baselines consistently in all four tasks, giving at least +3% Bleu. When our denoising model is applied on top of it, we have additional gain around +3% Bleu. Note that our methods do not involve any decoding steps to generate pseudo-parallel training data, but still perform better than unsupervised MT systems that rely on repetitive back-translations BIBREF13 , BIBREF12 by up to +3.9% Bleu. The total training time of our method is only 1-2 days with a single GPU."
        ]
      },
      {
        "section_name": "Ablation Study: Denoising",
        "paragraphs": [
          "To examine the effect of each noise type in denoising autoencoder, we tuned each parameter of the noise and combined them incrementally (Table 2 ). Firstly, for permutations, a significant improvement is achieved from $d_\\text{per} = 3$ , since a local reordering usually involves a sequence of 3 to 4 words. With $d_\\text{per} > 5$ , it shuffles too many consecutive words together, yielding no further improvement. This noise cannot handle long-range reordering, which is usually a swap of words that are far from each other, keeping the words in the middle as they are.",
          "Secondly, we applied the deletion noise with different values of $p_\\text{del}$ . 0.1 gives +0.8% Bleu, but we immediately see a degradation with a larger value; it is hard to observe one-to-many translations more than once in each sentence pair.",
          "Finally, we optimized $V_\\text{ins}$ for the insertion noise, fixing $p_\\text{ins} = 0.1$ . Increasing $V_\\text{ins}$ is generally not beneficial, since it provides too much variations in the inserted word; it might not be related to its neighboring words. Overall, we observe the best result (+1.5% Bleu) with $V_\\text{ins} = 50$ ."
        ]
      },
      {
        "section_name": "Ablation Study: Vocabulary",
        "paragraphs": [
          "We also examined how the translation performance varies with different vocabularies of cross-lingual word embedding in Table 3 . The first three rows show that BPE embeddings perform worse than word embeddings, especially with smaller vocabulary size. For short BPE tokens, the context they meet during the embedding training is much more various than a complete word, and a direct translation of such token to a BPE token of another language would be very ambiguous.",
          "For word level embeddings, we compared different vocabulary sizes used for training the cross-lingual mapping (the second step in Section \"Cross-lingual Word Embedding\" ). Surprisingly, cross-lingual word embedding learned only on top 20k words is comparable to that of 200k words in the translation quality. We also increased the search vocabulary to more than 200k but the performance only degrades. This means that word-by-word translation with cross-lingual embedding depends highly on the frequent word mappings, and learning the mapping between rare words does not have a positive effect."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we proposed a simple pipeline to greatly improve sentence translation based on cross-lingual word embedding. We achieved context-aware lexical choices using beam search with LM, and solved insertion/deletion/reordering problems using denoising autoencoder. Our novel insertion noise shows a promising performance even combined with other noise types. Our methods do not need back-translation steps but still outperforms costly unsupervised neural MT systems. In addition, we proved that for general translation purpose, an effective cross-lingual mapping can be learned using only a small set of frequent words, not on subword units. Our implementation of the LM integration and the denoising autoencoder is available online."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "This work has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme, grant agreement No. 694537 (SEQCLAS). The GPU computing cluster was partially funded by Deutsche Forschungsgemeinschaft (DFG) under grant INST 222/1168-1 FUGG. The work reflects only the authors' views and neither ERC nor DFG is responsible for any use that may be made of the information it contains."
        ]
      }
    ],
    "qas": [
      {
        "question": "How does the paper use language model for context aware search?",
        "question_id": "d0048ef1cba3f63b5d60c568d5d0ba62ac4d7e75",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "language model",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:",
                "$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $",
                "Here, $q(f,e)$ is a lexical score defined as:",
                "$ q(f,e) = \\frac{d(f,e) + 1}{2} $",
                "where $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance."
              ],
              "highlighted_evidence": [
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:\n\n$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $\n\nHere, $q(f,e)$ is a lexical score defined as:\n\n$ q(f,e) = \\frac{d(f,e) + 1}{2} $\n\nwhere $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance."
              ],
              "yes_no": null,
              "free_form_answer": "the language model is combined with cross-lingual word embedding to obtain context information in the word-by-word translation",
              "extractive_spans": []
            },
            "annotation_id": "7f6b3044d15268c9fee1d58f0be9e920f7e6eb7f",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "combining a language model (LM) with cross-lingual word embedding",
                "Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:\n\n$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $\n\nHere, $q(f,e)$ is a lexical score defined as:\n\n$ q(f,e) = \\frac{d(f,e) + 1}{2} $\n\nwhere $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ .",
                "Accumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:",
                "$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $",
                "Here, $q(f,e)$ is a lexical score defined as:",
                "$ q(f,e) = \\frac{d(f,e) + 1}{2} $",
                "where $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance.",
                "Accumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
              ],
              "highlighted_evidence": [
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:\n\n$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $\n\nHere, $q(f,e)$ is a lexical score defined as:\n\n$ q(f,e) = \\frac{d(f,e) + 1}{2} $\n\nwhere $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance.\n\nAccumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
              ]
            },
            "annotation_id": "8055015a2d805546da5be07d109f5a8ab2c0e387",
            "worker_id": "c7d4a630661cd719ea504dba56393f78278b296b"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "It is used to calculate the probability of a possible target word given the history of target words that come before it.",
              "evidence": [
                "The word translation using nearest neighbor search does not consider context around the current word. In many cases, the correct translation is not the nearest target word but other close words with morphological variations or synonyms, depending on the context.",
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:",
                "$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $",
                "Here, $q(f,e)$ is a lexical score defined as:",
                "$ q(f,e) = \\frac{d(f,e) + 1}{2} $",
                "where $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability. In our experiments, we found that this simple linear scaling is better than sigmoid or softmax functions in the final translation performance.",
                "Accumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
              ],
              "highlighted_evidence": [
                "The word translation using nearest neighbor search does not consider context around the current word. In many cases, the correct translation is not the nearest target word but other close words with morphological variations or synonyms, depending on the context.",
                "In this paper, we integrate context information into word-by-word translation by combining a language model (LM) with cross-lingual word embedding. Let $f$ be a source word in the current position and $e$ a possible target word. Given a history $h$ of target words before $e$ , the score of $e$ to be the translation of $f$ would be:\n\n$ L(e;f,h) = \\lambda _\\text{emb}\\log q(f,e) + \\lambda _\\text{LM}\\log p(e|h) $\n\nHere, $q(f,e)$ is a lexical score defined as:\n\n$ q(f,e) = \\frac{d(f,e) + 1}{2} $\n\nwhere $d(f,e) \\in [-1,1]$ is a cosine similarity between $f$ and $e$ . It is transformed to the range $[0,1]$ to make it similar in scale with the LM probability.",
                "Accumulating the scores per position, we perform a beam search to allow only reasonable translation hypotheses."
              ]
            },
            "annotation_id": "a5f194c30674babd27fab0e1e7e968b4355c5b99",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Example of denoising a deletion noise."
      },
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Example of denoising an insertion noise."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Example of denoising the reordering noise."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Translation results on German\u2194English newstest2016 and French\u2194English newstest2014."
      },
      {
        "file": "5-Table3-1.png",
        "caption": "Table 3: Translation results with different vocabularies for German\u2192English (without denoising)."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: Translation results with different values of denoising parameters for German\u2192English."
      }
    ]
  },
  "1905.07562": {
    "title": "Human-like machine thinking: Language guided imagination",
    "abstract": "Human thinking requires the brain to understand the meaning of language expression and to properly organize the thoughts flow using the language. However, current natural language processing models are primarily limited in the word probability estimation. Here, we proposed a Language guided imagination (LGI) network to incrementally learn the meaning and usage of numerous words and syntaxes, aiming to form a human-like machine thinking process. LGI contains three subsystems: (1) vision system that contains an encoder to disentangle the input or imagined scenarios into abstract population representations, and an imagination decoder to reconstruct imagined scenario from higher level representations; (2) Language system, that contains a binarizer to transfer symbol texts into binary vectors, an IPS (mimicking the human IntraParietal Sulcus, implemented by an LSTM) to extract the quantity information from the input texts, and a textizer to convert binary vectors into text symbols; (3) a PFC (mimicking the human PreFrontal Cortex, implemented by an LSTM) to combine inputs of both language and vision representations, and predict text symbols and manipulated images accordingly. LGI has incrementally learned eight different syntaxes (or tasks), with which a machine thinking loop has been formed and validated by the proper interaction between language and vision system. The paper provides a new architecture to let the machine learn, understand and use language in a human-like way that could ultimately enable a machine to construct fictitious 'mental' scenario and possess intelligence.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Human thinking is regarded as \u2018mental ideas flow guided by language to achieve a goal\u2019. For instance, after seeing heavy rain, you may say internally \u2018holding an umbrella could avoid getting wet\u2019, and then you will take an umbrella before leaving. In the process, we know that the visual input of \u2018water drop\u2019 is called rain, and can imagine \u2018holding an umbrella\u2019 could keep off the rain, and can even experience the feeling of being wet. This continual thinking capacity distinguishes us from the machine, even though the latter can also recognize images, process language, and sense rain-drops. Continual thinking requires the capacity to generate mental imagination guided by language, and extract language representations from a real or imagined scenario.",
          "Modern natural language processing (NLP) techniques can handle question answering etc. tasks, such as answering that \u2018Cao Cao\u2019s nickname is Meng De\u2019 based on the website knowledge [1]. However, the NLP network is just a probability model [2] and does not know whether Cao Cao is a man or cat. Indeed, it even does not understand what is a man. On the other hand, human being learns Cao Cao with his nickname via watching TV. When presented the question \u2018what\u2019s Cao Cao\u2019s nickname?\u2019, we can give the correct answer of \u2018Meng De\u2019 while imagining the figure of an actor in the brain. In this way, we say the machine network does not understand it, but the human does.",
          "Human beings possess such thinking capacity due to its cumulative learning capacity accompanying the neural developmental process. Initially, parent points to a real apple and teaches the baby \u2018this is an apple\u2019. After gradually assimilating the basic meanings of numerous nouns, children begin to learn some phrases and finally complicated syntaxes. Unlike the cumulative learning, most NLP techniques normally choose to learn by reading and predicting target words. After consuming billions of words in corpus materials [2], the NLP network can predict \u2018Trump\u2019 following \u2018Donald\u2019, but it is merely a probability machine.",
          "The human-like thinking system often requires specific neural substrates to support the corresponding functionalities. The most important brain area related to thinking is the prefrontal cortex (PFC), where the working memory takes place, including but not confined to, the maintenance and manipulation of particular information [3]. With the PFC, human beings can analyze and execute various tasks via \u2018phonological loop\u2019 and \u2018visuospatial scratchpad\u2019 etc. [4,5]. Inspired by the human-like brain organization, we build a \u2018PFC\u2019 network to combine language and vision streams to achieve tasks such as language controlled imagination, and imagination based thinking process. Our results show that the LGI network could incrementally learn eight syntaxes rapidly. Based on the LGI, we present the first language guided continual thinking process, which shows considerable promise for the human-like strong machine intelligence."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Our goal is to build a human-like neural network by removing components unsupported by neuroscience from AI architecture while introducing novel neural mechanisms and algorithms into it. Taking the convolution neural network (CNN) as an example, although it has reached human-level performance in image recognition tasks [6], animal neural systems do not support such kernel scanning operation across retinal neurons, and thus the neuronal responses measured on monkeys do not match that of CNN units [7,8]. Therefore, instead of CNN, we used fully connected (FC) module [9] to build our neural network, which achieved more resemblance to animal neurophysiology in term of the network development, neuronal firing patterns, object recognition mechanism, learning and forgetting mechanisms, as illustrated in our concurrent submission [10]. In addition, the error backpropagation technique is generally used to modify network weights to learn representation and achieve training objectives [11]. However, in neuroscience, it is the activity-dependent molecular events (e.g. the inflow of calcium ion and the switching of glutamate N-methyl-D-aspartate receptor etc.) that modify synaptic connections [12, 13]. Indeed, the real neural feedback connection provides the top-down imagery information [14], which is usually ignored by AI network constructions due to the concept of error backpropagation. What\u2019s more, our concurrent paper [10] demonstrates that the invariance property of visual recognition under the rotation, scaling, and translation of an object is supported by coordinated population coding rather than the max-pooling mechanism [15]. The softmax classification is usually used to compute the probability of each category (or word) in the repository (or vocabulary) before prediction. However, in reality, we never evaluate all fruit categories in mind before saying \u2018it is an apple\u2019, let alone the complicated computation of the normalization term in the softmax. In this paper, we demonstrate object classification is directly output by neurons via a simple rounding operation, rather than the neuroscience unsupported softmax classification [16].",
          "Modern autoencoder techniques could synthesize an unseen view for the desired viewpoint. Using car as an example [17], during training, the autoencoder learns the 3D characteristics of a car with a pair of images from two views of the same car together with the viewpoint of the output view. During testing, the autoencoder could predict the desired image from a single image of the car given the expected viewpoint. However, this architecture is task-specific, namely that the network can only make predictions on cars' unseen views. To include multiple tasks, we added an additional PFC layer that can receive task commands conveyed via language stream and object representation via the visual encoder pathway, and output the modulated images according to task commands and the desired text prediction associated with the images. In addition, by transmitting the output image from the decoder to the encoder, an imagination loop is formed, which enables the continual operation of a human-like thinking process involving both language and image."
        ]
      },
      {
        "section_name": "Architecture",
        "paragraphs": [
          "As is shown in Figure 1, the LGI network contains three main subsystems including the vision, language and PFC subsystems. The vision autoencoder network was trained separately, whose characteristics of development, recognition, learning, and forgetting can be referred to [10]. After training, the autoencoder is separated into two parts: the encoder (or recognition) part ranges from the image entry point to the final encoding layer, which functions as human anterior inferior temporal lobe (AIT) to provide the high-level abstract representation of the input image [18]; the decoder (or imagination) part ranges from the AIT to image prediction point. The activity vectors of the third encoding layer INLINEFORM0 and AIT layer INLINEFORM1 are concatenated with language activity vectors INLINEFORM2 as input signals to the PFC. We expect, after acquiring the language command, the PFC could output a desired visual activation vector INLINEFORM3 , based on which the imagination network could reconstruct the predicted image. Finally, the predicted or imagined image is fed back to the encoder network for the next thinking iteration.",
          "The language processing component first binarizes the input text symbol-wise into a sequence of binary vectors INLINEFORM0 , where T is the text length. To improve the language command recognition, we added one LSTM layer to extract the quantity information of the text (for example, suppose text = \u2018move left 12\u2019, the expected output INLINEFORM1 is 1 dimensional quantity 12 at the last time point). This layer mimics the number processing functionality of human Intra-Parietal Sulcus (IPS), so it is given the name IPS layer. The PFC outputs the desired activation of INLINEFORM2 , which can either be decoded by the \u2018texitizer\u2019 into predicted text or serve as INLINEFORM3 for the next iteration of the imagination process. Here, we propose a textizer (a rounding operation, followed by symbol mapping from binary vector, whose detailed discussion can be referred to the Supplementary section A) to classify the predicted symbol instead of softmax operation which has no neuroscience foundation.",
          "The PFC subsystem contains a LSTM and a full connected layer. It receives inputs from both language and vision subsystems in a concatenated form of INLINEFORM0 at time t, and gives a prediction output INLINEFORM1 , which is expected to be identical to INLINEFORM2 at time t+1. This has been achieved with a next frame prediction (NFP) loss function as, INLINEFORM3 . So given an input image, the PFC can predict the corresponding text description; while given an input text command the PFC can predict the corresponding manipulated image. This NFP loss function has neuroscience foundation, since the molecular mediated synaptic plasticity always takes place after the completion of an event, when the information of both t and t+1 time points have been acquired and presented by the neural system. The strategy of learning by predicting its own next frame is essentially an unsupervised learning.",
          "For human brain development, the visual and auditory systems mature in much earlier stages than the PFC [19]. To mimic this process, our PFC subsystem was trained separately after vision and language components had completed their functionalities. We have trained the network to accumulatively learn eight syntaxes, and the related results are shown in the following section. Finally, we demonstrate how the network forms a thinking loop with text language and imagined pictures."
        ]
      },
      {
        "section_name": "Experiment",
        "paragraphs": [
          "The first syntaxes that LGI has learned are the \u2018move left\u2019 and \u2018move right\u2019 random pixels, with the corresponding results shown in Figure 3. After 50000 steps training, LGI could not only reconstruct the input image with high precision but also predict the 'mentally' moved object with specified morphology, correct manipulated direction and position just after the command sentence completed. The predicted text can complete the word \u2018move\u2019 given the first letter \u2018m\u2019 (till now, LGI has only learned syntaxes of \u2018move left or right\u2019). LGI tried to predict the second word \u2018right\u2019 with initial letter \u2018r\u2019, however, after knowing the command text is \u2018l\u2019, it turned to complete the following symbols with \u2018eft\u2019. It doesn\u2019t care if the sentence length is 12 or 11, the predicted image and text just came at proper time and position. Even if the command asked to move out of screen, LGI still could reconstruct the partially occluded image with high fidelity.",
          "Based on the same network, LGI continued to learn syntax \u2018this is \u2026\u2019. Just like a parent teaching child numbers by pointing to number instances, Figure 4 demonstrates that, after training of 50000 steps, LGI could classify figures in various morphology with correct identity (accuracy = 72.7%). Note that, the classification process is not performed by softmax operation, but by directly textizing operation (i.e. rounding followed by a symbol mapping operation), which is more biologically plausible than the softmax operation.",
          "After that, LGI learned the syntax \u2018the size is big/small\u2019, followed by \u2018the size is not small/big\u2019. Figure 5 illustrates that LGI could correctly categorize whether the digit size was small or big with proper text output. And we witness that, based on the syntax of \u2018the size is big/small\u2019 (train steps =1000), the negative adverb \u2018not\u2019 in the language text \u2018the size is not small/big\u2019 was much easier to be learned (train steps =200, with same hyper-parameters). This is quite similar to the cumulative learning process of the human being.",
          "And then, LGI rapidly learned three more syntaxes: \u2018give me a \u2026\u2019, \u2018enlarge/shrink\u2019, and \u2018rotate \u2026\u2019, whose results are shown in Figure 6. After training (5000 steps), LGI could generate a correct digit figure given the language command \u2018give me a [number]\u2019 (Figure 6.A). The generated digit instance is somewhat the \u2018averaged\u2019 version of all training examples of the same digit identity. In the future, the generative adversarial network (GAN) technique could be included to generate object instances with specific details. However, using more specific language, such as \u2018give me a red Arial big 9\u2019 to generate the characterized instance can better resemble the human thinking process than GAN. LGI can also learn to change the size and orientation of an imagined object. Figure 6.B-C illustrates the morphology of the final imagined instance could be kept unchanged after experiencing various manipulations. Some other syntaxes or tasks could be integrated into LGI in a similar way.",
          "Finally, in Figure 7, we illustrate how LGI performed the human-like language-guided thinking process, with the above-learned syntaxes. (1) LGI first closed its eyes, namely, that no input images were fed into the vision subsystem (all the subsequent input images were generated through the imagination process). (2) LGI said to itself \u2018give me a 9\u2019, then the PFC produced the corresponding encoding vector INLINEFORM0 , and finally one digit \u20189\u2019 instance was reconstructed via the imagination network. (3) LGI gave the command \u2018rotate 180\u2019, then the imagined digit \u20189\u2019 was rotated upside down. (4) Following the language command \u2018this is \u2019, LGI automatically predicted that the newly imaged object was the digit \u20186\u2019. (5) LGI used \u2018enlarge\u2019 command to make the object bigger. (6) Finally, LGI predicted that the size was \u2018big\u2019 according to the imagined object morphology. This demonstrates that LGI can understand the verbs and nouns by properly manipulating the imagination, and can form the iterative thinking process via the interaction between vision and language subsystems through the PFC layer. The human thinking process normally would not form a concrete imagination through the full visual loop, but rather a vague and rapid imagination through the short-cut loop by feeding back INLINEFORM1 to AIT directly. On the other hand, the full path of clear imagination may explain the dream mechanism. Figure 7.B shows the short cut imagination process, where LGI also regarded the rotated \u20189\u2019 as digit 6, which suggests the AIT activation does not encode the digit identity, but the untangled features of input image or imagined image. Those high level cortices beyond visual cortex could be the place for identity representation."
        ]
      },
      {
        "section_name": "Discussion",
        "paragraphs": [
          "Language guided imagination is the nature of human thinking and intelligence. Normally, the real-time tasks or goals are conveyed by language, such as \u2018to build a Lego car\u2019. To achieve this goal, first, an agent (human being or machine) needs to know what\u2019s car, and then imagine a vague car instance, based on which the agent can plan to later collect wheel, window and chassis blocks for construction. Imagining the vague car is the foundation for decomposing future tasks. We trained the LGI network with a human-like cumulative learning process, from learning the meaning of words, to understanding complicated syntaxes, and finally organizing the thinking process with language. We trained the LGI to associate object name with corresponding instances by \u2018this is \u2026\u2019 syntax; and trained the LGI to produce a digit instance, when there comes the sentence \u2018give me a [number]\u2019. In contrast, traditional language models could only serve as a word dependency predictor rather than really understand the sentence.",
          "Language is the most remarkable characteristics distinguishing mankind from animals. Theoretically, all kinds of information such as object properties, tasks and goals, commands and even emotions can be described and conveyed by language [21]. We trained with LGI eight different syntaxes (in other word, eight different tasks), and LGI demonstrates its understanding by correctly interacting with the vision system. After learning \u2018this is 9\u2019, it is much easier to learn \u2018give me a 9\u2019; after learning the \u2018size is big\u2019, it is much easier to learn \u2018the size is not small\u2019. Maybe some digested words or syntaxes were represented by certain PFC units, which could be shared with the following sentence learning.",
          "Imagination is another key component of human thinking. For the game Go [22, 23], the network using a reinforcement learning strategy has to be trained with billions of games in order to acquire a feeling (Q value estimated for each potential action) to move the chess. As human beings, after knowing the rule conveyed by language, we can quickly start a game with proper moves using a try-in-imagination strategy without requiring even a single practice. With imagination, people can change the answering contents (or even tell good-will lies) by considering or imagining the consequence of the next few output sentences. Machine equipped with the unique ability of imagination could easily select clever actions for multiple tasks without being trained heavily.",
          "In the future, many more syntaxes and functionalities can be added to LGI in a similar way, such as math reasoning, intuitive physics prediction and navigation [24, 25, 26]. Insights of human audition processing could be leveraged to convert sound wave into language text as a direct input for LGI [27, 28]. And the mechanisms of human value systems in the striatum [29] may also endow LGI with motivation and emotion. The PFC cortex consists of many sub-regions interacted within the PFC and across the whole brain areas [3, 30], and the implementation of these features might finally enable LGI to possess real machine intelligence."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this paper, we first introduced a PFC layer to involve representations from both language and vision subsystems to form a human-like thinking system (the LGI system). The LGI contains three subsystems: the vision, language, and PFC subsystem, which are trained separately. The development, recognition and learning mechanism is discussed in the cocurrent paper [10]. In the language subsystem, we use an LSTM layer to mimic the human IPS to extract the quantity information from language text and proposed a biologically plausible textizer to produce text symbols output, instead of traditional softmax classifier. We propose to train the LGI with the NFP loss function, which endows the capacity to describe the image content in form of symbol text and manipulated images according to language commands. LGI shows its ability to learn eight different syntaxes or tasks in a cumulative learning way, and form the first machine thinking loop with the interaction between imagined pictures and language text."
        ]
      },
      {
        "section_name": "References",
        "paragraphs": [
          "[1] Wei, M., He, Y., Zhang, Q. & Si, L. (2019). Multi-Instance Learning for End-to-End Knowledge Base Question Answering. arXiv preprint arXiv:1903.02652.",
          "[2] Devlin, J., Chang, M. W., Lee, K. & Toutanova, K. (2018). Bert: Pre-training of deep bidirectional transformers for language understanding. arXiv preprint arXiv:1810.04805.",
          "[3] Miller, E. K. & Cohen, J. D. (2001). An integrative theory of prefrontal cortex function. Annual review of neuroscience, 24(1), 167-202.",
          "[4] Baddeley, A., Gathercole, S. & Papagno, C. (1998). The phonological loop as a language learning device. Psychological review, 105(1), 158.",
          "[5] Finke, K., Bublak, P., Neugebauer, U. & Zihl, J. (2005). Combined processing of what and where information within the visuospatial scratchpad. European Journal of Cognitive Psychology, 17(1), 1-22.",
          "[6] Simonyan, K. & Zisserman, A. (2014). Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556.",
          "[7] DiCarlo, J. J., Zoccolan, D. & Rust, N. C. (2012). How does the brain solve visual object recognition?. Neuron, 73(3), 415-434.",
          "[8] Freiwald, W. A. & Tsao, D. Y. (2010). Functional compartmentalization and viewpoint generalization within the macaque face-processing system. Science, 330(6005), 845-851.",
          "[9] Rosenblatt, F. (1958). The perceptron: a probabilistic model for information storage and organization in the brain. Psychological review, 65(6), 386.",
          "[10] Anonymous A. (2019). The development, recognition, and learning mechanisms of animal-like neural network. Advances in Neural Information Processing Systems, in submission",
          "[11] Rumelhart, D. E., Hinton, G. E. & Williams, R. J. (1988). Learning representations by back-propagating errors. Cognitive modeling, 5(3), 1.",
          "[12] Yasuda, R., Sabatini, B. L. & Svoboda, K. (2003). Plasticity of calcium channels in dendritic spines. Nature neuroscience, 6(9), 948.",
          "[13] Liu, L., Wong, T. P., Pozza, M. F., Lingenhoehl, K., Wang, Y., Sheng, M. & Wang, Y. T. (2004). Role of NMDA receptor subtypes in governing the direction of hippocampal synaptic plasticity. Science, 304(5673), 1021-1024.",
          "[14] Pearson, J., Naselaris, T., Holmes, E. A. & Kosslyn, S. M. (2015). Mental imagery: functional mechanisms and clinical applications. Trends in cognitive sciences, 19(10), 590-602.",
          "[15] Boureau, Y. L., Ponce, J. & LeCun, Y. (2010). A theoretical analysis of feature pooling in visual recognition. In Proceedings of the 27th international conference on machine learning (ICML-10) (pp. 111-118).",
          "[16] LeCun, Y., Bengio, Y. & Hinton, G. (2015). Deep learning. Nature, 521(7553), 436.",
          "[17] Zhou, T., Brown, M., Snavely, N. & Lowe, D. G. (2017). Unsupervised learning of depth and ego-motion from video. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 1851-1858).",
          "[18] Ralph, M. A. L., Jefferies, E., Patterson, K. & Rogers, T. T. (2017). The neural and computational bases of semantic cognition. Nature Reviews Neuroscience, 18(1), 42.",
          "[19] Petanjek, Z., Juda\u0161, M., Kostovi\u0107, I. & Uylings, H. B. (2007). Lifespan alterations of basal dendritic trees of pyramidal neurons in the human prefrontal cortex: a layer-specific pattern. Cerebral cortex, 18(4), 915-929.",
          "[20] Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S. & Bengio, Y. (2014). Generative adversarial nets. In Advances in neural information processing systems (pp. 2672-2680).",
          "[21] Wittgenstein, L. (2013). Tractatus logico-philosophicus.",
          "[22] Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., Van Den Driessche, G., & Dieleman, S. (2016). Mastering the game of Go with deep neural networks and tree search. Nature, 529(7587), 484.",
          "[23] Silver, D., Schrittwieser, J., Simonyan, K., Antonoglou, I., Huang, A., Guez, A. & Chen, Y. (2017). Mastering the game of go without human knowledge. Nature, 550(7676), 354.",
          "[24] Saxton, D., Grefenstette, E., Hill, F. & Kohli, P. (2019). Analysing Mathematical Reasoning Abilities of Neural Models. arXiv preprint arXiv:1904.01557.",
          "[25] Battaglia, P., Pascanu, R., Lai, M. & Rezende, D. J. (2016). Interaction networks for learning about objects, relations and physics. In Advances in neural information processing systems (pp. 4502-4510).",
          "[26] Banino, A., Barry, C., Uria, B., Blundell, C., Lillicrap, T., Mirowski, P. & Wayne, G. (2018). Vector-based navigation using grid-like representations in artificial agents. Nature, 557(7705), 429.",
          "[27] Jasmin, K., Lima, C. F. & Scott, S. K. (2019). Understanding rostral\u2013caudal auditory cortex contributions to auditory perception. Nature Reviews Neuroscience, in press.",
          "[28] Afouras, T., Chung, J. S. & Zisserman, A. (2018). The conversation: Deep audio-visual speech enhancement. arXiv preprint arXiv:1804.04121.",
          "[29] Husain, M. & Roiser, J. (2018). Neuroscience of apathy and anhedonia: a transdiagnostic approach. Nature Reviews Neuroscience, 19, 470-484.",
          "[30] Barbas, H. (2015). General cortical and special prefrontal connections: principles from structure to function. Annual review of neuroscience, 38, 269-289."
        ]
      }
    ],
    "qas": [
      {
        "question": "Do they report results only on English data?",
        "question_id": "693cdb9978749db04ba34d9c168e71534f00a226",
        "nlp_background": "five",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "e8b24c3133e0bec0a6465e1f13acd3a5ed816b37",
        "answers": [
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "0f16f51a71c8eb451630fd56aad68d181f0a4e66",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "The first syntaxes that LGI has learned are the \u2018move left\u2019 and \u2018move right\u2019 random pixels, with the corresponding results shown in Figure 3. After 50000 steps training, LGI could not only reconstruct the input image with high precision but also predict the 'mentally' moved object with specified morphology, correct manipulated direction and position just after the command sentence completed. The predicted text can complete the word \u2018move\u2019 given the first letter \u2018m\u2019 (till now, LGI has only learned syntaxes of \u2018move left or right\u2019). LGI tried to predict the second word \u2018right\u2019 with initial letter \u2018r\u2019, however, after knowing the command text is \u2018l\u2019, it turned to complete the following symbols with \u2018eft\u2019. It doesn\u2019t care if the sentence length is 12 or 11, the predicted image and text just came at proper time and position. Even if the command asked to move out of screen, LGI still could reconstruct the partially occluded image with high fidelity.",
                "FLOAT SELECTED: Figure 3: Mental manipulation of images based on syntaxes of \u2018move left x\u2019 and \u2018move right x\u2019, where x is a random number, ranging from 0 to 28. LGI has the capacity to correctly predict the next text symbols and image manipulation (with correct morphology, position, direction) at the proper time point. It can recognize the sentence with flexible text length and digit length."
              ],
              "highlighted_evidence": [
                "The first syntaxes that LGI has learned are the \u2018move left\u2019 and \u2018move right\u2019 random pixels, with the corresponding results shown in Figure 3. ",
                "FLOAT SELECTED: Figure 3: Mental manipulation of images based on syntaxes of \u2018move left x\u2019 and \u2018move right x\u2019, where x is a random number, ranging from 0 to 28. LGI has the capacity to correctly predict the next text symbols and image manipulation (with correct morphology, position, direction) at the proper time point. It can recognize the sentence with flexible text length and digit length."
              ]
            },
            "annotation_id": "83d16a90685b94fe9a92a83e74724fe0ba832912",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "Based on the same network, LGI continued to learn syntax \u2018this is \u2026\u2019. Just like a parent teaching child numbers by pointing to number instances, Figure 4 demonstrates that, after training of 50000 steps, LGI could classify figures in various morphology with correct identity (accuracy = 72.7%). Note that, the classification process is not performed by softmax operation, but by directly textizing operation (i.e. rounding followed by a symbol mapping operation), which is more biologically plausible than the softmax operation.",
                "After that, LGI learned the syntax \u2018the size is big/small\u2019, followed by \u2018the size is not small/big\u2019. Figure 5 illustrates that LGI could correctly categorize whether the digit size was small or big with proper text output. And we witness that, based on the syntax of \u2018the size is big/small\u2019 (train steps =1000), the negative adverb \u2018not\u2019 in the language text \u2018the size is not small/big\u2019 was much easier to be learned (train steps =200, with same hyper-parameters). This is quite similar to the cumulative learning process of the human being."
              ],
              "highlighted_evidence": [
                "Based on the same network, LGI continued to learn syntax \u2018this is \u2026\u2019. Just like a parent teaching child numbers by pointing to number instances, Figure 4 demonstrates that, after training of 50000 steps, LGI could classify figures in various morphology with correct identity (accuracy = 72.7%).",
                "After that, LGI learned the syntax \u2018the size is big/small\u2019, followed by \u2018the size is not small/big\u2019."
              ]
            },
            "annotation_id": "b5ed2c9c72e2686cbb2a5acdbc9c2fa1edd38326",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: The LGI architecture. It contains three subsystems that are trained separated. In the vision subsystem, the encoder can transfer an input or imagined (or predicted) image into a population representation vector V4 at the AIT layer (mimicking the Anterior Temporal Lobe for high-level image representation), and the decoder can reconstruct a V\u20323 output from PFC to a predicted image, which can be fed into the encoder to form the imagination loop. In the language subsystem, a binarizer can transfer the input text symbols into binary representation vectors L0, and a texitizer can transfer the predicted vector L\u20320 from the PFC into predicted text symbols, which can also be fed into the language loop. There is an IPS layer implemented by an LSTM to extract quantity information L1 from the text vector L0. The PFC layer serves as working memory, that takes the concatenated input [L0,L1,V3,V4] from both language and vision subsystems, and output the predicted next frame representation that could be fed back into both subsystems to form an imagination loop. LIG can use the short cut imagination path (rendered in grey) to rapidly feel the predicted scenario without fully reconstructing the predicted images."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Training based on the next frame prediction (NFP). The LSTM-like PFC is trained by the NFP principle, where the goal of the PFC is to output the representation vectors (including both language and vision) of the next frame, as indicated by red arrows. The red dash arrow indicates that, at time T, the PFC of LGI curately generated the mentally manipulated digit instance, which required the understanding of the previous text language and observed images."
      },
      {
        "file": "5-Figure3-1.png",
        "caption": "Figure 3: Mental manipulation of images based on syntaxes of \u2018move left x\u2019 and \u2018move right x\u2019, where x is a random number, ranging from 0 to 28. LGI has the capacity to correctly predict the next text symbols and image manipulation (with correct morphology, position, direction) at the proper time point. It can recognize the sentence with flexible text length and digit length."
      },
      {
        "file": "5-Figure4-1.png",
        "caption": "Figure 4: LGI learns to classify digits with syntax \u2018this is . . . \u2019. LGI understood the meaning of the command text and managed to extract digit identity according to the morphology of digit instance. Note that the classification is performed by the proposed textizer rather than softmax."
      },
      {
        "file": "6-Figure5-1.png",
        "caption": "Figure 5: LGI learns to judge the digit size with syntaxes \u2019the size is big/small\u2019 and \u2019the size is not small/big\u2019. LGI could understand the text command, offer correct judgment on digit size, and properly adjust the answer when encountered negative adverb \u2018not\u2019."
      },
      {
        "file": "6-Figure6-1.png",
        "caption": "Figure 6: LGI learns to generate a fictitious digit instance with syntax \u2018give me a [number]\u2019, and \u2018mentally\u2019 manipulate objects with syntaxes \u2018enlarge\u2019, \u2018shrink\u2019, and \u2018rotate . . . \u2019 etc."
      },
      {
        "file": "7-Figure7-1.png",
        "caption": "Figure 7: The language guided thinking process. LGI generated an instance of digit \u20189\u2019 without any input image. Then the instance was \u2018mentally\u2019 rotated 180 degree, based on which LGI found that the digit identity was changed to 6. After that, LGI enlarged the instance and identified its proper size."
      }
    ]
  },
  "1908.07491": {
    "title": "Controversy in Context",
    "abstract": "With the growing interest in social applications of Natural Language Processing and Computational Argumentation, a natural question is how controversial a given concept is. Prior works relied on Wikipedia's metadata and on content analysis of the articles pertaining to a concept in question. Here we show that the immediate textual context of a concept is strongly indicative of this property, and, using simple and language-independent machine-learning tools, we leverage this observation to achieve state-of-the-art results in controversiality prediction. In addition, we analyze and make available a new dataset of concepts labeled for controversiality. It is significantly larger than existing datasets, and grades concepts on a 0-10 scale, rather than treating controversiality as a binary label.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Indicating that a web page is controversial, or disputed - for example, in a search result - facilitates an educated consumption of the information therein, suggesting the content may not represent the \u201cfull picture\u201d. Here, we consider the problem of estimating the level of controversiality associated with a given Wikipedia concept (title). We demonstrate that the textual contexts in which the concept is referenced can be leveraged to facilitate this.",
          "The definition of which concepts are controversial is controversial by itself; an accurate definition of this elusive notion attracted the attention of researchers from various fields, see for example some recent attempts in BIBREF0, BIBREF1, BIBREF2.",
          "Most people would agree, for example, that Global warming is a controversial concept, whereas Summer is not. However, the concept Pollution may be seen as neutral by some, yet controversial by others, who associate it with environmental debates. In other words, different people may have different opinions, potentially driven by different contexts salient in their mind. Yet, as reported in the sequel, an appreciable level of agreement can be reached, even without explicit context.",
          "Focusing here on Wikipedia concepts, we adopt as an initial \u201cground truth\u201d the titles listed on the Wikipedia list of controversial issues, which is curated based on so-called \u201cedit wars\u201d. We then manually annotate a set of Wikipedia titles which are locked for editing, and evaluate our system on this much larger and more challenging dataset.",
          "To estimate the level of controversy associated with a Wikipedia concept, we propose to simply examine the words in the sentences in which the concept is referenced. Because a concept can often be found in multiple contexts, the estimation can be seen as reflecting the \u201cgeneral opinion\u201d about it in the corpus. This contrasts previous works, which consider this a binary problem, and employ a complex combination of features extracted from Wikipedia's article contents and inter-references, and more extensively \u2013 from the rich edit history thereof."
        ]
      },
      {
        "section_name": "Related work",
        "paragraphs": [
          "Analysis of controversy in Wikipedia, online news and social media has attracted considerable attention in recent years. Exploiting the collaborative structure of Wikipedia, estimators of the level of controversy in a Wikipedia article were developed based on the edit-history of the article BIBREF0, BIBREF3. Along these lines, BIBREF4 detect controversy based on mutual reverts, bi-polarity in the collaboration network, and mutually-reinforced scores for editors and articles. Similarly, BIBREF1 classify whether a Wikipedia page is controversial through the combined evaluation of the topically neighboring set of pages.",
          "Content analysis of controversial Wikipedia articles has been used to evaluate the level of controversy of other documents (e.g., web pages) by mapping them to related Wikipedia articles BIBREF5. BIBREF6 further build a language model, which enhances predictions made by existing classifiers, by inferring word probabilities from Wikipedia articles prominent in Wikipedia controversy features (mainly signals in edit history as discussed above) and from articles retrieved by manually selected query terms, believed to indicate controversy.",
          "BIBREF7 detect controversy in news items by inspecting terms with excessive frequency in contexts containing sentiment words, and BIBREF8 study controversy in user comments of news articles using lexicons. Finally, BIBREF9 suggest that controversy is not a universal but rather a community-related concept, and, therefore, should be studied in context.",
          "Here we measure a concept's controversiality from the explicit sentence-level context in which it is mentioned. In this, our approach is reminiscent of BIBREF10, who suggest a similar approach to detect abstract concepts."
        ]
      },
      {
        "section_name": "Estimating a concept's controversiality level ::: Datasets",
        "paragraphs": [
          "We consider three datasets, two of which are a contribution of this work.",
          "Dataset I consists of 480 concepts previously analyzed in BIBREF1, BIBREF4. 240 are positive examples, titles from the Wikipedia list of controversial issues, and 240 are negative examples chosen at random and exclusive of the positives. Over this dataset, we compare the methodology suggested here to those reported by BIBREF1, BIBREF4. As the latter report overall accuracy of their binary prediction, we convert our controversiality estimates to a binary classification by classifying the higher-scored half as controversial, and the lower half as non-controversial.",
          "Dataset II is based on a more recent version of the Wikipedia list of controversial issues (May 2017). As positive examples we take, from this list, all concepts which appear more than 50 times in Wikipedia. This leaves 608 controversial Wikipedia concepts. For negative examples, we follow BIBREF1, BIBREF4 and select a like number of concepts at random. Here too, since each concept only has a binary label, we convert our estimation into a binary classification, and report accuracy.",
          "Dataset III is extracted from 3561 concepts whose Wikipedia pages are under edit protection, assuming that many of them are likely to be controversial. They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. We used this dataset for testing the models trained on Dataset I.",
          "In all datasets, to obtain the sentence-level context of the concepts (positive and negative), we randomly select two equal-sized sets of Wikipedia sentences, that explicitly reference these concepts \u2013 i.e., that contain a hyperlink to the article titled by the concept. Importantly, in each sentence we mask the words that reference the concept \u2013 i.e., the surface form of the hyperlink leading to the concept \u2013 by a fixed, singular token, thus focusing solely on the context within which the concepts are mentioned."
        ]
      },
      {
        "section_name": "Estimating a concept's controversiality level ::: Controversiality Estimators",
        "paragraphs": [
          "We employ three estimation schemes based on the textual contexts of concepts. The first relies on the context via pre-trained word embeddings of the concepts, which, in turn, are derived from the concepts' distributional properties in large samples of free texts. The other two schemes directly access the sentence-level contexts of the concepts.",
          "Nearest neighbors (NN) Estimator: We used the pre-trained GloVe embeddings BIBREF11 of concepts to implement a nearest-neighbor estimator as follows. Given a concept $c$, we extract all labeled concepts within a given radius $r$ (cosine similarity $0.3$). In one variant, $c$'s controversiality score is taken to be the fraction of controversial concepts among them. In another variant, labeled concepts are weighted by their cosine similarity to $c$.",
          "Naive Bayes (NB) Estimator: A Naive Bayes model was learned, with a bag-of-words feature set, using the word counts in the sentences of our training data \u2013 the contexts of the controversial and non-controversial concepts. The controversiality score of a concept $c$ for its occurrence in a sentence $s$, is taken as the posterior probability (according to the NB model) of $s$ to contain a controversial concept, given the words of $s$ excluding $c$, and taking a prior of $0.5$ for controversiality (as is the case in the datasets). The controversiality score of $c$ is then defined as the average score over all sentences referencing $c$.",
          "Recurrent neural network (RNN): A bidirectional RNN using the architecture suggested in BIBREF10 was similarly trained. The network receives as input a concept and a referring sentence, and outputs a score. The controversiality score of a concept is defined, as above, to be the average of these scores."
        ]
      },
      {
        "section_name": "Estimating a concept's controversiality level ::: Validation ::: Random @!START@$k$@!END@-fold",
        "paragraphs": [
          "We first examined the estimators in $k$-fold cross-validation scheme on the datasets I and II with $k=10$: the set of positive (controversial) concepts was split into 10 equal size sets, and the corresponding sentences were split accordingly. Each set was matched with similarly sized sets of negative (non-controversial) concepts and corresponding sentences. For each fold, a model was generated from the training sentences and used to score the test concepts. Scores were converted into a binary classification, as described in SECREF3, and accuracy was computed accordingly. Finally, the accuracy over the $k$ folds was averaged."
        ]
      },
      {
        "section_name": "Estimating a concept's controversiality level ::: Validation ::: Leave one category out",
        "paragraphs": [
          "In a preliminary task, we looked for words which may designate sentences associated with controversial concepts. To this end, we ranked the words appearing in positive sentences according to their information gain for this task. The top of the list comprises the following: that, sexual, people, movement, religious, issues, rights.",
          "The Wikipedia list of controversial issues specifies categories for the listed concepts, like Politics and economics, Religion, History, and Sexuality (some concepts are associated with two or more categories). While some top-ranked words - that, people, issues - do seem to directly indicate controversiality BIBREF12, BIBREF13, others seem to have more to do with the category they belong to. Although these categories may indeed indicate controversiality, we consider this as an indirect or implicit indication, since it is more related to the controversial theme than to controversiality per-se.",
          "To control for this effect, we performed a second experiment where we set the concepts from one category as the test set, and used the others for training (concepts associated with the excluded category are left out, regardless of whether they are also associated with one of the training categories). We did this for 5 categories: History, Politics and economics, Religion, Science, and Sexuality. This way, thematic relatedness observed in the training set should have little or no effect on correctly estimating the level of controversy associated of concepts in the test set, and may even \u201cmislead\u201d the estimator. We note that previous work on controversiality does not seem to address this issue, probably because the meta-data used is less sensitive to it."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "Table TABREF14 compares the accuracy reported on Dataset I for the methods suggested in BIBREF1, BIBREF4 with the accuracy obtained by our methods, as well as the latter on Dataset II, using 10-fold cross-validation in all cases. Table TABREF14 reports accuracy results of the more stringent analysis described in section SECREF13.",
          "BIBREF4 review several controversy classifiers. The most accurate one, the Structure classifier, builds, among others, collaboration networks by considering high-level behavior of editors both in their individual forms, and their pairwise interactions. A collaboration profile containing these individual and pairwise features is built for each two interacting editors and is classified based on the agreement or disagreement relation between them. This intensive computation renders that classifier impractical. Table TABREF14 therefore also includes the most accurate classifier BIBREF4 consider practical.",
          "As seen in Table TABREF14, for the usual 10-fold analysis the simple classifiers suggested here are on par with the best and more complex classifier reported in BIBREF4. Moreover, in the leave-one-category-out setting (Table TABREF14), accuracy indeed drops, but only marginally. We also observe the superiority of classifiers that directly access the context (NB and RNN) over classifiers that access it via word embedding (NN).",
          "Table TABREF14 presents results obtained when models trained on Dataset I are applied to Dataset III. For this experiment we also included a BERT network BIBREF14 fine tuned on Dataset I. The Pearson correlation between the scores obtained via manual annotation and the scores generated by our automatic estimators suggests a rather strong linear relationship between the two. Accuracy was computed as for previous datasets, by taking here as positive examples the concepts receiving 6 or more positive votes, and as negative a random sample of 670 concepts out of the 1182 concepts receiving no positive vote."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "We demonstrated that the sentence\u2013level context in which a concept appears is indicative of its controversiality. This follows BIBREF10, who show this for concept abstractness and suggest to explore further properties identifiable in this way. Importantly, we observed that this method may pick up signals which are not directly related to the property of interest. For example, since many controversial concepts have to do with religion, part of what this method may learn is thematic relatedness to religion. However, when controlling for this effect, the drop in accuracy is fairly small.",
          "The major advantages of our estimation scheme are its simplicity and reliance on abundantly accessible features. At the same time, its accuracy is similar to state-of-the-art classifiers, which depend on complex meta-data, and rely on sophisticated - in some cases impractical - algorithmic techniques. Because the features herein are so simple, our estimators are convertible to any corpus, in any language, even of moderate size.",
          "Recently, IBM introduced Project Debater BIBREF15, an AI system that debates humans on controversial topics. Training and evaluating such a system undoubtedly requires an extensive supply of such topics, which can be enabled by the automatic extraction methods suggested here as well as the new datasets."
        ]
      },
      {
        "section_name": "Acknowledgment",
        "paragraphs": [
          "We are grateful to Shiri Dori-Hacohen and Hoda Sepehri Rad for sharing their data with us and giving us permission to use it."
        ]
      }
    ],
    "qas": [
      {
        "question": "how was labeling done?",
        "question_id": "4de6bcddd46726bf58326304b0490fdb9e7e86ec",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. After that, annotations were normalized to controversiality scores on an integer scale of 0 - 10",
              "evidence": [
                "Dataset III is extracted from 3561 concepts whose Wikipedia pages are under edit protection, assuming that many of them are likely to be controversial. They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. We used this dataset for testing the models trained on Dataset I."
              ],
              "highlighted_evidence": [
                "The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. "
              ]
            },
            "annotation_id": "107cf459cf81c7bb69fcd2f64a1c7d8d966879ee",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "10 or more annotators marked whether a topic was controversial or not. The score was then normalized on an integer scale of 0-10.",
              "evidence": [
                "Dataset III is extracted from 3561 concepts whose Wikipedia pages are under edit protection, assuming that many of them are likely to be controversial. They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. We used this dataset for testing the models trained on Dataset I."
              ],
              "highlighted_evidence": [
                "They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. "
              ]
            },
            "annotation_id": "bfebe4ffea719f5522ae76edd287554ecd22188c",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "As positive examples we take, from this list, all concepts which appear more than 50 times in Wikipedia.",
                "For negative examples, we follow BIBREF1, BIBREF4 and select a like number of concepts at random",
                "The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10."
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Dataset II is based on a more recent version of the Wikipedia list of controversial issues (May 2017). As positive examples we take, from this list, all concepts which appear more than 50 times in Wikipedia. This leaves 608 controversial Wikipedia concepts. For negative examples, we follow BIBREF1, BIBREF4 and select a like number of concepts at random. Here too, since each concept only has a binary label, we convert our estimation into a binary classification, and report accuracy.",
                "Dataset III is extracted from 3561 concepts whose Wikipedia pages are under edit protection, assuming that many of them are likely to be controversial. They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10. We used this dataset for testing the models trained on Dataset I."
              ],
              "highlighted_evidence": [
                "Dataset II is based on a more recent version of the Wikipedia list of controversial issues (May 2017). As positive examples we take, from this list, all concepts which appear more than 50 times in Wikipedia. This leaves 608 controversial Wikipedia concepts. For negative examples, we follow BIBREF1, BIBREF4 and select a like number of concepts at random.",
                "Dataset III is extracted from 3561 concepts whose Wikipedia pages are under edit protection, assuming that many of them are likely to be controversial. They were then crowd-annotated, with 10 or more annotators per concept. The annotation instructions were: \u201cGiven a topic and its description on Wikipedia, mark if this is a topic that people are likely to argue about.\u201d. Average pairwise kappa agreement on this task was 0.532. Annotations were normalized to controversiality scores on an integer scale of 0 - 10."
              ]
            },
            "annotation_id": "de23c42be3a336e0dd1ad6ab722834d4d9e8a788",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: Accuracy obtained by controversiality classifiers with 10-fold cross validation."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: Accuracy obtained by controversiality classifiers using leave-one-category-out cross validation."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Pearson Correlation and Accuracy obtained by using the models from Dataset I on Dataset III."
      }
    ]
  },
  "1805.11850": {
    "title": "Neural Joking Machine : Humorous image captioning",
    "abstract": "What is an effective expression that draws laughter from human beings? In the present paper, in order to consider this question from an academic standpoint, we generate an image caption that draws a\"laugh\"by a computer. A system that outputs funny captions based on the image caption proposed in the computer vision field is constructed. Moreover, we also propose the Funny Score, which flexibly gives weights according to an evaluation database. The Funny Score more effectively brings out\"laughter\"to optimize a model. In addition, we build a self-collected BoketeDB, which contains a theme (image) and funny caption (text) posted on\"Bokete\", which is an image Ogiri website. In an experiment, we use BoketeDB to verify the effectiveness of the proposed method by comparing the results obtained using the proposed method and those obtained using MS COCO Pre-trained CNN+LSTM, which is the baseline and idiot created by humans. We refer to the proposed method, which uses the BoketeDB pre-trained model, as the Neural Joking Machine (NJM).",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Laughter is a special, higher-order function that only humans possess. In the analysis of laughter, as Wikipedia says, \u201cLaughter is thought to be a shift of composition (schema)\", and laughter frequently occurs when there is a change from a composition of receiver. However, the viewpoint of laughter differs greatly depending on the position of the receiver. Therefore, the quantitative measurement of laughter is very difficult. Image Ogiri on web services such as \"Bokete\" BIBREF0 have recently appeared, where users post funny captions for thematic images and the captions are evaluated in an SNS-like environment. Users compete to obtain the greatest number of \u201cstars\u201d. Although quantification of laughter is considered to be a very difficult task, the correspondence between evaluations and images on Bokete allows us to treat laughter quantitatively. Image captioning is an active topic in computer vision, and we believe that humorous image captioning can be realized. The main contributions of the present paper are as follows:",
          "BoketeDB",
          "In the experimental section, we compare the proposed method based on Funny Score and BoketeDB pre-trained parameters with a baseline provided by MS COCO Pre-trained CNN+LSTM. We also compare the results of the NJM with funny captions provided by humans. In an evaluation by humans, the results provided by the proposed method were ranked lower than those provided by humans (22.59% vs. 67.99%) but were ranked higher than the baseline (9.41%). Finally, we show the generated funny captions for several images."
        ]
      },
      {
        "section_name": "Related Research",
        "paragraphs": [
          "Through the great research progress with deep neural networks (DNNs), the combination of a convolutional neural network and a recurrent neural network (CNN+RNN) is a successful model for both feature extraction and sequential processing BIBREF1 . Although there is no clear division, a CNN is often used for image processing, whereas an RNN is used for text processing. Moreover, these two domains are integrated. One successful application is image caption generation with CNN+LSTM (CNN+Long-Short Term Memory) BIBREF2 . This technique enables text to be automatically generated from an image input. However, we believe that image captions require human intuition and emotion. In the present paper, we help to guide an image caption has funny expression. In the following, we introduce related research on humorous image caption generation.",
          "Wang et al. proposed an automatic \u201cmeme\" generation technique BIBREF3 . A meme is a funny image that often includes humorous text. Wang et al. statistically analyzed the correlation between memes and comments in order to automatically generate a meme by modeling probabilistic dependencies, such as those of images and text.",
          "Chandrasekaran et al. conducted a humor enhancement of an image BIBREF4 by constructing an analyzer to quantify \u201cvisual humor\u201d in an image input. They also constructed datasets including interesting (3,200) and non-interesting (3,200) human-labeled images to evaluate visual humor. The \u201cfunniness\u201d of an image can be trained by defining five stages."
        ]
      },
      {
        "section_name": "Proposed Method",
        "paragraphs": [
          "We effectively train a funny caption generator by using the proposed Funny Score by weight evaluation. We adopt CNN+LSTM as a baseline, but we have been exploring an effective scoring function and database construction. We refer to the proposed method as the Neural Joking Machine (NJM), which is combined with the BoketeDB pre-trained model, as described in Section SECREF4 ."
        ]
      },
      {
        "section_name": "CNN+LSTM",
        "paragraphs": [
          "The flow of the proposed method is shown in Figure FIGREF2 . Basically, we adopted the CNN+LSTM model used in Show and Tell, but the CNN is replaced by ResNet-152 as an image feature extraction method. In the next subsection, we describe in detail how to calculate a loss function with a Funny Score. The function appropriately evaluates the number of stars and its \u201cfunniness\u201d."
        ]
      },
      {
        "section_name": "Funny Score",
        "paragraphs": [
          "The Bokete Ogiri website uses the number of stars to evaluate the degree of funniness of a caption. The user evaluates the \u201cfunniness\u201d of a posted caption and assigns one to three stars to the caption. Therefore, funnier captions tend to be assigned a lot of stars. We focus on the number of stars in order to propose an effective training method, in which the Funny Score enables us to evaluate the funniness of a caption. Based on the results of our pre-experiment, a Funny Score of 100 stars is treated as a threshold. In other words, the Funny Score outputs a loss value INLINEFORM0 when #star is less than 100. In contrast, the Funny Score returns INLINEFORM1 when #star is over 100. The loss value INLINEFORM2 is calculated with the LSTM as an average of each mini-batch."
        ]
      },
      {
        "section_name": "BoketeDB",
        "paragraphs": [
          "We have downloaded pairs of images and funny captions in order to construct a Bokete Database (BoketeDB). As of March 2018, 60M funny captions and 3.4M images have been posted on the Bokete Ogiri website. In the present study, we consider 999,571 funny captions for 70,981 images. A number of pair between image and funny caption is posted in temporal order on the Ogiri website Bokete. We collected images and funny captions to make corresponding image and caption pairs. Thus, we obtained a database for generating funny captions like an image caption one.",
          "Comparison with MS COCO BIBREF5 . MS COCO contains a correspondence for each of 160,000 images to one of five types of captions. In comparison with MS COCO, BoketeDB has approximately half the number of the images and 124% the number of captions."
        ]
      },
      {
        "section_name": "Experiment",
        "paragraphs": [
          "We conducted evaluations to confirm the effectiveness of the proposed method. We describe the experimental method in Section SECREF11 , and the experimental results are presented in Section SECREF12 ."
        ]
      },
      {
        "section_name": "Experimental contents",
        "paragraphs": [
          "Here, we describe the experimental method used to validate the effectiveness of the NJM. We compare the proposed method with two other methods of generating funny captions: 1) human generated captions, which are highly ranked on Bokete (indicated by \u201cHuman\" in Table TABREF10 ), and 2) Japanese image caption generation using CNN+LSTM pre-trained by STAIR caption BIBREF7 . Based on the captions provided by MS COCO, the STAIR caption is translated from English to Japanese (indicated by \u201cSTAIR caption\u201d in Table TABREF10 ). We use a questionnaire as the evaluation method. We selected a total of 30 themes from the Bokete Ogiri website that included \u201cpeople\u201d, \u201ctwo or more people\u201d, \u201canimals\u201d, \u201clandscape\u201d, \u201cinorganics\u201d, and \u201cillustrations\u201d. The questionnaire asks respondents to rank the captions provided by humans, the NJM, and STAIR caption in order of \u201cfunniness\u201d. The questionnaire does not reveal the origins of the captions."
        ]
      },
      {
        "section_name": "Questionnaire Results",
        "paragraphs": [
          "In this subsection, we present the experimental results along with a discussion. Table TABREF10 shows the experimental results of the questionnaire. A total of 16 personal questionnaires were completed. Table TABREF10 shows the percentages of captions of each rank for each method of caption generation considered herein. Captions generated by humans were ranked \u201cfunniest\u201d 67.99% of the time, followed by the NJM at 22.59%. The baseline captions, STAIR caption, were ranked \u201cfunniest\u201d 9.41% of the time. These results suggest that captions generated by the NJM are less funny than those generated by humans. However, the NJM is ranked much higher than STAIR caption."
        ]
      },
      {
        "section_name": "Posting to Bokete",
        "paragraphs": [
          "We are currently posting funny captions generated by the NJM to the Bokete Ogiri website in order to evaluate the proposed method. Here, we compare the proposed method with STAIR captions. As reported by Bokete users, the funny captions generated by STAIR caption averaged 1.71 stars, whereas the NJM averaged 3.23 stars. Thus, the NJM is funnier than the baseline STAIR caption according to Bokete users. We believe that this difference is the result of using (i) Funny Score to effectively train the generator regarding funny captions and (ii) the self-collected BoketeDB, which is a large-scale database for funny captions."
        ]
      },
      {
        "section_name": "Visual results",
        "paragraphs": [
          "Finally, we present the visual results in Figure FIGREF14 , which includes examples of funny captions obtained using NJM. Although the original caption is in Japanese, we also translated the captions into English. Enjoy!"
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In the present paper, we proposed a method by which to generate captions that draw laughter. We built the BoketeDB, which contains pairs comprising a theme (image) and a corresponding funny caption (text) posted on the Bokete Ogiri website. We effectively trained a funny caption generator with the proposed Funny Score by weight evaluation. Although we adopted CNN+LSTM as a baseline, we have been exploring an effective scoring function and database construction. The experiments of the present study suggested that the NJM was much funnier than the baseline STAIR caption."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is the performance of NJM?",
        "question_id": "267d70d9f3339c56831ea150d2213643fbc5129b",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "NJM vas selected as the funniest caption among the three options 22.59% of the times, and NJM captions posted to Bokete averaged 3.23 stars",
              "evidence": [
                "In this subsection, we present the experimental results along with a discussion. Table TABREF10 shows the experimental results of the questionnaire. A total of 16 personal questionnaires were completed. Table TABREF10 shows the percentages of captions of each rank for each method of caption generation considered herein. Captions generated by humans were ranked \u201cfunniest\u201d 67.99% of the time, followed by the NJM at 22.59%. The baseline captions, STAIR caption, were ranked \u201cfunniest\u201d 9.41% of the time. These results suggest that captions generated by the NJM are less funny than those generated by humans. However, the NJM is ranked much higher than STAIR caption.",
                "We are currently posting funny captions generated by the NJM to the Bokete Ogiri website in order to evaluate the proposed method. Here, we compare the proposed method with STAIR captions. As reported by Bokete users, the funny captions generated by STAIR caption averaged 1.71 stars, whereas the NJM averaged 3.23 stars. Thus, the NJM is funnier than the baseline STAIR caption according to Bokete users. We believe that this difference is the result of using (i) Funny Score to effectively train the generator regarding funny captions and (ii) the self-collected BoketeDB, which is a large-scale database for funny captions.",
                "We effectively train a funny caption generator by using the proposed Funny Score by weight evaluation. We adopt CNN+LSTM as a baseline, but we have been exploring an effective scoring function and database construction. We refer to the proposed method as the Neural Joking Machine (NJM), which is combined with the BoketeDB pre-trained model, as described in Section SECREF4 .",
                "Here, we describe the experimental method used to validate the effectiveness of the NJM. We compare the proposed method with two other methods of generating funny captions: 1) human generated captions, which are highly ranked on Bokete (indicated by \u201cHuman\" in Table TABREF10 ), and 2) Japanese image caption generation using CNN+LSTM pre-trained by STAIR caption BIBREF7 . Based on the captions provided by MS COCO, the STAIR caption is translated from English to Japanese (indicated by \u201cSTAIR caption\u201d in Table TABREF10 ). We use a questionnaire as the evaluation method. We selected a total of 30 themes from the Bokete Ogiri website that included \u201cpeople\u201d, \u201ctwo or more people\u201d, \u201canimals\u201d, \u201clandscape\u201d, \u201cinorganics\u201d, and \u201cillustrations\u201d. The questionnaire asks respondents to rank the captions provided by humans, the NJM, and STAIR caption in order of \u201cfunniness\u201d. The questionnaire does not reveal the origins of the captions."
              ],
              "highlighted_evidence": [
                "In this subsection, we present the experimental results along with a discussion. Table TABREF10 shows the experimental results of the questionnaire. A total of 16 personal questionnaires were completed. Table TABREF10 shows the percentages of captions of each rank for each method of caption generation considered herein. Captions generated by humans were ranked \u201cfunniest\u201d 67.99% of the time, followed by the NJM at 22.59%. The baseline captions, STAIR caption, were ranked \u201cfunniest\u201d 9.41% of the time. These results suggest that captions generated by the NJM are less funny than those generated by humans. However, the NJM is ranked much higher than STAIR caption.",
                "We are currently posting funny captions generated by the NJM to the Bokete Ogiri website in order to evaluate the proposed method. Here, we compare the proposed method with STAIR captions. As reported by Bokete users, the funny captions generated by STAIR caption averaged 1.71 stars, whereas the NJM averaged 3.23 stars.",
                "We effectively train a funny caption generator by using the proposed Funny Score by weight evaluation. We adopt CNN+LSTM as a baseline, but we have been exploring an effective scoring function and database construction. We refer to the proposed method as the Neural Joking Machine (NJM), which is combined with the BoketeDB pre-trained model, as described in Section SECREF4 .",
                "Here, we describe the experimental method used to validate the effectiveness of the NJM. We compare the proposed method with two other methods of generating funny captions: 1) human generated captions, which are highly ranked on Bokete (indicated by \u201cHuman\" in Table TABREF10 ), and 2) Japanese image caption generation using CNN+LSTM pre-trained by STAIR caption BIBREF7"
              ]
            },
            "annotation_id": "0f3e939701493561142fa56ae5a407c69fa4176e",
            "worker_id": "5053f146237e8fc8859ed3984b5d3f02f39266b7"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "It obtained a score of 22.59%",
              "evidence": [
                "FLOAT SELECTED: Table 1. Comparison of the output results: The \u201cHuman\u201d row indicates captions provided by human users and was ranked highest on the Bokete website. The \u201cNJM\u201d row indicates the results of applying the proposed model based of Funny Score and BoketeDB. The \u201cSTAIR caption\u201d row indicates the results provided by Japanese translation of MS COCO."
              ],
              "highlighted_evidence": [
                "FLOAT SELECTED: Table 1. Comparison of the output results: The \u201cHuman\u201d row indicates captions provided by human users and was ranked highest on the Bokete website. The \u201cNJM\u201d row indicates the results of applying the proposed model based of Funny Score and BoketeDB. The \u201cSTAIR caption\u201d row indicates the results provided by Japanese translation of MS COCO."
              ]
            },
            "annotation_id": "7724b0747279716cc9dee52eb2602011a3909950",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Captions generated by NJM were ranked \"funniest\" 22.59% of the time.",
              "evidence": [
                "In this subsection, we present the experimental results along with a discussion. Table TABREF10 shows the experimental results of the questionnaire. A total of 16 personal questionnaires were completed. Table TABREF10 shows the percentages of captions of each rank for each method of caption generation considered herein. Captions generated by humans were ranked \u201cfunniest\u201d 67.99% of the time, followed by the NJM at 22.59%. The baseline captions, STAIR caption, were ranked \u201cfunniest\u201d 9.41% of the time. These results suggest that captions generated by the NJM are less funny than those generated by humans. However, the NJM is ranked much higher than STAIR caption."
              ],
              "highlighted_evidence": [
                "Captions generated by humans were ranked \u201cfunniest\u201d 67.99% of the time, followed by the NJM at 22.59%."
              ]
            },
            "annotation_id": "c2e04ff84377b77ba7d7a3f67af865566b659621",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Figure1-1.png",
        "caption": "Figure 1. Examples of funny captions generated by NJM from an image input."
      },
      {
        "file": "2-Figure2-1.png",
        "caption": "Figure 2. Proposed CNN+LSTM architecture for funny caption generation."
      },
      {
        "file": "3-Table1-1.png",
        "caption": "Table 1. Comparison of the output results: The \u201cHuman\u201d row indicates captions provided by human users and was ranked highest on the Bokete website. The \u201cNJM\u201d row indicates the results of applying the proposed model based of Funny Score and BoketeDB. The \u201cSTAIR caption\u201d row indicates the results provided by Japanese translation of MS COCO."
      },
      {
        "file": "4-Figure3-1.png",
        "caption": "Figure 3. Visual results obtain using the proposed NJM."
      }
    ]
  },
  "1710.06923": {
    "title": "Adapting general-purpose speech recognition engine output for domain-specific natural language question answering",
    "abstract": "Speech-based natural language question-answering interfaces to enterprise systems are gaining a lot of attention. General-purpose speech engines can be integrated with NLP systems to provide such interfaces. Usually, general-purpose speech engines are trained on large `general' corpus. However, when such engines are used for specific domains, they may not recognize domain-specific words well, and may produce erroneous output. Further, the accent and the environmental conditions in which the speaker speaks a sentence may induce the speech engine to inaccurately recognize certain words. The subsequent natural language question-answering does not produce the requisite results as the question does not accurately represent what the speaker intended. Thus, the speech engine's output may need to be adapted for a domain before further natural language processing is carried out. We present two mechanisms for such an adaptation, one based on evolutionary development and the other based on machine learning, and show how we can repair the speech-output to make the subsequent natural language question-answering better.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Speech-enabled natural-language question-answering interfaces to enterprise application systems, such as Incident-logging systems, Customer-support systems, Marketing-opportunities systems, Sales data systems etc., are designed to allow end-users to speak-out the problems/questions that they encounter and get automatic responses. The process of converting human spoken speech into text is performed by an Automatic Speech Recognition (ASR) engine. While functional examples of ASR with enterprise systems can be seen in day-to-day use, most of these work under constraints of a limited domain, and/or use of additional domain-specific cues to enhance the speech-to-text conversion process. Prior speech-and-natural language interfaces for such purposes have been rather restricted to either Interactive Voice Recognition (IVR) technology, or have focused on building a very specialized speech engine with domain specific terminology that recognizes key-words in that domain through an extensively customized language model, and trigger specific tasks in the enterprise application system. This makes the interface extremely specialized, rather cumbersome and non-adaptable for other domains. Further, every time a new enterprise application requires a speech and natural language interface, one has to redevelop the entire interface again.",
          "An alternative to domain-specific speech recognition engines has been to re-purpose general-purpose speech recognition engines, such as Google Speech API, IBM Watson Speech to text API which can be used across domains with natural language question answering systems. Such general-purpose automatic speech engines (gp-ASR) are deep trained on very large general corpus using deep neural network (DNN) techniques. The deep learnt acoustic and language models enhance the performance of a ASR. However, this comes with its own limitations. For freely spoken natural language sentences, the typical recognition accuracy achievable even for state-of-the-art speech recognition systems have been observed to be about 60% to 90% in real-world environments BIBREF0 . The recognition is worse if we consider factors such as domain-specific words, environmental noise, variations in accent, poor ability to express on the part of the user, or inadequate speech and language resources from the domain to train such speech recognition systems. The subsequent natural language processing, such as that in a question answering system, of such erroneously and partially recognized text becomes rather problematic, as the domain terms may be inaccurately recognized or linguistic errors may creep into the sentence. It is, hence, important to improve the accuracy of the ASR output text.",
          "In this paper, we focus on the issues of using a readily available gp-ASR and adapting its output for domain-specific natural language question answering BIBREF1 . We present two mechanisms for adaptation, namely",
          "We present the results of these two adaptation and gauge the usefulness of each mechanism. The rest of the paper is organized as follows, in Section SECREF2 we briefly describe the work done in this area which motivates our contribution. The main contribution of our work is captured in Section SECREF3 and we show the performance of our approach through experiments in Section SECREF4 . We conclude in Section SECREF5 ."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Most work on ASR error detection and correction has focused on using confidence measures, generally called the log-likelihood score, provided by the speech recognition engine; the text with lower confidence is assumed to be incorrect and subjected to correction. Such confidence based methods are useful only when we have access to the internals of a speech recognition engine built for a specific domain. As mentioned earlier, use of domain-specific engine requires one to rebuild the interface every time the domain is updated, or a new domain is introduced. As mentioned earlier, our focus is to avoid rebuilding the interface each time the domain changes by using an existing ASR. As such our method is specifically a post-ASR system. A post-ASR system provides greater flexibility in terms of absorbing domain variations and adapting the output of ASR in ways that are not possible during training a domain-specific ASR system BIBREF2 .",
          "Note that an erroneous ASR output text will lead to an equally (or more) erroneous interpretation by the natural language question-answering system, resulting in a poor performance of the overall QA system",
          "Machine learning classifiers have been used in the past for the purpose of combining features to calculate a confidence score for error detection. Non-linguistic and syntactic knowledge for detection of errors in ASR output, using a support vector machine to combine non-linguistic features was proposed in BIBREF3 and Naive Bayes classifier to combine confidence scores at a word and utterance level, and differential scores of the alternative hypotheses was used in BIBREF4 Both BIBREF3 and BIBREF4 rely on the availability of confidence scores output by the ASR engine. A syllable-based noisy channel model combined with higher level semantic knowledge for post recognition error correction, independent of the internal confidence measures of the ASR engine is described in BIBREF5 . In BIBREF6 the authors propose a method to correct errors in spoken dialogue systems. They consider several contexts to correct the speech recognition output including learning a threshold during training to decide when the correction must be carried out in the context of a dialogue system. They however use the confidence scores associated with the output text to do the correction or not. The correction is carried using syntactic-semantic and lexical models to decide whether a recognition result is correct.",
          "In BIBREF7 the authors proposes a method to detect and correct ASR output based on Microsoft N-Gram dataset. They use a context-sensitive error correction algorithm for selecting the best candidate for correction using the Microsoft N-Gram dataset which contains real-world data and word sequences extracted from the web which can mimic a comprehensive dictionary of words having a large and all-inclusive vocabulary.",
          "In BIBREF8 the authors assume the availability of pronunciation primitive characters as the output of the ASR engine and then use domain-specific named entities to establish the context, leading to the correction of the speech recognition output. The patent BIBREF9 proposes a manual correction of the ASR output transcripts by providing visual display suggesting the correctness of the text output by ASR. Similarly, BIBREF10 propose a re-ranking and classification strategy based on logistic regression model to estimate the probability for choosing word alternates to display to the user in their framework of a tap-to-correct interface.",
          "Our proposed machine learning based system is along the lines of BIBREF5 but with differences: (a) while they use a single feature (syllable count) for training, we propose the use of multiple features for training the Naive Bayes classifier, and (b) we do not perform any manual alignment between the ASR and reference text \u2013 this is done using an edit distance based technique for sentence alignment. Except for BIBREF5 all reported work in this area make use of features from the internals of the ASR engine for ASR text output error detection.",
          "We assume the use of a gp-ASR in the rest of the paper. Though we use examples of natural language sentences in the form of queries or questions, it should be noted that the description is applicable to any conversational natural language sentence."
        ]
      },
      {
        "section_name": "Errors in ASR  output",
        "paragraphs": [
          "In this paper we focus on question answering interfaces to enterprise systems, though our discussion is valid for any kind of natural language processing sentences that are not necessarily a query. For example, suppose we have a retail-sales management system domain, then end-users would be able to query the system through spoken natural language questions ( INLINEFORM0 ) such as INLINEFORM1 ",
          "A perfect ASR would take INLINEFORM0 as the input and produce ( INLINEFORM1 ), namely, INLINEFORM2 ",
          "We consider the situation where a ASR takes such a sentence ( INLINEFORM0 ) spoken by a person as input, and outputs an inaccurately recognized text ( INLINEFORM1 ) sentence. In our experiments, when the above question was spoken by a person and processed by a popular ASR engine such as Google Speech API, the output text sentence was ( INLINEFORM2 ) INLINEFORM3 ",
          "Namely INLINEFORM0 ",
          " It should be noted that an inaccurate output by the ASR engine maybe the result of various factors such as background noise, accent of the person speaking the sentence, the speed at which he or she is speaking the sentence, domain-specific words that are not part of popular vocabulary etc. The subsequent natural language question answering system cannot answer the above output sentence from its retail sales data. Thus the question we tackle here is \u2013 how do we adapt or repair the sentence ( INLINEFORM0 ) back to the original sentence ( INLINEFORM1 ) as intended by the speaker. Namely INLINEFORM2 ",
          " We present two mechanisms for adaptation or repair of the ASR output, namely INLINEFORM0 , in this paper: (a) an evolutionary development based artificial development mechanism, and (b) a machine-learning mechanism."
        ]
      },
      {
        "section_name": "Machine Learning mechanism of adaptation",
        "paragraphs": [
          "In the machine learning based mechanism of adaptation, we assume the availability of example pairs of INLINEFORM0 namely (ASR output, the actual transcription of the spoken sentence) for training. We further assume that such a machine-learnt model can help repair an unseen ASR output to its intended correct sentence. We address the following hypothesis",
          "Using the information from past recorded errors and the corresponding correction, can we learn how to repair (and thus adapt to a new domain) the text after ASR?",
          "Note that this is equivalent to, albiet loosely, learning the error model of a specific ASR. Since we have a small training set, we have used the Naive Bayes classifier that is known to perform well for small datasets with high bias and low variance. We have used the NLTK BIBREF11 Naive Bayes classifier in all our experiments.",
          "Let INLINEFORM0 be the erroneous text (which is the ASR output), INLINEFORM1 the corresponding reference text (which is the textual representation of the spoken sentence) and INLINEFORM2 a feature extractor, such that DISPLAYFORM0 ",
          "where DISPLAYFORM0 ",
          "is a set of INLINEFORM0 features extracted from INLINEFORM1 . Suppose there are several pairs say ( INLINEFORM2 , INLINEFORM3 ) for INLINEFORM4 . Then we can derive INLINEFORM5 for each INLINEFORM6 using ( EQREF7 ). The probability that INLINEFORM7 belongs to the class INLINEFORM8 can be derived through the feature set INLINEFORM9 as follows. INLINEFORM10 ",
          "where INLINEFORM0 is the apriori probability of the class INLINEFORM1 and INLINEFORM2 is the probability of occurrence of the features INLINEFORM3 in the class INLINEFORM4 , and INLINEFORM5 is the overall probability of the occurrence of the feature set INLINEFORM6 . Making naive assumption of independence in the features INLINEFORM7 we get DISPLAYFORM0 ",
          "In our experiments, the domain specific reference text INLINEFORM0 was spoken by several people and the spoken speech was passed through a general purpose speech recognition engine (ASR) that produced a (possibly) erroneous hypothesis INLINEFORM1 . Each pair of reference and the ASR output (i.e. hypothesis) was then word aligned using edit distance, and the mismatching pairs of words were extracted as INLINEFORM2 pairs. For example, if we have the following spoken sentence: INLINEFORM3 ",
          "and the corresponding true transcription INLINEFORM0 ",
          "One of the corresponding ASR output INLINEFORM0 was INLINEFORM1 ",
          "In this case the INLINEFORM0 pairs are (dear, beer) and (have, has). As another example consider that INLINEFORM1 was spoken but INLINEFORM2 was recognized by the ASR. INLINEFORM3 INLINEFORM4 ",
          "Clearly, in this case the INLINEFORM0 pair is (than twenty, jewelry).",
          "Let us assume two features, namely, INLINEFORM0 in ( EQREF7 ) is of dimension INLINEFORM1 . Let the two features be INLINEFORM2 . Then, for the INLINEFORM3 pair (than twenty, jewelry) we have INLINEFORM4 ",
          "since the number of words in than twenty is 2 and than twenty contains 3 syllables. INLINEFORM0 in this case would be the probability that the number of words in the input are two ( INLINEFORM1 ) when the correction is jewelry. A third example is: INLINEFORM2 INLINEFORM3 ",
          "Note that in this case the INLINEFORM0 pair is (peak sales, pixel).",
          "Calculating thus the values of INLINEFORM0 for all reference corrections, INLINEFORM1 for all feature values, INLINEFORM2 for all the INLINEFORM3 features in INLINEFORM4 , we are in a position to calculate the RHS of ( EQREF9 ). When this trained classifier is given an erroneous text, features are extracted from this text and the repair works by replacing the erroneous word by a correction that maximizes ( EQREF9 ), INLINEFORM5 ",
          "Namely, the INLINEFORM0 for which INLINEFORM1 is maximum."
        ]
      },
      {
        "section_name": "Experiments and results",
        "paragraphs": [
          "We present the results of our experiments with both the Evo-Devo and the Machine Learning mechanisms described earlier using the U.S. Census Bureau conducted Annual Retail Trade Survey of U.S. Retail and Food Services Firms for the period of 1992 to 2013 BIBREF12 ."
        ]
      },
      {
        "section_name": "Data Preparation",
        "paragraphs": [
          "We downloaded this survey data and hand crafted a total of 293 textual questions BIBREF13 which could answer the survey data. A set of 6 people (L2 English) generated 50 queries each with the only constraint that these queries should be able to answer the survey data. In all a set of 300 queries were crafted of which duplicate queries were removed to leave 293 queries in all. Of these, we chose 250 queries randomly and distributed among 5 Indian speakers, who were asked to read aloud the queries into a custom-built audio data collecting application. So, in all we had access to 250 audio queries spoken by 5 different Indian speakers; each speaking 50 queries.",
          "Each of these 250 audio utterances were passed through 4 different ASR engines, namely, Google ASR (Ga), Kaldi with US acoustic models (Ku), Kaldi with Indian Acoustic models (Ki) and PocketSphinx ASR (Ps). In particular, that audio utterances were in wave format (.wav) with a sampling rate of 8 kHz and 16 bit. In case of Google ASR (Ga), each utterance was first converted into .flac format using the utility sound exchange (sox) commonly available on Unix machines. The .flac audio files were sent to the cloud based Google ASR (Ga) one by one in a batch mode and the text string returned by Ga was stored. In all 7 utterances did not get any text output, presumably Ga was unable to recognize the utterance. For all the other 243 utterances a text output was received.",
          "In case of the other ASR engines, namely, Kaldi with US acoustic models (Ku), Kaldi with Indian Acoustic models (Ki) and PocketSphinx ASR (Ps) we first took the queries corresponding to the 250 utterances and built a statistical language model (SLM) and a lexicon using the scripts that are available with PocketSphinx BIBREF14 and Kaldi BIBREF15 . This language model and lexicon was used with the acoustic model that were readily available with Kaldi and Ps. In case of Ku we used the American English acoustic models, while in case of Ki we used the Indian English acoustic model. In case of Ps we used the Voxforge acoustic models BIBREF16 . Each utterance was passed through Kaldi ASR for two different acoustic models to get INLINEFORM0 corresponding to Ku and Ki. Similarly all the 250 audio utterance were passed through the Ps ASR to get the corresponding INLINEFORM1 for Ps. A sample utterance and the output of the four engines is shown in Figure FIGREF12 .",
          "Figure FIGREF11 and Table TABREF14 capture the performance of the different speech recognition engines. The performance of the ASR engines varied, with Ki performing the best with 127 of the 250 utterances being correctly recognized while Ps returned only 44 correctly recognized utterances (see Table TABREF14 , Column 4 named \"Correct\") of 250 utterances. The accuracy of the ASR varied widely. For instance, in case of Ps there were as many as 97 instances of the 206 erroneously recognized utterances which had an accuracy of less than 70%.",
          "Note that the accuracy is computed as the number of deletions, insertions, substitutions that are required to convert the ASR output to the textual reference (namely, INLINEFORM0 ) and is a common metric used in speech literature BIBREF17 .",
          "For all our analysis, we used only those utterances that had an accuracy 70% but less that INLINEFORM0 , namely, 486 instances (see Table TABREF14 , Figure FIGREF13 ). An example showing the same utterance being recognized by four different ASR engines is shown in Figure FIGREF12 . Note that we used INLINEFORM1 corresponding to Ga, Ki and Ku in our analysis (accuracy INLINEFORM2 ) and not INLINEFORM3 corresponding to Ps which has an accuracy of INLINEFORM4 only. This is based on our observation that any ASR output that is lower that INLINEFORM5 accurate is so erroneous that it is not possible to adapt and steer it towards the expected output.",
          "The ASR output ( INLINEFORM0 ) are then given as input in the Evo-Devo and Machine Learning mechanism of adaptation."
        ]
      },
      {
        "section_name": " Evo-Devo based experiments",
        "paragraphs": [
          "We ran our Evo-Devo mechanism with the 486 ASR sentences (see Table TABREF14 ) and measured the accuracy after each repair. On an average we have achieved about 5 to 10% improvements in the accuracy of the sentences. Fine-tuning the repair and fitness functions, namely Equation (), would probably yield much better performance accuracies. However, experimental results confirm that the proposed Evo-Devo mechanism is an approach that is able to adapt INLINEFORM0 to get closer to INLINEFORM1 . We present a snapshot of the experiments with Google ASR (Ga) and calculate accuracy with respect to the user spoken question as shown in Table TABREF16 .",
          "Table TABREF16 clearly demonstrates the promise of the evo-devo mechanism for adaptation/repair. In our experiments we observed that the adaptation/repair of sub-parts in ASR-output ( INLINEFORM0 ) that most probably referred to domain terms occurred well and were easily repaired, thus contributing to increase in accuracy. For non-domain-specific linguistic terms the method requires one to build very good linguistic repair rules, without which the method could lead to a decrease in accuracy. One may need to fine-tune the repair, match and fitness functions for linguistic terms. However, we find the abstraction of evo-devo mechanism is very apt to use."
        ]
      },
      {
        "section_name": "Machine Learning experiments",
        "paragraphs": [
          "In the machine learning technique of adaptation, we considers INLINEFORM0 pairs as the predominant entity and tests the accuracy of classification of errors.",
          "In our experiment, we used a total of 570 misrecognition errors (for example, (dear, beer) and (have, has) derived from INLINEFORM0 or (than twenty, jewelry) derived from INLINEFORM1 ) in the 486 sentences. We performed 10-fold cross validation, each fold containing 513 INLINEFORM2 pairs for training and 57 pairs for testing, Note that we assume the erroneous words in the ASR output being marked by a human oracle, in the training as well as the testing set. Suppose the following example ( INLINEFORM3 ) occurs in the training set: INLINEFORM4 INLINEFORM5 ",
          "The classifier is given the pair INLINEFORM0 (latest stills), cumulative sales} to the classifier. And if the following example occurs in the testing set ( INLINEFORM1 ), INLINEFORM2 INLINEFORM3 ",
          "the trained model or the classifier is provided INLINEFORM0 (wine) and successful repair would mean it correctly labels (adapts) it to remain the. The features used for classification were ( INLINEFORM1 in Equation ( EQREF8 ))",
          "",
          "The combination of features INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 , INLINEFORM4 namely, (bag of consonants, bag of vowels, left context, number of words, right context) gave the best results with INLINEFORM5 % improvement in accuracy in classification over 10-fold validation.",
          "The experimental results for both evo-devo and machine learning based approaches demonstrate that these techniques can be used to correct the erroneous output of ASR. This is what we set out to establish in this paper."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "General-purpose ASR engines when used for enterprise domains may output erroneous text, especially when encountering domain-specific terms. One may have to adapt/repair the ASR output in order to do further natural language processing such as question-answering. We have presented two mechanisms for adaptation/repair of ASR-output with respect to a domain. The Evo-Devo mechanism provides a bio-inspired abstraction to help structure the adaptation and repair process. This is one of the main contribution of this paper. The machine learning mechanism provides a means of adaptation and repair by examining the feature-space of the ASR output. The results of the experiments show that both these mechanisms are promising and may need further development."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "Nikhil, Chirag, Aditya have contributed in conducting some of the experiments. We acknowledge their contribution."
        ]
      }
    ],
    "qas": [
      {
        "question": "Which of their proposed domain adaptation methods proves best overall?",
        "question_id": "b9a3836cff16af7454c7a8b0e5ff90206d0db1f5",
        "nlp_background": "",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "2cfd959e433f290bb50b55722370f0d22fe090b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Machine learning approach",
              "evidence": [
                "We ran our Evo-Devo mechanism with the 486 ASR sentences (see Table TABREF14 ) and measured the accuracy after each repair. On an average we have achieved about 5 to 10% improvements in the accuracy of the sentences. Fine-tuning the repair and fitness functions, namely Equation (), would probably yield much better performance accuracies. However, experimental results confirm that the proposed Evo-Devo mechanism is an approach that is able to adapt INLINEFORM0 to get closer to INLINEFORM1 . We present a snapshot of the experiments with Google ASR (Ga) and calculate accuracy with respect to the user spoken question as shown in Table TABREF16 .",
                "In the machine learning technique of adaptation, we considers INLINEFORM0 pairs as the predominant entity and tests the accuracy of classification of errors.",
                "The combination of features INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 , INLINEFORM4 namely, (bag of consonants, bag of vowels, left context, number of words, right context) gave the best results with INLINEFORM5 % improvement in accuracy in classification over 10-fold validation."
              ],
              "highlighted_evidence": [
                "We ran our Evo-Devo mechanism with the 486 ASR sentences (see Table TABREF14 ) and measured the accuracy after each repair. On an average we have achieved about 5 to 10% improvements in the accuracy of the sentences.",
                "In the machine learning technique of adaptation, we considers INLINEFORM0 pairs as the predominant entity and tests the accuracy of classification of errors.",
                "The combination of features INLINEFORM0 , INLINEFORM1 , INLINEFORM2 , INLINEFORM3 , INLINEFORM4 namely, (bag of consonants, bag of vowels, left context, number of words, right context) gave the best results with INLINEFORM5 % improvement in accuracy in classification over 10-fold validation."
              ]
            },
            "annotation_id": "58f3a0d4da795208a496138913b8887b872a8005",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": true,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [],
              "highlighted_evidence": []
            },
            "annotation_id": "e20bba251f1f60e72bfafd3d1a0c2a5d6d405de3",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "7-Figure1-1.png",
        "caption": "Fig. 1 Fitness Function."
      },
      {
        "file": "10-Table1-1.png",
        "caption": "Table 1 Ontology Structure."
      },
      {
        "file": "14-Figure2-1.png",
        "caption": "Fig. 2 T \u2032 accuracy (y-axis) for the 250 utterance (x-axis) for Ga, Ki, Ku and Ps."
      },
      {
        "file": "15-Table2-1.png",
        "caption": "Table 2 ASR engines and their output %accuracy"
      },
      {
        "file": "16-Figure4-1.png",
        "caption": "Fig. 4 All utterances that have and T \u2032 accuracy (y-axis) \u2265 70 and < 100 used in all our experiments."
      },
      {
        "file": "17-Table3-1.png",
        "caption": "Table 3 Evo-Devo experiments with Google ASR (Ga)."
      }
    ]
  },
  "1906.01749": {
    "title": "Multi-News: a Large-Scale Multi-Document Summarization Dataset and Abstractive Hierarchical Model",
    "abstract": "Automatic generation of summaries from multiple news articles is a valuable tool as the number of online publications grows rapidly. Single document summarization (SDS) systems have benefited from advances in neural encoder-decoder model thanks to the availability of large datasets. However, multi-document summarization (MDS) of news articles has been limited to datasets of a couple of hundred examples. In this paper, we introduce Multi-News, the first large-scale MDS news dataset. Additionally, we propose an end-to-end model which incorporates a traditional extractive summarization model with a standard SDS model and achieves competitive results on MDS datasets. We benchmark several methods on Multi-News and release our data and code in hope that this work will promote advances in summarization in the multi-document setting.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Summarization is a central problem in Natural Language Processing with increasing applications as the desire to receive content in a concise and easily-understood format increases. Recent advances in neural methods for text summarization have largely been applied in the setting of single-document news summarization and headline generation BIBREF0 , BIBREF1 , BIBREF2 . These works take advantage of large datasets such as the Gigaword Corpus BIBREF3 , the CNN/Daily Mail (CNNDM) dataset BIBREF4 , the New York Times dataset BIBREF5 and the Newsroom corpus BIBREF6 , which contain on the order of hundreds of thousands to millions of article-summary pairs. However, multi-document summarization (MDS), which aims to output summaries from document clusters on the same topic, has largely been performed on datasets with less than 100 document clusters such as the DUC 2004 BIBREF7 and TAC 2011 BIBREF8 datasets, and has benefited less from advances in deep learning methods.",
          "Multi-document summarization of news events offers the challenge of outputting a well-organized summary which covers an event comprehensively while simultaneously avoiding redundancy. The input documents may differ in focus and point of view for an event. We present an example of multiple input news documents and their summary in Figure TABREF2 . The three source documents discuss the same event and contain overlaps in content: the fact that Meng Wanzhou was arrested is stated explicitly in Source 1 and 3 and indirectly in Source 2. However, some sources contain information not mentioned in the others which should be included in the summary: Source 3 states that (Wanzhou) is being sought for extradition by the US while only Source 2 mentioned the attitude of the Chinese side.",
          "Recent work in tackling this problem with neural models has attempted to exploit the graph structure among discourse relations in text clusters BIBREF9 or through an auxiliary text classification task BIBREF10 . Additionally, a couple of recent papers have attempted to adapt neural encoder decoder models trained on single document summarization datasets to MDS BIBREF11 , BIBREF12 , BIBREF13 .",
          "However, data sparsity has largely been the bottleneck of the development of neural MDS systems. The creation of large-scale multi-document summarization dataset for training has been restricted due to the sparsity and cost of human-written summaries. liu18wikisum trains abstractive sequence-to-sequence models on a large corpus of Wikipedia text with citations and search engine results as input documents. However, no analogous dataset exists in the news domain. To bridge the gap, we introduce Multi-News, the first large-scale MDS news dataset, which contains 56,216 articles-summary pairs. We also propose a hierarchical model for neural abstractive multi-document summarization, which consists of a pointer-generator network BIBREF1 and an additional Maximal Marginal Relevance (MMR) BIBREF14 module that calculates sentence ranking scores based on relevancy and redundancy. We integrate sentence-level MMR scores into the pointer-generator model to adapt the attention weights on a word-level. Our model performs competitively on both our Multi-News dataset and the DUC 2004 dataset on ROUGE scores. We additionally perform human evaluation on several system outputs.",
          "Our contributions are as follows: We introduce the first large-scale multi-document summarization datasets in the news domain. We propose an end-to-end method to incorporate MMR into pointer-generator networks. Finally, we benchmark various methods on our dataset to lay the foundations for future work on large-scale MDS."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Traditional non-neural approaches to multi-document summarization have been both extractive BIBREF14 , BIBREF15 , BIBREF16 , BIBREF17 , BIBREF18 as well as abstractive BIBREF19 , BIBREF20 , BIBREF21 , BIBREF22 . Recently, neural methods have shown great promise in text summarization, although largely in the single-document setting, with both extractive BIBREF23 , BIBREF24 , BIBREF25 and abstractive methods BIBREF26 , BIBREF27 , BIBREF1 , BIBREF28 , BIBREF29 , BIBREF30 , BIBREF2 ",
          "In addition to the multi-document methods described above which address data sparsity, recent work has attempted unsupervised and weakly supervised methods in non-news domains BIBREF31 , BIBREF32 . The methods most related to this work are SDS adapted for MDS data. zhang18mds adopts a hierarchical encoding framework trained on SDS data to MDS data by adding an additional document-level encoding. baumel18mds incorporates query relevance into standard sequence-to-sequence models. lebanoff18mds adapts encoder-decoder models trained on single-document datasets to the MDS case by introducing an external MMR module which does not require training on the MDS dataset. In our work, we incorporate the MMR module directly into our model, learning weights for the similarity functions simultaneously with the rest of the model."
        ]
      },
      {
        "section_name": "Multi-News Dataset",
        "paragraphs": [
          "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com. Each summary is professionally written by editors and includes links to the original articles cited. We will release stable Wayback-archived links, and scripts to reproduce the dataset from these links. Our dataset is notably the first large-scale dataset for MDS on news articles. Our dataset also comes from a diverse set of news sources; over 1,500 sites appear as source documents 5 times or greater, as opposed to previous news datasets (DUC comes from 2 sources, CNNDM comes from CNN and Daily Mail respectively, and even the Newsroom dataset BIBREF6 covers only 38 news sources). A total of 20 editors contribute to 85% of the total summaries on newser.com. Thus we believe that this dataset allows for the summarization of diverse source documents and summaries."
        ]
      },
      {
        "section_name": "Statistics and Analysis",
        "paragraphs": [
          "The number of collected Wayback links for summaries and their corresponding cited articles totals over 250,000. We only include examples with between 2 and 10 source documents per summary, as our goal is MDS, and the number of examples with more than 10 sources was minimal. The number of source articles per summary present, after downloading and processing the text to obtain the original article text, varies across the dataset, as shown in Table TABREF4 . We believe this setting reflects real-world situations; often for a new or specialized event there may be only a few news articles. Nonetheless, we would like to summarize these events in addition to others with greater news coverage.",
          "We split our dataset into training (80%, 44,972), validation (10%, 5,622), and test (10%, 5,622) sets. Table TABREF5 compares Multi-News to other news datasets used in experiments below. We choose to compare Multi-News with DUC data from 2003 and 2004 and TAC 2011 data, which are typically used in multi-document settings. Additionally, we compare to the single-document CNNDM dataset, as this has been recently used in work which adapts SDS to MDS BIBREF11 . The number of examples in our Multi-News dataset is two orders of magnitude larger than previous MDS news data. The total number of words in the concatenated inputs is shorter than other MDS datasets, as those consist of 10 input documents, but larger than SDS datasets, as expected. Our summaries are notably longer than in other works, about 260 words on average. While compressing information into a shorter text is the goal of summarization, our dataset tests the ability of abstractive models to generate fluent text concise in meaning while also coherent in the entirety of its generally longer output, which we consider an interesting challenge."
        ]
      },
      {
        "section_name": "Diversity",
        "paragraphs": [
          "We report the percentage of n-grams in the gold summaries which do not appear in the input documents as a measure of how abstractive our summaries are in Table TABREF6 . As the table shows, the smaller MDS datasets tend to be more abstractive, but Multi-News is comparable and similar to the abstractiveness of SDS datasets. Grusky:18 additionally define three measures of the extractive nature of a dataset, which we use here for a comparison. We extend these notions to the multi-document setting by concatenating the source documents and treating them as a single input. Extractive fragment coverage is the percentage of words in the summary that are from the source article, measuring the extent to which a summary is derivative of a text: DISPLAYFORM0 ",
          "where A is the article, S the summary, and INLINEFORM0 the set of all token sequences identified as extractive in a greedy manner; if there is a sequence of source tokens that is a prefix of the remainder of the summary, that is marked as extractive. Similarly, density is defined as the average length of the extractive fragment to which each summary word belongs: DISPLAYFORM0 ",
          "Finally, compression ratio is defined as the word ratio between the articles and its summaries: DISPLAYFORM0 ",
          "These numbers are plotted using kernel density estimation in Figure FIGREF11 . As explained above, our summaries are larger on average, which corresponds to a lower compression rate. The variability along the x-axis (fragment coverage), suggests variability in the percentage of copied words, with the DUC data varying the most. In terms of y-axis (fragment density), our dataset shows variability in the average length of copied sequence, suggesting varying styles of word sequence arrangement. Our dataset exhibits extractive characteristics similar to the CNNDM dataset."
        ]
      },
      {
        "section_name": "Other Datasets",
        "paragraphs": [
          "As discussed above, large scale datasets for multi-document news summarization are lacking. There have been several attempts to create MDS datasets in other domains. zopf18mds introduce a multi-lingual MDS dataset based on English and German Wikipedia articles as summaries to create a set of about 7,000 examples. liu18wikisum use Wikipedia as well, creating a dataset of over two million examples. That paper uses Wikipedia references as input documents but largely relies on Google search to increase topic coverage. We, however, are focused on the news domain, and the source articles in our dataset are specifically cited by the corresponding summaries. Related work has also focused on opinion summarization in the multi-document setting; angelidis18opinions introduces a dataset of 600 Amazon product reviews."
        ]
      },
      {
        "section_name": "Preliminaries",
        "paragraphs": [
          "We introduce several common methods for summarization."
        ]
      },
      {
        "section_name": "Pointer-generator Network",
        "paragraphs": [
          "The pointer-generator network BIBREF1 is a commonly-used encoder-decoder summarization model with attention BIBREF33 which combines copying words from source documents and outputting words from a vocabulary. The encoder converts each token INLINEFORM0 in the document into the hidden state INLINEFORM1 . At each decoding step INLINEFORM2 , the decoder has a hidden state INLINEFORM3 . An attention distribution INLINEFORM4 is calculated as in BIBREF33 and is used to get the context vector INLINEFORM5 , which is a weighted sum of the encoder hidden states, representing the semantic meaning of the related document content for this decoding time step:",
          " DISPLAYFORM0 ",
          " The context vector INLINEFORM0 and the decoder hidden state INLINEFORM1 are then passed to two linear layers to produce the vocabulary distribution INLINEFORM2 . For each word, there is also a copy probability INLINEFORM3 . It is the sum of the attention weights over all the word occurrences:",
          " DISPLAYFORM0 ",
          " The pointer-generator network has a soft switch INLINEFORM0 , which indicates whether to generate a word from vocabulary by sampling from INLINEFORM1 , or to copy a word from the source sequence by sampling from the copy probability INLINEFORM2 .",
          " DISPLAYFORM0 ",
          "where INLINEFORM0 is the decoder input. The final probability distribution is a weighted sum of the vocabulary distribution and copy probability:",
          "P(w) = pgenPvocab(w) + (1-pgen)Pcopy(w)"
        ]
      },
      {
        "section_name": "Transformer",
        "paragraphs": [
          "The Transformer model replaces recurrent layers with self-attention in an encoder-decoder framework and has achieved state-of-the-art results in machine translation BIBREF34 and language modeling BIBREF35 , BIBREF36 . The Transformer has also been successfully applied to SDS BIBREF2 . More specifically, for each word during encoding, the multi-head self-attention sub-layer allows the encoder to directly attend to all other words in a sentence in one step. Decoding contains the typical encoder-decoder attention mechanisms as well as self-attention to all previous generated output. The Transformer motivates the elimination of recurrence to allow more direct interaction among words in a sequence."
        ]
      },
      {
        "section_name": "MMR",
        "paragraphs": [
          "Maximal Marginal Relevance (MMR) is an approach for combining query-relevance with information-novelty in the context of summarization BIBREF14 . MMR produces a ranked list of the candidate sentences based on the relevance and redundancy to the query, which can be used to extract sentences. The score is calculated as follows:",
          "MMR=*argmax D i RS [ Sim 1 (D i ,Q)-(1-) D j S Sim2 (D i ,D j ) ] where INLINEFORM0 is the collection of all candidate sentences, INLINEFORM1 is the query, INLINEFORM2 is the set of sentences that have been selected, and INLINEFORM3 is set of the un-selected ones. In general, each time we want to select a sentence, we have a ranking score for all the candidates that considers relevance and redundancy. A recent work BIBREF11 applied MMR for multi-document summarization by creating an external module and a supervised regression model for sentence importance. Our proposed method, however, incorporates MMR with the pointer-generator network in an end-to-end manner that learns parameters for similarity and redundancy."
        ]
      },
      {
        "section_name": "Hi-MAP Model",
        "paragraphs": [
          "In this section, we provide the details of our Hierarchical MMR-Attention Pointer-generator (Hi-MAP) model for multi-document neural abstractive summarization. We expand the existing pointer-generator network model into a hierarchical network, which allows us to calculate sentence-level MMR scores. Our model consists of a pointer-generator network and an integrated MMR module, as shown in Figure FIGREF19 ."
        ]
      },
      {
        "section_name": "Sentence representations",
        "paragraphs": [
          "To expand our model into a hierarchical one, we compute sentence representations on both the encoder and decoder. The input is a collection of sentences INLINEFORM0 from all the source documents, where a given sentence INLINEFORM1 is made up of input word tokens. Word tokens from the whole document are treated as a single sequential input to a Bi-LSTM encoder as in the original encoder of the pointer-generator network from see2017ptrgen (see bottom of Figure FIGREF19 ). For each time step, the output of an input word token INLINEFORM2 is INLINEFORM3 (we use superscript INLINEFORM4 to indicate word-level LSTM cells, INLINEFORM5 for sentence-level).",
          "To obtain a representation for each sentence INLINEFORM0 , we take the encoder output of the last token for that sentence. If that token has an index of INLINEFORM1 in the whole document INLINEFORM2 , then the sentence representation is marked as INLINEFORM3 . The word-level sentence embeddings of the document INLINEFORM4 will be a sequence which is fed into a sentence-level LSTM network. Thus, for each input sentence INLINEFORM5 , we obtain an output hidden state INLINEFORM6 . We then get the final sentence-level embeddings INLINEFORM7 (we omit the subscript for sentences INLINEFORM8 ). To obtain a summary representation, we simply treat the current decoded summary as a single sentence and take the output of the last step of the decoder: INLINEFORM9 . We plan to investigate alternative methods for input and output sentence embeddings, such as separate LSTMs for each sentence, in future work."
        ]
      },
      {
        "section_name": "MMR-Attention",
        "paragraphs": [
          "Now, we have all the sentence-level representation from both the articles and summary, and then we apply MMR to compute a ranking on the candidate sentences INLINEFORM0 . Intuitively, incorporating MMR will help determine salient sentences from the input at the current decoding step based on relevancy and redundancy.",
          "We follow Section 4.3 to compute MMR scores. Here, however, our query document is represented by the summary vector INLINEFORM0 , and we want to rank the candidates in INLINEFORM1 . The MMR score for an input sentence INLINEFORM2 is then defined as:",
          "MMR i = Sim 1 (hs i ,ssum)-(1-) sj D, j i Sim2 (hs i ,hs j ) We then add a softmax function to normalize all the MMR scores of these candidates as a probability distribution. MMR i = ( MMR i )i( MMR i ) Now we define the similarity function between each candidate sentence INLINEFORM0 and summary sentence INLINEFORM1 to be: DISPLAYFORM0 ",
          "where INLINEFORM0 is a learned parameter used to transform INLINEFORM1 and INLINEFORM2 into a common feature space.",
          "For the second term of Equation SECREF21 , instead of choosing the maximum score from all candidates except for INLINEFORM0 , which is intended to find the candidate most similar to INLINEFORM1 , we choose to apply a self-attention model on INLINEFORM2 and all the other candidates INLINEFORM3 . We then choose the largest weight as the final score:",
          " DISPLAYFORM0 ",
          " Note that INLINEFORM0 is also a trainable parameter. Eventually, the MMR score from Equation SECREF21 becomes:",
          " MMR i = Sim 1 (hsi,ssum)-(1-) scorei"
        ]
      },
      {
        "section_name": "MMR-attention Pointer-generator",
        "paragraphs": [
          "After we calculate INLINEFORM0 for each sentence representation INLINEFORM1 , we use these scores to update the word-level attention weights for the pointer-generator model shown by the blue arrows in Figure FIGREF19 . Since INLINEFORM2 is a sentence weight for INLINEFORM3 , each token in the sentence will have the same value of INLINEFORM4 . The new attention for each input token from Equation EQREF14 becomes: DISPLAYFORM0 "
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "In this section we describe additional methods we compare with and present our assumptions and experimental process."
        ]
      },
      {
        "section_name": "Baseline and Extractive Methods",
        "paragraphs": [
          "First We concatenate the first sentence of each article in a document cluster as the system summary. For our dataset, First- INLINEFORM0 means the first INLINEFORM1 sentences from each source article will be concatenated as the summary. Due to the difference in gold summary length, we only use First-1 for DUC, as others would exceed the average summary length.",
          "LexRank Initially proposed by BIBREF16 , LexRank is a graph-based method for computing relative importance in extractive summarization.",
          "TextRank Introduced by BIBREF17 , TextRank is a graph-based ranking model. Sentence importance scores are computed based on eigenvector centrality within a global graph from the corpus.",
          "MMR In addition to incorporating MMR in our pointer generator network, we use this original method as an extractive summarization baseline. When testing on DUC data, we set these extractive methods to give an output of 100 tokens and 300 tokens for Multi-News data."
        ]
      },
      {
        "section_name": "Neural Abstractive Methods",
        "paragraphs": [
          "PG-Original, PG-MMR These are the original pointer-generator network models reported by BIBREF11 .",
          "PG-BRNN The PG-BRNN model is a pointer-generator implementation from OpenNMT. As in the original paper BIBREF1 , we use a 1-layer bi-LSTM as encoder, with 128-dimensional word-embeddings and 256-dimensional hidden states for each direction. The decoder is a 512-dimensional single-layer LSTM. We include this for reference in addition to PG-Original, as our Hi-MAP code builds upon this implementation.",
          "CopyTransformer Instead of using an LSTM, the CopyTransformer model used in Gehrmann:18 uses a 4-layer Transformer of 512 dimensions for encoder and decoder. One of the attention heads is chosen randomly as the copy distribution. This model and the PG-BRNN are run without the bottom-up masked attention for inference from Gehrmann:18 as we did not find a large improvement when reproducing the model on this data."
        ]
      },
      {
        "section_name": "Experimental Setting",
        "paragraphs": [
          "Following the setting from BIBREF11 , we report ROUGE BIBREF37 scores, which measure the overlap of unigrams (R-1), bigrams (R-2) and skip bigrams with a max distance of four words (R-SU). For the neural abstractive models, we truncate input articles to 500 tokens in the following way: for each example with INLINEFORM0 source input documents, we take the first 500 INLINEFORM1 tokens from each source document. As some source documents may be shorter, we iteratively determine the number of tokens to take from each document until the 500 token quota is reached. Having determined the number of tokens per source document to use, we concatenate the truncated source documents into a single mega-document. This effectively reduces MDS to SDS on longer documents, a commonly-used assumption for recent neural MDS papers BIBREF10 , BIBREF38 , BIBREF11 . We chose 500 as our truncation size as related MDS work did not find significant improvement when increasing input length from 500 to 1000 tokens BIBREF38 . We simply introduce a special token between source documents to aid our models in detecting document-to-document relationships and leave direct modeling of this relationship, as well as modeling longer input sequences, to future work. We hope that the dataset we introduce will promote such work. For our Hi-MAP model, we applied a 1-layer bidirectional LSTM network, with the hidden state dimension 256 in each direction. The sentence representation dimension is also 256. We set the INLINEFORM2 to calculate the MMR value in Equation SECREF21 .",
          "As our focus was on deep methods for MDS, we only tested several non-neural baselines. However, other classical methods deserve more attention, for which we refer the reader to Hong14 and leave the implementation of these methods on Multi-News for future work.",
          ""
        ]
      },
      {
        "section_name": "Analysis and Discussion",
        "paragraphs": [
          "In Table TABREF30 and Table TABREF31 we report ROUGE scores on DUC 2004 and Multi-News datasets respectively. We use DUC 2004, as results on this dataset are reported in lebanoff18mds, although this dataset is not the focus of this work. For results on DUC 2004, models were trained on the CNNDM dataset, as in lebanoff18mds. PG-BRNN and CopyTransformer models, which were pretrained by OpenNMT on CNNDM, were applied to DUC without additional training, analogous to PG-Original. We also experimented with training on Multi-News and testing on DUC data, but we did not see significant improvements. We attribute the generally low performance of pointer-generator, CopyTransformer and Hi-MAP to domain differences between DUC and CNNDM as well as DUC and Multi-News. These domain differences are evident in the statistics and extractive metrics discussed in Section 3.",
          "Additionally, for both DUC and Multi-News testing, we experimented with using the output of 500 tokens from extractive methods (LexRank, TextRank and MMR) as input to the abstractive model. However, this did not improve results. We believe this is because our truncated input mirrors the First-3 baseline, which outperforms these three extractive methods and thus may provide more information as input to the abstractive model.",
          "Our model outperforms PG-MMR when trained and tested on the Multi-News dataset. We see much-improved model performances when trained and tested on in-domain Multi-News data. The Transformer performs best in terms of R-1 while Hi-MAP outperforms it on R-2 and R-SU. Also, we notice a drop in performance between PG-original, and PG-MMR (which takes the pre-trained PG-original and applies MMR on top of the model). Our PG-MMR results correspond to PG-MMR w Cosine reported in lebanoff18mds. We trained their sentence regression model on Multi-News data and leave the investigation of transferring regression models from SDS to Multi-News for future work.",
          "In addition to automatic evaluation, we performed human evaluation to compare the summaries produced. We used Best-Worst Scaling BIBREF39 , BIBREF40 , which has shown to be more reliable than rating scales BIBREF41 and has been used to evaluate summaries BIBREF42 , BIBREF32 . Annotators were presented with the same input that the systems saw at testing time; input documents were truncated, and we separated input documents by visible spaces in our annotator interface. We chose three native English speakers as annotators. They were presented with input documents, and summaries generated by two out of four systems, and were asked to determine which summary was better and which was worse in terms of informativeness (is the meaning in the input text preserved in the summary?), fluency (is the summary written in well-formed and grammatical English?) and non-redundancy (does the summary avoid repeating information?). We randomly selected 50 documents from the Multi-News test set and compared all possible combinations of two out of four systems. We chose to compare PG-MMR, CopyTransformer, Hi-MAP and gold summaries. The order of summaries was randomized per example.",
          "The results of our pairwise human-annotated comparison are shown in Table TABREF32 . Human-written summaries were easily marked as better than other systems, which, while expected, shows that there is much room for improvement in producing readable, informative summaries. We performed pairwise comparison of the models over the three metrics combined, using a one-way ANOVA with Tukey HSD tests and INLINEFORM0 value of 0.05. Overall, statistically significant differences were found between human summaries score and all other systems, CopyTransformer and the other two models, and our Hi-MAP model compared to PG-MMR. Our Hi-MAP model performs comparably to PG-MMR on informativeness and fluency but much better in terms of non-redundancy. We believe that the incorporation of learned parameters for similarity and redundancy reduces redundancy in our output summaries. In future work, we would like to incorporate MMR into Transformer models to benefit from their fluent summaries."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          " In this paper we introduce Multi-News, the first large-scale multi-document news summarization dataset. We hope that this dataset will promote work in multi-document summarization similar to the progress seen in the single-document case. Additionally, we introduce an end-to-end model which incorporates MMR into a pointer-generator network, which performs competitively compared to previous multi-document summarization models. We also benchmark methods on our dataset. In the future we plan to explore interactions among documents beyond concatenation and experiment with summarizing longer input documents."
        ]
      }
    ],
    "qas": [
      {
        "question": "What sources do the news come from?",
        "question_id": "86656aae3c27c6ea108f5600dd09ab7e421d876a",
        "nlp_background": "",
        "topic_background": "",
        "paper_read": "",
        "search_query": "",
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "1500 news sites",
              "evidence": [
                "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com. Each summary is professionally written by editors and includes links to the original articles cited. We will release stable Wayback-archived links, and scripts to reproduce the dataset from these links. Our dataset is notably the first large-scale dataset for MDS on news articles. Our dataset also comes from a diverse set of news sources; over 1,500 sites appear as source documents 5 times or greater, as opposed to previous news datasets (DUC comes from 2 sources, CNNDM comes from CNN and Daily Mail respectively, and even the Newsroom dataset BIBREF6 covers only 38 news sources). A total of 20 editors contribute to 85% of the total summaries on newser.com. Thus we believe that this dataset allows for the summarization of diverse source documents and summaries."
              ],
              "highlighted_evidence": [
                "Our dataset also comes from a diverse set of news sources; over 1,500 sites appear as source documents 5 times or greater, as opposed to previous news datasets (DUC comes from 2 sources, CNNDM comes from CNN and Daily Mail respectively, and even the Newsroom dataset BIBREF6 covers only 38 news sources)."
              ]
            },
            "annotation_id": "1cff300495ad4c5fc7552f9c3bca04456c67e7c1",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "From a diverse set of news sources on site newser.com",
              "evidence": [
                "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com. Each summary is professionally written by editors and includes links to the original articles cited. We will release stable Wayback-archived links, and scripts to reproduce the dataset from these links. Our dataset is notably the first large-scale dataset for MDS on news articles. Our dataset also comes from a diverse set of news sources; over 1,500 sites appear as source documents 5 times or greater, as opposed to previous news datasets (DUC comes from 2 sources, CNNDM comes from CNN and Daily Mail respectively, and even the Newsroom dataset BIBREF6 covers only 38 news sources). A total of 20 editors contribute to 85% of the total summaries on newser.com. Thus we believe that this dataset allows for the summarization of diverse source documents and summaries."
              ],
              "highlighted_evidence": [
                "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com. ",
                "Our dataset also comes from a diverse set of news sources;"
              ]
            },
            "annotation_id": "25f84af4ea997a28a3674b363d4ae27281080efa",
            "worker_id": "34c35a1877e453ecaebcf625df3ef788e1953cc4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "newser.com"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com. Each summary is professionally written by editors and includes links to the original articles cited. We will release stable Wayback-archived links, and scripts to reproduce the dataset from these links. Our dataset is notably the first large-scale dataset for MDS on news articles. Our dataset also comes from a diverse set of news sources; over 1,500 sites appear as source documents 5 times or greater, as opposed to previous news datasets (DUC comes from 2 sources, CNNDM comes from CNN and Daily Mail respectively, and even the Newsroom dataset BIBREF6 covers only 38 news sources). A total of 20 editors contribute to 85% of the total summaries on newser.com. Thus we believe that this dataset allows for the summarization of diverse source documents and summaries."
              ],
              "highlighted_evidence": [
                "Our dataset, which we call Multi-News, consists of news articles and human-written summaries of these articles from the site newser.com."
              ]
            },
            "annotation_id": "9e58fe62c98a67a1d8fdff55bf6ef46a5b5f36d1",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "1-Table1-1.png",
        "caption": "Table 1: An example from our multi-document summarization dataset showing the input documents and their summary. Content found in the summary is colorcoded."
      },
      {
        "file": "3-Table2-1.png",
        "caption": "Table 2: The number of source articles per example, by frequency, in our dataset."
      },
      {
        "file": "4-Table3-1.png",
        "caption": "Table 3: Comparison of our Multi-News dataset to other MDS datasets as well as an SDS dataset used as training data for MDS (CNNDM). Training, validation and testing size splits (article(s) to summary) are provided when applicable. Statistics for multi-document inputs are calculated on the concatenation of all input sources."
      },
      {
        "file": "4-Table4-1.png",
        "caption": "Table 4: Percentage of n-grams in summaries which do not appear in the input documents , a measure of the abstractiveness, in relevant datasets."
      },
      {
        "file": "4-Figure1-1.png",
        "caption": "Figure 1: Density estimation of extractive diversity scores as explained in Section 3.2. Large variability along the y-axis suggests variation in the average length of source sequences present in the summary, while the x axis shows variability in the average length of the extractive fragments to which summary words belong."
      },
      {
        "file": "5-Figure2-1.png",
        "caption": "Figure 2: Our Hierarchical MMR-Attention Pointergenerator (Hi-MAP) model incorporates sentence-level representations and hidden-state-based MMR on top of a standard pointer-generator network."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: ROUGE scores on the DUC 2004 dataset for models trained on CNNDM data, as in Lebanoff et al. (2018).3"
      },
      {
        "file": "7-Table6-1.png",
        "caption": "Table 6: ROUGE scores for models trained and tested on the Multi-News dataset."
      },
      {
        "file": "8-Table7-1.png",
        "caption": "Table 7: Number of times a system was chosen as best in pairwise comparisons according to informativeness, fluency and non-redundancy."
      }
    ]
  },
  "1908.11046": {
    "title": "Remedying BiLSTM-CNN Deficiency in Modeling Cross-Context for NER.",
    "abstract": "Recent researches prevalently used BiLSTM-CNN as a core module for NER in a sequence-labeling setup. This paper formally shows the limitation of BiLSTM-CNN encoders in modeling cross-context patterns for each word, i.e., patterns crossing past and future for a specific time step. Two types of cross-structures are used to remedy the problem: A BiLSTM variant with cross-link between layers; a multi-head self-attention mechanism. These cross-structures bring consistent improvements across a wide range of NER domains for a core system using BiLSTM-CNN without additional gazetteers, POS taggers, language-modeling, or multi-task supervision. The model surpasses comparable previous models on OntoNotes 5.0 and WNUT 2017 by 1.4% and 4.6%, especially improving emerging, complex, confusing, and multi-token entity mentions, showing the importance of remedying the core module of NER.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Named Entity Recognition (NER) is a core task for information extraction. Originally a structured prediction task, NER has since been formulated as a task of sequential token labeling. BiLSTM-CNN uses a CNN to encode each word and then uses bi-directional LSTMs to encode past and future context respectively at each time step. With state-of-the-art empirical results, most regard it as a robust core module for sequence-labeling NER BIBREF0, BIBREF1, BIBREF2, BIBREF3, BIBREF4.",
          "However, each direction of BiLSTM only sees and encodes half of a sequence at each time step. For each token, the forward LSTM only encodes past context; the backward LSTM only encodes future context. For computing sentence representations for tasks such as sentence classification and machine translation, this is not a problem, as only the rightmost hidden state of the forward LSTM and only the leftmost hidden state of the backward LSTM are used, and each of the endpoint hidden states sees and encodes the whole sentence. For computing sentence representations for sequence-labeling tasks such as NER, however, this becomes a limitation, as each token uses its own midpoint hidden states, which do not model the patterns that happen to cross past and future at this specific time step.",
          "This paper explores two types of cross-structures to help cope with the problem: Cross-BiLSTM-CNN and Att-BiLSTM-CNN. Previous studies have tried to stack multiple LSTMs for sequence-labeling NER BIBREF1. As they follow the trend of stacking forward and backward LSTMs independently, the Baseline-BiLSTM-CNN is only able to learn higher-level representations of past or future per se. Instead, Cross-BiLSTM-CNN, which interleaves every layer of the two directions, models cross-context in an additive manner by learning higher-level representations of the whole context of each token. On the other hand, Att-BiLSTM-CNN models cross-context in a multiplicative manner by capturing the interaction between past and future with a dot-product self-attentive mechanism BIBREF5, BIBREF6.",
          "Section SECREF3 formulates the three Baseline, Cross, and Att-BiLSTM-CNN models. The section gives a concrete proof that patterns forming an XOR cannot be modeled by Baseline-BiLSTM-CNN used in all previous work. Cross-BiLSTM-CNN and Att-BiLSTM-CNN are shown to have additive and multiplicative cross-structures respectively to deal with the problem. Section SECREF4 evaluates the approaches on two challenging NER datasets spanning a wide range of domains with complex, noisy, and emerging entities. The cross-structures bring consistent improvements over the prevalently used Baseline-BiLSTM-CNN without additional gazetteers, POS taggers, language-modeling, or multi-task supervision. The improved core module surpasses comparable previous models on OntoNotes 5.0 and WNUT 2017 by 1.4% and 4.6% respectively. Experiments reveal that emerging, complex, confusing, and multi-token entity mentions benefitted much from the cross-structures, and the in-depth entity-chunking analysis finds that the prevalently used Baseline-BiLSTM-CNN is flawed for real-world NER."
        ]
      },
      {
        "section_name": "Related Work",
        "paragraphs": [
          "Many have attempted tackling the NER task with LSTM-based sequence encoders BIBREF7, BIBREF0, BIBREF1, BIBREF8. Among these, the most sophisticated, state-of-the-art is the BiLSTM-CNN proposed by BIBREF1. They stack multiple layers of LSTM cells per direction and also use a CNN to compute character-level word vectors alongside pre-trained word vectors. This paper largely follows their work in constructing the Baseline-BiLSTM-CNN, including the selection of raw features, the CNN, and the multi-layer BiLSTM. A subtle difference is that they send the output of each direction through separate affine-softmax classifiers and then sum their probabilities, while this paper sum the scores from affine layers before computing softmax once. While not changing the modeling capacity regarded in this paper, the baseline model does perform better than their formulation.",
          "The modeling of global contexts for sequence-labeling NER has been accomplished using traditional models with extensive feature engineering and conditional random fields (CRF). BIBREF9 build the Illinois NER tagger with feature-based perceptrons. In their analysis, the usefulness of Viterbi decoding is minimal and conflicts their handcrafted global features. On the other hand, recent researches on LSTM or CNN-based sequence encoders report empirical improvements brought by CRF BIBREF7, BIBREF0, BIBREF8, BIBREF10, as it discourages illegal predictions by explicitly modeling class transition probabilities. However, transition probabilities are independent of input sentences. In contrast, the cross-structures studied in this work provide for the direct capture of global patterns and extraction of better features to improve class observation likelihoods.",
          "Thought to lighten the burden of compressing all relevant information into a single hidden state, using attention mechanisms on top of LSTMs have shown empirical success for sequence encoders BIBREF5, BIBREF6 and decoders BIBREF11. Self-attention has also been used below encoders to compute word vectors conditioned on context BIBREF12. This work further formally analyzes the deficiency of BiLSTM encoders for sequence labeling and shows that using self-attention on top is actually providing one type of cross structures that capture interactions between past and future context.",
          "Besides using additional gazetteers or POS taggers BIBREF13, BIBREF2, BIBREF14, there is a recent trend to use additional large-scale language-modeling corpora BIBREF3 or additional multi-task supervision BIBREF4 to further improve NER performance beyond bare-bone models. However, they all rely on a core BiLSTM sentence encoder with the same limitation studied and remedied in Section SECREF3. So they would indeed benefit from the improvements presented in this paper."
        ]
      },
      {
        "section_name": "Model ::: CNN and Word Features",
        "paragraphs": [
          "All models in the experiments use the same set of raw features: character embedding, character type, word embedding, and word capitalization.",
          "For character embedding, 25d vectors are trained from scratch, and 4d one-hot character-type features indicate whether a character is uppercase, lowercase, digit, or punctuation BIBREF1. Word token lengths are unified to 20 by truncation and padding. The resulting 20-by-(25+4) feature map of each token is applied to a character-trigram CNN with 20 kernels per length 1 to 3 and max-over-time pooling to compute a 60d character-based word vector BIBREF15, BIBREF1, BIBREF0.",
          "For word embedding, either pre-trained 300d GloVe vectors BIBREF16 or 400d Twitter vectors BIBREF17 are used without further tuning. Also, 4d one-hot word capitalization features indicate whether a word is uppercase, upper-initial, lowercase, or mixed-caps BIBREF18, BIBREF1.",
          "Throughout this paper, $X$ denotes the $n$-by-$d_x$ matrix of sequence features, where $n$ is the sentence length and $d_x$ is either 364 (with GloVe) or 464 (with Twitter)."
        ]
      },
      {
        "section_name": "Model ::: Baseline-BiLSTM-CNN",
        "paragraphs": [
          "On top of an input feature sequence, BiLSTM is used to capture the future and the past for each time step. Following BIBREF1, 4 distinct LSTM cells \u2013 two in each direction \u2013 are stacked to capture higher level representations:",
          "where $\\overrightarrow{LSTM}_i, \\overleftarrow{LSTM}_i$ denote applying LSTM cell $i$ in forward, backward order, $\\overrightarrow{H}, \\overleftarrow{H}$ denote the resulting feature matrices of the stacked application, and $||$ denotes row-wise concatenation. In all the experiments, 100d LSTM cells are used, so $H \\in R^{n\\times d_h}$ and $d_h=200$.",
          "Finally, suppose there are $d_p$ token classes, the probability of each of which is given by the composition of affine and softmax transformations:",
          "where $H_t$ is the $t^{th}$ row of $H$, $W_p\\in R^{d_h\\times d_p}$, $b\\in R^{d_p}$ are a trainable weight matrix and bias, and $s_{ti}$ and $s_{tj}$ are the $i$-th and $j$-th elements of $s_t$.",
          "Following BIBREF1, the 5 chunk labels O, S, B, I, E denote if a word token is Outside any entity mentions, the Sole token of a mention, the Beginning token of a multi-token mention, In the middle of a multi-token mention, or the Ending token of a multi-token mention. Hence when there are $P$ types of named entities, the actual number of token classes $d_p=P\\times 4+1$ for sequence labeling NER."
        ]
      },
      {
        "section_name": "Model ::: Baseline-BiLSTM-CNN ::: XOR Limitation",
        "paragraphs": [
          "Consider the following four phrases that form an XOR:",
          "Key and Peele (work-of-art)",
          "You and I (work-of-art)",
          "Key and I",
          "You and Peele",
          "The first two phrases are respectively a show title and a song title. The other two are not entities as a whole, where the last one actually occurs in an interview with Keegan-Michael Key. Suppose each phrase is the sequence given to Baseline-BiLSTM-CNN for sequence tagging, then the 2nd token \"and\" should be tagged as work-of-art:I in the first two cases and as O in the last two cases.",
          "Firstly, note that the score vector at each time step is simply the sum of contributions coming from forward and backward directions plus a bias.",
          "where $\\overrightarrow{W}_p,\\overleftarrow{W}_p$ denotes the top-half and bottom-half of $W_p$.",
          "Suppose the index of work-of-art:I and O are i, j respectively. Then, to predict each \"and\" correctly, it must hold that",
          "where superscripts denote the phrase number.",
          "Now, the catch is that phrase 1 and phrase 3 have exactly the same past context for \"and\". Hence the same $\\overrightarrow{H}_2$ and the same $\\overrightarrow{s}_2$, i.e., $\\overrightarrow{s}^1_2=\\overrightarrow{s}^3_2$. Similarly, $\\overrightarrow{s}^2_2=\\overrightarrow{s}^4_2$, $\\overleftarrow{s}^1_2=\\overleftarrow{s}^4_2$, and $\\overleftarrow{s}^2_2=\\overleftarrow{s}^3_2$. Rewriting the constraints with these equalities gives",
          "Finally, summing the first two inequalities and the last two inequalities gives two contradicting constraints that cannot be satisfied. In other words, even if an oracle is given to training the model, Baseline-BiLSTM-CNN can only tag at most 3 out of 4 \"and\" correctly. No matter how many LSTM cells are stacked for each direction, the formulation in previous studies simply does not have enough modeling capacity to capture cross-context patterns for sequence labeling NER."
        ]
      },
      {
        "section_name": "Model ::: Cross-BiLSTM-CNN",
        "paragraphs": [
          "Motivated by the limitation of the conventional Baseline-BiLSTM-CNN for sequence labeling, this paper proposes the use of Cross-BiLSTM-CNN by changing the deep structure in Section SECREF2 to",
          "As the forward and backward hidden states are interleaved between stacked LSTM layers, Cross-BiLSTM-CNN models cross-context patterns by computing representations of the whole sequence in a feed-forward, additive manner.",
          "Specifically, for the XOR cases introduced in Section SECREF3, although phrase 1 and phrase 3 still have the same past context for \"and\" and hence the first layer $\\overrightarrow{LSTM}_1$ can only extract the same low-level hidden features $\\overrightarrow{H}^1_2$, the second layer $\\overrightarrow{LSTM}_2$ considers the whole context $\\overrightarrow{H}^1||\\overleftarrow{H}^3$ and thus have the ability to extract different high-level hidden features $\\overrightarrow{H}^2_2$ for the two phrases.",
          "As the higher-level LSTMs of Cross-BiLSTM-CNN have interleaved input from forward and backward hidden states down below, their weight parameters double the size of the first-level LSTMs. Nevertheless, the cross formulation provides the modeling capacity absent in previous studies with how many more LSTM layers."
        ]
      },
      {
        "section_name": "Model ::: Att-BiLSTM-CNN",
        "paragraphs": [
          "Another way to capture the interaction between past and future context per time step is to add a token-level self-attentive mechanism on top of the same BiLSTM formulation introduced in Section SECREF2. Given the hidden features $H$ of a whole sequence, the model projects each hidden state to different subspaces, depending on whether it is used as the query vector to consult other hidden states for each word token, the key vector to compute its dot-similarities with incoming queries, or the value vector to be weighted and actually convey information to the querying token. As different aspects of a task can call for different attention, multiple attention heads running in parallel are used BIBREF19.",
          "Formally, let $m$ be the number of attention heads and $d_c$ be the subspace dimension. For each head $i\\in \\lbrace 1..m\\rbrace $, the attention weight matrix and context matrix are computed by",
          "where $W^{qi},W^{ki},W^{vi}\\in R^{d_h\\times d_c}$ are trainable projection matrices and $\\sigma $ performs softmax along the second dimension. Each row of the resulting $\\alpha ^1,\\alpha ^2,\\ldots ,\\alpha ^m\\in R^{n\\times n}$ contains the attention weights of a token to its context, and each row of $C^1,C^2,\\ldots ,C^m\\in R^{n\\times d_c}$ is its context vector.",
          "For Att-BiLSTM-CNN, the hidden vector and context vectors of each token are considered together for classification:",
          "where $C^i_t$ is the $t$-th row of $C^i$, and $W_c\\in R^{(d_h+md_c)\\times d_p}$ is a trainable weight matrix. In all the experiments, $m=5$ and $d_c=\\frac{d_h}{5}$, so $W_c\\in R^{2d_h\\times d_p}$.",
          "While the BiLSTM formulation stays the same as Baseline-BiLSTM-CNN, the computation of attention weights $\\alpha ^i$ and context features $C^i$ models the cross interaction between past and future. To see this, the computation of attention scores can be rewritten as follows.",
          "With the un-shifted covariance matrix of the projected $\\overrightarrow{H}\\ ||\\ \\overleftarrow{H}$, Att-BiLSTM-CNN correlates past and future context for each token in a dot-product, multiplicative manner.",
          "One advantage of the multi-head self-attentive mechanism is that it only needs to be computed once per sequence, and the matrix computations are highly parallelizable, resulting in little computation time overhead. Moreover, in Section SECREF4, the attention weights provide a better understanding of how the model learns to tackle sequence-labeling NER."
        ]
      },
      {
        "section_name": "Experiments ::: Datasets",
        "paragraphs": [
          "OntoNotes 5.0 Fine-Grained NER \u2013 a million-token corpus with diverse sources of newswires, web, broadcast news, broadcast conversations, magazines, and telephone conversations BIBREF20, BIBREF21. Some are transcriptions of talk shows, and some are translations from Chinese or Arabic. The dataset contains 18 fine-grained entity types, including hard ones such as law, event, and work-of-art. All the diversities and noisiness require that models are robust across broad domains and able to capture a multitude of linguistic patterns for complex entities.",
          "WNUT 2017 Emerging NER \u2013 a dataset providing maximally diverse, noisy, and drifting user-generated text BIBREF22. The training set consists of previously annotated tweets \u2013 social media text with non-standard spellings, abbreviations, and unreliable capitalization BIBREF23; the development set consists of newly sampled YouTube comments; the test set includes text newly drawn from Twitter, Reddit, and StackExchange. Besides drawing new samples from diverse topics across different sources, the shared task also filtered out text containing surface forms of entities seen in the training set. The resulting dataset requires models to generalize to emerging contexts and entities instead of relying on familiar surface cues."
        ]
      },
      {
        "section_name": "Experiments ::: Implementation and Baselines",
        "paragraphs": [
          "All experiments for Baseline-, Cross-, and Att-BiLSTM-CNN used the same model parameters given in Section SECREF3. The training minimized per-token cross-entropy loss with the Nadam optimizer BIBREF24 with uniform learning rate 0.001, batch size 32, and 35% dropout. Each training lasted 400 epochs when using GloVe embedding (OntoNotes), and 1600 epochs when using Twitter embedding (WNUT). The development set of each dataset was used to select the best epoch to restore model weights for testing. Following previous work on NER, model performances were evaluated with strict mention F1 score. Training of each model on each dataset repeated 6 times to report the mean score and standard deviation.",
          "Besides comparing to the Baseline implemented in this paper, results also compared against previously reported results of BiLSTM-CNN BIBREF1, CRF-BiLSTM(-BiLSTM) BIBREF10, BIBREF25, and CRF-IDCNN BIBREF10 on the two datasets. Among them, IDCNN was a CNN-based sentence encoder, which should not have the XOR limitation raised in this paper. Only fair comparisons against models without using additional resources were made. However, the models that used those additional resources (Secion SECREF2) actually all used a BiLSTM sentence encoder with the XOR limitation, so they could indeed integrate with and benefit from the cross-structures."
        ]
      },
      {
        "section_name": "Experiments ::: Overall Results",
        "paragraphs": [
          "Table TABREF14 shows overall results on the two datasets spanning broad domains of newswires, broadcast, telephone, and social media. The models proposed in this paper significantly surpassed previous comparable models by 1.4% on OntoNotes and 4.6% on WNUT. Compared to the re-implemented Baseline-BiLSTM-CNN, the cross-structures brought 0.7% and 2.2% improvements on OntoNotes and WNUT. More substantial improvements were achieved for WNUT 2017 emerging NER, suggesting that cross-context patterns were even more crucial for emerging contexts and entities than familiar entities, which might often be memorized by their surface forms."
        ]
      },
      {
        "section_name": "Experiments ::: Complex and Confusing Entity Mentions",
        "paragraphs": [
          "Table TABREF16 shows significant results per entity type compared to Baseline ($>$3% absolute F1 differences for either Cross or Att). It could be seen that harder entity types generally benefitted more from the cross-structures. For example, work-of-art/creative-work entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media. Such mentions require models to learn a deep, generalized understanding of their context to accurately identify their boundaries and disambiguate their types. Both cross-structures were more capable in dealing with such hard entities (2.1%/5.6%/3.2%/2.0%) than the prevalently used, problematic Baseline.",
          "Moreover, disambiguating fine-grained entity types is also a challenging task. For example, entities of language and NORP often take the same surface forms. Figure FIGREF19 shows an example containing \"Dutch\" and \"English\". While \"English\" was much more frequently used as a language and was identified correctly, the \"Dutch\" mention was tricky for Baseline. The attention heat map (Figure FIGREF24) further tells the story that Att has relied on its attention head to make context-aware decisions. Overall, both cross-structures were much better at disambiguating these fine-grained types (4.1%/0.8%/3.3%/3.4%)."
        ]
      },
      {
        "section_name": "Experiments ::: Multi-Token Entity Mentions",
        "paragraphs": [
          "Table TABREF17 shows results among different entity lengths. It could be seen that cross-structures were much better at dealing with multi-token mentions (1.8%/2.3%/8.7%/2.6%) compared to the prevalently used, problematic Baseline.",
          "In fact, identifying correct mention boundaries for multi-token mentions poses a unique challenge for sequence-labeling models \u2013 all tokens in a mention must be tagged with correct sequential labels to form one correct prediction. Although models often rely on strong hints from a token itself or a single side of the context, however, in general, cross-context modeling is required. For example, a token should be tagged as Inside if and only if it immediately follows a Begin or an I and is immediately followed by an I or an End.",
          "Figure FIGREF19 shows a sentence with multiple entity mentions. Among them, \"the White house\" is a triple-token facility mention with unreliable capitalization, resulting in an emerging surface form. Without usual strong hints given by a seen surface form, Baseline predicted a false single-token mention \"White\". In contrast, Att utilized its multiple attention heads (Figure FIGREF24, FIGREF24, FIGREF24) to consider the preceding and succeeding tokens for each token and correctly tagged the three tokens as facility:B, facility:I, facility:E."
        ]
      },
      {
        "section_name": "Experiments ::: Entity-Chunking",
        "paragraphs": [
          "Entity-chunking is a subtask of NER concerned with locating entity mentions and their boundaries without disambiguating their types. For sequence-labeling models, this means correct O, S, B, I, E tagging for each token. In addition to showing that cross-structures achieved superior performance on multi-token entity mentions (Section SECREF18), an ablation study focused on the chunking tags was performed to better understand how it was achieved.",
          "Table TABREF22 shows the entity-chunking ablation results on OntoNotes 5.0 development set. Both Att and Baseline models were taken without re-training for this subtask. The $HC^{all}$ column lists the performance of Att-BiLSTM-CNN on each chunking tag. Other columns list the performance compared to $HC^{all}$. Columns $H$ to $C^5$ are when the full model is deprived of all other information in testing time by forcefully zeroing all vectors except the one specified by the column header. The figures shown in the table are per-token recalls for each chunking tag, which tells if a part of the model is responsible for signaling the whole model to predict that tag. Colors mark relatively high and low values of interest.",
          "Firstly, Att appeared to designate the task of scoring I to the attention mechanism: When context vectors $C^{all}$ were left alone, the recall for I tokens only dropped a little (-3.80); When token hidden states $H$ were left alone, the recall for I tokens seriously degraded (-28.18). When $H$ and $C^{all}$ work together, the full Att model was then better at predicting multi-token entity mentions than Baseline.",
          "Then, breaking context vectors to each attention head reveals that they have worked in cooperation: $C^2$, $C^3$ focused more on scoring E (-36.45, -39.19) than I (-60.56, -50.19), while $C^4$ focused more on scoring B (-12.21) than I (-57.19). It was when information from all these heads were combined was Att able to better identify a token as being Inside a multi-token mention than Baseline.",
          "Finally, the quantitative ablation analysis of chunking tags in this Section and the qualitative case-study attention visualizations in Section SECREF18 explains each other: $C^2$ and especially $C^3$ tended to focus on looking for immediate preceding mention tokens (the diagonal shifted left in Figure FIGREF24, FIGREF24), enabling them to signal for End and Inside; $C^4$ tended to focus on looking for immediate succeeding mention tokens (the diagonal shifted right in Figure FIGREF24), enabling it to signal for Begin and Inside. In fact, without context vectors, instead of BIE, Att would tag \"the White house\" as BSE and extract the same false mention of \"White\" as the OSO of Baseline.",
          "Lacking the ability to model cross-context patterns, Baseline inadvertently learned to retract to predict single-token entities (0.13 vs. -0.63, -0.41, -0.38) when an easy hint from a familiar surface form is not available. This indicates a major flaw in BiLSTM-CNNs prevalently used for real-world NER today."
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "This paper has formally analyzed and remedied the deficiency of the prevalently used BiLSTM-CNN in modeling cross-context for NER. A concrete proof of its inability to capture XOR patterns has been given. Additive and multiplicative cross-structures have shown to be crucial in modeling cross-context, significantly enhancing recognition of emerging, complex, confusing, and multi-token entity mentions. Against comparable previous models, 1.4% and 4.6% overall improvements on OntoNotes 5.0 and WNUT 2017 have been achieved, showing the importance of remedying the core module of NER."
        ]
      }
    ],
    "qas": [
      {
        "question": "How is \"complexity\" and \"confusability\" of entity mentions defined in this work?",
        "question_id": "1dcfcfa46dbcffc2fc7be92dd57df9620258097b",
        "nlp_background": "infinity",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "fa716cd87ce6fd6905e2f23f09b262e90413167f",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "Complexity is defined by examples of a singular named entity (e.g. work-of-art and creative-work entities) being represented by multiple surface forms. Mapping all of these forms to a single NE requires a complex understanding of the variations, some of which are genre-specific. Confusability is defined by examples when it becomes more difficult to disambiguate named entities that share the same surface form, such as the \"language\" versus \"NORP\" distinction represented by the surface forms Dutch and English.",
              "evidence": [
                "Table TABREF16 shows significant results per entity type compared to Baseline ($>$3% absolute F1 differences for either Cross or Att). It could be seen that harder entity types generally benefitted more from the cross-structures. For example, work-of-art/creative-work entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media. Such mentions require models to learn a deep, generalized understanding of their context to accurately identify their boundaries and disambiguate their types. Both cross-structures were more capable in dealing with such hard entities (2.1%/5.6%/3.2%/2.0%) than the prevalently used, problematic Baseline.",
                "Moreover, disambiguating fine-grained entity types is also a challenging task. For example, entities of language and NORP often take the same surface forms. Figure FIGREF19 shows an example containing \"Dutch\" and \"English\". While \"English\" was much more frequently used as a language and was identified correctly, the \"Dutch\" mention was tricky for Baseline. The attention heat map (Figure FIGREF24) further tells the story that Att has relied on its attention head to make context-aware decisions. Overall, both cross-structures were much better at disambiguating these fine-grained types (4.1%/0.8%/3.3%/3.4%)."
              ],
              "highlighted_evidence": [
                "For example, work-of-art/creative-work entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media. ",
                "Such mentions require models to learn a deep, generalized understanding of their context to accurately identify their boundaries and disambiguate their types. ",
                "Moreover, disambiguating fine-grained entity types is also a challenging task.",
                "For example, entities of language and NORP often take the same surface forms. ",
                "the disambiguation task becomes harder "
              ]
            },
            "annotation_id": "005bcaedd05d389eceeaeb93099963dc0b75f068",
            "worker_id": "ea4394112c1549185e6b763d6f36733a9f2ed794"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "disambiguating fine-grained entity types",
                "entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Table TABREF16 shows significant results per entity type compared to Baseline ($>$3% absolute F1 differences for either Cross or Att). It could be seen that harder entity types generally benefitted more from the cross-structures. For example, work-of-art/creative-work entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media. Such mentions require models to learn a deep, generalized understanding of their context to accurately identify their boundaries and disambiguate their types. Both cross-structures were more capable in dealing with such hard entities (2.1%/5.6%/3.2%/2.0%) than the prevalently used, problematic Baseline.",
                "Moreover, disambiguating fine-grained entity types is also a challenging task. For example, entities of language and NORP often take the same surface forms. Figure FIGREF19 shows an example containing \"Dutch\" and \"English\". While \"English\" was much more frequently used as a language and was identified correctly, the \"Dutch\" mention was tricky for Baseline. The attention heat map (Figure FIGREF24) further tells the story that Att has relied on its attention head to make context-aware decisions. Overall, both cross-structures were much better at disambiguating these fine-grained types (4.1%/0.8%/3.3%/3.4%)."
              ],
              "highlighted_evidence": [
                "For example, work-of-art/creative-work entities could in principle take any surface forms \u2013 unseen, the same as a person name, abbreviated, or written with unreliable capitalizations on social media.",
                "Moreover, disambiguating fine-grained entity types is also a challenging task."
              ]
            },
            "annotation_id": "daf29b1f82dffaa029e3a898ff5e91920d960365",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Datasets (K-tokens / K-entities)."
      },
      {
        "file": "6-Table2-1.png",
        "caption": "Table 2: Overall results. *Used on WNUT for character-based word vectors, reported better than CNN."
      },
      {
        "file": "6-Table4-1.png",
        "caption": "Table 4: Improvements against Baseline among different mention lengths."
      },
      {
        "file": "7-Figure1-1.png",
        "caption": "Figure 1: Example problematic entities for Baseline-BiLSTM-CNN."
      },
      {
        "file": "7-Table5-1.png",
        "caption": "Table 5: Entity-chunking ablation results."
      },
      {
        "file": "8-Figure2-1.png",
        "caption": "Figure 2: Attention heat maps for the mentions in Figure 1, best viewed on computer."
      }
    ]
  },
  "1908.09919": {
    "title": "Gender Prediction from Tweets: Improving Neural Representations with Hand-Crafted Features",
    "abstract": "Author profiling is the characterization of an author through some key attributes such as gender, age, and language. In this paper, a RNN model with Attention (RNNwA) is proposed to predict the gender of a twitter user using their tweets. Both word level and tweet level attentions are utilized to learn 'where to look'. This model (this https URL) is improved by concatenating LSA-reduced n-gram features with the learned neural representation of a user. Both models are tested on three languages: English, Spanish, Arabic. The improved version of the proposed model (RNNwA + n-gram) achieves state-of-the-art performance on English and has competitive results on Spanish and Arabic.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Author profiling is the characterization of an author through some key attributes such as gender, age, and language. It's an indispensable task especially in security, forensics, and marketing. Recently, social media has become a great data source for the potential learning approaches. Furthermore, gender prediction has been a popular profiling task.",
          "The traditional approach to gender prediction problem is extracting a useful set of hand-crafted features and then feeding them into a standard classification algorithm. In their study, BIBREF0 work with the style-based features of message length, stop word usage, frequency of smiley etc. and use different classifiers such as k-nearest neighbor, naive bayes, covering rules, and backpropagation to predict gender on chat messages. Similarly, BIBREF1 select some hand-crafted features and feed them into various classifiers.",
          "Most of the work on gender prediction rely on n-gram features BIBREF2. BIBREF3 give Latent Semantic Analysis (LSA)-reduced forms of word and character n-grams into Support Vector Machine (SVM) and achieve state-of-the-art performance. Apart from exploiting n-gram frequencies, there are studies BIBREF4, BIBREF5, BIBREF6 to extract cross-lingual features to determine gender from tweets. Some other work BIBREF4, BIBREF7 exploit user metadata besides using just tweets.",
          "Recently, neural network-based models have been proposed to solve this problem. Rather than explicitly extracting features, the aim is to develop an architecture that implicitly learns. In author profiling, both style and content-based features were proved useful BIBREF8 and neural networks are able to capture both syntactic and semantic regularities. In general, syntactic information is drawn from the local context. On the other hand, semantic information is often captured with larger window sizes. Thus, CNNs are preferred to obtain style-based features while RNNs are the methods of choice for addressing content-based features BIBREF9. In literature, CNN BIBREF10 or RNN BIBREF11, BIBREF12, BIBREF13 is used on this task. BIBREF11 obtain state-of-the-art performance among neural methods by proposing a model architecture where they process text through RNN with GRU cells. Also, the presence of an attention layer is shown to boost the performance of neural methods BIBREF11, BIBREF10.",
          "In this work, we propose a model that relies on RNN with attention mechanism (RNNwA). A bidirectional RNN with attention mechanism both on word level and tweet level is trained with word embeddings. The final representation of the user is fed to a fully connected layer for prediction. Since combining some hand-crafted features with a learned linear layer has shown to perform well in complex tasks like Semantic Role Labeling (SRL) BIBREF14, an improved version of the model (RNNwA + n-gram) is also tested with hand-crafted features. In the improved version, LSA-reduced n-gram features are concatenated with the neural representation of the user. Then the result is fed into a fully-connected layer to make prediction. Models are tested in three languages; English, Spanish, and Arabic, and the improved version achieves state-of-the-art accuracy on English, and competitive results on Spanish and Arabic corpus.",
          "There are many datasets created for this task BIBREF15, BIBREF16. In this work, we have used the dataset and benchmarks provided by the PAN 2018 shared task on author profiling BIBREF15. As the dataset contains a constant number of 100 tweets per user, accuracy tests are performed both on user and tweet level (tweet-level predictions are made by removing the user-level attention). Tweet-level accuracy tests show interesting results during hyperparameter optimization. When the tweet-level predictions are averaged to produce user-level predictions, it is seen that the hyperparameters that gave the best results in terms of tweet-level accuracy, performs worse in user-level accuracy. The better user-level models, with different hyperparameters, that gave the highest user-level accuracy are observed to slightly overfit on tweet-level. It leads us to believe that the overfitting in the tweet-level predictions in best user-level models acts similar to an attention mechanism by over-emphasizing some distinctive tweets and ignoring the rest."
        ]
      },
      {
        "section_name": "Model architecture",
        "paragraphs": [
          "In author profiling, both style-based and content-based features must be addressed BIBREF8. An appropriate baseline for this task is a CNN-based model that is able to capture style-based information BIBREF10. The proposed RNN-based model relies on extracting content-based features. In addition, in order to improve its accuracy, the proposed model is combined with some hand-crafted features. For all of the models, Adam optimizer BIBREF17 is used with cross-entropy loss along with the L2 regularization to prevent from overfitting."
        ]
      },
      {
        "section_name": "Model architecture ::: Baseline CNN model",
        "paragraphs": [
          "CNN model (denoted CNNwA on results) is based on BIBREF10 where each character in the tweet is represented with a character embedding of size 25, which is trained along the neural network. All characters are lower-cased. Non-alphabetical characters such as punctuation are kept with a view to capturing some information on the profile of the user since they are heavily used in twitter as emoticons.",
          "Filters of size $3\\times 3$, $6\\times 6$ and $9\\times 9$ are used for each language, and the number of filters is determined by performing grid search on validation set. Among the tested range (50-125 with intervals of 25), the number of filters that gives the best accuracy is 100 (per each filter), for all languages."
        ]
      },
      {
        "section_name": "Model architecture ::: RNN Model",
        "paragraphs": [
          "Since the dataset is not big enough to train word embeddings, Glove word embeddings BIBREF18 of size 200 are used in the proposed RNN Model (denoted RNNwA on results) due to their success at various NLP tasks and their multi-linguality: They encompass all the languages in the test set. In addition, the Glove embeddings are also trained on Twitter data which make them reflect the nature of the dataset better than other alternatives.",
          "A bidirectional RNN with GRU BIBREF19 cells are used in this model where the number of cells is a hyperparameter. Among the tested range (50-150 with intervals of 25), best accuracy on validation set is obtained by 150 cells in English and 100 cells in Spanish and Arabic. An attention mechanism is used on word-level in addition to tweet-level to capture the important parts of each tweet as shown in Figure FIGREF2.",
          "A feature vector for each tweet is created by feeding tweets to RNN separately. In order to discriminate tweets with respect to their information carrying capacity on its author's gender, Bahdanau attention mechanism BIBREF20 is used to combine the tweets rather than concatenating them before feeding to the network or averaging their predictions later. Figure FIGREF4 shows the tweet-level attention layer in detail which is calculated by the following formulas:",
          "where $W_\\alpha $ is a learnable weight matrix that is used to multiply each output of the RNN, $t_i$ is the feature vector of $i$th tweet, $b$ is a learnable bias vector, $w_i$ is a learnable attention weight, $A_i$ is the attention context vector, $v_i$ is the attention value for $i$th tweet, $o_i$ is attention output vector for the corresponding tweet, $K$ is the output vector for user. Matrix $W_\\alpha $ and vectors $w_i$ and $b$ are learned parameters.",
          "Attention layer outputs a single feature vector that corresponds to a user, which is then fed to a fully-connected layer to lower the dimension to the number of classes.",
          "There are two different attention layers on the model. One is a word level attention where it amplifies the signal coming from important words, the other one is on tweet level where it combines the signals coming from each tweet and creates the final representation of a user."
        ]
      },
      {
        "section_name": "Model architecture ::: RNN with N-gram Model",
        "paragraphs": [
          "For this model (denoted RNNwA + n-gram on results), n-gram features are collected with the same method described in BIBREF3. At the beginning, word level and character level n-gram features are obtained and concatenated. Then they are normalized with tf-idf transformation. For reducing the number of features and sparsity in n-gram vectors, tuples that have frequency less than 2 are ignored. For character level n-gram $N$ is selected as $3,4$, and 5 and for word level n-gram, $N$ is $1,2$ for Spanish and Arabic; $1,2,3$ for English. The dimension of the vector is reduced by LSA to 300. Then the vector is concatenated with neural representation which is produced right after tweet level attention in RNNwA model. The resultant representation is fed to a fully- connected layer that produces predictions."
        ]
      },
      {
        "section_name": "Model architecture ::: Dataset",
        "paragraphs": [
          "Models are tested on the PAN 2018 author profiling dataset BIBREF15, which provides tweets in three languages: English, Spanish and Arabic with training/test datasets of sizes (3000 users, 1900 users), (3000 users, 2200 users), and (1500 users, 1000 users) respectively, where each user has 100 tweets. Each training set is further partitioned randomly into training and validation sets with the ratio ($0.8$, $0.2$) respectively for hyper-parameter optimization."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "In order to measure the effectiveness of the attention mechanism, in addition to the CNN baseline model (CNNwA) and RNNwA, two new models (denoted as CNN and RNN) are created by removing the tweet level attention layer (word level attention stays the same) and generating a prediction for each tweet then just simply taking an average to give a user level prediction. Tweet level accuracies for these models are shown in Table TABREF9.",
          "In Table TABREF10, user level accuracy results for the proposed model (RNNwA) along with the baseline models are given. As can be seen in the results, tweet level attention mechanism increases the score of all baseline models with the only exception of the CNNwA model in Arabic.",
          "Also, compared to the best neural model BIBREF11 where max pooling is used instead of an attention mechanism on the outputs of RNN, the proposed model (RNNwA) gives better results in terms of accuracy on English and Arabic datasets, and produces similar accuracy levels on Spanish dataset (Table TABREF11). These results show that an attention layer is able to learn \"where/how to look\" for features that are helpful in identifying the gender of a user.",
          "On the other hand, the improved model (RNNwA + n-gram), where neural and hand-crafted features are concatenated, increases the accuracy of the proposed model by approximately $0,5$% on English and approximately 2% in Spanish and Arabic. This also supports our intuition that the performance of neural models can be improved by hand-crafted features, which is based on the study of BIBREF14. As can be seen in Table TABREF11, the improved model outperforms the state-of-the-art method of BIBREF3 in English and produces competitive results in Spanish and Arabic.",
          "There is an interesting observation concerning the models without tweet level attention (RNN and CNN) in hyper-parameter optimization. During the hyperparameter optimization of the models RNN and CNN, we saved both the models that gave the best tweet-level accuracy and the models that gave the best user-level accuracy. The expectation is to see that the best setup on tweet-level also gives the best performance in user-level, but the outcome is the opposite: Best setups on tweet-level always fall behind best user-level setups. Performance differences between various setups can be seen in Figure FIGREF12 where accuracies of the best three models in terms of tweet-level and best three models in terms of user-level are shown for all languages. It can be observed that the best tweet-level setups are almost $4\\%$ worse in terms of user-level accuracy. Deeper investigation shows that the best user-level models exhibit slight overfitting on tweet-level, in training. Although overfitting normally leads to poor generalization, in this case we believe that this overfitting acts similar to an attention mechanism by over-emphasizing some important tweets and ignoring uninformative ones in the process. Even though this leads to poor tweet-level accuracy, it improves the user-level accuracy of the models as it can be seen from the Figure FIGREF12.",
          "[1]In their paper, authors report a result of 82.21 in English but we couldn't verify their accuracy in our repetitions by using their software and the same dataset. [2]Since their software is not provided, we directly take the accuracy values from their paper.",
          "",
          ""
        ]
      },
      {
        "section_name": "Conclusion",
        "paragraphs": [
          "In this work, a neural network-based model namely RNN with attention (RNNwA) is proposed on the task of gender prediction from tweets. The proposed model is further improved by hand-crafted features which are obtained by LSA-reduced n-grams and concatenated with the neural representation from RNNwA. User representations that is the result of this model is then fed to a fully-connected layer to make prediction. This improved model achieved state-of-the-art accuracy on English and has a competitive performance on Spanish and Arabic.",
          "We also would like to kindly remind our readers that although the model is self-learning, there might still exist a gender bias in the evaluation of the model due to the data itself. Since the model learns to predict the gender directly from tweets of the twitter users, any bias the twitter users have might be reflected in the model predictions."
        ]
      },
      {
        "section_name": "Acknowledgments",
        "paragraphs": [
          "We would like to thank Computer Vision Research Group from Izmir Institute of Technology for providing us the hardware for performing the tests in this research.",
          "The Titan V used for this research was donated by the NVIDIA Corporation."
        ]
      }
    ],
    "qas": [
      {
        "question": "How is this model different from a LSTM?",
        "question_id": "e1f61500eb733f2b95692b6a9a53f8aaa6f1e1f6",
        "nlp_background": "two",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "Spanish",
        "question_writer": "486a870694ba60f1a1e7e4ec13e328164cd4b43c",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "It's a recurrent neural network with n-gram model",
              "evidence": [
                "Model architecture ::: RNN with N-gram Model",
                "For this model (denoted RNNwA + n-gram on results), n-gram features are collected with the same method described in BIBREF3. At the beginning, word level and character level n-gram features are obtained and concatenated. Then they are normalized with tf-idf transformation. For reducing the number of features and sparsity in n-gram vectors, tuples that have frequency less than 2 are ignored. For character level n-gram $N$ is selected as $3,4$, and 5 and for word level n-gram, $N$ is $1,2$ for Spanish and Arabic; $1,2,3$ for English. The dimension of the vector is reduced by LSA to 300. Then the vector is concatenated with neural representation which is produced right after tweet level attention in RNNwA model. The resultant representation is fed to a fully- connected layer that produces predictions."
              ],
              "highlighted_evidence": [
                "Model architecture ::: RNN with N-gram Model\nFor this model (denoted RNNwA + n-gram on results), n-gram features are collected with the same method described in BIBREF3. At the beginning, word level and character level n-gram features are obtained and concatenated. Then they are normalized with tf-idf transformation. For reducing the number of features and sparsity in n-gram vectors, tuples that have frequency less than 2 are ignored. For character level n-gram $N$ is selected as $3,4$, and 5 and for word level n-gram, $N$ is $1,2$ for Spanish and Arabic; $1,2,3$ for English. The dimension of the vector is reduced by LSA to 300. Then the vector is concatenated with neural representation which is produced right after tweet level attention in RNNwA model. The resultant representation is fed to a fully- connected layer that produces predictions."
              ]
            },
            "annotation_id": "014f8026384acc63c0d3e7bf58fcdacbc598d917",
            "worker_id": "fa716cd87ce6fd6905e2f23f09b262e90413167f"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                "bidirectional RNN with GRU"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "A bidirectional RNN with GRU BIBREF19 cells are used in this model where the number of cells is a hyperparameter. Among the tested range (50-150 with intervals of 25), best accuracy on validation set is obtained by 150 cells in English and 100 cells in Spanish and Arabic. An attention mechanism is used on word-level in addition to tweet-level to capture the important parts of each tweet as shown in Figure FIGREF2."
              ],
              "highlighted_evidence": [
                "A bidirectional RNN with GRU BIBREF19 cells are used in this model where the number of cells is a hyperparameter."
              ]
            },
            "annotation_id": "c44973cf976f3f4826c748b21a9599d6d687df11",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "3-Figure1-1.png",
        "caption": "Figure 1: Proposed model."
      },
      {
        "file": "4-Figure2-1.png",
        "caption": "Figure 2: Tweet-level Attention Layer in Detail."
      },
      {
        "file": "5-Table2-1.png",
        "caption": "Table 2: User Level Accuracy of the Proposed Model (RNNwA) along with the Baselines."
      },
      {
        "file": "5-Table1-1.png",
        "caption": "Table 1: Tweet Level Accuracy of the CNN and RNN Models without Attention."
      },
      {
        "file": "6-Table3-1.png",
        "caption": "Table 3: Accuracy on PAN 2018 test set."
      },
      {
        "file": "6-Figure3-1.png",
        "caption": "Figure 3: Comparison of Tweet-Level and User-level accuracy of RNN Model. Best three user-level models (colored in red) and best three tweet-level models (colored in blue) are selected for each language."
      }
    ]
  },
  "1910.10670": {
    "title": "Efficient Dynamic WFST Decoding for Personalized Language Models",
    "abstract": "We propose a two-layer cache mechanism to speed up dynamic WFST decoding with personalized language models. The first layer is a public cache that stores most of the static part of the graph. This is shared globally among all users. A second layer is a private cache that caches the graph that represents the personalized language model, which is only shared by the utterances from a particular user. We also propose two simple yet effective pre-initialization methods, one based on breadth-first search, and another based on a data-driven exploration of decoder states using previous utterances. Experiments with a calling speech recognition task using a personalized contact list demonstrate that the proposed public cache reduces decoding time by factor of three compared to decoding without pre-initialization. Using the private cache provides additional efficiency gains, reducing the decoding time by a factor of five.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "Speech input is now a common feature for smart devices. In many cases, the user's query involves entities such as a name from a contact list, a location, or a music title. Recognizing entities is particularly challenging for speech recognition because many entities are infrequent or out of the main vocabulary of the system. One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities. Because each user can have their own personalized LM, it is vital that the speech decoder be able to efficiently load the model on the fly, so it can be used in decoding, without any noticeable increase in latency.",
          "Many state-of-the-art speech recognition decoders are based on the weighted finite state transducer (WFST) paradigm BIBREF0, BIBREF1. A conventional WFST decoder searches a statically composed $H C L G$ graph, where $H$ is the graph that translates HMM states to CD phones, $C$ translates CD phones to graphemes, $L$ translates graphemes to words and $G$ is graph that represents the language model. Using a statically composed graph has two limitations. First, it is both compute and memory intensive when the vocabulary and LM are large. Second, the static graph approach makes it hard to handle personalized language models BIBREF2. Many common tasks a user may want to perform with a voice assistant such as making phone calls, messaging to a specific contact or playing favorite music require a personalized language model. A dynamic WFST decoder is better suited for such cases. As denoted in Eq (DISPLAY_FORM1), in a dynamic WFST decoder, $HCL$ is composed and optimized offline, while $G$ is composed on the fly with lazy (on-demand) composition, denoted as $\\circ $.",
          "To handle dynamic entities, a class LM $G_c$ is normally used as background $G$ and a personalized LM $G_p$ is replaced on-the-fly, before applying lazy composition.",
          "Since the non-terminal states are composed on-the-fly, it means the states of recognition FST will also contain personalized information that cannot be used by other users or service threads.",
          "In previous work, a method was proposed to do a pre-initialized composition for a non-class LM BIBREF3. However, it the dynamic part is still expanded on-the-fly. In this work, we propose two improvements in order to best leverage class language models. First, we use simpler methods for pre-initialization which do not need to pre-generate decoder state statistics. Second, we propose a two-layer pre-initialization mechanism that also avoids performing dynamic expansion on per user basis. In the two-layer pre-initialization method, we make use of a class LM with class tag. We build a personalized FST that contains the members of the class for each user. Using the FST replacement algorithm, we obtain a personalized language transducer BIBREF4. We perform a pre-composition for all FST states whose transitions do not contain class tags. By doing so, the actual on-demand composition is only required for the states in personalized FST. For a multi-threaded service, the pre-composed FST can be shared by all threads, since it does not contain personalized FST states (non-terminals). The personalized part will be shared for all utterances from the same user, which will take full advantage of memory usage.",
          "Unlike the previous pre-initialization approach that is based on calculating the state statistics BIBREF3, our simplified pre-initialization methods do not rely on pre-calculated state frequencies. Instead, we directly expand the graph with breadth-first search or through a data-driven approach where a small numbers of utterances are processed by the decoder offline. We found that both methods are effective, but the data-driven approach outperforms the breadth first search algorithm. Both methods can be combined to achieve the best performance. Through a series of experiments on a speech recognition task for the calling domain, we found that pre-initialization on the public graph speeds up the decoding time by a factor of three. Futhermore, sharing the private graph further reduces decoding time and results in factor of five improvement in efficiency."
        ]
      },
      {
        "section_name": "Architecture and Algorithm",
        "paragraphs": [
          "The general composition algorithm is well-explained in BIBREF5, BIBREF6 and a pre-composition algorithm with a non-class LM is described in BIBREF3. Here we will only present our new algorithm focusing on how to pre-compose the graph while avoiding non-terminal states. In this work, we use the same mathematical notation as BIBREF0."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Two-layer cached FST during decoding",
        "paragraphs": [
          "A WFST can be written as",
          "where $\\mathcal {A}$, $\\mathcal {B}$ are finite label sets for input and output. $Q$ is the finite state set. $I\\subseteq Q$ is the initial state set, $F\\subseteq Q$ is final state set. $E\\subseteq Q\\times (\\mathcal {A} \\cup \\lbrace \\epsilon \\rbrace ) \\times (\\mathcal {B} \\cup \\lbrace \\epsilon \\rbrace ) \\times \\mathbb {K} \\times Q$ is a set of transitional mapping between states in $Q$ with weighted input/output label pair, where $\\mathbb {K}$ is a semiring $(\\mathbb {K}, \\oplus , \\otimes , \\overline{0}, \\overline{1})$.",
          "The composition of two weighted FSTs is defined as",
          "where $\\mathcal {B} = \\mathcal {B}_1 \\cap \\mathcal {A}_2$ is the intersection of output label set of $T_1$ and input label set of $T_2$. For $a, b, c\\ne \\epsilon $, two transitions $(q_1, a, b, w_1, q_1^{\\prime })$ in $T_1$ and $(q2, b, c, w_2, q_2^{\\prime })$, the composed transition will be $((q_1, q_2), a, c, w_1 \\bigotimes w_2, (q_1^{\\prime }, q_2^{\\prime }))$.",
          "For two FSTs $T_1$, $T_2$ over semiring $\\mathbb {K}$,",
          "is the class language model transducer obtained by replacing the class labels in generic root FST $G_c$ with class FSTs $G_p$ for different classes, where $\\mathcal {C}$ denotes the set of all supported classes.",
          "The calculation for composition is very slow for LM with large vocabulary size. Naive on-the-fly composition is very time-consuming. In BIBREF3, the authors proposed a pre-initialized composition algorithm, which does a partial composition based on the state frequency. This one-time cost calculation can do some composition in advance. During decoding search, the FST will skip the composition of pre-initialized states. However, extending this algorithm to class LMs is non-trivial in practice. For a class LM, the non-terminal states cannot be composed during pre-initialization since we need a pre-initialization that is applicable to all users, which means we need to apply some restrictions to prevent composition of the personalized part.",
          "We define $T_P$ as a partial composed FST structure for $T=T_1 \\circ T_2$, where $P \\subseteq Q$ is the set of pre-composed states. In real time decoding, the on-the-fly composition will be performed on top of the pre-initialized $T_P$, which is similar to previous work BIBREF3. In a production environment, multiple threads will share the same pre-composed FST $T_P$ structure, while each thread will own a private FST structure.",
          "where $T_D$ is the dynamic cache built on top of $T_P$. $T_D$ may need to copy some states from $T_P$ if we need to update information for those states in $T_P$.",
          "In order to support this mechanism, we use a two-layered cached FST for decoding. The first layer is public cache which represents $T_P$. It is a static cache created by pre-initialization. The second layer is the private cache, which is owned by a particular user and constructed on-the-fly. Figure FIGREF9 shows the architecture of our two-layer FST. The solid box denotes the static graph and the dashed ones show the dynamic graph. Personalized states will appear only in $T_D$.",
          "The static public cache stores the most frequent states, which greatly reduces the run time factor (RTF) of online decoding. Since $T_D$ has a smaller size than a fully dynamic graph, the marginal memory efficiency for multi-threaded service will be better.",
          "Furthermore, the private cache will not be freed after decoding a single utterance. The lifetime of a private cache actually can last for the entire dialog section for a specific user. The private cache keeps updating during the dialog session, making processing the subsequent utterances faster as more states are composed and stored in $T_D$. With this accumulated dynamic cache, a longer dialog can expect a better RTF in theory. In general, the static public cache serves all threads, while the private cache boosts the performance within a dialog session. The private cache will be freed at the end of the dialog."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Pre-composition algorithm for class language models",
        "paragraphs": [
          "Based on the algorithm described in BIBREF3, we allow the states $(q_1, q_2)$ such that $q_2 = (q_c, q_p), q_c \\in Q_c, q_p=0 $ to be pre-composed, where $q_c$ and $q_p$ denote states in $G_c$ and $G_p$, respectively. States in $G_c$ with a class label transition will be ignored during pre-composition.",
          "By applying this restriction, the states in the pre-composed recognition FST $T_P$ will not contain any personalized states, and thus, can be shared by all users and threads.",
          "Note that care must taken to account for the special case when the initial states could have transitions with a class label. In this case, the entire graph is blocked (Figure FIGREF12(a)), so we need to add an extra $\\epsilon $ transition before class label in the root FST, which will guarantee all the initial states are composed (Figure FIGREF12(b)). In the pre-composition stage, we don't need the actual class FSTs for each class, so $G_p$ is simply a placeholder FST which only contains a placeholder word $\\left\\langle temp \\right\\rangle $. This means all the transitions following the placeholder transition may be blocked if there is no other path that skips over the placeholder transition. In practice, for a large LM graph with a large vocabulary, the connectivity is usually very high, once the initial states are guaranteed to be composed.",
          "This pre-composition algorithm can be applied with lookahead filter BIBREF7. We implemented this algorithm using OpenFst framework BIBREF4, which supports such a lookahead filter in both the pre-composition and decoding stages. In our implementation, the decoding FST has a two-layered cache and state table. The state table is necessary since the add-on composition during decoding must be based on the same state map."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Pre-composition methods",
        "paragraphs": [
          "In general, we can pre-compose all the states of the decoding FST that are applied to all users, i.e. those unrelated to the personalized language model. However, this full set pre-composition could be very slow and memory consuming. In fact, most of the states are rarely composed during real data traffic, and therefore, performing partial pre-composition is sufficient. Here we propose two simple methods for pre-composition."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Pre-composition methods ::: Distance based method",
        "paragraphs": [
          "Naive breath-first-search (BFS) is the most obvious way to perform pre-composition. We iterate over all states within a specific distance from the start state of decoding FST. It generalizes to a full set pre-composition when the search depth is large."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Pre-composition methods ::: Data-driven warm-up",
        "paragraphs": [
          "Our goal is to pre-compose the most frequently encountered states. However, if some frequent states are far from the start state, they may not be identified by naive BFS. In this case, it is very time and memory consuming to increase the depth of the BFS. Moreover, if we simply use a offline corpus of utterances to analyze the frequency of all states, some highly frequent states could be blocked by less frequent states. Thus, the easiest way is to do pre-composition using real utterances.",
          "The decoding FST can be expanded while decoding utterances. We utilize a special decoder in the warm-up stage. This warm-up decoder will apply the same restriction discussed in the previous section. We use an empty contact FST in the warm-up stage to avoid expanding any personalization-related states. This data driven pre-composition will expand most frequent states which are visited during warm-up decoding, especially for some specific patterns."
        ]
      },
      {
        "section_name": "Architecture and Algorithm ::: Out-Of-Vocabulary recognition",
        "paragraphs": [
          "Handling out-of-vocabulary (OOV) words in speech recognition is very important especially for contact name recognition. We replace the normal class (contact) FST with a mono-phone FST by adding monophone words in the lexicon BIBREF2, BIBREF8, BIBREF9. By using s monophone FST, we avoid the necessity of adding new words into lexicon on-the-fly, which significantly simplifies the system. We use silence phone \"SIL\" to represent the word boundary. These monophone words will not be applied with silence phone in lexicon since they are not real words.",
          "In Figure FIGREF17, the contact name is represented as monophone words using IPA phone set. SIL is added after each name in contact FST. Names with the same pronunciation also need to be handled using disambiguation symbols. In practice, because of accent and pronunciation variability, we have found that multiple pronunciations of OOV names are required in the personalized class FST."
        ]
      },
      {
        "section_name": "Experiments",
        "paragraphs": [
          "We performed a series of experiments on different data sets in order to evaluate the impact on real-time factor (RTF) and word error rate (WER) of the proposed approach. In theory, the pre-composition algorithm will not change the WER, since the search algorithm does not change."
        ]
      },
      {
        "section_name": "Experiments ::: Experimental Setup",
        "paragraphs": [
          "In these experiments, speech recognition was performed using a hybrid LSTM-HMM framework. The acoustic model is an LSTM that consumes 40-dimensional log filterbank coefficients as the input and generates the posterior probabilities of 8000 tied context-dependent states as the output. The LM is a pruned 4-gram model trained using various semantic patterns that include a class label as well as a general purpose text corpus. The LM contains $@contact$ as an entity word, which will be replaced by the personalized contact FST. After pruning, the LM has 26 million n-grams.",
          "The personalized class FST (contact FST) only contains monophone words. Determinization and minimization are applied to the contact FST with disambiguation symbols. The disambiguation symbols are removed after graph optimization. The decoding experiments are performed on a server with 110 GB memory and 24 processors.",
          "Experiments are performed on two data sets. The first contains 7,500 utterances from the calling domain from Facebook employees. This includes commands like \u201cPlease call Jun Liu now\". The second consists of approximately 10,000 utterances from other common domains, such as weather, time, and music. Note that we include the contact FST for both calling and non-calling utterances, as we do not assume knowledge of the user's intent a priori. Each user has a contact FST containing 500 contacts on average. We keep up to five pronunciations for each name, generated by a grapheme-to-phoneme model.",
          "We experiment with both the naive BFS and the proposed data-driven pre-composition methods. For the data-driven approach, we randomly picked 500 utterances from the evaluation data set as warm up utterances. We use an empty contact FST to be replaced into the root LM to avoid personalized states during warm-up decoding. In order to evaluate the benefit of the proposed private cache to store the personalized language model, we group multiple utterances from a user into virtual dialog sessions of one, two, or five turns."
        ]
      },
      {
        "section_name": "Experiments ::: Results",
        "paragraphs": [
          "Table TABREF19 shows the WER and RTF for two corpora with different pre-composition methods with ten concurrent speech recognition client requests. The private cache is freed after decoding each utterance. RTF is calculated by $t_{decode}/t_{wav}$, where $t_{decode}$ is the decoding time and $t_{wav}$ is the audio duration. We use 50th and 95th percentile values for the RTF comparison. As expected, the WER remains unchanged for the same data set. With pre-composition, the RTF for both calling and non-calling is reduced by a factor of three.",
          "Table TABREF21 shows the additional RTF improvement that can be obtained during multi-turn dialogs from the proposed private cache. When the dialog session is only a single turn, the RTF remains unchanged. However, for multi-turn sessions, additional RTF reductions are obtained for both the calling and non-calling corpora. The decoding time is reduced by a factor of five compared to a fully dynamic graph for dialog sessions of five turns.",
          "Figure FIGREF22 shows the RTF and memory usage for teh different pre-composition approaches. The upper graph shows the RTF for different steps of naive BFS using the calling data set. The figure shows that additional BFS steps improves RTF for both 50 and 95 percentiles. However, no improvement is observed beyond five steps, because the most frequent states close to the start state have already been pre-composed. The additional BFS steps only result in more memory usage. With the data-driven warmup, the RTF shows additional improvement. Furthermore, the difference in the p50 and p95 RTF values becomes much smaller than in the BFS approach.",
          "The lower graph of Figure FIGREF22 shows the memory usage as a function of the number of concurrent requests. Though the pre-composed graph may use more memory when we have only a small number of threads, the marginal memory cost for additional requests for a fully dynamic graph is roughly 1.5 times larger than for the pre-composed graph. The data-driven method has the best marginal memory efficiency for a large number of concurrent requests."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this work, we propose new methods for improving the efficiency of dynamic WFST decoding with personalized language models. Experimental results show that using a pre-composed graph can reduce the RTF by a factor of three compared with a fully dynamic graph. Moreover, in multi-utterance dialog sessions, the RTF can be reduced by a factor of 5 using the proposed private cache without harming WER. Though a fully dynamic graph uses less memory for the graph, the pre-composed graph has a better marginal memory cost, which is more memory efficient in large-scale production services that need to support a large number of concurrent requests.",
          "Our results also show that increasing the steps of naive BFS will not help the RTF, since it may compose infrequently encountered states, resulting in unnecessary memory usage. Using the proposed data-driven warm-up performs better in both marginal memory efficiency and RTF than naive BFS. Both pre-composition methods can also be combined."
        ]
      },
      {
        "section_name": "Acknoledgements",
        "paragraphs": [
          "We would like to thank Mike Seltzer, Christian Fuegen, Julian Chan, and Dan Povey for useful discussions about the work."
        ]
      }
    ],
    "qas": [
      {
        "question": "What is a personalized language model?",
        "question_id": "5695908a8c6beb0e3863a1458a1b93aab508fd34",
        "nlp_background": "five",
        "topic_background": "unfamiliar",
        "paper_read": "no",
        "search_query": "",
        "question_writer": "5053f146237e8fc8859ed3984b5d3f02f39266b7",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "A model that contains the expected user-specific entities.",
              "evidence": [
                "Speech input is now a common feature for smart devices. In many cases, the user's query involves entities such as a name from a contact list, a location, or a music title. Recognizing entities is particularly challenging for speech recognition because many entities are infrequent or out of the main vocabulary of the system. One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities. Because each user can have their own personalized LM, it is vital that the speech decoder be able to efficiently load the model on the fly, so it can be used in decoding, without any noticeable increase in latency."
              ],
              "highlighted_evidence": [
                "One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities. "
              ]
            },
            "annotation_id": "064a7f6030d4576c2e33f599d97efb0c7fa925d5",
            "worker_id": "71f73551e7aabf873649e8fe97aefc54e6dd14f8"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": null,
              "free_form_answer": "language model which contains user-specific entities",
              "evidence": [
                "Speech input is now a common feature for smart devices. In many cases, the user's query involves entities such as a name from a contact list, a location, or a music title. Recognizing entities is particularly challenging for speech recognition because many entities are infrequent or out of the main vocabulary of the system. One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities. Because each user can have their own personalized LM, it is vital that the speech decoder be able to efficiently load the model on the fly, so it can be used in decoding, without any noticeable increase in latency."
              ],
              "highlighted_evidence": [
                "One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities."
              ]
            },
            "annotation_id": "5769d5f2119de030c0462c54b3d4ba5f4402e854",
            "worker_id": "18f4d5a2eb93a969d55361267e74aa0c4f6f82fe"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [
                " contains the expected user-specific entities"
              ],
              "yes_no": null,
              "free_form_answer": "",
              "evidence": [
                "Speech input is now a common feature for smart devices. In many cases, the user's query involves entities such as a name from a contact list, a location, or a music title. Recognizing entities is particularly challenging for speech recognition because many entities are infrequent or out of the main vocabulary of the system. One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities. Because each user can have their own personalized LM, it is vital that the speech decoder be able to efficiently load the model on the fly, so it can be used in decoding, without any noticeable increase in latency.",
                "Many state-of-the-art speech recognition decoders are based on the weighted finite state transducer (WFST) paradigm BIBREF0, BIBREF1. A conventional WFST decoder searches a statically composed $H C L G$ graph, where $H$ is the graph that translates HMM states to CD phones, $C$ translates CD phones to graphemes, $L$ translates graphemes to words and $G$ is graph that represents the language model. Using a statically composed graph has two limitations. First, it is both compute and memory intensive when the vocabulary and LM are large. Second, the static graph approach makes it hard to handle personalized language models BIBREF2. Many common tasks a user may want to perform with a voice assistant such as making phone calls, messaging to a specific contact or playing favorite music require a personalized language model. A dynamic WFST decoder is better suited for such cases. As denoted in Eq (DISPLAY_FORM1), in a dynamic WFST decoder, $HCL$ is composed and optimized offline, while $G$ is composed on the fly with lazy (on-demand) composition, denoted as $\\circ $."
              ],
              "highlighted_evidence": [
                "One way to improve performance is such cases is through the use of a personal language model (LM) which contains the expected user-specific entities.",
                "Many common tasks a user may want to perform with a voice assistant such as making phone calls, messaging to a specific contact or playing favorite music require a personalized language model."
              ]
            },
            "annotation_id": "f28b073eb28eb85fc67d1a5a3a774014581e4c49",
            "worker_id": "258ee4069f740c400c0049a2580945a1cc7f044c"
          }
        ]
      }
    ],
    "figures_and_tables": [
      {
        "file": "2-Figure1-1.png",
        "caption": "Figure 1: Architecture of two layer cached FST. TP is the static public cache built in pre-initialization. TD is the private cache for dynamic composition in decoding time. The lifetime of TD varies based on the length of dialog section."
      },
      {
        "file": "3-Figure2-1.png",
        "caption": "Figure 2: Class language model FST with contact tags. (a) Conventional LM with @contact. (b) LM with additional <eps> between start state 0 and @contact. This guarantees the start state is pre-composed."
      },
      {
        "file": "3-Figure3-1.png",
        "caption": "Figure 3: Monophone contact FST. The monophone will be treated as word in the lexicon without a word boundary, so there is an additional silence phone after each name."
      },
      {
        "file": "4-Table1-1.png",
        "caption": "Table 1: WER and RTF results for different data set and different pre-composition methods."
      },
      {
        "file": "4-Table2-1.png",
        "caption": "Table 2: RTF results for decoding in session. Decoder will hold the private cache for entire dialog session."
      },
      {
        "file": "4-Figure4-1.png",
        "caption": "Figure 4: RTF and memory usage comparison. Upper: RTF between fully dynamic graph, different steps of BFS and data driven pre-composition. Lower: Memory usage for different graphs. A pre-composed graph has a better marginal memory cost than a fully dynamic graph."
      }
    ]
  },
  "1902.06734": {
    "title": "Author Profiling for Hate Speech Detection",
    "abstract": "The rapid growth of social media in recent years has fed into some highly undesirable phenomena such as proliferation of abusive and offensive language on the Internet. Previous research suggests that such hateful content tends to come from users who share a set of common stereotypes and form communities around them. The current state-of-the-art approaches to hate speech detection are oblivious to user and community information and rely entirely on textual (i.e., lexical and semantic) cues. In this paper, we propose a novel approach to this problem that incorporates community-based profiling features of Twitter users. Experimenting with a dataset of 16k tweets, we show that our methods significantly outperform the current state of the art in hate speech detection. Further, we conduct a qualitative analysis of model characteristics. We release our code, pre-trained models and all the resources used in the public domain.",
    "full_text": [
      {
        "section_name": "Introduction",
        "paragraphs": [
          "This work is licensed under a Creative Commons Attribution 4.0 International License.",
          "License details: http://creativecommons.org/licenses/by/4.0/. Hate speech, a term used to collectively refer to offensive language, racist comments, sexist remarks, etc., is omnipresent in social media. Users on social media platforms are at risk of being exposed to content that may not only be degrading but also harmful to their mental health in the long term. Pew Research Center highlighted the gravity of the situation via a recently released report BIBREF0 . As per the report, 40% of adult Internet users have personally experienced harassment online, and 60% have witnessed the use of offensive names and expletives. Expectedly, the majority (66%) of those who have personally faced harassment have had their most recent incident occur on a social networking website or app. While most of these websites and apps provide ways of flagging offensive and hateful content, only 8.8% of the victims have actually considered using such provisions. These statistics suggest that passive or manual techniques for curbing propagation of hateful content (such as flagging) are neither effective nor easily scalable BIBREF1 . Consequently, the efforts to automate the detection and moderation of such content have been gaining popularity in natural language processing (nlp) BIBREF2 , BIBREF3 .",
          "Several approaches to hate speech detection demonstrate the effectiveness of character-level bag-of-words features in a supervised classification setting BIBREF4 , BIBREF5 , BIBREF6 . More recent approaches, and currently the best performing ones, utilize recurrent neural networks (rnns) to transform content into dense low-dimensional semantic representations that are then used for classification BIBREF1 , BIBREF7 . All of these approaches rely solely on lexical and semantic features of the text they are applied to. Waseem and Hovy c53cecce142c48628b3883d13155261c adopted a more user-centric approach based on the idea that perpetrators of hate speech are usually segregated into small demographic groups; they went on to show that gender information of authors (i.e., users who have posted content) is a helpful indicator. However, Waseem and Hovy focused only on coarse demographic features of the users, disregarding information about their communication with others. But previous research suggests that users who subscribe to particular stereotypes that promote hate speech tend to form communities online. For example, Zook zook mapped the locations of racist tweets in response to President Obama's re-election to show that such tweets were not uniformly distributed across the United States but formed clusters instead. In this paper, we present the first approach to hate speech detection that leverages author profiling information based on properties of the authors' social network and investigate its effectiveness.",
          "Author profiling has emerged as a powerful tool for NLP applications, leading to substantial performance improvements in several downstream tasks, such as text classification, sentiment analysis and author attribute identification BIBREF8 , BIBREF9 , BIBREF10 . The relevance of information gained from it is best explained by the idea of homophily, i.e., the phenomenon that people, both in real life as well as on the Internet, tend to associate more with those who appear similar. Here, similarity can be defined along various axes, e.g., location, age, language, etc. The strength of author profiling lies in that if we have information about members of a community $c$ defined by some similarity criterion, and we know that the person $p$ belongs to $c$ , we can infer information about $p$ . This concept has a straightforward application to our task: knowing that members of a particular community are prone to creating hateful content, and knowing that the author p is connected to this community, we can leverage information beyond linguistic cues and more accurately predict the use of hateful/non-hateful language from $p$ . The questions that we seek to address here are: are some authors, and the respective communities that they belong to, more hateful than the others? And can such information be effectively utilized to improve the performance of automated hate speech detection methods?",
          "In this paper, we answer these questions and develop novel methods that take into account community-based profiling features of authors when examining their tweets for hate speech. Experimenting with a dataset of $16k$ tweets, we show that the addition of such profiling features to the current state-of-the-art methods for hate speech detection significantly enhances their performance. We also release our code (including code that replicates previous work), pre-trained models and the resources we used in the public domain."
        ]
      },
      {
        "section_name": "Hate speech detection",
        "paragraphs": [
          "Amongst the first ones to apply supervised learning to the task of hate speech detection were Yin et al. Yin09detectionof who used a linear svm classifier to identify posts containing harassment based on local (e.g., n-grams), contextual (e.g., similarity of a post to its neighboring posts) and sentiment-based (e.g., presence of expletives) features. Their best results were with all of these features combined.",
          "Djuric et al. Djuric:2015:HSD:2740908.2742760 experimented with comments extracted from the Yahoo Finance portal and showed that distributional representations of comments learned using paragraph2vec BIBREF11 outperform simpler bag-of-words (bow) representations in a supervised classification setting for hate speech detection. Nobata et al. Nobata:2016:ALD:2872427.2883062 improved upon the results of Djuric et al. by training their classifier on a combination of features drawn from four different categories: linguistic (e.g., count of insult words), syntactic (e.g., pos tags), distributional semantic (e.g., word and comment embeddings) and bow-based (word and characters n-grams). They reported that while the best results were obtained with all features combined, character n-grams contributed more to performance than all the other features.",
          "Waseem and Hovy c53cecce142c48628b3883d13155261c created and experimented with a dataset of racist, sexist and clean tweets. Utilizing a logistic regression (lr) classifier to distinguish amongst them, they found that character n-grams coupled with gender information of users formed the optimal feature set; on the other hand, geographic and word-length distribution features provided little to no improvement. Working with the same dataset, Badjatiya et al. Badjatiya:17 improved on their results by training a gradient-boosted decision tree (gbdt) classifier on averaged word embeddings learnt using a long short-term memory (lstm) network that they initialized with random embeddings.",
          "Waseem zeerakW16-5618 sampled $7k$ more tweets in the same manner as Waseem and Hovy c53cecce142c48628b3883d13155261c. They recruited expert and amateur annotators to annotate the tweets as racism, sexism, both or neither in order to study the influence of annotator knowledge on the task of hate speech detection. Combining this dataset with that of Waseem and Hovy c53cecce142c48628b3883d13155261c, Park et al. W17-3006 explored the merits of a two-step classification process. They first used a lr classifier to separate hateful and non-hateful tweets, followed by another lr classifier to distinguish between racist and sexist ones. They showed that this setup had comparable performance to a one-step classification setup built with convolutional neural networks.",
          "Davidson et al. davidson created a dataset of about $25k$ tweets wherein each tweet was annotated as being racist, offensive or neither of the two. They tested several multi-class classifiers with the aim of distinguishing clean tweets from racist and offensive tweets while simultaneously being able to separate the racist and offensive ones. Their best model was a lr classifier trained using tf-idf and pos n-gram features, as well as the count of hash tags and number of words.",
          "Wulczyn et al. Wulczyn:2017:EMP:3038912.3052591 prepared three different datasets of comments collected from the English Wikipedia Talk page; one was annotated for personal attacks, another for toxicity and the third one for aggression. Their best performing model was a multi-layered perceptron (mlp) classifier trained on character n-gram features. Experimenting with the personal attack and toxicity datasets, Pavlopoulos et al. Pavlopoulos:17 improved the results of Wulczyn et al. by using a gated recurrent unit (gru) model to encode the comments into dense low-dimensional representations, followed by a lr layer to classify the comments based on those representations."
        ]
      },
      {
        "section_name": "Author profiling",
        "paragraphs": [
          "Author profiling has been leveraged in several ways for a variety of purposes in nlp. For instance, many studies have relied on demographic information of the authors. Amongst these are Hovy et al. hovy2015demographic and Ebrahimi et al. ebrahimi2016personalized who extracted age and gender-related information to achieve superior performance in a text classification task. Pavalanathan and Eisenstein pavalanathan2015confounds, in their work, further showed the relevance of the same information to automatic text-based geo-location. Researching along the same lines, Johannsen et al. johannsen2015cross and Mirkin et al. mirkin2015motivating utilized demographic factors to improve syntactic parsing and machine translation respectively.",
          "While demographic information has proved to be relevant for a number of tasks, it presents a significant drawback: since this information is not always available for all authors in a social network, it is not particularly reliable. Consequently, of late, a new line of research has focused on creating representations of users in a social network by leveraging the information derived from the connections that they have with other users. In this case, node representations (where nodes represent the authors in the social network) are typically induced using neural architectures. Given the graph representing the social network, such methods create low-dimensional representations for each node, which are optimized to predict the nodes close to it in the network. This approach has the advantage of overcoming the absence of information that the previous approaches face. Among those that implement this idea are Yang et al. yang2016toward, who used representations derived from a social graph to achieve better performance in entity linking tasks, and Chen and Ku chen2016utcnn, who used them for stance classification.",
          "A considerable amount of literature has also been devoted to sentiment analysis with representations built from demographic factors BIBREF10 , BIBREF12 . Other tasks that have benefited from social representations are sarcasm detection BIBREF13 and political opinion prediction BIBREF14 ."
        ]
      },
      {
        "section_name": "Dataset",
        "paragraphs": [
          "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech. The authors retrieved around $136k$ tweets over a period of two months. They bootstrapped their collection process with a search for commonly used slurs and expletives related to religious, sexual, gender and ethnic minorities. From the results, they identified terms and references to entities that frequently showed up in hateful tweets. Based on this sample, they used a public Twitter api to collect the entire corpus of ca. $136k$ tweets. After having manually annotated a randomly sampled subset of $16,914$ tweets under the categories racism, sexism or none themselves, they asked an expert to review their annotations in order to mitigate against any biases. The inter-annotator agreement was reported at $\\kappa =0.84$ , with a further insight that $85\\%$ of all the disagreements occurred in the sexism class.",
          "The dataset was released as a list of $16,907$ tweet IDs along with their corresponding annotations. Using python's Tweepy library, we could only retrieve $16,202$ of the tweets since some of them have now been deleted or their visibility limited. Of the ones retrieved, 1,939 (12%) are labelled as racism, 3,148 (19.4%) as sexism, and the remaining 11,115 (68.6%) as none; this distribution follows the original dataset very closely (11.7%, 20.0%, 68.3%).",
          "We were able to extract community-based information for 1,836 out of the 1,875 unique authors who posted the $16,202$ tweets, covering a cumulative of 16,124 of them; the remaining 39 authors have either deactivated their accounts or are facing suspension. Tweets in the racism class are from 5 of the 1,875 authors, while those in the sexism class are from 527 of them."
        ]
      },
      {
        "section_name": "Representing authors",
        "paragraphs": [
          "In order to leverage community-based information for the authors whose tweets form our dataset, we create an undirected unlabeled community graph wherein nodes are the authors and edges are the connections between them. An edge is instantiated between two authors $u$ and $v$ if $u$ follows $v$ on Twitter or vice versa. There are a total of 1,836 nodes and 7,561 edges. Approximately 400 of the nodes have no edges, indicating solitary authors who neither follow any other author nor are followed by any. Other nodes have an average degree of 8, with close to 600 of them having a degree of at least 5. The graph is overall sparse with a density of 0.0075.",
          "From this community graph, we obtain a vector representation, i.e., an embedding that we refer to as author profile, for each author using the node2vec framework BIBREF15 . Node2vec applies the skip-gram model of Mikolov et al. mikolov2013efficient to a graph in order to create a representation for each of its nodes based on their positions and their neighbors. Specifically, given a graph with nodes $V = \\lbrace v_1$ , $v_2$ , $\\dots $ , $v_n\\rbrace $ , node2vec seeks to maximize the following log probability: ",
          "$$\\nonumber \\sum _{v \\in V} \\log Pr\\,(N_s(v)\\, |\\, v)$$   (Eq. 6) ",
          "where $N_s(v)$ denotes the network neighborhood of node $v$ generated through sampling strategy $s$ .",
          "In doing so, the framework learns low-dimensional embeddings for nodes in the graph. These embeddings can emphasize either their structural role or the local community they are a part of. This depends on the sampling strategies used to generate the neighborhood: if breadth-first sampling (bfs) is adopted, the model focuses on the immediate neighbors of a node; when depth-first sampling (dfs) is used, the model explores farther regions in the network, which results in embeddings that encode more information about the nodes' structural role (e.g., hub in a cluster, or peripheral node). The balance between these two ways of sampling the neighbors is directly controlled by two node2vec parameters, namely $p$ and $q$ . The default value for these is 1, which ensures a node representation that gives equal weight to both structural and community-oriented information. In our work, we use the default value for both $p$ and $q$ . Additionally, since node2vec does not produce embeddings for solitary authors, we map these to a single zero embedding.",
          "Figure 1 shows example snippets from the community graph. Some authors belong to densely-connected communities (left figure), while others are part of more sparse ones (right figure). In either case, node2vec generates embeddings that capture the authors' neighborhood."
        ]
      },
      {
        "section_name": "Classifying content",
        "paragraphs": [
          "We experiment with seven different methods for classifying tweets as one of racism, sexism, or none. We first re-implement three established and currently best-performing hate speech detection methods \u2014 based on character n-grams and recurrent neural networks \u2014 as our baselines. We then test whether incorporating author profiling features improves their performance.",
          "Char n-grams (lr). As our first baseline, we adopt the method used by Waseem and Hovy c53cecce142c48628b3883d13155261c wherein they train a logistic regression (lr) classifier on the Twitter dataset using character n-gram counts. We use uni-grams, bi-grams, tri-grams and four-grams, and l $_2$ -normalize their counts. Character n-grams have been shown to be effective for the task of hate speech detection BIBREF5 .",
          "Hidden-state (hs). As our second baseline, we take the \u201crnn\u201d method of Pavlopoulos et al. Pavlopoulos:17 which achieves state-of-the-art results on the Wikipedia datasets released by Wulczyn et al. Wulczyn:2017:EMP:3038912.3052591. The method comprises a 1-layer gated recurrent unit (gru) that takes a sequence $w_1$ , $\\dots $ , $w_n$ of words represented as $d$ -dimensional embeddings and encodes them into hidden states $h_1$ , $\\dots $ , $h_n$ . This is followed by an lr layer that uses the last hidden state $h_n$ to classify the tweet. We make two minor modifications to the authors' original architecture: we deepen the 1-layer gru to a 2-layer gru and use softmax instead of sigmoid in the lr layer. Like Pavlopoulos et al., we initialize the word embeddings to glove vectors BIBREF16 . In all our methods, words not available in the glove set are randomly initialized in the range $\\pm 0.05$ , indicating the lack of semantic information. By not mapping these words to a single random embedding, we mitigate against the errors that may arise due to their conflation BIBREF17 . A special oov (out of vocabulary) token is also initialized in the same range. All the embeddings are updated during training, allowing some of the randomly-initialized ones to get task-tuned; the ones that do not get tuned lie closely clustered around the oov token, to which unseen words in the test set are mapped.",
          "Word-sum (ws). As a third baseline, we adopt the \u201clstm+glove+gbdt\" method of Badjatiya et al. Badjatiya:17, which achieves state-of-the-art results on the Twitter dataset we are using. The authors first utilize an lstm to task-tune glove-initialized word embeddings by propagating the error back from an lr layer. They then train a gradient boosted decision tree (gbdt) classifier to classify texts based on the average of the embeddings of constituent words. We make two minor modifications to this method: we use a 2-layer gru instead of the lstm to tune the embeddings, and we train the gbdt classifier on the l $_2$ -normalized sum of the embeddings instead of their average. Although the authors achieved state-of-the-art results on Twitter by initializing embeddings randomly rather than with glove (which is what we do here), we found the opposite when performing a 10-fold stratified cross-validation (cv). A possible explanation of this lies in the authors' decision to not use stratification, which for such a highly imbalanced dataset can lead to unexpected outcomes BIBREF18 . Furthermore, the authors train their lstm on the entire dataset (including the test set) without any early stopping criterion, which leads to over-fitting of the randomly-initialized embeddings.",
          "Author profile (auth). In order to test whether community-based information of authors is in itself sufficient to correctly classify the content produced by them, we utilize just the author profiles we generated to train a gbdt classifier.",
          "Char n-grams + author profile (lr + auth). This method builds upon the lr baseline by appending author profile vectors on to the character n-gram count vectors for training the lr classifier.",
          "Hidden-state + author profile (hs + auth) and Word-sum + author profile (ws + auth). These methods are identical to the char n-grams + author profile method except that here we append the author profiling features on to features derived from the hidden-state and word-sum baselines respectively and feed them to a gbdt classifier."
        ]
      },
      {
        "section_name": "Experimental setup",
        "paragraphs": [
          "We normalize the input by lowercasing all words and removing stop words. For the gru architecture, we use exactly the same hyper-parameters as Pavlopoulos et al. Pavlopoulos:17, i.e., 128 hidden units, Glorot initialization, cross-entropy loss, and the Adam optimizer BIBREF19 . Badjatiya et al. Badjatiya:17 also use the same settings except they have fewer hidden units. In all our models, besides dropout regularization BIBREF20 , we hold out a small part of the training set as validation data to prevent over-fitting. We implement the models in Keras BIBREF21 with Theano back-end and use 200-dimensional pre-trained glove word embeddings. We employ Lightgbm BIBREF22 as our gdbt classifier and tune its hyper-parameters using 5-fold grid search. For the node2vec framework, we use the same parameters as in the original paper BIBREF15 except we set the dimensionality of node embeddings to 200 and increase the number of iterations to 25 for better convergence."
        ]
      },
      {
        "section_name": "Results",
        "paragraphs": [
          "We perform 10-fold stratified cross validation (cv), as suggested by Forman and Scholz Forman:10, to evaluate all seven methods described in the previous section. Following previous research BIBREF7 , BIBREF23 , we report the average weighted precision, recall, and f $_1$ scores for all the methods. The average weighted precision is calculated as: ",
          "$$\\nonumber \\frac{\\sum _{i=1}^{10}\\; (w_r\\cdot \\textrm {P}_r^i + w_s\\cdot \\textrm {P}_s^i + w_n\\cdot \\textrm {P}_n^i)}{10}$$   (Eq. 16) ",
          "where $\\textrm {P}_r^i, \\textrm {P}_s^i, \\textrm {P}_n^i$ are precision scores on the racism, sexism, and none classes from the $i^{th}$ fold of the cv. The values $w_r$ , $w_s$ , and $w_n$ are the proportions of the racism, sexism, and none classes in the dataset respectively; since we use stratification, these proportions are constant ( $w_r=0.12$ , $w_s=0.19$ , $w_n=0.69$ ) across all folds. Average weighted recall and f $_1$ are calculated in the same manner.",
          "The results are presented in Table 1 . For all three baseline methods (lr, ws, and hs), the addition of author profiling features significantly improves performance ( $p < 0.05$ under 10-fold cv paired t-test). The lr + auth method yields the highest performance of f $_1$ $=87.57$ , exceeding its respective baseline by nearly 4 points. A similar trend can be observed for the other methods as well. These results point to the importance of community-based information and author profiling in hate speech detection and demonstrate that our approach can further improve the performance of existing state-of-the-art methods.",
          "In Table 2 , we further compare the performance of the different methods on the racism and sexism classes individually. As in the previous experiments, the scores are averaged over 10 folds of cv. Of particular interest are the scores for the sexism class where the f $_1$ increases by over 10 points upon the addition of author profiling features. Upon analysis, we find that such a substantial increase in performance stems from the fact that many of the 527 unique authors of the sexist tweets are closely connected in the community graph. This allows for their penchant for sexism to be expressed in their respective author profiles.",
          "The author profiling features on their own (auth) achieve impressive results overall and in particular on the sexism class, where their performance is typical of a community-based generalization, i.e., low precision but high recall. For the racism class on the other hand, the performance of auth on its own is quite poor. This contrast can be explained by the fact that tweets in the racism class come from only 5 unique authors who: (i) are isolated in the community graph, or (ii) have also authored several tweets in the sexism class, or (iii) are densely connected to authors from the sexism and none classes which possibly camouflages their racist nature.",
          "We believe that the gains in performance will be more pronounced as the underlying community graph grows since there will be less solitary authors and more edges worth harnessing information from. Even when the data is skewed and there is an imbalance of hateful vs. non-hateful authors, we do expect our approach to still be able to identify clusters of authors with similar views."
        ]
      },
      {
        "section_name": "Analysis and discussion",
        "paragraphs": [
          "We conduct a qualitative analysis of system errors and the cases where author profiling leads to the correct classification of previously misclassified examples. Table 3 shows examples of hateful tweets from the dataset that are misclassified by the lr method, but are correctly classified upon the addition of author profiling features, i.e., by the lr + auth method. It is worth noting that some of the wins scored by the latter are on tweets that are part of a larger hateful discourse or contain links to hateful content while not explicitly having textual cues that are indicative of hate speech per se. The addition of author profiling features may then be viewed as a proxy for wider discourse information, thus allowing us to correctly resolve the cases where lexical and semantic features alone are insufficient.",
          "However, a number of hateful tweets still remain misclassified despite the addition of author profiling features. According to our analysis, many of these tend to contain urls to hateful content, e.g., \u201c@salmonfarmer1: Logic in the world of Islam http://t.co/6nALv2HPc3\" and \u201c@juliarforster Yes. http://t.co/ixbt0uc7HN\". Since Twitter shortens all urls into a standard format, there is no indication of what they refer to. One way to deal with this limitation could be to additionally maintain a blacklist of links. Another source of system errors is the deliberate obfuscation of words by authors in order to evade detection, e.g., \u201cKat, a massive c*nt. The biggest ever on #mkr #cuntandandre\". Current hate speech detection methods, including ours, do not directly attempt to address this issue. While this is a challenge for bag-of-word based methods such as lr, we hypothesize that neural networks operating at the character level may be helpful in recognizing obfuscated words.",
          "We further conducted an analysis of the author embeddings generated by node2vec, in order to validate that they capture the relevant aspects of the community graph. We visualized the author embeddings in 2-dimensional space using t-sne BIBREF24 , as shown in Figure 2 . We observe that, as in the community graph, there are a few densely populated regions in the visualization that represent authors in closely knit groups who exhibit similar characteristics. The other regions are largely sparse with smaller clusters. Note that we exclude solitary users from this visualization since we have to use a single zero embedding to represent them.",
          "Figure 3 further provides visualizations for authors from the sexism and none classes separately. While the authors from the none class are spread out in the embedding space, the ones from the sexism class are more tightly clustered. Note that we do not visualize the 5 authors from the racism class since 4 of them are already covered in the sexism class."
        ]
      },
      {
        "section_name": "Conclusions",
        "paragraphs": [
          "In this paper, we explored the effectiveness of community-based information about authors for the purpose of identifying hate speech. Working with a dataset of $16k$ tweets annotated for racism and sexism, we first comprehensively replicated three established and currently best-performing hate speech detection methods based on character n-grams and recurrent neural networks as our baselines. We then constructed a graph of all the authors of tweets in our dataset and extracted community-based information in the form of dense low-dimensional embeddings for each of them using node2vec. We showed that the inclusion of author embeddings significantly improves system performance over the baselines and advances the state of the art in this task. Users prone to hate speech do tend to form social groups online, and this stresses the importance of utilizing community-based information for automatic hate speech detection. In the future, we wish to explore the effectiveness of community-based author profiling in other tasks such as stereotype identification and metaphor detection."
        ]
      }
    ],
    "qas": [
      {
        "question": "Is the dataset used in other work?",
        "question_id": "fa800a21469a70fa6490bfc67cabdcc8bf086fb5",
        "nlp_background": "five",
        "topic_background": "familiar",
        "paper_read": "no",
        "search_query": "",
        "answers": [
          {
            "answer": {
              "unanswerable": false,
              "evidence": [
                "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech. The authors retrieved around $136k$ tweets over a period of two months. They bootstrapped their collection process with a search for commonly used slurs and expletives related to religious, sexual, gender and ethnic minorities. From the results, they identified terms and references to entities that frequently showed up in hateful tweets. Based on this sample, they used a public Twitter api to collect the entire corpus of ca. $136k$ tweets. After having manually annotated a randomly sampled subset of $16,914$ tweets under the categories racism, sexism or none themselves, they asked an expert to review their annotations in order to mitigate against any biases. The inter-annotator agreement was reported at $\\kappa =0.84$ , with a further insight that $85\\%$ of all the disagreements occurred in the sexism class.",
                "The dataset was released as a list of $16,907$ tweet IDs along with their corresponding annotations. Using python's Tweepy library, we could only retrieve $16,202$ of the tweets since some of them have now been deleted or their visibility limited. Of the ones retrieved, 1,939 (12%) are labelled as racism, 3,148 (19.4%) as sexism, and the remaining 11,115 (68.6%) as none; this distribution follows the original dataset very closely (11.7%, 20.0%, 68.3%)."
              ],
              "highlighted_evidence": [
                "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech. The authors retrieved around $136k$ tweets over a period of two months. They bootstrapped their collection process with a search for commonly used slurs and expletives related to religious, sexual, gender and ethnic minorities. From the results, they identified terms and references to entities that frequently showed up in hateful tweets. Based on this sample, they used a public Twitter api to collect the entire corpus of ca. $136k$ tweets. After having manually annotated a randomly sampled subset of $16,914$ tweets under the categories racism, sexism or none themselves, they asked an expert to review their annotations in order to mitigate against any biases.",
                "The dataset was released as a list of $16,907$ tweet IDs along with their corresponding annotations. Using python's Tweepy library, we could only retrieve $16,202$ of the tweets since some of them have now been deleted or their visibility limited. "
              ],
              "yes_no": null,
              "free_form_answer": "Yes, in Waseem and Hovy (2016)",
              "extractive_spans": []
            },
            "annotation_id": "74f6f2d9f7f8944b6e9883dd61a8be1fb4ce60ea",
            "worker_id": "5d0eb97e8e840e171f73b7642c2c89dd3984157b"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech. The authors retrieved around $136k$ tweets over a period of two months. They bootstrapped their collection process with a search for commonly used slurs and expletives related to religious, sexual, gender and ethnic minorities. From the results, they identified terms and references to entities that frequently showed up in hateful tweets. Based on this sample, they used a public Twitter api to collect the entire corpus of ca. $136k$ tweets. After having manually annotated a randomly sampled subset of $16,914$ tweets under the categories racism, sexism or none themselves, they asked an expert to review their annotations in order to mitigate against any biases. The inter-annotator agreement was reported at $\\kappa =0.84$ , with a further insight that $85\\%$ of all the disagreements occurred in the sexism class."
              ],
              "highlighted_evidence": [
                "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech."
              ]
            },
            "annotation_id": "8cc7b6c439f94016a9eebcaa66f732422e251275",
            "worker_id": "c1fbdd7a261021041f75fbe00a55b4c386ebbbb4"
          },
          {
            "answer": {
              "unanswerable": false,
              "extractive_spans": [],
              "yes_no": true,
              "free_form_answer": "",
              "evidence": [
                "We experiment with the dataset of Waseem and Hovy c53cecce142c48628b3883d13155261c, containing tweets manually annotated for hate speech. The authors retrieved around $136k$ tweets over a period of two months. They bootstrapped their collection process with a search for commonly used slurs and expletives related to religious, sexual, gender and ethnic minorities. From the results, they identified terms and references to entities that frequently showed up in hateful tweets. Based on this sample, they used a public Twitter api to collect the entire corpus of ca. $136k$ tweets. After having manually annotated a randomly sampled subset of $16,914$ tweets under the categories racism, sexism or none themselves, they asked an expert to review their annotations in order to mitigate against any biases. The inter-annotator agreement was reported at $\\kappa =0.84$ , with a further insight that $85\\%$ of all the disagreements occurred in the sexism class."
              ],
              "highlighted_evidence": [
                "We experiment with the dataset of Waseem and Hovy"
              ]
            },
            "annotation_id": "8ec6e54cb39330a1d13fb274fd62668a7878d148",
            "worker_id": "efdb8f7f2fe9c47e34dfe1fb7c491d0638ec2d86"
          }
        ],
        "question_writer": "50d8b4a941c26b89482c94ab324b5a274f9ced66"
      }
    ],
    "figures_and_tables": [
      {
        "file": "5-Figure1-1.png",
        "caption": "Figure 1: Snippets from the community graph for our Twitter data."
      },
      {
        "file": "7-Table1-1.png",
        "caption": "Table 1: Average weighted precision, recall and F1 scores of the different methods on the Twitter datasest. All improvements are significant (p < 0.05) under 10-fold CV paired t-test."
      },
      {
        "file": "7-Table2-1.png",
        "caption": "Table 2: Performance of the methods on the racism and sexism classes separately. All improvements are significant (p < 0.05) under 10-fold CV paired t-test."
      },
      {
        "file": "8-Table3-1.png",
        "caption": "Table 3: Examples of improved classification upon the addition of author profiling features (AUTH)."
      },
      {
        "file": "8-Figure2-1.png",
        "caption": "Figure 2: Visualization of author embeddings in 2-dimensional space."
      },
      {
        "file": "9-Figure3-1.png",
        "caption": "Figure 3: Visualization of authors from different classes."
      }
    ]
  }
}